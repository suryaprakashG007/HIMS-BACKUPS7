import _slicedToArray from "@babel/runtime/helpers/slicedToArray";

/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { useEffect, useRef, useState } from 'react';
export function usePressable(ref) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      onPress = _ref.onPress,
      onPressIn = _ref.onPressIn,
      onPressOut = _ref.onPressOut,
      onLongPress = _ref.onLongPress,
      _ref$delayLongPressMs = _ref.delayLongPressMs,
      delayLongPressMs = _ref$delayLongPressMs === void 0 ? 500 : _ref$delayLongPressMs;

  var savedOnPress = useRef(onPress);
  var savedOnPressIn = useRef(onPressIn);
  var savedOnPressOut = useRef(onPressOut);
  var savedOnLongPress = useRef(onLongPress);

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      pendingLongPress = _useState2[0],
      setPendingLongPress = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      longPress = _useState4[0],
      setLongPress = _useState4[1];

  var state = useRef({
    longPress: false
  });
  useEffect(function () {
    savedOnPress.current = onPress;
  }, [onPress]);
  useEffect(function () {
    savedOnPressIn.current = onPressIn;
  }, [onPressIn]);
  useEffect(function () {
    savedOnPressOut.current = onPressOut;
  }, [onPressOut]);
  useEffect(function () {
    savedOnLongPress.current = onLongPress;
  }, [onLongPress]);
  useEffect(function () {
    var element = ref.current; // Fired when a pointer becomes active buttons state.

    function onPointerDown() {
      var _savedOnPressIn$curre;

      setPendingLongPress(true);
      (_savedOnPressIn$curre = savedOnPressIn.current) === null || _savedOnPressIn$curre === void 0 ? void 0 : _savedOnPressIn$curre.call(savedOnPressIn);
    } // Fired when a pointer is no longer active buttons state.


    function onPointerUp() {
      var _savedOnPressOut$curr;

      setPendingLongPress(false);
      setLongPress(false);
      (_savedOnPressOut$curr = savedOnPressOut.current) === null || _savedOnPressOut$curr === void 0 ? void 0 : _savedOnPressOut$curr.call(savedOnPressOut, state.current);
    } // A browser fires this event if it concludes the pointer
    // will no longer be able to generate events (for example
    // the related device is deactivated).


    function onPointerCancel() {
      var _savedOnPressOut$curr2;

      setPendingLongPress(false);
      setLongPress(false);
      (_savedOnPressOut$curr2 = savedOnPressOut.current) === null || _savedOnPressOut$curr2 === void 0 ? void 0 : _savedOnPressOut$curr2.call(savedOnPressOut);
      state.current.longPress = false;
    } // Fired when a pointer is moved out of the hit test
    // boundaries of an element. For pen devices, this event
    // is fired when the stylus leaves the hover range
    // detectable by the digitizer.


    function onPointerLeave() {
      var _savedOnPressOut$curr3;

      setPendingLongPress(false);
      setLongPress(false);
      (_savedOnPressOut$curr3 = savedOnPressOut.current) === null || _savedOnPressOut$curr3 === void 0 ? void 0 : _savedOnPressOut$curr3.call(savedOnPressOut);
      state.current.longPress = false;
    }

    function onClick() {
      var _savedOnPress$current;

      setLongPress(false);
      setPendingLongPress(false);
      (_savedOnPress$current = savedOnPress.current) === null || _savedOnPress$current === void 0 ? void 0 : _savedOnPress$current.call(savedOnPress, state.current);
      state.current.longPress = false;
    }

    function onTouchStart(event) {
      // We prevent the default event on touchstart so that text selection is
      // disabled on iOS  Safari when interacting with a "pressable" element
      event.preventDefault();
    }

    element.addEventListener('touchstart', onTouchStart);
    element.addEventListener('pointerdown', onPointerDown);
    element.addEventListener('pointerup', onPointerUp);
    element.addEventListener('pointercancel', onPointerCancel);
    element.addEventListener('pointerleave', onPointerLeave);
    element.addEventListener('click', onClick);
    return function () {
      element.removeEventListener('touchstart', onTouchStart);
      element.removeEventListener('pointerdown', onPointerDown);
      element.removeEventListener('pointerup', onPointerUp);
      element.removeEventListener('pointercancel', onPointerCancel);
      element.removeEventListener('pointerleave', onPointerLeave);
      element.removeEventListener('click', onClick);
    };
  }, [ref]);
  useEffect(function () {
    if (pendingLongPress) {
      var timeoutId = setTimeout(function () {
        setPendingLongPress(false);
        setLongPress(true);
      }, delayLongPressMs);
      return function () {
        clearTimeout(timeoutId);
      };
    }
  }, [pendingLongPress, delayLongPressMs]);
  useEffect(function () {
    if (longPress) {
      var _savedOnLongPress$cur;

      state.current.longPress = true;
      return (_savedOnLongPress$cur = savedOnLongPress.current) === null || _savedOnLongPress$cur === void 0 ? void 0 : _savedOnLongPress$cur.call(savedOnLongPress);
    }
  }, [longPress]);
}