"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _synchronousPromise = require("synchronous-promise");

var _Cancel = _interopRequireDefault(require("./cancel/Cancel"));

var _CancelToken = _interopRequireDefault(require("./cancel/CancelToken"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** a FIFO queue of pending request */
var _pending_requests = [];

var _newReq = function _newReq() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var actualConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof config === 'string') {
    // Allow for axios('example/url'[, config])
    actualConfig.url = config;
    config = actualConfig;
  }

  var method = config.method || "get";
  var url = config.url;
  var data = config.data;

  var promise = _synchronousPromise.SynchronousPromise.unresolved();

  if (config.cancelToken) {
    config.cancelToken.promise.then(function (cancel) {
      // check if promise is still waiting for an answer
      if (_pending_requests.find(function (x) {
        return x.promise === promise;
      })) {
        MockAxios.mockError(cancel, promise);
      }
    });
  }

  _pending_requests.push({
    config: config,
    data: data,
    method: method,
    promise: promise,
    url: url
  });

  return promise;
};

var _helperReq = function _helperReq(method, url, data, config) {
  var conf = data && config ? config : {};
  return _newReq(_objectSpread(_objectSpread({}, conf), {}, {
    data: data,
    method: method,
    url: url
  }));
};

var _helperReqNoData = function _helperReqNoData(method, url, config) {
  return _helperReq(method, url, {}, config);
};

var MockAxios = jest.fn(_newReq); // mocking Axios methods

MockAxios.get = jest.fn(_helperReqNoData.bind(null, "get"));
MockAxios.post = jest.fn(_helperReq.bind(null, "post"));
MockAxios.put = jest.fn(_helperReq.bind(null, "put"));
MockAxios.patch = jest.fn(_helperReq.bind(null, "patch"));
MockAxios["delete"] = jest.fn(_helperReqNoData.bind(null, "delete"));
MockAxios.request = jest.fn(_newReq);
MockAxios.all = jest.fn(function (values) {
  return Promise.all(values);
});
MockAxios.head = jest.fn(_helperReqNoData.bind(null, "head"));
MockAxios.options = jest.fn(_helperReqNoData.bind(null, "options"));
MockAxios.create = jest.fn(function () {
  return MockAxios;
});
MockAxios.interceptors = {
  request: {
    use: jest.fn(),
    eject: jest.fn()
  },
  response: {
    use: jest.fn(),
    eject: jest.fn()
  }
};
MockAxios.defaults = {
  headers: {
    common: []
  }
};

MockAxios.popPromise = function (promise) {
  if (promise) {
    // remove the promise from pending queue
    for (var ix = 0; ix < _pending_requests.length; ix++) {
      var req = _pending_requests[ix];

      if (req.promise === promise) {
        _pending_requests.splice(ix, 1);

        return req.promise;
      }
    }
  } else {
    // take the oldest promise
    var _req = _pending_requests.shift();

    return _req ? _req.promise : void 0;
  }
};

MockAxios.popRequest = function (request) {
  if (request) {
    var ix = _pending_requests.indexOf(request);

    if (ix === -1) {
      return void 0;
    }

    _pending_requests.splice(ix, 1);

    return request;
  } else {
    return _pending_requests.shift();
  }
};
/**
 * Removes an item form the queue, based on it's type
 * @param queueItem
 */


var popQueueItem = function popQueueItem() {
  var queueItem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  // first let's pretend the param is a queue item
  var request = MockAxios.popRequest(queueItem);

  if (request) {
    // IF the request was found
    // > set the promise
    return request.promise;
  } else {
    // ELSE maybe the `queueItem` is a promise (legacy mode)
    return MockAxios.popPromise(queueItem);
  }
};

MockAxios.mockResponse = function (response) {
  var queueItem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var silentMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // replacing missing data with default values
  response = Object.assign({
    config: {},
    data: {},
    headers: {},
    status: 200,
    statusText: "OK"
  }, response);
  var promise = popQueueItem(queueItem);

  if (!promise && !silentMode) {
    throw new Error("No request to respond to!");
  } else if (!promise) {
    return;
  } // resolving the Promise with the given response data


  promise.resolve(response);
};

MockAxios.mockResponseFor = function (criteria, response) {
  var silentMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (typeof criteria === "string") {
    criteria = {
      url: criteria
    };
  }

  var queueItem = MockAxios.getReqMatching(criteria);

  if (!queueItem && !silentMode) {
    throw new Error("No request to respond to!");
  } else if (!queueItem) {
    return;
  }

  MockAxios.mockResponse(response, queueItem, silentMode);
};

MockAxios.mockError = function () {
  var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var queueItem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var silentMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var promise = popQueueItem(queueItem);

  if (!promise && !silentMode) {
    throw new Error("No request to respond to!");
  } else if (!promise) {
    return;
  }

  if (error && _typeof(error) === 'object' && error.isAxiosError === void 0) {
    error.isAxiosError = true;
  } // resolving the Promise with the given error


  promise.reject(error);
};

MockAxios.isAxiosError = function (payload) {
  return _typeof(payload) === 'object' && payload.isAxiosError === true;
};

MockAxios.lastReqGet = function () {
  return _pending_requests[_pending_requests.length - 1];
};

MockAxios.lastPromiseGet = function () {
  var req = MockAxios.lastReqGet();
  return req ? req.promise : void 0;
};

var _findReqByPredicate = function _findReqByPredicate(predicate) {
  return _pending_requests.slice().reverse() // reverse cloned array to return most recent req
  .find(predicate);
};

var _checkCriteria = function _checkCriteria(item, criteria) {
  if (criteria.method !== undefined && criteria.method.toLowerCase() !== item.method.toLowerCase()) {
    return false;
  }

  if (criteria.url !== undefined && criteria.url !== item.url) {
    return false;
  }

  if (criteria.params !== undefined) {
    if (item.config === undefined || !item.config.params || _typeof(item.config.params) !== 'object') {
      return false;
    }

    var paramsMatching = Object.entries(criteria.params).every(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          value = _ref2[1];

      return item.config.params[key] === value;
    });

    if (!paramsMatching) {
      return false;
    }
  }

  return true;
};

MockAxios.getReqMatching = function (criteria) {
  return _findReqByPredicate(function (x) {
    return _checkCriteria(x, criteria);
  });
};

MockAxios.getReqByUrl = function (url) {
  return MockAxios.getReqMatching({
    url: url
  });
};

MockAxios.getReqByMatchUrl = function (url) {
  return _findReqByPredicate(function (x) {
    return url.test(x.url);
  });
};

MockAxios.getReqByRegex = function (opts) {
  return _findReqByPredicate(function (x) {
    return Object.entries(opts).every(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          key = _ref4[0],
          value = _ref4[1];

      return value.test(JSON.stringify(x[key]));
    });
  });
};

MockAxios.queue = function () {
  return _pending_requests;
};

MockAxios.reset = function () {
  // remove all the requests
  _pending_requests.splice(0, _pending_requests.length); // resets all information stored in the mockFn.mock.calls and mockFn.mock.instances arrays


  MockAxios.get.mockClear();
  MockAxios.post.mockClear();
  MockAxios.put.mockClear();
  MockAxios.patch.mockClear();
  MockAxios["delete"].mockClear();
  MockAxios.head.mockClear();
  MockAxios.options.mockClear();
  MockAxios.request.mockClear();
  MockAxios.all.mockClear();
};

MockAxios.Cancel = _Cancel["default"];
MockAxios.CancelToken = _CancelToken["default"];

MockAxios.isCancel = function (u) {
  return !!(u && u.__CANCEL__);
}; // this is a singleton object


var _default = MockAxios;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2xpYi9tb2NrLWF4aW9zLnRzIl0sIm5hbWVzIjpbIl9wZW5kaW5nX3JlcXVlc3RzIiwiX25ld1JlcSIsImNvbmZpZyIsImFjdHVhbENvbmZpZyIsInVybCIsIm1ldGhvZCIsImRhdGEiLCJwcm9taXNlIiwiU3luY2hyb25vdXNQcm9taXNlIiwidW5yZXNvbHZlZCIsImNhbmNlbFRva2VuIiwidGhlbiIsImNhbmNlbCIsImZpbmQiLCJ4IiwiTW9ja0F4aW9zIiwibW9ja0Vycm9yIiwicHVzaCIsIl9oZWxwZXJSZXEiLCJjb25mIiwiX2hlbHBlclJlcU5vRGF0YSIsImplc3QiLCJmbiIsImdldCIsImJpbmQiLCJwb3N0IiwicHV0IiwicGF0Y2giLCJyZXF1ZXN0IiwiYWxsIiwidmFsdWVzIiwiUHJvbWlzZSIsImhlYWQiLCJvcHRpb25zIiwiY3JlYXRlIiwiaW50ZXJjZXB0b3JzIiwidXNlIiwiZWplY3QiLCJyZXNwb25zZSIsImRlZmF1bHRzIiwiaGVhZGVycyIsImNvbW1vbiIsInBvcFByb21pc2UiLCJpeCIsImxlbmd0aCIsInJlcSIsInNwbGljZSIsInNoaWZ0IiwicG9wUmVxdWVzdCIsImluZGV4T2YiLCJwb3BRdWV1ZUl0ZW0iLCJxdWV1ZUl0ZW0iLCJtb2NrUmVzcG9uc2UiLCJzaWxlbnRNb2RlIiwiT2JqZWN0IiwiYXNzaWduIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsIkVycm9yIiwicmVzb2x2ZSIsIm1vY2tSZXNwb25zZUZvciIsImNyaXRlcmlhIiwiZ2V0UmVxTWF0Y2hpbmciLCJlcnJvciIsImlzQXhpb3NFcnJvciIsInJlamVjdCIsInBheWxvYWQiLCJsYXN0UmVxR2V0IiwibGFzdFByb21pc2VHZXQiLCJfZmluZFJlcUJ5UHJlZGljYXRlIiwicHJlZGljYXRlIiwic2xpY2UiLCJyZXZlcnNlIiwiX2NoZWNrQ3JpdGVyaWEiLCJpdGVtIiwidW5kZWZpbmVkIiwidG9Mb3dlckNhc2UiLCJwYXJhbXMiLCJwYXJhbXNNYXRjaGluZyIsImVudHJpZXMiLCJldmVyeSIsImtleSIsInZhbHVlIiwiZ2V0UmVxQnlVcmwiLCJnZXRSZXFCeU1hdGNoVXJsIiwidGVzdCIsImdldFJlcUJ5UmVnZXgiLCJvcHRzIiwiSlNPTiIsInN0cmluZ2lmeSIsInF1ZXVlIiwicmVzZXQiLCJtb2NrQ2xlYXIiLCJDYW5jZWwiLCJDYW5jZWxUb2tlbiIsImlzQ2FuY2VsIiwidSIsIl9fQ0FOQ0VMX18iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFRQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBUUE7QUFDQSxJQUFNQSxpQkFBdUMsR0FBRyxFQUFoRDs7QUFFQSxJQUFNQyxPQUE0RCxHQUFHLFNBQS9EQSxPQUErRCxHQUE4QztBQUFBLE1BQTdDQyxNQUE2Qyx1RUFBL0IsRUFBK0I7QUFBQSxNQUEzQkMsWUFBMkIsdUVBQVAsRUFBTzs7QUFDL0csTUFBRyxPQUFPRCxNQUFQLEtBQWtCLFFBQXJCLEVBQStCO0FBQzNCO0FBQ0FDLElBQUFBLFlBQVksQ0FBQ0MsR0FBYixHQUFtQkYsTUFBbkI7QUFDQUEsSUFBQUEsTUFBTSxHQUFHQyxZQUFUO0FBQ0g7O0FBRUQsTUFBTUUsTUFBYyxHQUFHSCxNQUFNLENBQUNHLE1BQVAsSUFBaUIsS0FBeEM7QUFDQSxNQUFNRCxHQUFXLEdBQUdGLE1BQU0sQ0FBQ0UsR0FBM0I7QUFDQSxNQUFNRSxJQUFTLEdBQUdKLE1BQU0sQ0FBQ0ksSUFBekI7O0FBQ0EsTUFBTUMsT0FBMEMsR0FBR0MsdUNBQW1CQyxVQUFuQixFQUFuRDs7QUFFQSxNQUFHUCxNQUFNLENBQUNRLFdBQVYsRUFBdUI7QUFDbkJSLElBQUFBLE1BQU0sQ0FBQ1EsV0FBUCxDQUFtQkgsT0FBbkIsQ0FBMkJJLElBQTNCLENBQWdDLFVBQUNDLE1BQUQsRUFBaUI7QUFDN0M7QUFDQSxVQUFHWixpQkFBaUIsQ0FBQ2EsSUFBbEIsQ0FBdUIsVUFBQUMsQ0FBQztBQUFBLGVBQUlBLENBQUMsQ0FBQ1AsT0FBRixLQUFjQSxPQUFsQjtBQUFBLE9BQXhCLENBQUgs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USxHQUFWLENBQWNxRSxTQUFkO0FBQ0E3RSxFQUFBQSxTQUFTLENBQUNVLElBQVYsQ0FBZW1FLFNBQWY7QUFDQTdFLEVBQUFBLFNBQVMsQ0FBQ1csR0FBVixDQUFja0UsU0FBZDtBQUNBN0UsRUFBQUEsU0FBUyxDQUFDWSxLQUFWLENBQWdCaUUsU0FBaEI7QUFDQTdFLEVBQUFBLFNBQVMsVUFBVCxDQUFpQjZFLFNBQWpCO0FBQ0E3RSxFQUFBQSxTQUFTLENBQUNpQixJQUFWLENBQWU0RCxTQUFmO0FBQ0E3RSxFQUFBQSxTQUFTLENBQUNrQixPQUFWLENBQWtCMkQsU0FBbEI7QUFDQTdFLEVBQUFBLFNBQVMsQ0FBQ2EsT0FBVixDQUFrQmdFLFNBQWxCO0FBQ0E3RSxFQUFBQSxTQUFTLENBQUNjLEdBQVYsQ0FBYytELFNBQWQ7QUFDSCxDQWREOztBQWdCQTdFLFNBQVMsQ0FBQzhFLE1BQVYsR0FBbUJBLGtCQUFuQjtBQUNBOUUsU0FBUyxDQUFDK0UsV0FBVixHQUF3QkEsdUJBQXhCOztBQUNBL0UsU0FBUyxDQUFDZ0YsUUFBVixHQUFxQixVQUFDQyxDQUFELEVBQW9CO0FBQ3JDLFNBQU8sQ0FBQyxFQUFFQSxDQUFDLElBQUlBLENBQUMsQ0FBQ0MsVUFBVCxDQUFSO0FBQ0gsQ0FGRCxDLENBSUE7OztlQUNlbEYsUyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVHlwZVNjcmlwdCB2ZXJzaW9uIG9mIEF4aW9zIG1vY2sgZm9yIHVuaXQgdGVzdGluZyB3aXRoIFtKZXN0XShodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9qZXN0LykuXG4gKiBUaGlzIGZpbGUgaXMgYmFzZWQgb24gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vdHV4NC8zNjAwNmExODU5MzIzZjc3OWFiMFxuICpcbiAqIEBhdXRob3IgICBrbmVlLWNvbGEgPG5pa29sYS5kZXJlemljQGdtYWlsLmNvbT5cbiAqIEBsaWNlbnNlICBAbGljZW5zZSBNSVQgTGljZW5zZSwgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG5pbXBvcnQgeyBTeW5jaHJvbm91c1Byb21pc2UsIFVucmVzb2x2ZWRTeW5jaHJvbm91c1Byb21pc2UgfSBmcm9tIFwic3luY2hyb25vdXMtcHJvbWlzZVwiO1xuaW1wb3J0IENhbmNlbCBmcm9tIFwiLi9jYW5jZWwvQ2FuY2VsXCI7XG5pbXBvcnQgQ2FuY2VsVG9rZW4gZnJvbSBcIi4vY2FuY2VsL0NhbmNlbFRva2VuXCI7XG5pbXBvcnQge1xuICAgIEF4aW9zTW9ja1F1ZXVlSXRlbSxcbiAgICBBeGlvc01vY2tSZXF1ZXN0Q3JpdGVyaWEsXG4gICAgQXhpb3NNb2NrVHlwZSxcbiAgICBIdHRwUmVzcG9uc2UsXG59IGZyb20gXCIuL21vY2stYXhpb3MtdHlwZXNcIjtcblxuLyoqIGEgRklGTyBxdWV1ZSBvZiBwZW5kaW5nIHJlcXVlc3QgKi9cbmNvbnN0IF9wZW5kaW5nX3JlcXVlc3RzOiBBeGlvc01vY2tRdWV1ZUl0ZW1bXSA9IFtdO1xuXG5jb25zdCBfbmV3UmVxOiAoY29uZmlnPzogYW55KSA9PiBVbnJlc29sdmVkU3luY2hyb25vdXNQcm9taXNlPGFueT4gPSAoY29uZmlnOiBhbnkgPSB7fSwgYWN0dWFsQ29uZmlnOiBhbnkgPSB7fSkgPT4ge1xuICAgIGlmKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSlcbiAgICAgICAgYWN0dWFsQ29uZmlnLnVybCA9IGNvbmZpZztcbiAgICAgICAgY29uZmlnID0gYWN0dWFsQ29uZmlnO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGhvZDogc3RyaW5nID0gY29uZmlnLm1ldGhvZCB8fCBcImdldFwiO1xuICAgIGNvbnN0IHVybDogc3RyaW5nID0gY29uZmlnLnVybDtcbiAgICBjb25zdCBkYXRhOiBhbnkgPSBjb25maWcuZGF0YTtcbiAgICBjb25zdCBwcm9taXNlOiBVbnJlc29sdmVkU3luY2hyb25vdXNQcm9taXNlPGFueT4gPSBTeW5jaHJvbm91c1Byb21pc2UudW5yZXNvbHZlZCgpO1xuXG4gICAgaWYoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oKGNhbmNlbDogYW55KSA9PiB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBwcm9taXNlIGlzIHN0aWxsIHdhaXRpbmcgZm9yIGFuIGFuc3dlclxuICAgICAgICAgICAgaWYoX3BlbmRpbmdfcmVxdWVzdHMuZmluZCh4ID0+IHgucHJvbWlzZSA9PT0gcHJvbWlzZSkpIHtcbiAgICAgICAgICAgICAgICBNb2NrQXhpb3MubW9ja0Vycm9yKGNhbmNlbCwgcHJvbWlzZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBfcGVuZGluZ19yZXF1ZXN0cy5wdXNoKHtcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBkYXRhLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIHByb21pc2UsXG4gICAgICAgIHVybFxuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufTtcblxuY29uc3QgX2hlbHBlclJlcSA9IChtZXRob2Q6IHN0cmluZywgdXJsOiBzdHJpbmcsIGRhdGE/OiBhbnksIGNvbmZpZz86IGFueSkgPT4ge1xuICAgIGNvbnN0IGNvbmYgPSBkYXRhICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9O1xuICAgIHJldHVybiBfbmV3UmVxKHtcbiAgICAgICAgLi4uY29uZixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICB1cmwsXG4gICAgfSk7XG59O1xuXG5jb25zdCBfaGVscGVyUmVxTm9EYXRhID0gKG1ldGhvZDogc3RyaW5nLCB1cmw6IHN0cmluZywgY29uZmlnPzogYW55KSA9PiB7XG4gICAgcmV0dXJuIF9oZWxwZXJSZXEobWV0aG9kLCB1cmwsIHt9LCBjb25maWcpXG59XG5cbmNvbnN0IE1vY2tBeGlvczogQXhpb3NNb2NrVHlwZSA9IChqZXN0LmZuKF9uZXdSZXEpIGFzIHVua25vd24pIGFzIEF4aW9zTW9ja1R5cGU7XG5cbi8vIG1vY2tpbmcgQXhpb3MgbWV0aG9kc1xuTW9ja0F4aW9zLmdldCA9IGplc3QuZm4oX2hlbHBlclJlcU5vRGF0YS5iaW5kKG51bGwsIFwiZ2V0XCIpKTtcbk1vY2tBeGlvcy5wb3N0ID0gamVzdC5mbihfaGVscGVyUmVxLmJpbmQobnVsbCwgXCJwb3N0XCIpKTtcbk1vY2tBeGlvcy5wdXQgPSBqZXN0LmZuKF9oZWxwZXJSZXEuYmluZChudWxsLCBcInB1dFwiKSk7XG5Nb2NrQXhpb3MucGF0Y2ggPSBqZXN0LmZuKF9oZWxwZXJSZXEuYmluZChudWxsLCBcInBhdGNoXCIpKTtcbk1vY2tBeGlvcy5kZWxldGUgPSBqZXN0LmZuKF9oZWxwZXJSZXFOb0RhdGEuYmluZChudWxsLCBcImRlbGV0ZVwiKSk7XG5Nb2NrQXhpb3MucmVxdWVzdCA9IGplc3QuZm4oX25ld1JlcSk7XG5Nb2NrQXhpb3MuYWxsID0gamVzdC5mbigodmFsdWVzKSA9PiBQcm9taXNlLmFsbCh2YWx1ZXMpKTtcbk1vY2tBeGlvcy5oZWFkID0gamVzdC5mbihfaGVscGVyUmVxTm9EYXRhLmJpbmQobnVsbCwgXCJoZWFkXCIpKTtcbk1vY2tBeGlvcy5vcHRpb25zID0gamVzdC5mbihfaGVscGVyUmVxTm9EYXRhLmJpbmQobnVsbCwgXCJvcHRpb25zXCIpKTtcbk1vY2tBeGlvcy5jcmVhdGUgPSBqZXN0LmZuKCgpID0+IE1vY2tBeGlvcyk7XG5cbk1vY2tBeGlvcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgcmVxdWVzdDoge1xuICAgICAgICB1c2U6IGplc3QuZm4oKSxcbiAgICAgICAgZWplY3Q6IGplc3QuZm4oKSxcbiAgICB9LFxuICAgIHJlc3BvbnNlOiB7XG4gICAgICAgIHVzZTogamVzdC5mbigpLFxuICAgICAgICBlamVjdDogamVzdC5mbigpLFxuICAgIH0sXG59O1xuXG5Nb2NrQXhpb3MuZGVmYXVsdHMgPSB7XG4gICAgaGVhZGVyczoge1xuICAgICAgICBjb21tb246IFtdLFxuICAgIH0sXG59O1xuXG5Nb2NrQXhpb3MucG9wUHJvbWlzZSA9IChwcm9taXNlPzogU3luY2hyb25vdXNQcm9taXNlPGFueT4pID0+IHtcbiAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAvLyByZW1vdmUgdGhlIHByb21pc2UgZnJvbSBwZW5kaW5nIHF1ZXVlXG4gICAgICAgIGZvciAobGV0IGl4ID0gMDsgaXggPCBfcGVuZGluZ19yZXF1ZXN0cy5sZW5ndGg7IGl4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcTogQXhpb3NNb2NrUXVldWVJdGVtID0gX3BlbmRpbmdfcmVxdWVzdHNbaXhdO1xuXG4gICAgICAgICAgICBpZiAocmVxLnByb21pc2UgPT09IHByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBfcGVuZGluZ19yZXF1ZXN0cy5zcGxpY2UoaXgsIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXEucHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRha2UgdGhlIG9sZGVzdCBwcm9taXNlXG4gICAgICAgIGNvbnN0IHJlcTogQXhpb3NNb2NrUXVldWVJdGVtID0gX3BlbmRpbmdfcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHJlcSA/IHJlcS5wcm9taXNlIDogdm9pZCAwO1xuICAgIH1cbn07XG5cbk1vY2tBeGlvcy5wb3BSZXF1ZXN0ID0gKHJlcXVlc3Q/OiBBeGlvc01vY2tRdWV1ZUl0ZW0pID0+IHtcbiAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBpeCA9IF9wZW5kaW5nX3JlcXVlc3RzLmluZGV4T2YocmVxdWVzdCk7XG4gICAgICAgIGlmIChpeCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cblxuICAgICAgICBfcGVuZGluZ19yZXF1ZXN0cy5zcGxpY2UoaXgsIDEpO1xuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX3BlbmRpbmdfcmVxdWVzdHMuc2hpZnQoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYW4gaXRlbSBmb3JtIHRoZSBxdWV1ZSwgYmFzZWQgb24gaXQncyB0eXBlXG4gKiBAcGFyYW0gcXVldWVJdGVtXG4gKi9cbmNvbnN0IHBvcFF1ZXVlSXRlbSA9IChxdWV1ZUl0ZW06IFN5bmNocm9ub3VzUHJvbWlzZTxhbnk+IHwgQXhpb3NNb2NrUXVldWVJdGVtID0gbnVsbCkgPT4ge1xuICAgIC8vIGZpcnN0IGxldCdzIHByZXRlbmQgdGhlIHBhcmFtIGlzIGEgcXVldWUgaXRlbVxuICAgIGNvbnN0IHJlcXVlc3Q6IEF4aW9zTW9ja1F1ZXVlSXRlbSA9IE1vY2tBeGlvcy5wb3BSZXF1ZXN0KFxuICAgICAgICBxdWV1ZUl0ZW0gYXMgQXhpb3NNb2NrUXVldWVJdGVtLFxuICAgICk7XG5cbiAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAvLyBJRiB0aGUgcmVxdWVzdCB3YXMgZm91bmRcbiAgICAgICAgLy8gPiBzZXQgdGhlIHByb21pc2VcbiAgICAgICAgcmV0dXJuIHJlcXVlc3QucHJvbWlzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFTFNFIG1heWJlIHRoZSBgcXVldWVJdGVtYCBpcyBhIHByb21pc2UgKGxlZ2FjeSBtb2RlKVxuICAgICAgICByZXR1cm4gTW9ja0F4aW9zLnBvcFByb21pc2UocXVldWVJdGVtIGFzIFVucmVzb2x2ZWRTeW5jaHJvbm91c1Byb21pc2U8YW55Pik7XG4gICAgfVxufTtcblxuTW9ja0F4aW9zLm1vY2tSZXNwb25zZSA9IChcbiAgICByZXNwb25zZT86IEh0dHBSZXNwb25zZSxcbiAgICBxdWV1ZUl0ZW06IFN5bmNocm9ub3VzUHJvbWlzZTxhbnk+IHwgQXhpb3NNb2NrUXVldWVJdGVtID0gbnVsbCxcbiAgICBzaWxlbnRNb2RlOiBib29sZWFuID0gZmFsc2UsXG4pOiB2b2lkID0+IHtcbiAgICAvLyByZXBsYWNpbmcgbWlzc2luZyBkYXRhIHdpdGggZGVmYXVsdCB2YWx1ZXNcbiAgICByZXNwb25zZSA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbmZpZzoge30sXG4gICAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiBcIk9LXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICk7XG5cbiAgICBjb25zdCBwcm9taXNlID0gcG9wUXVldWVJdGVtKHF1ZXVlSXRlbSk7XG5cbiAgICBpZiAoIXByb21pc2UgJiYgIXNpbGVudE1vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVxdWVzdCB0byByZXNwb25kIHRvIVwiKTtcbiAgICB9IGVsc2UgaWYgKCFwcm9taXNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyByZXNvbHZpbmcgdGhlIFByb21pc2Ugd2l0aCB0aGUgZ2l2ZW4gcmVzcG9uc2UgZGF0YVxuICAgIHByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XG59O1xuXG5Nb2NrQXhpb3MubW9ja1Jlc3BvbnNlRm9yID0gKFxuICAgIGNyaXRlcmlhOiBzdHJpbmcgfCBBeGlvc01vY2tSZXF1ZXN0Q3JpdGVyaWEsXG4gICAgcmVzcG9uc2U/OiBIdHRwUmVzcG9uc2UsXG4gICAgc2lsZW50TW9kZTogYm9vbGVhbiA9IGZhbHNlLFxuKTogdm9pZCA9PiB7XG4gICAgaWYgKHR5cGVvZiBjcml0ZXJpYSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjcml0ZXJpYSA9IHt1cmw6IGNyaXRlcmlhfTtcbiAgICB9XG4gICAgY29uc3QgcXVldWVJdGVtID0gTW9ja0F4aW9zLmdldFJlcU1hdGNoaW5nKGNyaXRlcmlhKTtcblxuICAgIGlmICghcXVldWVJdGVtICYmICFzaWxlbnRNb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlcXVlc3QgdG8gcmVzcG9uZCB0byFcIik7XG4gICAgfSBlbHNlIGlmICghcXVldWVJdGVtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBNb2NrQXhpb3MubW9ja1Jlc3BvbnNlKHJlc3BvbnNlLCBxdWV1ZUl0ZW0sIHNpbGVudE1vZGUpO1xufTtcblxuTW9ja0F4aW9zLm1vY2tFcnJvciA9IChcbiAgICBlcnJvcjogYW55ID0ge30sXG4gICAgcXVldWVJdGVtOiBTeW5jaHJvbm91c1Byb21pc2U8YW55PiB8IEF4aW9zTW9ja1F1ZXVlSXRlbSA9IG51bGwsXG4gICAgc2lsZW50TW9kZTogYm9vbGVhbiA9IGZhbHNlLFxuKSA9PiB7XG4gICAgY29uc3QgcHJvbWlzZSA9IHBvcFF1ZXVlSXRlbShxdWV1ZUl0ZW0pO1xuXG4gICAgaWYgKCFwcm9taXNlICYmICFzaWxlbnRNb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlcXVlc3QgdG8gcmVzcG9uZCB0byFcIik7XG4gICAgfSBlbHNlIGlmICghcHJvbWlzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IuaXNBeGlvc0Vycm9yID09PSB2b2lkIDApIHtcbiAgICAgICAgZXJyb3IuaXNBeGlvc0Vycm9yID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyByZXNvbHZpbmcgdGhlIFByb21pc2Ugd2l0aCB0aGUgZ2l2ZW4gZXJyb3JcbiAgICBwcm9taXNlLnJlamVjdChlcnJvcik7XG59O1xuXG5Nb2NrQXhpb3MuaXNBeGlvc0Vycm9yID0gKHBheWxvYWQpID0+ICh0eXBlb2YgcGF5bG9hZCA9PT0gJ29iamVjdCcpICYmIChwYXlsb2FkLmlzQXhpb3NFcnJvciA9PT0gdHJ1ZSk7XG5cbk1vY2tBeGlvcy5sYXN0UmVxR2V0ID0gKCkgPT4ge1xuICAgIHJldHVybiBfcGVuZGluZ19yZXF1ZXN0c1tfcGVuZGluZ19yZXF1ZXN0cy5sZW5ndGggLSAxXTtcbn07XG5cbk1vY2tBeGlvcy5sYXN0UHJvbWlzZUdldCA9ICgpID0+IHtcbiAgICBjb25zdCByZXEgPSBNb2NrQXhpb3MubGFzdFJlcUdldCgpO1xuICAgIHJldHVybiByZXEgPyByZXEucHJvbWlzZSA6IHZvaWQgMDtcbn07XG5cbmNvbnN0IF9maW5kUmVxQnlQcmVkaWNhdGUgPSAocHJlZGljYXRlOiAoaXRlbTogQXhpb3NNb2NrUXVldWVJdGVtKSA9PiBib29sZWFuKSA9PiB7XG4gICAgcmV0dXJuIF9wZW5kaW5nX3JlcXVlc3RzXG4gICAgLnNsaWNlKClcbiAgICAucmV2ZXJzZSgpIC8vIHJldmVyc2UgY2xvbmVkIGFycmF5IHRvIHJldHVybiBtb3N0IHJlY2VudCByZXFcbiAgICAuZmluZChwcmVkaWNhdGUpO1xufVxuXG5jb25zdCBfY2hlY2tDcml0ZXJpYSA9IChpdGVtOiBBeGlvc01vY2tRdWV1ZUl0ZW0sIGNyaXRlcmlhOiBBeGlvc01vY2tSZXF1ZXN0Q3JpdGVyaWEpID0+IHtcbiAgICBpZiAoY3JpdGVyaWEubWV0aG9kICE9PSB1bmRlZmluZWQgJiYgY3JpdGVyaWEubWV0aG9kLnRvTG93ZXJDYXNlKCkgIT09IGl0ZW0ubWV0aG9kLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChjcml0ZXJpYS51cmwgIT09IHVuZGVmaW5lZCAmJiBjcml0ZXJpYS51cmwgIT09IGl0ZW0udXJsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZihjcml0ZXJpYS5wYXJhbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZihpdGVtLmNvbmZpZyA9PT0gdW5kZWZpbmVkIHx8ICFpdGVtLmNvbmZpZy5wYXJhbXMgfHwgKHR5cGVvZiBpdGVtLmNvbmZpZy5wYXJhbXMgIT09ICdvYmplY3QnKSApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXJhbXNNYXRjaGluZyA9IE9iamVjdC5lbnRyaWVzKGNyaXRlcmlhLnBhcmFtcykuZXZlcnkoKFtrZXksIHZhbHVlXSkgPT4gaXRlbS5jb25maWcucGFyYW1zW2tleV0gPT09IHZhbHVlKTtcbiAgICAgICAgaWYoIXBhcmFtc01hdGNoaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbk1vY2tBeGlvcy5nZXRSZXFNYXRjaGluZyA9IChjcml0ZXJpYTogQXhpb3NNb2NrUmVxdWVzdENyaXRlcmlhKSA9PiB7XG4gICAgcmV0dXJuIF9maW5kUmVxQnlQcmVkaWNhdGUoKHgpID0+IF9jaGVja0NyaXRlcmlhKHgsIGNyaXRlcmlhKSk7XG59O1xuXG5Nb2NrQXhpb3MuZ2V0UmVxQnlVcmwgPSAodXJsOiBzdHJpbmcpID0+IHtcbiAgICByZXR1cm4gTW9ja0F4aW9zLmdldFJlcU1hdGNoaW5nKHt1cmx9KTtcbn07XG5cbk1vY2tBeGlvcy5nZXRSZXFCeU1hdGNoVXJsID0gKHVybDogUmVnRXhwKSA9PiB7XG4gICAgcmV0dXJuIF9maW5kUmVxQnlQcmVkaWNhdGUoKHgpID0+IHVybC50ZXN0KHgudXJsKSk7XG59O1xuXG5Nb2NrQXhpb3MuZ2V0UmVxQnlSZWdleCA9IChvcHRzOiB7W2tleSBpbiBrZXlvZiBBeGlvc01vY2tRdWV1ZUl0ZW1dKz86IFJlZ0V4cH0pID0+IHtcbiAgcmV0dXJuIF9maW5kUmVxQnlQcmVkaWNhdGUoeCA9PiBPYmplY3QuZW50cmllcyhvcHRzKS5ldmVyeSgoW2tleSwgdmFsdWVdKSA9PiB2YWx1ZS50ZXN0KEpTT04uc3RyaW5naWZ5KHhba2V5XSkpKSk7XG59O1xuXG5Nb2NrQXhpb3MucXVldWUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIF9wZW5kaW5nX3JlcXVlc3RzO1xufTtcblxuTW9ja0F4aW9zLnJlc2V0ID0gKCkgPT4ge1xuICAgIC8vIHJlbW92ZSBhbGwgdGhlIHJlcXVlc3RzXG4gICAgX3BlbmRpbmdfcmVxdWVzdHMuc3BsaWNlKDAsIF9wZW5kaW5nX3JlcXVlc3RzLmxlbmd0aCk7XG5cbiAgICAvLyByZXNldHMgYWxsIGluZm9ybWF0aW9uIHN0b3JlZCBpbiB0aGUgbW9ja0ZuLm1vY2suY2FsbHMgYW5kIG1vY2tGbi5tb2NrLmluc3RhbmNlcyBhcnJheXNcbiAgICBNb2NrQXhpb3MuZ2V0Lm1vY2tDbGVhcigpO1xuICAgIE1vY2tBeGlvcy5wb3N0Lm1vY2tDbGVhcigpO1xuICAgIE1vY2tBeGlvcy5wdXQubW9ja0NsZWFyKCk7XG4gICAgTW9ja0F4aW9zLnBhdGNoLm1vY2tDbGVhcigpO1xuICAgIE1vY2tBeGlvcy5kZWxldGUubW9ja0NsZWFyKCk7XG4gICAgTW9ja0F4aW9zLmhlYWQubW9ja0NsZWFyKCk7XG4gICAgTW9ja0F4aW9zLm9wdGlvbnMubW9ja0NsZWFyKCk7XG4gICAgTW9ja0F4aW9zLnJlcXVlc3QubW9ja0NsZWFyKCk7XG4gICAgTW9ja0F4aW9zLmFsbC5tb2NrQ2xlYXIoKTtcbn07XG5cbk1vY2tBeGlvcy5DYW5jZWwgPSBDYW5jZWw7XG5Nb2NrQXhpb3MuQ2FuY2VsVG9rZW4gPSBDYW5jZWxUb2tlbjtcbk1vY2tBeGlvcy5pc0NhbmNlbCA9ICh1KTogdSBpcyBDYW5jZWwgPT4ge1xuICAgIHJldHVybiAhISh1ICYmIHUuX19DQU5DRUxfXyk7XG59O1xuXG4vLyB0aGlzIGlzIGEgc2luZ2xldG9uIG9iamVjdFxuZXhwb3J0IGRlZmF1bHQgTW9ja0F4aW9zO1xuIl19