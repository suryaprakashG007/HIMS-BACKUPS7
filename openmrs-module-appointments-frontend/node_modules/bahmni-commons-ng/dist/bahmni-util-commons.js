(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


window.Bahmni = window.Bahmni || {};
Bahmni.Common = Bahmni.Common || {};
Bahmni.Common.Util = Bahmni.Common.Util || {};

angular.module('bahmni.common.util', []).provider('$bahmniCookieStore', [function () {
    var self = this;
    self.defaultOptions = {};
    var fixedEncodeURIComponent = function (str) {
        return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
            return '%' + c.charCodeAt(0).toString(16);
        });
    };

    self.setDefaultOptions = function (options) {
        self.defaultOptions = options;
    };

    self.$get = function () {
        return {
            get: function (name) {
                var jsonCookie = $.cookie(name);
                if (jsonCookie) {
                    return angular.fromJson(decodeURIComponent(jsonCookie));
                }
                return null;
            },
            put: function (name, value, options) {
                options = $.extend({}, self.defaultOptions, options);
                $.cookie.raw = true;
                $.cookie(name, fixedEncodeURIComponent(angular.toJson(value)), options);
            },
            remove: function (name, options) {
                options = $.extend({}, self.defaultOptions, options);
                $.removeCookie(name, options);
            }
        };
    };
}]);

__webpack_require__(1);

__webpack_require__(2);
__webpack_require__(3);
__webpack_require__(4);
__webpack_require__(5);
__webpack_require__(6);
__webpack_require__(7);
__webpack_require__(8);
__webpack_require__(9);
__webpack_require__(10);
__webpack_require__(11);
__webpack_require__(12);
__webpack_require__(13);
__webpack_require__(14);

/***/ }),
/* 1 */
/***/ (function(module, exports) {

/*** IMPORTS FROM imports-loader ***/
(function() {

/* Modernizr 2.8.3 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-touch-mq-cssclasses-teststyles-prefixes
 */
;window.Modernizr = function (a, b, c) {
  function x(a) {
    j.cssText = a;
  }function y(a, b) {
    return x(m.join(a + ";") + (b || ""));
  }function z(a, b) {
    return typeof a === b;
  }function A(a, b) {
    return !!~("" + a).indexOf(b);
  }function B(a, b, d) {
    for (var e in a) {
      var f = b[a[e]];if (f !== c) return d === !1 ? a[e] : z(f, "function") ? f.bind(d || b) : f;
    }return !1;
  }var d = "2.8.3",
      e = {},
      f = !0,
      g = b.documentElement,
      h = "modernizr",
      i = b.createElement(h),
      j = i.style,
      k,
      l = {}.toString,
      m = " -webkit- -moz- -o- -ms- ".split(" "),
      n = {},
      o = {},
      p = {},
      q = [],
      r = q.slice,
      s,
      t = function (a, c, d, e) {
    var f,
        i,
        j,
        k,
        l = b.createElement("div"),
        m = b.body,
        n = m || b.createElement("body");if (parseInt(d, 10)) while (d--) j = b.createElement("div"), j.id = e ? e[d] : h + (d + 1), l.appendChild(j);return f = ["&#173;", '<style id="s', h, '">', a, "</style>"].join(""), l.id = h, (m ? l : n).innerHTML += f, n.appendChild(l), m || (n.style.background = "", n.style.overflow = "hidden", k = g.style.overflow, g.style.overflow = "hidden", g.appendChild(n)), i = c(l, a), m ? l.parentNode.removeChild(l) : (n.parentNode.removeChild(n), g.style.overflow = k), !!i;
  },
      u = function (b) {
    var c = a.matchMedia || a.msMatchMedia;if (c) return c(b) && c(b).matches || !1;var d;return t("@media " + b + " { #" + h + " { position: absolute; } }", function (b) {
      d = (a.getComputedStyle ? getComputedStyle(b, null) : b.currentStyle)["position"] == "absolute";
    }), d;
  },
      v = {}.hasOwnProperty,
      w;!z(v, "undefined") && !z(v.call, "undefined") ? w = function (a, b) {
    return v.call(a, b);
  } : w = function (a, b) {
    return b in a && z(a.constructor.prototype[b], "undefined");
  }, Function.prototype.bind || (Function.prototype.bind = function (b) {
    var c = this;if (typeof c != "function") throw new TypeError();var d = r.call(arguments, 1),
        e = function () {
      if (this instanceof e) {
        var a = function () {};a.prototype = c.prototype;var f = new a(),
            g = c.apply(f, d.concat(r.call(arguments)));return Object(g) === g ? g : f;
      }return c.apply(b, d.concat(r.call(arguments)));
    };return e;
  }), n.touch = function () {
    var c;return "ontouchstart" in a || a.DocumentTouch && b instanceof DocumentTouch ? c = !0 : t(["@media (", m.join("touch-enabled),("), h, ")", "{#modernizr{top:9px;position:absolute}}"].join(""), function (a) {
      c = a.offsetTop === 9;
    }), c;
  };for (var C in n) w(n, C) && (s = C.toLowerCase(), e[s] = n[C](), q.push((e[s] ? "" : "no-") + s));return e.addTest = function (a, b) {
    if (typeof a == "object") for (var d in a) w(a, d) && e.addTest(d, a[d]);else {
      a = a.toLowerCase();if (e[a] !== c) return e;b = typeof b == "function" ? b() : b, typeof f != "undefined" && f && (g.className += " " + (b ? "" : "no-") + a), e[a] = b;
    }return e;
  }, x(""), i = k = null, e._version = d, e._prefixes = m, e.mq = u, e.testStyles = t, g.className = g.className.replace(/(^|\s)no-js(\s|$)/, "$1$2") + (f ? " js " + q.join(" ") : ""), e;
}(this, this.document);
}.call(window));

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Bahmni.Common.Util.AgeUtil = function () {
    var differenceInMonths = function (date, anotherDate) {
        var age = fromBirthDateTillReferenceDate(date, anotherDate);
        return parseFloat((age.years * 12 + age.months + age.days / 30).toFixed(3));
    };

    var fromBirthDateTillReferenceDate = function (birthDate, referenceDate) {
        var DateUtil = Bahmni.Common.Util.DateUtil;
        referenceDate = referenceDate || DateUtil.now();
        var period = DateUtil.diffInYearsMonthsDays(birthDate, referenceDate);
        return { years: period.years, months: period.months, days: period.days };
    };

    var monthsToAgeString = function (months) {
        var age = monthsToAge(months);
        var ageString = '';
        if (age.years) {
            ageString += age.years + 'y ';
        }
        if (age.months) {
            ageString += age.months + 'm ';
        }
        if (age.days) {
            ageString += age.days + 'd';
        }
        return ageString;
    };

    var monthsToAge = function (months) {
        var years = Math.floor(months / 12);
        var remainingMonths = Math.floor(months % 12);
        var days = Math.round((months - Math.floor(months)) * 30);
        return { years: years, months: remainingMonths, days: days };
    };

    return {
        monthsToAgeString: monthsToAgeString,
        differenceInMonths: differenceInMonths
    };
}();

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Bahmni.Common.Util.ArrayUtil = {
    chunk: function (array, chunkSize) {
        var chunks = [];
        for (var i = 0; i < array.length; i += chunkSize) {
            chunks.push(array.slice(i, i + chunkSize));
        }
        return chunks;
    },

    groupByPreservingOrder: function (records, groupingFunction, keyName, valueName) {
        var groups = [];
        records.forEach(function (record) {
            var recordKey = groupingFunction(record);
            var existingGroup = _.find(groups, function (group) {
                return group[keyName] === recordKey;
            });
            if (existingGroup) {
                existingGroup[valueName].push(record);
            } else {
                var newGroup = {};
                newGroup[keyName] = recordKey;
                newGroup[valueName] = [record];
                groups.push(newGroup);
            }
        });
        return groups;
    }
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Bahmni.Common.Util.DateTimeFormatter = {

    getDateWithoutTime: function (datetime) {
        return datetime ? moment(datetime).format("YYYY-MM-DD") : null;
    }
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Bahmni.Common.Util.DateUtil = {
    diffInDays: function (dateFrom, dateTo) {
        return Math.floor((this.parse(dateTo) - this.parse(dateFrom)) / (60 * 1000 * 60 * 24));
    },

    diffInMinutes: function (dateFrom, dateTo) {
        return moment(dateTo).diff(moment(dateFrom), 'minutes');
    },

    diffInSeconds: function (dateFrom, dateTo) {
        return moment(dateFrom).diff(moment(dateTo), 'seconds');
    },

    isInvalid: function (date) {
        return date == "Invalid Date";
    },

    diffInDaysRegardlessOfTime: function (dateFrom, dateTo) {
        var from = new Date(dateFrom);
        var to = new Date(dateTo);
        from.setHours(0, 0, 0, 0);
        to.setHours(0, 0, 0, 0);
        return Math.floor((to - from) / (60 * 1000 * 60 * 24));
    },

    addSeconds: function (date, seconds) {
        return moment(date).add(seconds, 'seconds').toDate();
    },

    addMinutes: function (date, minutes) {
        return this.addSeconds(date, minutes * 60);
    },

    addDays: function (date, days) {
        return moment(date).add(days, 'day').toDate();
    },
    addMonths: function (date, months) {
        return moment(date).add(months, 'month').toDate();
    },
    addYears: function (date, years) {
        return moment(date).add(years, 'year').toDate();
    },

    subtractSeconds: function (date, seconds) {
        return moment(date).subtract(seconds, 'seconds').toDate();
    },
    subtractDays: function (date, days) {
        return this.addDays(date, -1 * days);
    },
    subtractMonths: function (date, months) {
        return this.addMonths(date, -1 * months);
    },
    subtractYears: function (date, years) {
        return this.addYears(date, -1 * years);
    },

    createDays: function (startDate, endDate) {
        var startDate = this.getDate(startDate);
        var endDate = this.getDate(endDate);
        var numberOfDays = this.diffInDays(startDate, endDate);
        var days = [];
        for (var i = 0; i <= numberOfDays; i++) {
            days.push({ dayNumber: i + 1, date: this.addDays(startDate, i) });
        }
        return days;
    },

    getDayNumber: function (referenceDate, date) {
        return this.diffInDays(this.getDate(referenceDate), this.getDate(date)) + 1;
    },

    getDateWithoutTime: function (datetime) {
        return datetime ? moment(datetime).format("YYYY-MM-DD") : null;
    },

    getDateInMonthsAndYears: function (date, format) {
        var format = format || "MMM YY";
        var dateRepresentation = isNaN(Number(date)) ? date : Number(date);
        if (!moment(dateRepresentation).isValid()) {
            return date;
        }
        return dateRepresentation ? moment(dateRepresentation).format(format) : null;
    },

    formatDateWithTime: function (datetime) {
        var dateRepresentation = isNaN(Number(datetime)) ? datetime : Number(datetime);
        if (!moment(dateRepresentation).isValid()) {
            return datetime;
        }
        return dateRepresentation ? moment(dateRepresentation).format("DD MMM YY h:mm a") : null;
    },

    formatDateWithoutTime: function (date) {
        var dateRepresentation = isNaN(Number(date)) ? date : Number(date);
        if (!moment(dateRepresentation).isValid()) {
            return date;
        }
        return dateRepresentation ? moment(dateRepresentation).format("DD MMM YY") : null;
    },

    formatDateInStrictMode: function (date) {
        var dateRepresentation = isNaN(Number(date)) ? date : Number(date);
        if (moment(dateRepresentation, 'YYYY-MM-DD', true).isValid()) {
            return moment(dateRepresentation).format("DD MMM YY");
        }
        if (moment(dateRepresentation, 'YYYY-MM-DDTHH:mm:ss.SSSZZ', true).isValid()) {
            return moment(dateRepresentation).format("DD MMM YY");
        }
        return date;
    },

    formatTime: function (date) {
        var dateRepresentation = isNaN(Number(date)) ? date : Number(date);
        if (!moment(dateRepresentation).isValid()) {
            return date;
        }
        return dateRepresentation ? moment(dateRepresentation).format("h:mm a") : null;
    },

    getDate: function (dateTime) {
        return moment(this.parse(dateTime)).startOf('day').toDate();
    },

    parse: function (dateString) {
        return dateString ? moment(dateString).toDate() : null;
    },

    parseDatetime: function (dateTimeString) {
        return dateTimeString ? moment(dateTimeString) : null;
    },

    now: function () {
        return new Date();
    },

    today: function () {
        return this.getDate(this.now());
    },
    endOfToday: function () {
        return moment(this.parse(this.now())).endOf('day').toDate();
    },

    getDateWithoutHours: function (dateString) {
        return moment(dateString).toDate().setHours(0, 0, 0, 0);
    },

    getDateTimeWithoutSeconds: function (dateString) {
        return moment(dateString).toDate().setSeconds(0, 0);
    },

    isSameDateTime: function (date1, date2) {
        if (date1 == null || date2 == null) {
            return false;
        }
        var dateOne = this.parse(date1);
        var dateTwo = this.parse(date2);
        return dateOne.getTime() == dateTwo.getTime();
    },

    isBeforeDate: function (date1, date2) {
        return moment(date1).isBefore(moment(date2));
    },
    isSameDate: function (date1, date2) {
        if (date1 == null || date2 == null) {
            return false;
        }
        var dateOne = this.parse(date1);
        var dateTwo = this.parse(date2);
        return dateOne.getFullYear() === dateTwo.getFullYear() && dateOne.getMonth() === dateTwo.getMonth() && dateOne.getDate() === dateTwo.getDate();
    },

    diffInYearsMonthsDays: function (dateFrom, dateTo) {
        dateFrom = this.parse(dateFrom);
        dateTo = this.parse(dateTo);

        var from = {
            d: dateFrom.getDate(),
            m: dateFrom.getMonth(),
            y: dateFrom.getFullYear()
        };

        var to = {
            d: dateTo.getDate(),
            m: dateTo.getMonth(),
            y: dateTo.getFullYear()
        };

        var age = {
            d: 0,
            m: 0,
            y: 0
        };

        var daysFebruary = to.y % 4 != 0 || to.y % 100 == 0 && to.y % 400 != 0 ? 28 : 29;
        var daysInMonths = [31, daysFebruary, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        age.y = to.y - from.y;
        age.m = to.m - from.m;

        if (from.m > to.m) {
            age.y = age.y - 1;
            age.m = to.m - from.m + 12;
        }
        age.d = to.d - from.d;

        if (from.d > to.d) {
            age.m = age.m - 1;

            if (from.m == to.m) {
                age.y = age.y - 1;
                age.m = age.m + 12;
            }
            age.d = to.d - from.d + daysInMonths[parseInt(from.m)];
        }
        return {
            days: age.d,
            months: age.m,
            years: age.y
        };
    },

    convertToUnits: function (minutes) {
        var allUnits = { "Years": 365 * 24 * 60, "Months": 30 * 24 * 60, "Weeks": 7 * 24 * 60, "Days": 24 * 60, "Hours": 60, "Minutes": 1 };

        var durationRepresentation = function (value, unitName, unitValueInMinutes) {
            return { "value": value, "unitName": unitName, "unitValueInMinutes": unitValueInMinutes, "allUnits": allUnits };
        };

        for (var unitName in allUnits) {
            var unitValueInMinutes = allUnits[unitName];
            if (minutes || minutes !== 0) {
                if (minutes >= unitValueInMinutes && minutes % unitValueInMinutes === 0) {
                    return durationRepresentation(minutes / unitValueInMinutes, unitName, unitValueInMinutes);
                }
            }
        }
        return durationRepresentation(undefined, undefined, undefined);
    },

    getEndDateFromDuration: function (dateFrom, value, unit) {
        dateFrom = this.parse(dateFrom);
        var from = {
            h: dateFrom.getHours(),
            d: dateFrom.getDate(),
            m: dateFrom.getMonth(),
            y: dateFrom.getFullYear()
        };
        var to = new Date(from.y, from.m, from.d, from.h);

        if (unit === "Months") {
            to.setMonth(from.m + value);
        } else if (unit === "Weeks") {
            to.setDate(from.d + value * 7);
        } else if (unit === "Days") {
            to.setDate(from.d + value);
        } else if (unit === "Hours") {
            to.setHours(from.h + value);
        }
        return to;
    },

    parseLongDateToServerFormat: function (longDate) {
        return longDate ? moment(longDate).format("YYYY-MM-DDTHH:mm:ss.SSS") : null;
    },

    parseServerDateToDate: function (longDate) {
        return longDate ? moment(longDate, "YYYY-MM-DDTHH:mm:ss.SSSZZ").toDate() : null;
    },
    getDateTimeInSpecifiedFormat: function (date, format) {
        return date ? moment(date).format(format) : null;
    },
    getISOString: function (date) {
        return date ? moment(date).toDate().toISOString() : null;
    },
    isBeforeTime: function (time, otherTime) {
        return moment(time, 'hh:mm a').format('YYYY-MM-DD');
    }
};

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Bahmni.Common.Util.DynamicResourceLoader = function () {
    return {
        includeJs: function (script) {
            var element = document.createElement('script');
            element.setAttribute('src', script);
            document.body.appendChild(element);
        },
        includeCss: function (url) {
            var element = document.createElement('link');
            element.setAttribute('href', url);
            element.setAttribute('rel', "stylesheet");
            element.setAttribute('type', "text/css");
            document.head.appendChild(element);
        }
    };
}();

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Bahmni.Common.Util.FormFieldPathUtil = {
    getFormNameAndVersion: function (path) {
        var formNameAndVersion = path.split("/")[0].split('.');
        return {
            formName: formNameAndVersion[0],
            formVersion: formNameAndVersion[1]
        };
    }
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


angular.module('httpErrorInterceptor', []).config(['$httpProvider', function ($httpProvider) {
    var interceptor = ['$rootScope', '$q', function ($rootScope, $q) {
        var serverErrorMessages = Bahmni.Common.Constants.serverErrorMessages;

        var showError = function (errorMessage) {
            var result = _.find(serverErrorMessages, function (listItem) {
                return listItem.serverMessage === errorMessage;
            });
            if (_.isEmpty(result)) {
                $rootScope.$broadcast('event:serverError', errorMessage);
            }
        };

        function stringAfter(value, searchString) {
            var indexOfFirstColon = value.indexOf(searchString);
            return value.substr(indexOfFirstColon + 1).trim();
        }

        function getServerError(message) {
            return stringAfter(message, ':');
        }

        function success(response) {
            return response;
        }

        function shouldRedirectToLogin(response) {
            var errorMessage = response.data.error ? response.data.error.message : response.data;
            if (errorMessage.search("HTTP Status 403 - Session timed out") > 0) {
                return true;
            }
        }

        function error(response) {
            var data = response.data;
            var unexpectedError = "There was an unexpected issue on the server. Please try again";
            if (response.status === 500) {
                var errorMessage = data.error && data.error.message ? getServerError(data.error.message) : unexpectedError;
                showError(errorMessage);
            } else if (response.status === 409) {
                var errorMessage = data.error && data.error.message ? getServerError(data.error.message) : "Duplicate entry error";
                showError(errorMessage);
            } else if (response.status === 0) {
                showError("Could not connect to the server. Please check your connection and try again");
            } else if (response.status === 405) {
                showError(unexpectedError);
            } else if (response.status === 400) {
                var errorMessage = data.error && data.error.message ? data.error.message : data.localizedMessage || "Could not connect to the server. Please check your connection and try again";
                showError(errorMessage);
            } else if (response.status === 403) {
                var errorMessage = data.error && data.error.message ? data.error.message : unexpectedError;
                if (shouldRedirectToLogin(response)) {
                    $rootScope.$broadcast('event:auth-loginRequired');
                } else {
                    showError(errorMessage);
                }
            } else if (response.status === 404) {
                //TODO-Temp write test and refacor with _.some
                if (!_.includes(response.config.url, "implementation_config") && !_.includes(response.config.url, "locale_") && !_.includes(response.config.url, "offlineMetadata") && !_.includes(response.config.url, "bahmni.appointments.runningOnOpenmrs") && !_.includes(response.config.url, "bahmni.config.baseUrlForUIConfigs")) {
                    showError("The requested information does not exist");
                }
            }
            return $q.reject(response);
        }

        return {
            response: success,
            responseError: error
        };
    }];
    $httpProvider.interceptors.push(interceptor);
}]);

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


$(function () {
    if (Modernizr.ios) {
        // This fix is needed when we use fastclick.js on ipad
        $(document).on("click", "label[for]", function () {
            var $inputElement = $('input#' + $(this).attr('for'));
            var elementType = $inputElement.attr('type');
            if (elementType === 'radio') {
                $inputElement.prop('checked', true);
            } else if (elementType === 'checkbox') {
                $inputElement.prop('checked', !$inputElement.prop('checked'));
            } else {
                $inputElement.focus();
            }
        });
    }
});

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Modernizr.addTest('ios', function () {
    return navigator.userAgent.match(/(iPad|iPhone|iPod)/i) ? true : false;
});

Modernizr.addTest('windowOS', function () {
    return navigator.appVersion.indexOf("Win") != -1;
});

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


angular.module('bahmni.common.util').service('offlineStatusService', ['$rootScope', '$interval', 'appService', function ($rootScope, $interval, appService) {
    this.checkOfflineStatus = function () {
        if (Offline.state === 'up') {
            Offline.check();
        }
    };
    this.setOfflineOptions = function () {
        var networkConnectivity = appService.getAppDescriptor().getConfigValue("networkConnectivity");
        var showNetworkStatusIndicator = networkConnectivity != null ? networkConnectivity.showNetworkStatusMessage : null;
        var intervalFrequency = networkConnectivity != null ? networkConnectivity.networkStatusCheckInterval : null;
        intervalFrequency = intervalFrequency ? intervalFrequency : 5000;

        Offline.options = {
            game: true,
            checkOnLoad: true,
            checks: { xhr: { url: Bahmni.Common.Constants.faviconUrl } }
        };

        this.checkOfflineStatus();
        if ($rootScope.offlineStatusCheckIntervalPromise === undefined) {
            $rootScope.offlineStatusCheckIntervalPromise = $interval(this.checkOfflineStatus, intervalFrequency);
        }

        var clearCheckOfflineStatusInterval = function (offlineStatusCheckIntervalPromise) {
            $interval.cancel(offlineStatusCheckIntervalPromise);
        };

        $rootScope.$on("$destroy", function () {
            clearCheckOfflineStatusInterval($rootScope.offlineStatusCheckIntervalPromise);
        });

        if (showNetworkStatusIndicator === false) {
            $('.offline-ui').css('display', 'none');
        }
    };
}]);

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


String.prototype.format = function () {
    // eslint-disable-line no-extend-native
    var content = this;
    for (var i = 0; i < arguments.length; i++) {
        var replacement = '{' + i + '}';
        content = content.replace(replacement, arguments[i]);
    }
    return content;
};

String.prototype.toValidId = function () {
    // eslint-disable-line no-extend-native
    var content = this;
    return content.replace(/\s/g, '-');
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Bahmni.Common.Util.ValidationUtil = function () {
    var isAcceptableType = function (propertyToCheck) {
        return _.includes(["string", "boolean", "number", "object"], typeof propertyToCheck);
    };

    var flattenObject = function (ob) {
        var toReturn = {};
        for (var i in ob) {
            if (!ob.hasOwnProperty(i) || !isAcceptableType(ob[i])) {
                continue;
            }
            if (typeof ob[i] == 'object' && !(ob[i] instanceof Date)) {
                var flatObject = flattenObject(ob[i]);
                for (var x in flatObject) {
                    if (!flatObject.hasOwnProperty(x) || !isAcceptableType(flatObject[x])) {
                        continue;
                    }
                    toReturn[i + '.' + x] = flatObject[x];
                }
            } else {
                toReturn[i] = ob[i];
            }
        }
        return toReturn;
    };

    // This will work only for patient attributes, since we are passing concept behind the attribute.
    // To have a generic one, we need to remove the concept dependency.. And concept will be null for non concept fields
    var validate = function (complexObject, objectConfiguration) {
        var allCustomValidators = Bahmni.Registration.customValidator;
        if (!allCustomValidators) {
            return [];
        }

        var dataArray = flattenObject(complexObject);
        var errorMessages = [];
        _.every(dataArray, function (value, field) {
            var isValid = true;
            var fieldSpecificValidator = allCustomValidators[field];
            if (!fieldSpecificValidator) {
                return isValid;
            }
            if (typeof fieldSpecificValidator.method == 'function' && value) {
                var personAttributeTypeConfig = _.find(objectConfiguration, { name: field });
                isValid = fieldSpecificValidator.method(field, value, personAttributeTypeConfig);
                if (!isValid) {
                    errorMessages.push(fieldSpecificValidator.errorMessage);
                    isValid = true;
                }
            }
            return isValid;
        });
        return errorMessages;
    };
    return {
        validate: validate
    };
}();

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


angular.module('bahmni.common.util').service('openMRSHelperService', ['$http', '$q', function ($http, $q) {
    let isRunningOnOpenMRS = function () {
        let defer = $q.defer();
        let systemSettingUrl = Bahmni.Common.Constants.openMRSSystemSettingUrl;
        let params = '?q=bahmni.appointments.runningOnOpenmrs&v=custom:(property,value)';
        let runningOnOpenMRSPromise = $http.get(systemSettingUrl + params);
        runningOnOpenMRSPromise.then(response => {
            let results = response.data.results;
            if (results && results.length > 0) {
                let property = results[0];
                if (property.value) {
                    let value = property.value.trim();
                    defer.resolve(value.toLowerCase() === "true");
                } else {
                    defer.resolve(false);
                }
            } else {
                defer.resolve(false);
            }
        });
        return defer.promise;
    };

    return {
        isRunningOnOpenMRS: isRunningOnOpenMRS
    };
}]);

/***/ })
/******/ ]);
});