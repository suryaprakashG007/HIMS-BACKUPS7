import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";

/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { render } from '@testing-library/react';
import React from 'react';
import ContentSwitcher from '../ContentSwitcher';
import Switch from '../Switch';
import { mount, shallow } from 'enzyme';
describe('ContentSwitcher', function () {
  describe('component initial rendering', function () {
    var wrapper = shallow( /*#__PURE__*/React.createElement(ContentSwitcher, {
      onChange: function onChange() {},
      className: "extra-class"
    }, /*#__PURE__*/React.createElement(Switch, {
      kind: "anchor",
      text: "one"
    }), /*#__PURE__*/React.createElement(Switch, {
      kind: "anchor",
      text: "two"
    })));
    var children = wrapper.find(Switch);
    it('should render children as expected', function () {
      expect(children.length).toEqual(2);
    });
    it('should default "selected" property to true on first child', function () {
      expect(children.first().props().selected).toEqual(true);
      expect(children.last().props().selected).toEqual(false);
    });
    it('should apply extra classes passed to it', function () {
      expect(wrapper.hasClass('extra-class')).toEqual(true);
    });
    it('should not have a selectionMode prop', function () {
      expect('selectionMode' in wrapper.props()).toEqual(false);
    });
  });
  describe('Allow initial state to draw from props', function () {
    var onChange = jest.fn();
    var mockData = {
      index: 0
    };
    var wrapper = mount( /*#__PURE__*/React.createElement(ContentSwitcher, {
      selectedIndex: 1,
      onChange: onChange,
      className: "extra-class"
    }, /*#__PURE__*/React.createElement(Switch, {
      kind: "anchor",
      text: "one"
    }), /*#__PURE__*/React.createElement(Switch, {
      kind: "anchor",
      text: "two"
    })));
    var children = wrapper.find(Switch);
    it('Should apply the selected property on the selected child', function () {
      expect(children.first().props().selected).toEqual(false);
      expect(children.last().props().selected).toEqual(true);
    });
    it('should avoid change the selected index upon setting props, unless there the value actually changes', function () {
      wrapper.setProps({
        selectedIndex: 1
      }); // Turns `state.selectedIndex` to `0`

      children.first().props().onClick(mockData);
      wrapper.setProps({
        selectedIndex: 1
      }); // No change in `selectedIndex` prop

      var clonedChildren = wrapper.find(Switch);
      expect(clonedChildren.first().props().selected).toEqual(true);
      expect(clonedChildren.last().props().selected).toEqual(false);
    });
    it('should change the selected index upon change in props', function () {
      wrapper.setProps({
        selectedIndex: 0
      });
      children.first().props().onClick(mockData);
      wrapper.setProps({
        selectedIndex: 1
      });
      var clonedChildren = wrapper.find(Switch);
      expect(clonedChildren.first().props().selected).toEqual(false);
      expect(clonedChildren.last().props().selected).toEqual(true);
    });
  });
  describe('when child component onClick is invoked', function () {
    var onChange = jest.fn();
    var mockData = {
      index: 1
    };
    var wrapper = mount( /*#__PURE__*/React.createElement(ContentSwitcher, {
      onChange: onChange
    }, /*#__PURE__*/React.createElement(Switch, {
      kind: "anchor",
      text: "one"
    }), /*#__PURE__*/React.createElement(Switch, {
      kind: "anchor",
      text: "two"
    })));
    var children = wrapper.find(Switch);
    children.first().props().onClick(mockData);
    it('should invoke onChange', function () {
      expect(onChange).toHaveBeenCalledWith(mockData);
    });
    it('should set the correct selectedIndex', function () {
      expect(wrapper.state('selectedIndex')).toEqual(mockData.index);
    });
    it('should set selected to true on the correct child', function () {
      wrapper.update();
      var firstChild = wrapper.find(Switch).first();
      var secondChild = wrapper.find(Switch).last();
      expect(firstChild.props().selected).toEqual(false);
      expect(secondChild.props().selected).toEqual(true);
    });
  });
  describe('when child component onKeyDown is invoked', function () {
    var onChange = jest.fn();
    var mockData = {
      index: 1
    };
    var wrapper = mount( /*#__PURE__*/React.createElement(ContentSwitcher, {
      onChange: onChange
    }, /*#__PURE__*/React.createElement(Switch, {
      kind: "anchor",
      text: "one"
    }), /*#__PURE__*/React.createElement(Switch, {
      kind: "anchor",
      text: "two"
    })));
    var children = wrapper.find(Switch);
    children.first().props().onKeyDown(mockData);
    it('should invoke onChange', function () {
      expect(onChange).toHaveBeenCalledWith(mockData);
    });
    it('should set the correct selectedIndex', function () {
      expect(wrapper.state('selectedIndex')).toEqual(mockData.index);
    });
    it('should set selected to true on the correct child', function () {
      wrapper.update();
      var firstChild = wrapper.find(Switch).first();
      var secondChild = wrapper.find(Switch).last();
      expect(firstChild.props().selected).toEqual(false);
      expect(secondChild.props().selected).toEqual(true);
    });
  });
  describe('onChange', function () {
    it('should call `onChange` with the newly selected switch data when using a keyboard', function () {
      var onChange = jest.fn();
      var wrapper = mount( /*#__PURE__*/React.createElement(ContentSwitcher, {
        onChange: onChange
      }, /*#__PURE__*/React.createElement(Switch, {
        name: "first",
        text: "first"
      }), /*#__PURE__*/React.createElement(Switch, {
        name: "second",
        text: "second"
      }), /*#__PURE__*/React.createElement(Switch, {
        name: "third",
        text: "third"
      })));
      wrapper.find({
        name: 'first'
      }).simulate('keydown', {
        key: 'ArrowRight'
      });
      expect(onChange).toHaveBeenCalledTimes(1);
      expect(onChange).toHaveBeenLastCalledWith({
        index: 1,
        name: 'second',
        text: 'second',
        key: 'ArrowRight'
      });
      wrapper.find({
        name: 'second'
      }).simulate('keydown', {
        key: 'ArrowRight'
      });
      expect(onChange).toHaveBeenLastCalledWith({
        index: 2,
        name: 'third',
        text: 'third',
        key: 'ArrowRight'
      });
      wrapper.find({
        name: 'third'
      }).simulate('keydown', {
        key: 'ArrowRight'
      });
      expect(onChange).toHaveBeenLastCalledWith({
        index: 0,
        name: 'first',
        text: 'first',
        key: 'ArrowRight'
      });
    });
    it('should call `onChange` with the newly selected switch data when using a mouse', function () {
      var onChange = jest.fn();
      var wrapper = mount( /*#__PURE__*/React.createElement(ContentSwitcher, {
        onChange: onChange
      }, /*#__PURE__*/React.createElement(Switch, {
        name: "first",
        text: "first"
      }), /*#__PURE__*/React.createElement(Switch, {
        name: "second",
        text: "second"
      }), /*#__PURE__*/React.createElement(Switch, {
        name: "third",
        text: "third"
      })));
      wrapper.find({
        name: 'second'
      }).simulate('click');
      expect(onChange).toHaveBeenCalledTimes(1);
      expect(onChange).toHaveBeenLastCalledWith({
        index: 1,
        name: 'second',
        text: 'second'
      });
      wrapper.find({
        name: 'third'
      }).simulate('click');
      expect(onChange).toHaveBeenLastCalledWith({
        index: 2,
        name: 'third',
        text: 'third'
      });
    });
  });
  describe('automated verification testing', function () {
    it('should have no aXe violations', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var _render, container;

      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _render = render( /*#__PURE__*/React.createElement(ContentSwitcher, null, /*#__PURE__*/React.createElement(Switch, {
                kind: "anchor",
                text: "one"
              }), /*#__PURE__*/React.createElement(Switch, {
                kind: "anchor",
                text: "two"
              }))), container = _render.container;
              _context.next = 3;
              return expect(container).toHaveNoAxeViolations();

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    it('should have no AC violations', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
      var _render2, container;

      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _render2 = render( /*#__PURE__*/React.createElement("main", null, /*#__PURE__*/React.createElement(ContentSwitcher, null, /*#__PURE__*/React.createElement(Switch, {
                kind: "anchor",
                text: "one"
              }), /*#__PURE__*/React.createElement(Switch, {
                kind: "anchor",
                text: "two"
              })))), container = _render2.container;
              _context2.next = 3;
              return expect(container).toHaveNoACViolations('ContentSwitcher');

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
  });
});