"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tab = exports.IconTab = void 0;
exports.TabList = TabList;
exports.TabPanel = void 0;
exports.TabPanels = TabPanels;
exports.Tabs = Tabs;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _iconsReact = require("@carbon/icons-react");

var _classnames = _interopRequireDefault(require("classnames"));

var _lodash = _interopRequireDefault(require("lodash.debounce"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _next = require("../../Tooltip/next");

var _useControllableState3 = require("../../../internal/useControllableState");

var _useEffectOnce = require("../../../internal/useEffectOnce");

var _useId = require("../../../internal/useId");

var _useIsomorphicEffect = _interopRequireDefault(require("../../../internal/useIsomorphicEffect"));

var _useMergedRefs = require("../../../internal/useMergedRefs");

var _useNoInteractiveChildren = require("../../../internal/useNoInteractiveChildren");

var _usePrefix = require("../../../internal/usePrefix");

var _keyboard = require("../../../internal/keyboard");

var _usePressable = require("./usePressable");

var _excluded = ["activation", "aria-label", "children", "className", "contained", "iconSize", "leftOverflowButtonProps", "light", "rightOverflowButtonProps", "scrollDebounceWait", "scrollIntoView"],
    _excluded2 = ["as", "children", "className", "disabled", "onClick", "onKeyDown"],
    _excluded3 = ["children", "className", "defaultOpen", "enterDelayMs", "leaveDelayMs", "label"],
    _excluded4 = ["children", "className"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Used to manage the overall state of the Tabs
var TabsContext = /*#__PURE__*/_react.default.createContext(); // Used to keep track of position in a tablist


var TabContext = /*#__PURE__*/_react.default.createContext(); // Used to keep track of position in a list of tab panels


var TabPanelContext = /*#__PURE__*/_react.default.createContext();

function Tabs(_ref) {
  var children = _ref.children,
      _ref$defaultSelectedI = _ref.defaultSelectedIndex,
      defaultSelectedIndex = _ref$defaultSelectedI === void 0 ? 0 : _ref$defaultSelectedI,
      _onChange = _ref.onChange,
      controlledSelectedIndex = _ref.selectedIndex;
  var baseId = (0, _useId.useId)('ccs'); // The active index is used to track the element which has focus in our tablist

  var _useState = (0, _react.useState)(defaultSelectedIndex),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      activeIndex = _useState2[0],
      setActiveIndex = _useState2[1]; // The selected index is used for the tab/panel pairing which is "visible"


  var _useControllableState = (0, _useControllableState3.useControllableState)({
    value: controlledSelectedIndex,
    defaultValue: defaultSelectedIndex,
    onChange: function onChange(value) {
      if (_onChange) {
        _onChange({
          selectedIndex: value
        });
      }
    }
  }),
      _useControllableState2 = (0, _slicedToArray2.default)(_useControllableState, 2),
      selectedIndex = _useControllableState2[0],
      setSelectedIndex = _useControllableState2[1];

  var value = {
    baseId: baseId,
    activeIndex: activeIndex,
    defaultSelectedIndex: defaultSelectedIndex,
    setActiveIndex: setActiveIndex,
    selectedIndex: selectedIndex,
    setSelectedIndex: setSelectedIndex
  };
  return /*#__PURE__*/_react.default.createElement(TabsContext.Provider, {
    value: value
  }, children);
}

Tabs.propTypes = {
  /**
   * Provide child elements to be rendered inside of the `Tabs`.
   * These elements should render either `TabsList` or `TabsPanels`
   */
  children: _propTypes.default.node,

  /**
   * Specify which content tab should be initially selected when the component
   * is first rendered
   */
  defaultSelectedIndex: _propTypes.default.number,

  /**
   * Provide an optional function which is called whenever the state of the
   * `Tabs` changes
   */
  onChange: _propTypes.default.func,

  /**
   * Control which content panel is currently selected. This puts the component
   * in a controlled mode and should be used along with `onChange`
   */
  selectedIndex: _propTypes.default.number
};
/**
 * Get the next index for a given keyboard event given a count of the total
 * items and the current index
 * @param {Event} event
 * @param {number} total
 * @param {number} index
 * @returns {number}
 */

function getNextIndex(event, total, index) {
  if ((0, _keyboard.match)(event, _keyboard.keys.ArrowRight)) {
    return (index + 1) % total;
  } else if ((0, _keyboard.match)(event, _keyboard.keys.ArrowLeft)) {
    return (total + index - 1) % total;
  } else if ((0, _keyboard.match)(event, _keyboard.keys.Home)) {
    return 0;
  } else if ((0, _keyboard.match)(event, _keyboard.keys.End)) {
    return total - 1;
  }
}

function TabList(_ref2) {
  var _cx;

  var _ref2$activation = _ref2.activation,
      activation = _ref2$activation === void 0 ? 'automatic' : _ref2$activation,
      label = _ref2['aria-label'],
      children = _ref2.children,
      customClassName = _ref2.className,
      _ref2$contained = _ref2.contained,
      contained = _ref2$contained === void 0 ? false : _ref2$contained,
      iconSize = _ref2.iconSize,
      leftOverflowButtonProps = _ref2.leftOverflowButtonProps,
      light = _ref2.light,
      rightOverflowButtonProps = _ref2.rightOverflowButtonProps,
      _ref2$scrollDebounceW = _ref2.scrollDebounceWait,
      scrollDebounceWait = _ref2$scrollDebounceW === void 0 ? 200 : _ref2$scrollDebounceW,
      scrollIntoView = _ref2.scrollIntoView,
      rest = (0, _objectWithoutProperties2.default)(_ref2, _excluded);

  var _React$useContext = _react.default.useContext(TabsContext),
      activeIndex = _React$useContext.activeIndex,
      selectedIndex = _React$useContext.selectedIndex,
      setSelectedIndex = _React$useContext.setSelectedIndex,
      setActiveIndex = _React$useContext.setActiveIndex;

  var prefix = (0, _usePrefix.usePrefix)();
  var ref = (0, _react.useRef)(null);
  var previousButton = (0, _react.useRef)(null);
  var nextButton = (0, _react.useRef)(null);

  var _useState3 = (0, _react.useState)(false),
      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
      isScrollable = _useState4[0],
      setIsScrollable = _useState4[1];

  var _useState5 = (0, _react.useState)(false),
      _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
      scrollLeft = _useState6[0],
      setScrollLeft = _useState6[1];

  var className = (0, _classnames.default)("".concat(prefix, "--tabs"), customClassName, (_cx = {}, (0, _defineProperty2.default)(_cx, "".concat(prefix, "--tabs--contained"), contained), (0, _defineProperty2.default)(_cx, "".concat(prefix, "--tabs--light"), light), (0, _defineProperty2.default)(_cx, "".concat(prefix, "--tabs__icon--default"), iconSize === 'default'), (0, _defineProperty2.default)(_cx, "".concat(prefix, "--tabs__icon--lg"), iconSize === 'lg'), _cx)); // Previous Button
  // VISIBLE IF:
  //   SCROLLABLE
  //   AND SCROLL_LEFT > 0

  var buttonWidth = 44;
  var isPreviousButtonVisible = ref.current ? isScrollable && scrollLeft > 0 : false; // Next Button
  // VISIBLE IF:
  //   SCROLLABLE
  //   AND SCROLL_LEFT + CLIENT_WIDTH < SCROLL_WIDTH

  var isNextButtonVisible = ref.current ? scrollLeft + buttonWidth + ref.current.clientWidth < ref.current.scrollWidth : false;
  var previousButtonClasses = (0, _classnames.default)("".concat(prefix, "--tab--overflow-nav-button"), "".concat(prefix, "--tab--overflow-nav-button--previous"), (0, _defineProperty2.default)({}, "".concat(prefix, "--tab--overflow-nav-button--hidden"), !isPreviousButtonVisible));
  var nextButtonClasses = (0, _classnames.default)("".concat(prefix, "--tab--overflow-nav-button"), "".concat(prefix, "--tab--overflow-nav-button--next"), (0, _defineProperty2.default)({}, "".concat(prefix, "--tab--overflow-nav-button--hidden"), !isNextButtonVisible));
  var tabs = [];
  var debouncedOnScroll = (0, _react.useCallback)(function () {
    return (0, _lodash.default)(function (event) {
      setScrollLeft(event.target.scrollLeft);
    }, scrollDebounceWait);
  }, [scrollDebounceWait]);

  function onKeyDown(event) {
    if ((0, _keyboard.matches)(event, [_keyboard.keys.ArrowRight, _keyboard.keys.ArrowLeft, _keyboard.keys.Home, _keyboard.keys.End])) {
      event.preventDefault();
      var activeTabs = tabs.filter(function (tab) {
        return !tab.current.disabled;
      });
      var currentIndex = activeTabs.indexOf(tabs[activation === 'automatic' ? selectedIndex : activeIndex]);
      var nextIndex = tabs.indexOf(activeTabs[getNextIndex(event, activeTabs.length, currentIndex)]);

      if (activation === 'automatic') {
        setSelectedIndex(nextIndex);
      } else if (activation === 'manual') {
        setActiveIndex(nextIndex);
      }

      tabs[nextIndex].current.focus();
    }
  }

  (0, _useEffectOnce.useEffectOnce)(function () {
    var tab = tabs[selectedIndex];

    if (scrollIntoView && tab) {
      tab.current.scrollIntoView({
        block: 'nearest',
        inline: 'nearest'
      });
    }
  });
  (0, _useEffectOnce.useEffectOnce)(function () {
    if (tabs[selectedIndex].current.disabled) {
      var activeTabs = tabs.filter(function (tab) {
        return !tab.current.disabled;
      });

      if (activeTabs.length > 0) {
        var tab = activeTabs[0];
        setSelectedIndex(tabs.indexOf(tab));
      }
    }
  });
  (0, _useIsomorphicEffect.default)(function () {
    if (ref.current) {
      setIsScrollable(ref.current.scrollWidth > ref.current.clientWidth);
    }

    function handler() {
      if (ref.current) {
        setIsScrollable(ref.current.scrollWidth > ref.current.clientWidth);
      }
    }

    var debouncedHandler = (0, _lodash.default)(handler, 200);
    window.addEventListener('resize', debouncedHandler);
    return function () {
      debouncedHandler.cancel();
      window.removeEventListener('resize', debouncedHandler);
    };
  }, []); // updates scroll location for all scroll behavior.

  (0, _useIsomorphicEffect.default)(function () {
    ref.current.scrollLeft = scrollLeft;
  }, [scrollLeft]);
  (0, _useIsomorphicEffect.default)(function () {
    var tab = activation === 'manual' ? tabs[activeIndex] : tabs[selectedIndex];

    if (tab) {
      // The width of the "scroll buttons"
      // The start and end position of the selected tab
      var _tab$current$getBound = tab.current.getBoundingClientRect(),
          tabWidth = _tab$current$getBound.width;

      var start = tab.current.offsetLeft;
      var end = tab.current.offsetLeft + tabWidth; // The start and end of the visible area for the tabs

      var visibleStart = ref.current.scrollLeft + buttonWidth;
      var visibleEnd = ref.current.scrollLeft + ref.current.clientWidth - buttonWidth; // The beginning of the tab is clipped and not visible

      if (start < visibleStart) {
        setScrollLeft(start - buttonWidth);
      } // The end of teh tab is clipped and not visible


      if (end > visibleEnd) {
        setScrollLeft(end + buttonWidth - ref.current.clientWidth);
      }
    }
  }, [activation, activeIndex, selectedIndex]);
  (0, _usePressable.usePressable)(previousButton, {
    onPress: function onPress(_ref3) {
      var longPress = _ref3.longPress;

      if (!longPress) {
        setScrollLeft(Math.max(scrollLeft - ref.current.scrollWidth / tabs.length * 1.5, 0));
      }
    },
    onLongPress: function onLongPress() {
      return createLongPressBehavior(ref, 'backward', setScrollLeft);
    }
  });
  (0, _usePressable.usePressable)(nextButton, {
    onPress: function onPress(_ref4) {
      var longPress = _ref4.longPress;

      if (!longPress) {
        setScrollLeft(Math.min(scrollLeft + ref.current.scrollWidth / tabs.length * 1.5, ref.current.scrollWidth - ref.current.clientWidth));
      }
    },
    onLongPress: function onLongPress() {
      return createLongPressBehavior(ref, 'forward', setScrollLeft);
    }
  });
  return /*#__PURE__*/_react.default.createElement("div", {
    className: className
  }, /*#__PURE__*/_react.default.createElement("button", (0, _extends2.default)({
    "aria-hidden": "true",
    "aria-label": "Scroll left",
    ref: previousButton,
    className: previousButtonClasses,
    type: "button"
  }, leftOverflowButtonProps), /*#__PURE__*/_react.default.createElement(_iconsReact.ChevronLeft16, null)), /*#__PURE__*/_react.default.createElement("div", (0, _extends2.default)({}, rest, {
    "aria-label": label,
    ref: ref,
    role: "tablist",
    className: "".concat(prefix, "--tab--list"),
    onScroll: debouncedOnScroll,
    onKeyDown: onKeyDown
  }), _react.default.Children.map(children, function (child, index) {
    var ref = /*#__PURE__*/_react.default.createRef();

    tabs.push(ref);
    return /*#__PURE__*/_react.default.createElement(TabContext.Provider, {
      value: index
    }, /*#__PURE__*/_react.default.cloneElement(child, {
      ref: ref
    }));
  })), /*#__PURE__*/_react.default.createElement("button", (0, _extends2.default)({
    "aria-hidden": "true",
    "aria-label": "Scroll right",
    ref: nextButton,
    className: nextButtonClasses,
    type: "button"
  }, rightOverflowButtonProps), /*#__PURE__*/_react.default.createElement(_iconsReact.ChevronRight16, null)));
}

TabList.propTypes = {
  /**
   * Specify whether the content tab should be activated automatically or
   * manually
   */
  activation: _propTypes.default.oneOf(['automatic', 'manual']),

  /**
   * Provide an accessible label to be read when a user interacts with this
   * component
   */
  'aria-label': _propTypes.default.string.isRequired,

  /**
   * Provide child elements to be rendered inside of `ContentTabs`.
   * These elements should render a `ContentTab`
   */
  children: _propTypes.default.node,

  /**
   * Specify an optional className to be added to the container node
   */
  className: _propTypes.default.string,

  /**
   * Specify whether component is contained type
   */
  contained: _propTypes.default.bool,

  /**
   * If using `IconTab`, specify the size of the icon being used.
   */
  iconSize: _propTypes.default.oneOf(['default', 'lg']),

  /**
   * Provide the props that describe the left overflow button
   */
  leftOverflowButtonProps: _propTypes.default.object,

  /**
   * Specify whether or not to use the light component variant
   */
  light: _propTypes.default.bool,

  /**
   * Provide the props that describe the right overflow button
   */
  rightOverflowButtonProps: _propTypes.default.object,

  /**
   * Optionally provide a delay (in milliseconds) passed to the lodash
   * debounce of the onScroll handler. This will impact the responsiveness
   * of scroll arrow buttons rendering when scrolling to the first or last tab.
   */
  scrollDebounceWait: _propTypes.default.number,

  /**
   * Choose whether or not to automatically scroll to newly selected tabs
   * on component rerender
   */
  scrollIntoView: _propTypes.default.bool
};
/**
 * Helper function to setup the behavior when a button is "long pressed". This
 * function will take a ref to the tablist, a direction, and a setter for
 * scrollLeft and will update the scroll position within a
 * requestAnimationFrame.
 *
 * It returns a cleanup function to be run when the long press is
 * deactivated
 *
 * @param {RefObject} ref
 * @param {'forward' | 'backward'} direction
 * @param {Function} setScrollLeft
 * @returns {Function}
 */

function createLongPressBehavior(ref, direction, setScrollLeft) {
  // We manually override the scroll behavior to be "auto". If it is set as
  // smooth, this animation does not update correctly
  var defaultScrollBehavior = ref.current.style['scroll-behavior'];
  ref.current.style['scroll-behavior'] = 'auto';
  var scrollDelta = direction === 'forward' ? 5 : -5;
  var frameId = null;

  function tick() {
    ref.current.scrollLeft = ref.current.scrollLeft + scrollDelta;
    frameId = requestAnimationFrame(tick);
  }

  frameId = requestAnimationFrame(tick);
  return function () {
    // Restore the previous scroll behavior
    ref.current.style['scroll-behavior'] = defaultScrollBehavior; // Make sure that our `scrollLeft` value is in sync with the existing
    // `ref` after our requestAnimationFrame loop above

    setScrollLeft(ref.current.scrollLeft);

    if (frameId) {
      cancelAnimationFrame(frameId);
    }
  };
}

var Tab = /*#__PURE__*/_react.default.forwardRef(function Tab(_ref5, ref) {
  var _cx4;

  var _ref5$as = _ref5.as,
      BaseComponent = _ref5$as === void 0 ? 'button' : _ref5$as,
      children = _ref5.children,
      customClassName = _ref5.className,
      disabled = _ref5.disabled,
      _onClick = _ref5.onClick,
      onKeyDown = _ref5.onKeyDown,
      rest = (0, _objectWithoutProperties2.default)(_ref5, _excluded2);
  var prefix = (0, _usePrefix.usePrefix)();

  var _React$useContext2 = _react.default.useContext(TabsContext),
      selectedIndex = _React$useContext2.selectedIndex,
      setSelectedIndex = _React$useContext2.setSelectedIndex,
      baseId = _React$useContext2.baseId;

  var index = _react.default.useContext(TabContext);

  var id = "".concat(baseId, "-tab-").concat(index);
  var panelId = "".concat(baseId, "-tabpanel-").concat(index);
  var className = (0, _classnames.default)("".concat(prefix, "--tabs__nav-item"), "".concat(prefix, "--tabs__nav-link"), customClassName, (_cx4 = {}, (0, _defineProperty2.default)(_cx4, "".concat(prefix, "--tabs__nav-item--selected"), selectedIndex === index), (0, _defineProperty2.default)(_cx4, "".concat(prefix, "--tabs__nav-item--disabled"), disabled), _cx4));
  return /*#__PURE__*/_react.default.createElement(BaseComponent, (0, _extends2.default)({}, rest, {
    "aria-controls": panelId,
    "aria-disabled": disabled,
    "aria-selected": selectedIndex === index,
    ref: ref,
    id: id,
    role: "tab",
    className: className,
    disabled: disabled,
    onClick: function onClick(evt) {
      if (disabled) {
        return;
      }

      setSelectedIndex(index);

      if (_onClick) {
        _onClick(evt);
      }
    },
    onKeyDown: onKeyDown,
    tabIndex: selectedIndex === index ? '0' : '-1',
    type: "button"
  }), children);
});

exports.Tab = Tab;
Tab.propTypes = {
  /**
   * Provide a custom element to render instead of the default button
   */
  as: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.elementType]),

  /**
   * Provide child elements to be rendered inside of `Tab`.
   */
  children: _propTypes.default.node,

  /**
   * Specify an optional className to be added to your Tab
   */
  className: _propTypes.default.string,

  /**
   * Whether your Tab is disabled.
   */
  disabled: _propTypes.default.bool,

  /**
   * Provide a handler that is invoked when a user clicks on the control
   */
  onClick: _propTypes.default.func,

  /**
   * Provide a handler that is invoked on the key down event for the control
   */
  onKeyDown: _propTypes.default.func,

  /*
   * An optional parameter to allow overriding the anchor rendering.
   * Useful for using Tab along with react-router or other client
   * side router libraries.
   **/
  renderButton: _propTypes.default.func
};

var IconTab = /*#__PURE__*/_react.default.forwardRef(function IconTab(_ref6, ref) {
  var children = _ref6.children,
      customClassName = _ref6.className,
      _ref6$defaultOpen = _ref6.defaultOpen,
      defaultOpen = _ref6$defaultOpen === void 0 ? false : _ref6$defaultOpen,
      enterDelayMs = _ref6.enterDelayMs,
      leaveDelayMs = _ref6.leaveDelayMs,
      label = _ref6.label,
      rest = (0, _objectWithoutProperties2.default)(_ref6, _excluded3);
  var prefix = (0, _usePrefix.usePrefix)();
  var classNames = (0, _classnames.default)("".concat(prefix, "--tabs__nav-item--icon"), customClassName);
  return /*#__PURE__*/_react.default.createElement(_next.Tooltip, {
    align: "bottom",
    defaultOpen: defaultOpen,
    className: "".concat(prefix, "--icon-tooltip"),
    enterDelayMs: enterDelayMs,
    label: label,
    leaveDelayMs: leaveDelayMs
  }, /*#__PURE__*/_react.default.createElement(Tab, (0, _extends2.default)({
    className: classNames,
    ref: ref
  }, rest), children));
});

exports.IconTab = IconTab;
IconTab.propTypes = {
  /**
   * Provide an icon to be rendered inside of `IconTab` as the visual label for Tab.
   */
  children: _propTypes.default.node,

  /**
   * Specify an optional className to be added to your Tab
   */
  className: _propTypes.default.string,

  /**
   * Specify whether the tooltip for the icon should be open when it first renders
   */
  defaultOpen: _propTypes.default.bool,

  /**
   * Specify the duration in milliseconds to delay before displaying the tooltip for the icon.
   */
  enterDelayMs: _propTypes.default.number,

  /**
   * Provide the label to be rendered inside of the Tooltip. The label will use
   * `aria-labelledby` and will fully describe the child node that is provided.
   * This means that if you have text in the child node it will not be
   * announced to the screen reader.
   */
  label: _propTypes.default.node.isRequired,

  /**
   * Specify the duration in milliseconds to delay before hiding the tooltip
   */
  leaveDelayMs: _propTypes.default.number
};

var TabPanel = /*#__PURE__*/_react.default.forwardRef(function TabPanel(_ref7, forwardRef) {
  var children = _ref7.children,
      customClassName = _ref7.className,
      rest = (0, _objectWithoutProperties2.default)(_ref7, _excluded4);
  var prefix = (0, _usePrefix.usePrefix)();
  var panel = (0, _react.useRef)(null);
  var ref = (0, _useMergedRefs.useMergedRefs)([forwardRef, panel]);

  var _useState7 = (0, _react.useState)('0'),
      _useState8 = (0, _slicedToArray2.default)(_useState7, 2),
      tabIndex = _useState8[0],
      setTabIndex = _useState8[1];

  var _React$useContext3 = _react.default.useContext(TabsContext),
      selectedIndex = _React$useContext3.selectedIndex,
      baseId = _React$useContext3.baseId;

  var index = _react.default.useContext(TabPanelContext);

  var id = "".concat(baseId, "-tabpanel-").concat(index);
  var tabId = "".concat(baseId, "-tab-").concat(index);
  var className = (0, _classnames.default)("".concat(prefix, "--tab-content"), customClassName); // tabindex should only be 0 if no interactive content in children

  (0, _react.useEffect)(function () {
    var interactiveContent = (0, _useNoInteractiveChildren.getInteractiveContent)(panel.current);

    if (interactiveContent) {
      setTabIndex('-1');
    }
  }, []);
  return /*#__PURE__*/_react.default.createElement("div", (0, _extends2.default)({}, rest, {
    "aria-labelledby": tabId,
    id: id,
    className: className,
    ref: ref,
    role: "tabpanel",
    tabIndex: tabIndex,
    hidden: selectedIndex !== index
  }), children);
});

exports.TabPanel = TabPanel;
TabPanel.propTypes = {
  /**
   * Provide child elements to be rendered inside of `TabPanel`.
   */
  children: _propTypes.default.node,

  /**
   * Specify an optional className to be added to TabPanel.
   */
  className: _propTypes.default.string
};

function TabPanels(_ref8) {
  var children = _ref8.children;
  return _react.default.Children.map(children, function (child, index) {
    return /*#__PURE__*/_react.default.createElement(TabPanelContext.Provider, {
      value: index
    }, child);
  });
}

TabPanels.propTypes = {
  /**
   * Provide child elements to be rendered inside of `TabPanels`.
   */
  children: _propTypes.default.node
};