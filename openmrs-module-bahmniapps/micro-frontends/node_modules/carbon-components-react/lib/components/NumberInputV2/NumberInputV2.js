"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.translationIds = exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _iconsReact = require("@carbon/icons-react");

var _classnames = _interopRequireDefault(require("classnames"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _useMergedRefs = require("../../internal/useMergedRefs");

var _useNormalizedInputProps = require("../../internal/useNormalizedInputProps");

var _usePrefix = require("../../internal/usePrefix");

var _deprecate = _interopRequireDefault(require("../../prop-types/deprecate"));

var _FluidForm = require("../FluidForm");

var _Text = require("../Text");

var _useControllableState3 = require("../../internal/useControllableState");

var _NumberInputUtilities = require("./NumberInputUtilities");

var _keyboard = require("../../internal/keyboard");

var _NumberFormatPropTypes = require("./NumberFormatPropTypes");

var _excluded = ["allowEmpty", "className", "decorator", "disabled", "disableWheel", "defaultValue", "formatOptions", "helperText", "hideLabel", "hideSteppers", "iconDescription", "id", "inputMode", "invalid", "invalidText", "label", "light", "locale", "max", "min", "onChange", "onBlur", "onClick", "onKeyUp", "pattern", "readOnly", "size", "slug", "step", "translateWithId", "type", "warn", "warnText", "value"];

var _defaultTranslations;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var translationIds = {
  'increment.number': 'increment.number',
  'decrement.number': 'decrement.number'
};
exports.translationIds = translationIds;

var clamp = function clamp(num, min, max) {
  return Math.min(max, Math.max(min, num));
};
/**
 * Message ids that will be passed to translateWithId().
 */


var defaultTranslations = (_defaultTranslations = {}, (0, _defineProperty2.default)(_defaultTranslations, translationIds['increment.number'], 'Increment number'), (0, _defineProperty2.default)(_defaultTranslations, translationIds['decrement.number'], 'Decrement number'), _defaultTranslations);

var NumberInputV2 = /*#__PURE__*/_react.default.forwardRef(function NumberInputV2(props, forwardRef) {
  var _classNames, _classNames2, _classNames3, _classNames4, _normalizedDecorator, _normalizedDecorator$, _normalizedDecorator2, _normalizedDecorator3;

  var _props$allowEmpty = props.allowEmpty,
      allowEmpty = _props$allowEmpty === void 0 ? false : _props$allowEmpty,
      customClassName = props.className,
      decorator = props.decorator,
      _props$disabled = props.disabled,
      disabled = _props$disabled === void 0 ? false : _props$disabled,
      _props$disableWheel = props.disableWheel,
      disableWheelProp = _props$disableWheel === void 0 ? false : _props$disableWheel,
      _props$defaultValue = props.defaultValue,
      defaultValue = _props$defaultValue === void 0 ? type === 'number' ? 0 : NaN : _props$defaultValue,
      formatOptions = props.formatOptions,
      _props$helperText = props.helperText,
      helperText = _props$helperText === void 0 ? '' : _props$helperText,
      _props$hideLabel = props.hideLabel,
      hideLabel = _props$hideLabel === void 0 ? false : _props$hideLabel,
      hideSteppers = props.hideSteppers,
      iconDescription = props.iconDescription,
      id = props.id,
      inputMode = props.inputMode,
      _props$invalid = props.invalid,
      invalid = _props$invalid === void 0 ? false : _props$invalid,
      invalidText = props.invalidText,
      label = props.label,
      light = props.light,
      _props$locale = props.locale,
      locale = _props$locale === void 0 ? 'en-US' : _props$locale,
      max = props.max,
      min = props.min,
      onChange = props.onChange,
      _onBlur = props.onBlur,
      onClick = props.onClick,
      onKeyUp = props.onKeyUp,
      _props$pattern = props.pattern,
      pattern = _props$pattern === void 0 ? '[0-9]*' : _props$pattern,
      readOnly = props.readOnly,
      _props$size = props.size,
      size = _props$size === void 0 ? 'md' : _props$size,
      slug = props.slug,
      _props$step = props.step,
      step = _props$step === void 0 ? 1 : _props$step,
      _props$translateWithI = props.translateWithId,
      t = _props$translateWithI === void 0 ? function (id) {
    return defaultTranslations[id];
  } : _props$translateWithI,
      _props$type = props.type,
      type = _props$type === void 0 ? 'number' : _props$type,
      _props$warn = props.warn,
      warn = _props$warn === void 0 ? false : _props$warn,
      _props$warnText = props.warnText,
      warnText = _props$warnText === void 0 ? '' : _props$warnText,
      controlledValue = props.value,
      rest = (0, _objectWithoutProperties2.default)(props, _excluded);
  var prefix = (0, _usePrefix.usePrefix)();

  var _useContext = (0, _react.useContext)(_FluidForm.FormContext),
      isFluid = _useContext.isFluid;

  var _useState = (0, _react.useState)(false),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      isFocused = _useState2[0],
      setIsFocused = _useState2[1];

  var _useState3 = (0, _react.useState)(function () {
    if (controlledValue !== undefined) {
      return controlledValue;
    }

    if (defaultValue !== undefined) {
      return defaultValue;
    }

    if (allowEmpty) {
      return '';
    }

    return 0;
  }),
      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
      value = _useState4[0],
      setValue = _useState4[1];

  var _useState5 = (0, _react.useState)(controlledValue),
      _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
      prevControlledValue = _useState6[0],
      setPrevControlledValue = _useState6[1];

  var numberParser = (0, _react.useMemo)(function () {
    return new _NumberInputUtilities.NumberParser(locale, formatOptions);
  }, [locale, formatOptions]);

  var _useControllableState = (0, _useControllableState3.useControllableState)({
    name: 'NumberInputV2',
    defaultValue: typeof defaultValue === 'string' ? numberParser.parse(defaultValue) : defaultValue,
    value: typeof controlledValue === 'string' ? numberParser.parse(controlledValue) : controlledValue
  }),
      _useControllableState2 = (0, _slicedToArray2.default)(_useControllableState, 3),
      numberValue = _useControllableState2[0],
      setNumberValue = _useControllableState2[1],
      isControlled = _useControllableState2[2];
  /**
   * The number value that was previously "committed" to the input on blur
   * Only used when type="text"
   */


  var _useState7 = (0, _react.useState)(numberValue),
      _useState8 = (0, _slicedToArray2.default)(_useState7, 2),
      previousNumberValue = _useState8[0],
      setPreviousNumberValue = _useState8[1];

  var _useState9 = (0, _react.useState)(function () {
    return isNaN(numberValue) ? '' : new _NumberInputUtilities.NumberFormatter(locale, formatOptions).format(numberValue);
  }),
      _useState10 = (0, _slicedToArray2.default)(_useState9, 2),
      inputValue = _useState10[0],
      setInputValue = _useState10[1];

  var numberingSystem = (0, _react.useMemo)(function () {
    return numberParser.getNumberingSystem(inputValue);
  }, [numberParser, inputValue]);
  var numberFormatter = (0, _react.useMemo)(function () {
    return new _NumberInputUtilities.NumberFormatter(locale, _objectSpread(_objectSpread({}, formatOptions), {}, {
      numberingSystem: numberingSystem
    }));
  }, [locale, formatOptions, numberingSystem]);
  var format = (0, _react.useCallback)(function (value) {
    return isNaN(value) || value === null ? '' : numberFormatter.format(value);
  }, [numberFormatter]);

  if (isControlled && !(isNaN(previousNumberValue) && isNaN(numberValue)) && previousNumberValue !== numberValue) {
    setInputValue(format(numberValue));
    setPreviousNumberValue(numberValue);
  }

  var inputRef = (0, _react.useRef)(null);
  var ref = (0, _useMergedRefs.useMergedRefs)([forwardRef, inputRef]);
  var numberInputClasses = (0, _classnames.default)((_classNames = {}, (0, _defineProperty2.default)(_classNames, "".concat(prefix, "--number"), true), (0, _defineProperty2.default)(_classNames, "".concat(prefix, "--number--helpertext"), true), (0, _defineProperty2.default)(_classNames, "".concat(prefix, "--number--readonly"), readOnly), (0, _defineProperty2.default)(_classNames, "".concat(prefix, "--number--light"), light), (0, _defineProperty2.default)(_classNames, "".concat(prefix, "--number--nolabel"), hideLabel), (0, _defineProperty2.default)(_classNames, "".concat(prefix, "--number--nosteppers"), hideSteppers), (0, _defineProperty2.default)(_classNames, "".concat(prefix, "--number--").concat(size), size), _classNames));
  var isInputValid = getInputValidity({
    allowEmpty: allowEmpty,
    invalid: invalid,
    value: type === 'number' ? value : numberValue,
    max: max,
    min: min
  });
  var normalizedProps = (0, _useNormalizedInputProps.useNormalizedInputProps)({
    id: id,
    readOnly: readOnly,
    disabled: disabled,
    invalid: !isInputValid,
    invalidText: invalidText,
    warn: warn,
    warnText: warnText
  });
  var _ref = [t('increment.number'), t('decrement.number')],
      incrementNumLabel = _ref[0],
      decrementNumLabel = _ref[1];
  var wrapperClasses = (0, _classnames.default)("".concat(prefix, "--number__input-wrapper"), (_classNames2 = {}, (0, _defineProperty2.default)(_classNames2, "".concat(prefix, "--number__input-wrapper--warning"), normalizedProps.warn), (0, _defineProperty2.default)(_classNames2, "".concat(prefix, "--number__input-wrapper--slug"), slug), (0, _defineProperty2.default)(_classNames2, "".concat(prefix, "--number__input-wrapper--decorator"), decorator), _classNames2));
  var iconClasses = (0, _classnames.default)((_classNames3 = {}, (0, _defineProperty2.default)(_classNames3, "".concat(prefix, "--number__invalid"), normalizedProps.invalid || normalizedProps.warn), (0, _defineProperty2.default)(_classNames3, "".concat(prefix, "--number__invalid--warning"), normalizedProps.warn), (0, _defineProperty2.default)(_classNames3, "".concat(prefix, "--number__readonly-icon"), readOnly), _classNames3));

  if (controlledValue !== prevControlledValue && !(isNaN(Number(controlledValue)) === isNaN(Number(prevControlledValue)))) {
    setValue(controlledValue);
    setPrevControlledValue(controlledValue);
  }

  var ariaDescribedBy;

  if (normalizedProps.invalid) {
    ariaDescribedBy = normalizedProps.invalidId;
  } else if (normalizedProps.warn) {
    ariaDescribedBy = normalizedProps.warnId;
  } else if (!normalizedProps.validation) {
    ariaDescribedBy = helperText ? normalizedProps.helperId : undefined;
  }

  function handleOnChange(event) {
    if (disabled) {
      return;
    }

    if (type === 'number') {
      var state = {
        value: allowEmpty && event.target.value === '' ? '' : Number(event.target.value),
        direction: value < event.target.value ? 'up' : 'down'
      };
      setValue(state.value);

      if (onChange) {
        onChange(event, state);
      }

      return;
    }

    if (type === 'text') {
      var _value = allowEmpty && event.target.value === '' ? '' : event.target.value; // When isControlled, setNumberValue will not update numberValue in useControllableState.


      setNumberValue(numberParser.parse(_value));
      setInputValue(_value);
    }
  }

  var handleFocus = function handleFocus(evt) {
    setIsFocused(evt.type === 'focus');
  };

  var outerElementClasses = (0, _classnames.default)("".concat(prefix, "--form-item"), (_classNames4 = {}, (0, _defineProperty2.default)(_classNames4, customClassName, !!customClassName), (0, _defineProperty2.default)(_classNames4, "".concat(prefix, "--number-input--fluid--invalid"), isFluid && normalizedProps.invalid), (0, _defineProperty2.default)(_classNames4, "".concat(prefix, "--number-input--fluid--focus"), isFluid && isFocused), (0, _defineProperty2.default)(_classNames4, "".concat(prefix, "--number-input--fluid--disabled"), isFluid && disabled), _classNames4));
  var Icon = normalizedProps.icon;

  var getDecimalPlaces = function getDecimalPlaces(num) {
    var parts = num.toString().split('.');
    return parts[1] ? parts[1].length : 0;
  };

  var handleStep = function handleStep(event, direction) {
    if (inputRef.current) {
      var currentValue = type === 'number' ? Number(inputRef.current.value) : numberValue;
      var rawValue;

      if (Number.isNaN(currentValue)) {
        // When the field is empty (NaN), incrementing begins at min,
        // decrementing begins at max.
        // When there's no min or max to use, it begins at 0.
        if (direction === "up" && min) {
          rawValue = min;
        } else if (direction === "down" && max) {
          rawValue = max;
        } else {
          rawValue = 0;
        }
      } else if (direction === 'up') {
        rawValue = currentValue + step;
      } else {
        rawValue = currentValue - step;
      }

      var precision = Math.max(getDecimalPlaces(currentValue), getDecimalPlaces(step));
      var floatValue = parseFloat(rawValue.toFixed(precision));
      var newValue = clamp(floatValue, min !== null && min !== void 0 ? min : -Infinity, max !== null && max !== void 0 ? max : Infinity);
      var state = {
        value: newValue,
        direction: direction
      };

      if (type === 'number') {
        setValue(state.value);
      }

      if (type === 'text') {
        // Calling format() can alter the number (such as rounding it) causing
        // the numberValue to mismatch the formatted value in the input.
        // To avoid this, the newValue is re-parsed after formatting.
        var formattedNewValue = format(newValue);
        var parsedFormattedNewValue = numberParser.parse(formattedNewValue); // When isControlled, setNumberValue will not actually update
        // numberValue in useControllableState.

        setNumberValue(parsedFormattedNewValue);
        setInputValue(formattedNewValue);
        setPreviousNumberValue(parsedFormattedNewValue);
      }

      if (onChange) {
        onChange(event, state);
      }

      return state;
    }
  };

  var handleStepperClick = function handleStepperClick(event, direction) {
    if (inputRef.current) {
      var state = handleStep(event, direction);

      if (onClick) {
        onClick(event, state);
      }
    }
  };

  var normalizedDecorator = /*#__PURE__*/_react.default.isValidElement(slug !== null && slug !== void 0 ? slug : decorator) ? slug !== null && slug !== void 0 ? slug : decorator : null;

  if (((_normalizedDecorator = normalizedDecorator) === null || _normalizedDecorator === void 0 ? void 0 : (_normalizedDecorator$ = _normalizedDecorator.type) === null || _normalizedDecorator$ === void 0 ? void 0 : _normalizedDecorator$.displayName) === 'AILabel') {
    normalizedDecorator = /*#__PURE__*/_react.default.cloneElement(normalizedDecorator, {
      size: 'mini'
    });
  }

  var isRevertActive;

  if (((_normalizedDecorator2 = normalizedDecorator) === null || _normalizedDecorator2 === void 0 ? void 0 : (_normalizedDecorator3 = _normalizedDecorator2.type) === null || _normalizedDecorator3 === void 0 ? void 0 : _normalizedDecorator3.displayName) === 'AILabel') {
    isRevertActive = normalizedDecorator.props.revertActive;
  }

  (0, _react.useEffect)(function () {
    if (!isRevertActive && slug && defaultValue) {
      setValue(defaultValue);
    }
  }, [defaultValue, isRevertActive, slug]);
  return /*#__PURE__*/_react.default.createElement("div", {
    className: outerElementClasses,
    onFocus: isFluid ? handleFocus : undefined,
    onBlur: isFluid ? handleFocus : undefined
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: numberInputClasses,
    "data-invalid": normalizedProps.invalid ? true : undefined
  }, /*#__PURE__*/_react.default.createElement(Label, {
    disabled: normalizedProps.disabled,
    hideLabel: hideLabel,
    id: id,
    label: label
  }), /*#__PURE__*/_react.default.createElement("div", {
    className: wrapperClasses
  }, /*#__PURE__*/_react.default.createElement("input", (0, _extends2.default)({}, rest, {
    "data-invalid": normalizedProps.invalid ? true : undefined,
    "aria-invalid": normalizedProps.invalid,
    "aria-describedby": ariaDescribedBy,
    "aria-readonly": readOnly,
    disabled: normalizedProps.disabled,
    ref: ref,
    id: id,
    max: max,
    min: min,
    onClick: onClick,
    onChange: handleOnChange,
    onKeyUp: onKeyUp,
    onKeyDown: function onKeyDown(e) {
      if (type === 'text') {
        (0, _keyboard.match)(e, _keyboard.keys.ArrowUp) && handleStep(e, 'up');
        (0, _keyboard.match)(e, _keyboard.keys.ArrowDown) && handleStep(e, 'down');
      }

      if (rest !== null && rest !== void 0 && rest.onKeyDown) {
        rest.onKeyDown(e);
      }
    },
    onFocus: function onFocus(e) {
      if (disableWheelProp) {
        e.target.addEventListener('wheel', disableWheel);
      }

      if (rest.onFocus) {
        rest.onFocus(e);
      }
    },
    onBlur: function onBlur(e) {
      if (disableWheelProp) {
        e.target.removeEventListener('wheel', disableWheel);
      }

      if (type === 'text') {
        var _numberValue = isControlled ? numberParser.parse(inputValue) : numberValue;

        var formattedValue = isNaN(_numberValue) ? '' : format(_numberValue);
        setInputValue(formattedValue); // Calling format() can alter the number (such as rounding it)
        // causing the _numberValue to mismatch the formatted value in
        // the input. To avoid this, formattedValue is re-parsed.

        var parsedFormattedNewValue = numberParser.parse(formattedValue);

        if (onChange) {
          var state = {
            value: parsedFormattedNewValue,
            direction: previousNumberValue < parsedFormattedNewValue ? 'up' : 'down'
          }; // If the old and new values are NaN, don't call onChange
          // to avoid an unecessary re-render and potential infinite
          // loop when isControlled.

          if (!(isNaN(previousNumberValue) && isNaN(parsedFormattedNewValue))) {
            onChange(e, state);
          }
        } // If the old and new values are NaN, don't set state to avoid
        // an unecessary re-render and potential infinite loop when
        // isControlled.


        if (!(isNaN(previousNumberValue) && isNaN(numberValue))) {
          setPreviousNumberValue(numberValue);
        }

        if (!(isNaN(numberValue) && isNaN(parsedFormattedNewValue))) {
          setNumberValue(parsedFormattedNewValue);
        }
      }

      if (_onBlur) {
        _onBlur(e);
      }
    },
    pattern: pattern,
    inputMode: inputMode,
    readOnly: readOnly,
    step: step,
    type: type,
    value: type === 'number' ? value : inputValue
  })), slug ? normalizedDecorator : decorator ? /*#__PURE__*/_react.default.createElement("div", {
    className: "".concat(prefix, "--number__input-inner-wrapper--decorator")
  }, normalizedDecorator) : null, Icon ? /*#__PURE__*/_react.default.createElement(Icon, {
    className: iconClasses
  }) : null, !hideSteppers && /*#__PURE__*/_react.default.createElement("div", {
    className: "".concat(prefix, "--number__controls")
  }, /*#__PURE__*/_react.default.createElement("button", {
    "aria-label": decrementNumLabel || iconDescription,
    className: "".concat(prefix, "--number__control-btn down-icon"),
    disabled: disabled || readOnly,
    onClick: function onClick(event) {
      return handleStepperClick(event, 'down');
    },
    onBlur: _onBlur,
    tabIndex: -1,
    title: decrementNumLabel || iconDescription,
    type: "button"
  }, /*#__PURE__*/_react.default.createElement(_iconsReact.Subtract16, {
    className: "down-icon"
  })), /*#__PURE__*/_react.default.createElement("div", {
    className: "".concat(prefix, "--number__rule-divider")
  }), /*#__PURE__*/_react.default.createElement("button", {
    "aria-label": incrementNumLabel || iconDescription,
    className: "".concat(prefix, "--number__control-btn up-icon"),
    disabled: disabled || readOnly,
    onClick: function onClick(event) {
      return handleStepperClick(event, 'up');
    },
    onBlur: _onBlur,
    tabIndex: -1,
    title: incrementNumLabel || iconDescription,
    type: "button"
  }, /*#__PURE__*/_react.default.createElement(_iconsReact.Add16, {
    className: "up-icon"
  })), /*#__PURE__*/_react.default.createElement("div", {
    className: "".concat(prefix, "--number__rule-divider")
  }))), isFluid && /*#__PURE__*/_react.default.createElement("hr", {
    className: "".concat(prefix, "--number-input__divider")
  }), normalizedProps.validation ? normalizedProps.validation : /*#__PURE__*/_react.default.createElement(HelperText, {
    id: normalizedProps.helperId,
    disabled: disabled,
    description: helperText
  })));
});

NumberInputV2.propTypes = {
  /**
   * `true` to allow empty string.
   */
  allowEmpty: _propTypes.default.bool,

  /**
   * Specify an optional className to be applied to the wrapper node
   */
  className: _propTypes.default.string,

  /**
   * **Experimental**: Provide a `decorator` component to be rendered inside the `NumberInput` component
   */
  decorator: _propTypes.default.node,

  /**
   * Optional starting value for uncontrolled state
   * Defaults to 0 when type="number"
   * Defaults to NaN when type="text"
   */
  defaultValue: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),

  /**
   * Specify if the wheel functionality for the input should be disabled, or no t
   */
  disableWheel: _propTypes.default.bool,

  /**
   * Specify if the control should be disabled, or not
   */
  disabled: _propTypes.default.bool,

  /**
   * **Experimental:** Specify Intl.NumberFormat options applied to internal
   * number parsing and formatting. Use with `type="text"`, has no effect when
   * `type="number"`.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   */
  formatOptions: _NumberFormatPropTypes.NumberFormatOptionsPropType,

  /**
   * Provide text that is used alongside the control label for additional help
   */
  helperText: _propTypes.default.node,

  /**
   * Specify whether you want the underlying label to be visually hidden
   */
  hideLabel: _propTypes.default.bool,

  /**
   * Specify whether you want the steppers to be hidden
   */
  hideSteppers: _propTypes.default.bool,

  /**
   * Provide a description for up/down icons that can be read by screen readers
   */
  iconDescription: _propTypes.default.string,

  /**
   * Specify a custom `id` for the input
   */
  id: _propTypes.default.string.isRequired,

  /**
   * Instruct the browser which keyboard to display on mobile devices. Note that
   * standard numeric keyboards vary across devices and operating systems.
   * @see https://css-tricks.com/everything-you-ever-wanted-to-know-about-inputmode/
   */
  inputMode: _propTypes.default.oneOf(['none', 'text', 'tel', 'url', 'email', 'numeric', 'decimal', 'search']),

  /**
   * Specify if the currently value is invalid.
   */
  invalid: _propTypes.default.bool,

  /**
   * Message which is displayed if the value is invalid.
   */
  invalidText: _propTypes.default.node,

  /**
   * Generic `label` that will be used as the textual representation of what
   * this field is for
   */
  label: _propTypes.default.node,

  /**
   * `true` to use the light version.
   */
  light: (0, _deprecate.default)(_propTypes.default.bool, 'The `light` prop for `NumberInputV2` is no longer needed and has ' + 'been deprecated in v11 in favor of the new `Layer` component. It will be moved in the next major release.'),

  /**
   * **Experimental:** Specify a [BCP47](https://www.ietf.org/rfc/bcp/bcp47.txt)
   * language code for parsing and formatting. Use with `type="text"`, has no
   * effect when `type="number"`.
   */
  locale: _propTypes.default.string,

  /**
   * The maximum value.
   */
  max: _propTypes.default.number,

  /**
   * The minimum value.
   */
  min: _propTypes.default.number,

  /**
   * Provide an optional handler that is called when the input or stepper
   * buttons are blurred.
   */
  onBlur: _propTypes.default.func,

  /**
   * Provide an optional handler that is called when the internal state of
   * NumberInput changes. This handler is called with event and state info.
   * When type="number", this is called on every change of the input.
   * When type="text", this is only called on blur after the number has been
   * parsed and formatted.
   * `(event, { value, direction }) => void`
   */
  onChange: _propTypes.default.func,

  /**
   * Provide an optional function to be called when the up/down button is clicked
   */
  onClick: _propTypes.default.func,

  /**
   * Provide an optional function to be called when a key is pressed in the number input
   */
  onKeyUp: _propTypes.default.func,

  /**
   * When type="text", provide an optional pattern to restrict user input. Has
   * no effect when type="number".
   */
  pattern: _propTypes.default.string,

  /**
   * Specify if the component should be read-only
   */
  readOnly: _propTypes.default.bool,

  /**
   * Specify the size of the Number Input.
   */
  size: _propTypes.default.oneOf(['sm', 'md', 'lg']),

  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the
   * `NumberInput` component
   */
  slug: (0, _deprecate.default)(_propTypes.default.node, 'The `slug` prop for `NumberInput` is no longer needed and has ' + 'been deprecated in v11 in favor of the new `decorator` prop. It will be moved in the next major release.'),

  /**
   * Specify how much the values should increase/decrease upon clicking on
   * up/down button
   */
  step: _propTypes.default.number,

  /**
   * Provide custom text for the component for each translation id
   */
  translateWithId: _propTypes.default.func,

  /**
   * **Experimental**: Specify if the input should be of type text or number.
   * Use type="text" with `locale`, `formatOptions`, and guide user input with
   * `pattern` and `inputMode`.
   */
  type: _propTypes.default.oneOf(['number', 'text']),

  /**
   * Specify the value of the input
   */
  value: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),

  /**
   * Specify whether the control is currently in warning state
   */
  warn: _propTypes.default.bool,

  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: _propTypes.default.node
};

var Label = function Label(_ref2) {
  var _classNames5;

  var disabled = _ref2.disabled,
      id = _ref2.id,
      hideLabel = _ref2.hideLabel,
      label = _ref2.label;
  var prefix = (0, _usePrefix.usePrefix)();
  var className = (0, _classnames.default)((_classNames5 = {}, (0, _defineProperty2.default)(_classNames5, "".concat(prefix, "--label"), true), (0, _defineProperty2.default)(_classNames5, "".concat(prefix, "--label--disabled"), disabled), (0, _defineProperty2.default)(_classNames5, "".concat(prefix, "--visually-hidden"), hideLabel), _classNames5));

  if (label) {
    return /*#__PURE__*/_react.default.createElement(_Text.Text, {
      as: "label",
      htmlFor: id,
      className: className
    }, label);
  }

  return null;
};

Label.propTypes = {
  disabled: _propTypes.default.bool,
  hideLabel: _propTypes.default.bool,
  id: _propTypes.default.string,
  label: _propTypes.default.node
};

function HelperText(_ref3) {
  var disabled = _ref3.disabled,
      description = _ref3.description,
      id = _ref3.id;
  var prefix = (0, _usePrefix.usePrefix)();
  var className = (0, _classnames.default)("".concat(prefix, "--form__helper-text"), (0, _defineProperty2.default)({}, "".concat(prefix, "--form__helper-text--disabled"), disabled));

  if (description) {
    return /*#__PURE__*/_react.default.createElement(_Text.Text, {
      as: "div",
      id: id,
      className: className
    }, description);
  }

  return null;
}

HelperText.propTypes = {
  description: _propTypes.default.node,
  disabled: _propTypes.default.bool,
  id: _propTypes.default.string
};
/**
 * Determine if the given value is invalid based on the given max, min and
 * conditions like `allowEmpty`. If `invalid` is passed through, it will default
 * to false.
 *
 * @param {object} config
 * @param {boolean} config.allowEmpty
 * @param {boolean} config.invalid
 * @param {number} config.value
 * @param {number} config.max
 * @param {number} config.min
 * @returns {boolean}
 */

function getInputValidity(_ref4) {
  var allowEmpty = _ref4.allowEmpty,
      invalid = _ref4.invalid,
      value = _ref4.value,
      max = _ref4.max,
      min = _ref4.min;

  if (invalid) {
    return false;
  }

  if (value === '') {
    return allowEmpty;
  }

  if (value > max || value < min) {
    return false;
  }

  return true;
}
/**
 * It prevents any wheel event from emitting.
 *
 * We want to prevent this input field from changing by the user accidentally
 * when the user scrolling up or down in a long form. So we prevent the default
 * behavior of wheel events when it is focused.
 *
 * Because React uses passive event handler by default, we can't just call
 * `preventDefault` in the `onWheel` event handler. So we have to get the input
 * ref and add our event handler manually.
 *
 * @see https://github.com/facebook/react/pull/19654
 * @param {WheelEvent} e A wheel event.
 */


function disableWheel(e) {
  e.preventDefault();
}

var _default = NumberInputV2;
exports.default = _default;