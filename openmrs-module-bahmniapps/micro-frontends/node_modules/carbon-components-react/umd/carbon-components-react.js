(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('prop-types'), require('react-dom'), require('carbon-icons')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'prop-types', 'react-dom', 'carbon-icons'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.CarbonComponentsReact = {}, global.React, global.PropTypes, global.ReactDOM));
})(this, (function (exports, React, PropTypes, ReactDOM) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }

  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
  var React__namespace = /*#__PURE__*/_interopNamespace(React);
  var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);
  var ReactDOM__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOM);

  function ownKeys$2(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2$2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {
        _defineProperty$2(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }

  function _classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$1(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$1(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$1(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _defineProperty$2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends$3() {
    _extends$3 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$3.apply(this, arguments);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf$1(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf$1(o, p) {
    _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$1(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _objectWithoutPropertiesLoose$3(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties$2(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose$3(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _assertThisInitialized$1(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized$1(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _slicedToArray$1(arr, i) {
    return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest$1();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
  }

  function _arrayWithHoles$1(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit$1(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray$1(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
  }

  function _arrayLikeToArray$1(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest$1() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper$1(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = it.call(o);
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function getAugmentedNamespace(n) {
  	if (n.__esModule) return n;
  	var a = Object.defineProperty({}, '__esModule', {value: true});
  	Object.keys(n).forEach(function (k) {
  		var d = Object.getOwnPropertyDescriptor(n, k);
  		Object.defineProperty(a, k, d.get ? d : {
  			enumerable: true,
  			get: function () {
  				return n[k];
  			}
  		});
  	});
  	return a;
  }

  var classnames = {exports: {}};

  (function (module) {
    /* global define */
    (function () {

      var hasOwn = {}.hasOwnProperty;

      function classNames() {
        var classes = [];

        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (!arg) continue;

          var argType = _typeof(arg);

          if (argType === 'string' || argType === 'number') {
            classes.push(arg);
          } else if (Array.isArray(arg)) {
            if (arg.length) {
              var inner = classNames.apply(null, arg);

              if (inner) {
                classes.push(inner);
              }
            }
          } else if (argType === 'object') {
            if (arg.toString === Object.prototype.toString) {
              for (var key in arg) {
                if (hasOwn.call(arg, key) && arg[key]) {
                  classes.push(key);
                }
              }
            } else {
              classes.push(arg.toString());
            }
          }
        }

        return classes.join(' ');
      }

      if (module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
      } else {
        window.classNames = classNames;
      }
    })();
  })(classnames);

  var cx = classnames.exports;

  /**
   * Settings.
   * @exports CarbonComponents.settings
   * @type Object
   * @property {boolean} [disableAutoInit]
   *   Disables automatic instantiation of components.
   *   By default (`CarbonComponents.disableAutoInit` is `false`),
   *   carbon-components attempts to instantiate components automatically
   *   by searching for elements with `data-component-name` (e.g. `data-loading`) attribute
   *   or upon DOM events (e.g. clicking) on such elements.
   *   See each components' static `.init()` methods for details.
   * @property {string} [prefix=bx]
   *   Brand prefix. Should be in sync with `$prefix` Sass variable in carbon-components/src/globals/scss/_vars.scss.
   * // @todo given that the default value is so long, is it appropriate to put in the JSDoc?
   * @property {string} [selectorTabbable]
   *   A selector selecting tabbable/focusable nodes.
   *   By default selectorTabbable references links, areas, inputs, buttons, selects, textareas,
   *   iframes, objects, embeds, or elements explicitly using tabindex or contenteditable attributes
   *   as long as the element is not `disabled` or the `tabindex="-1"`.
   * @property {string} [selectorFocusable]
   *   CSS selector that selects major nodes that are click focusable
   *   This property is identical to selectorTabbable with the exception of
   *   the `:not([tabindex='-1'])` pseudo class
   */
  var settings = {
    prefix: 'bx',
    selectorTabbable: "\n    a[href], area[href], input:not([disabled]):not([tabindex='-1']),\n    button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']),\n    textarea:not([disabled]):not([tabindex='-1']),\n    iframe, object, embed, *[tabindex]:not([tabindex='-1']), *[contenteditable=true]\n  ",
    selectorFocusable: "\n    a[href], area[href], input:not([disabled]),\n    button:not([disabled]),select:not([disabled]),\n    textarea:not([disabled]),\n    iframe, object, embed, *[tabindex], *[contenteditable=true]\n  "
  };
  var settings_1 = settings;

  /** Used as the `TypeError` message for "Functions" methods. */

  var FUNC_ERROR_TEXT$1 = 'Expected a function';
  /** Used as references for various `Number` constants. */

  var NAN$1 = 0 / 0;
  /** `Object#toString` result references. */

  var symbolTag$2 = '[object Symbol]';
  /** Used to match leading and trailing whitespace. */

  var reTrim$1 = /^\s+|\s+$/g;
  /** Used to detect bad signed hexadecimal string values. */

  var reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i;
  /** Used to detect binary string values. */

  var reIsBinary$1 = /^0b[01]+$/i;
  /** Used to detect octal string values. */

  var reIsOctal$1 = /^0o[0-7]+$/i;
  /** Built-in method references without a dependency on `root`. */

  var freeParseInt$1 = parseInt;
  /** Detect free variable `global` from Node.js. */

  var freeGlobal$2 = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  /** Detect free variable `self`. */

  var freeSelf$2 = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
  /** Used as a reference to the global object. */

  var root$2 = freeGlobal$2 || freeSelf$2 || Function('return this')();
  /** Used for built-in method references. */

  var objectProto$2 = Object.prototype;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var objectToString$2 = objectProto$2.toString;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeMax$2 = Math.max,
      nativeMin$1 = Math.min;
  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */

  var now$1 = function now() {
    return root$2.Date.now();
  };
  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */


  function debounce$3(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }

    wait = toNumber$1(wait) || 0;

    if (isObject$2(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax$2(toNumber$1(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;
      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time; // Start the timer for the trailing edge.

      timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          result = wait - timeSinceLastCall;
      return maxing ? nativeMin$1(result, maxWait - timeSinceLastInvoke) : result;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.

      return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }

    function timerExpired() {
      var time = now$1();

      if (shouldInvoke(time)) {
        return trailingEdge(time);
      } // Restart the timer.


      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.

      if (trailing && lastArgs) {
        return invokeFunc(time);
      }

      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }

      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now$1());
    }

    function debounced() {
      var time = now$1(),
          isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }

        if (maxing) {
          // Handle invocations in a tight loop.
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }

      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }

      return result;
    }

    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */


  function isObject$2(value) {
    var type = _typeof(value);

    return !!value && (type == 'object' || type == 'function');
  }
  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */


  function isObjectLike$2(value) {
    return !!value && _typeof(value) == 'object';
  }
  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */


  function isSymbol$2(value) {
    return _typeof(value) == 'symbol' || isObjectLike$2(value) && objectToString$2.call(value) == symbolTag$2;
  }
  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */


  function toNumber$1(value) {
    if (typeof value == 'number') {
      return value;
    }

    if (isSymbol$2(value)) {
      return NAN$1;
    }

    if (isObject$2(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject$2(other) ? other + '' : other;
    }

    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }

    value = value.replace(reTrim$1, '');
    var isBinary = reIsBinary$1.test(value);
    return isBinary || reIsOctal$1.test(value) ? freeParseInt$1(value.slice(2), isBinary ? 2 : 8) : reIsBadHex$1.test(value) ? NAN$1 : +value;
  }

  var lodash_debounce = debounce$3;
  var debounce$4 = lodash_debounce;

  var PrefixContext = /*#__PURE__*/React__default["default"].createContext(settings_1.prefix);
  function usePrefix() {
    return React__default["default"].useContext(PrefixContext);
  }

  var enabled$1 = {};

  try {
    if (process.env.CARBON_ENABLE_CSS_CUSTOM_PROPERTIES) {
      if (process.env.CARBON_ENABLE_CSS_CUSTOM_PROPERTIES === 'true') {
        enabled$1.enableCssCustomProperties = true;
      } else {
        enabled$1.enableCssCustomProperties = false;
      }
    } else {
      enabled$1.enableCssCustomProperties = false;
    }

    if (process.env.CARBON_ENABLE_USE_CONTROLLED_STATE_WITH_VALUE) {
      if (process.env.CARBON_ENABLE_USE_CONTROLLED_STATE_WITH_VALUE === 'true') {
        enabled$1.enableUseControlledStateWithValue = true;
      } else {
        enabled$1.enableUseControlledStateWithValue = false;
      }
    } else {
      enabled$1.enableUseControlledStateWithValue = false;
    }

    if (process.env.CARBON_ENABLE_CSS_GRID) {
      if (process.env.CARBON_ENABLE_CSS_GRID === 'true') {
        enabled$1.enableCssGrid = true;
      } else {
        enabled$1.enableCssGrid = false;
      }
    } else {
      enabled$1.enableCssGrid = false;
    }

    if (process.env.CARBON_ENABLE_V11_RELEASE) {
      if (process.env.CARBON_ENABLE_V11_RELEASE === 'true') {
        enabled$1.enableV11Release = true;
      } else {
        enabled$1.enableV11Release = false;
      }
    } else {
      enabled$1.enableV11Release = false;
    }
  } catch (error) {
    enabled$1.enableCssCustomProperties = false;
    enabled$1.enableUseControlledStateWithValue = false;
    enabled$1.enableCssGrid = false;
    enabled$1.enableV11Release = false;
  }

  var featureFlagInfo = [{
    name: "enable-css-custom-properties",
    description: "Describe what the flag does",
    enabled: enabled$1.enableCssCustomProperties
  }, {
    name: "enable-use-controlled-state-with-value",
    description: "Enable components to be created in either a controlled or uncontrolled mode\n",
    enabled: enabled$1.enableUseControlledStateWithValue
  }, {
    name: "enable-css-grid",
    description: "Enable CSS Grid Layout in the Grid and Column React components\n",
    enabled: enabled$1.enableCssGrid
  }, {
    name: "enable-v11-release",
    description: "Enable the features and functionality for the v11 Release\n",
    enabled: enabled$1.enableV11Release
  }];

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function F() {};

        return {
          s: F,
          n: function n() {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function e(_e2) {
            throw _e2;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function s() {
        it = it.call(o);
      },
      n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function e(_e3) {
        didErr = true;
        err = _e3;
      },
      f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }
  /**
   * Copyright IBM Corp. 2015, 2020
   *
   * This source code is licensed under the Apache-2.0 license found in the
   * LICENSE file in the root directory of this source tree.
   */


  var FeatureFlagScope = /*#__PURE__*/function () {
    function FeatureFlagScope(flags) {
      var _this = this;

      _classCallCheck(this, FeatureFlagScope);

      this.flags = new Map();

      if (flags) {
        Object.keys(flags).forEach(function (key) {
          _this.flags.set(key, flags[key]);
        });
      }
    }
    /**
     * Check to see if a flag exists
     * @param {string} name
     */


    _createClass(FeatureFlagScope, [{
      key: "checkForFlag",
      value: function checkForFlag(name) {
        if (!this.flags.has(name)) {
          throw new Error("Unable to find a feature flag with the name: `".concat(name, "`"));
        }
      }
      /**
       * Add a feature flag
       * @param {string} name
       * @param {boolean} enabled
       */

    }, {
      key: "add",
      value: function add(name, enabled) {
        if (this.flags.has(name)) {
          throw new Error("The feature flag: ".concat(name, " already exists"));
        }

        this.flags.set(name, enabled);
      }
      /**
       * Enable a feature flag
       * @param {string} name
       */

    }, {
      key: "enable",
      value: function enable(name) {
        this.checkForFlag(name);
        this.flags.set(name, true);
      }
      /**
       * Disable a feature flag
       * @param {string} name
       */

    }, {
      key: "disable",
      value: function disable(name) {
        this.checkForFlag(name);
        this.flags.set(name, false);
      }
      /**
       * Merge the given feature flags with the current set of feature flags.
       * Duplicate keys will be set to the value in the given feature flags.
       * @param {object} flags
       */

    }, {
      key: "merge",
      value: function merge(flags) {
        var _this2 = this;

        Object.keys(flags).forEach(function (key) {
          _this2.flags.set(key, flags[key]);
        });
      }
      /**
       * @param {FeatureFlagScope} scope
       */

    }, {
      key: "mergeWithScope",
      value: function mergeWithScope(scope) {
        var _iterator = _createForOfIteratorHelper(scope.flags),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray(_step.value, 2),
                key = _step$value[0],
                value = _step$value[1];

            if (this.flags.has(key)) {
              continue;
            }

            this.flags.set(key, value);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      /**
       * Check if a feature flag is enabled
       * @param {string} name
       * @returns {boolean}
       */

    }, {
      key: "enabled",
      value: function enabled(name) {
        this.checkForFlag(name);
        return this.flags.get(name);
      }
    }]);

    return FeatureFlagScope;
  }();

  var FeatureFlags$1 = createScope();

  for (var i = 0; i < featureFlagInfo.length; i++) {
    var featureFlag = featureFlagInfo[i];
    FeatureFlags$1.add(featureFlag.name, featureFlag.enabled);
  }

  function createScope(flags) {
    return new FeatureFlagScope(flags);
  }

  function enabled() {
    return FeatureFlags$1.enabled.apply(FeatureFlags$1, arguments);
  }

  var _excluded$2P = ["align", "children", "className", "disabled", "size"];

  function Accordion(_ref) {
    var _cx;

    var _ref$align = _ref.align,
        align = _ref$align === void 0 ? 'end' : _ref$align,
        children = _ref.children,
        customClassName = _ref.className,
        _ref$disabled = _ref.disabled,
        disabled = _ref$disabled === void 0 ? false : _ref$disabled,
        _ref$size = _ref.size,
        size = _ref$size === void 0 ? 'md' : _ref$size,
        rest = _objectWithoutProperties$2(_ref, _excluded$2P);

    var prefix = usePrefix();
    var className = cx("".concat(prefix, "--accordion"), customClassName, (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--accordion--").concat(align), align), _defineProperty$2(_cx, "".concat(prefix, "--accordion--").concat(size), size), _cx));
    return /*#__PURE__*/React__default["default"].createElement("ul", _extends$3({
      className: className
    }, rest), disabled ? React__default["default"].Children.toArray(children).map(function (child) {
      return /*#__PURE__*/React__default["default"].cloneElement(child, {
        disabled: disabled
      });
    }) : children);
  }

  Accordion.propTypes = {
    /**
     * Specify the alignment of the accordion heading title and chevron.
     */
    align: PropTypes__default["default"].oneOf(['start', 'end']),

    /**
     * Pass in the children that will be rendered within the Accordion
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether an individual AccordionItem should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Specify the size of the Accordion. Currently supports the following:
     */
    size: enabled('enable-v11-release') ? PropTypes__default["default"].oneOf(['sm', 'md', 'lg']) : PropTypes__default["default"].oneOf(['sm', 'md', 'lg', 'xl'])
  };

  function ownKeys$1(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2$1(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function _defineProperty$1(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectWithoutPropertiesLoose$2(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties$1(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose$2(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  var _excluded$2O = ["width", "height", "viewBox"],
      _excluded2$h = ["tabindex"];
  /**
   * Copyright IBM Corp. 2018, 2018
   *
   * This source code is licensed under the Apache-2.0 license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var defaultAttributes = {
    // Reference:
    // https://github.com/IBM/carbon-components-react/issues/1392
    // https://github.com/PolymerElements/iron-iconset-svg/pull/47
    // `focusable` is a string attribute which is why we do not use a boolean here
    focusable: 'false',
    preserveAspectRatio: 'xMidYMid meet'
  };
  /**
   * Get supplementary HTML attributes for a given <svg> element based on existing
   * attributes.
   */

  function getAttributes() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        _ref$viewBox = _ref.viewBox,
        viewBox = _ref$viewBox === void 0 ? "0 0 ".concat(width, " ").concat(height) : _ref$viewBox,
        attributes = _objectWithoutProperties$1(_ref, _excluded$2O);

    var tabindex = attributes.tabindex,
        rest = _objectWithoutProperties$1(attributes, _excluded2$h);

    var iconAttributes = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, defaultAttributes), rest), {}, {
      width: width,
      height: height,
      viewBox: viewBox
    }); // TODO: attributes.title assumes that the consumer will implement <title> and
    // correctly set `aria-labelledby`.


    if (iconAttributes['aria-label'] || iconAttributes['aria-labelledby'] || iconAttributes.title) {
      iconAttributes.role = 'img'; // Reference:
      // https://allyjs.io/tutorials/focusing-in-svg.html

      if (tabindex !== undefined && tabindex !== null) {
        iconAttributes.focusable = 'true';
        iconAttributes.tabindex = tabindex;
      }
    } else {
      iconAttributes['aria-hidden'] = true;
    }

    return iconAttributes;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends$2() {
    _extends$2 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$2.apply(this, arguments);
  }

  function _objectWithoutPropertiesLoose$1(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose$1(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  var _excluded$2N = ["className", "children", "tabIndex"],
      _excluded2$g = ["tabindex"];
  var Icon$2 = /*#__PURE__*/React__default["default"].forwardRef(function Icon(_ref, ref) {
    var className = _ref.className,
        children = _ref.children,
        tabIndex = _ref.tabIndex,
        rest = _objectWithoutProperties(_ref, _excluded$2N);

    var _getAttributes = getAttributes(_objectSpread2(_objectSpread2({}, rest), {}, {
      tabindex: tabIndex
    })),
        tabindex = _getAttributes.tabindex,
        props = _objectWithoutProperties(_getAttributes, _excluded2$g);

    if (className) {
      props.className = className;
    }

    if (tabindex !== undefined && tabindex !== null) {
      props.tabIndex = tabindex;
    }

    if (ref) {
      props.ref = ref;
    }

    return /*#__PURE__*/React__default["default"].createElement('svg', props, children);
  });
  Icon$2.displayName = 'Icon';
  Icon$2.propTypes = {
    'aria-hidden': PropTypes__default["default"].string,
    'aria-label': PropTypes__default["default"].string,
    'aria-labelledby': PropTypes__default["default"].string,
    children: PropTypes__default["default"].node,
    className: PropTypes__default["default"].string,
    height: PropTypes__default["default"].oneOfType([PropTypes__default["default"].number, PropTypes__default["default"].string]),
    preserveAspectRatio: PropTypes__default["default"].string,
    tabIndex: PropTypes__default["default"].string,
    viewBox: PropTypes__default["default"].string,
    width: PropTypes__default["default"].oneOfType([PropTypes__default["default"].number, PropTypes__default["default"].string]),
    xmlns: PropTypes__default["default"].string
  };
  Icon$2.defaultProps = {
    xmlns: 'http://www.w3.org/2000/svg',
    preserveAspectRatio: 'xMidYMid meet'
  };

  var _path140, _path155, _path156;

  var _excluded92 = ["children"],
      _excluded100 = ["children"];
  var Add16 = /*#__PURE__*/React__default["default"].forwardRef(function Add16(_ref92, ref) {
    var children = _ref92.children,
        rest = _objectWithoutProperties(_ref92, _excluded92);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path140 || (_path140 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M17 15L17 8 15 8 15 15 8 15 8 17 15 17 15 24 17 24 17 17 24 17 24 15z"
    })), children);
  });
  var AddFilled16 = /*#__PURE__*/React__default["default"].forwardRef(function AddFilled16(_ref100, ref) {
    var children = _ref100.children,
        rest = _objectWithoutProperties(_ref100, _excluded100);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path155 || (_path155 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M16,2A14.1725,14.1725,0,0,0,2,16,14.1725,14.1725,0,0,0,16,30,14.1725,14.1725,0,0,0,30,16,14.1725,14.1725,0,0,0,16,2Zm8,15H17v7H15V17H8V15h7V8h2v7h7Z"
    })), _path156 || (_path156 = /*#__PURE__*/React__default["default"].createElement("path", {
      fill: "none",
      d: "M24 17L17 17 17 24 15 24 15 17 8 17 8 15 15 15 15 8 17 8 17 15 24 15 24 17z",
      "data-icon-path": "inner-path"
    })), children);
  });

  var _path257, _path281;

  var _excluded157$1 = ["children"],
      _excluded181 = ["children"];
  var ArrowUp20 = /*#__PURE__*/React__default["default"].forwardRef(function ArrowUp20(_ref157, ref) {
    var children = _ref157.children,
        rest = _objectWithoutProperties(_ref157, _excluded157$1);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 20,
      height: 20,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path257 || (_path257 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M16 4L6 14 7.41 15.41 15 7.83 15 28 17 28 17 7.83 24.59 15.41 26 14 16 4z"
    })), children);
  });
  var ArrowsVertical20 = /*#__PURE__*/React__default["default"].forwardRef(function ArrowsVertical20(_ref181, ref) {
    var children = _ref181.children,
        rest = _objectWithoutProperties(_ref181, _excluded181);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 20,
      height: 20,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path281 || (_path281 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M27.6 20.6L24 24.2 24 4 22 4 22 24.2 18.4 20.6 17 22 23 28 29 22zM9 4L3 10 4.4 11.4 8 7.8 8 28 10 28 10 7.8 13.6 11.4 15 10z"
    })), children);
  });

  var _path170, _path302, _path307, _path312;

  var _excluded102 = ["children"],
      _excluded186 = ["children"],
      _excluded191 = ["children"],
      _excluded196 = ["children"];
  var Calendar16 = /*#__PURE__*/React__default["default"].forwardRef(function Calendar16(_ref102, ref) {
    var children = _ref102.children,
        rest = _objectWithoutProperties(_ref102, _excluded102);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path170 || (_path170 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M26,4h-4V2h-2v2h-8V2h-2v2H6C4.9,4,4,4.9,4,6v20c0,1.1,0.9,2,2,2h20c1.1,0,2-0.9,2-2V6C28,4.9,27.1,4,26,4z M26,26H6V12h20\tV26z M26,10H6V6h4v2h2V6h8v2h2V6h4V10z"
    })), children);
  });
  var CaretDown16 = /*#__PURE__*/React__default["default"].forwardRef(function CaretDown16(_ref186, ref) {
    var children = _ref186.children,
        rest = _objectWithoutProperties(_ref186, _excluded186);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path302 || (_path302 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M24 12L16 22 8 12z"
    })), children);
  });
  var CaretLeft16 = /*#__PURE__*/React__default["default"].forwardRef(function CaretLeft16(_ref191, ref) {
    var children = _ref191.children,
        rest = _objectWithoutProperties(_ref191, _excluded191);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path307 || (_path307 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M20 24L10 16 20 8z"
    })), children);
  });
  var CaretRight16 = /*#__PURE__*/React__default["default"].forwardRef(function CaretRight16(_ref196, ref) {
    var children = _ref196.children,
        rest = _objectWithoutProperties(_ref196, _excluded196);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path312 || (_path312 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M12 8L22 16 12 24z"
    })), children);
  });

  var _path148$1, _path163, _path164, _path197, _path202, _path203, _path204, _path205, _path236, _path237, _path268, _path269, _path282, _path290, _path291;

  var _excluded112 = ["children"],
      _excluded120 = ["children"],
      _excluded140 = ["children"],
      _excluded143$1 = ["children"],
      _excluded144 = ["children"],
      _excluded156 = ["children"],
      _excluded175 = ["children"],
      _excluded176 = ["children"],
      _excluded185 = ["children"],
      _excluded193 = ["children"],
      _excluded194 = ["children"];
  var Checkbox16 = /*#__PURE__*/React__default["default"].forwardRef(function Checkbox16(_ref112, ref) {
    var children = _ref112.children,
        rest = _objectWithoutProperties(_ref112, _excluded112);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path148$1 || (_path148$1 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4ZM6,26V6H26V26Z"
    })), children);
  });
  var CheckboxCheckedFilled16 = /*#__PURE__*/React__default["default"].forwardRef(function CheckboxCheckedFilled16(_ref120, ref) {
    var children = _ref120.children,
        rest = _objectWithoutProperties(_ref120, _excluded120);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path163 || (_path163 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4ZM14,21.5,9,16.5427,10.5908,15,14,18.3456,21.4087,11l1.5918,1.5772Z"
    })), _path164 || (_path164 = /*#__PURE__*/React__default["default"].createElement("path", {
      fill: "none",
      d: "M14,21.5,9,16.5427,10.5908,15,14,18.3456,21.4087,11l1.5918,1.5772Z",
      "data-icon-path": "inner-path"
    })), children);
  });
  var Checkmark16 = /*#__PURE__*/React__default["default"].forwardRef(function Checkmark16(_ref140, ref) {
    var children = _ref140.children,
        rest = _objectWithoutProperties(_ref140, _excluded140);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path197 || (_path197 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M13 24L4 15 5.414 13.586 13 21.171 26.586 7.586 28 9 13 24z"
    })), children);
  });
  var CheckmarkFilled20 = /*#__PURE__*/React__default["default"].forwardRef(function CheckmarkFilled20(_ref143, ref) {
    var children = _ref143.children,
        rest = _objectWithoutProperties(_ref143, _excluded143$1);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 20,
      height: 20,
      viewBox: "0 0 20 20",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path202 || (_path202 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M10,1c-4.9,0-9,4.1-9,9s4.1,9,9,9s9-4,9-9S15,1,10,1z M8.7,13.5l-3.2-3.2l1-1l2.2,2.2l4.8-4.8l1,1L8.7,13.5z"
    })), _path203 || (_path203 = /*#__PURE__*/React__default["default"].createElement("path", {
      fill: "none",
      d: "M8.7,13.5l-3.2-3.2l1-1l2.2,2.2l4.8-4.8l1,1L8.7,13.5z",
      "data-icon-path": "inner-path",
      opacity: "0"
    })), children);
  });
  var CheckmarkFilled16 = /*#__PURE__*/React__default["default"].forwardRef(function CheckmarkFilled16(_ref144, ref) {
    var children = _ref144.children,
        rest = _objectWithoutProperties(_ref144, _excluded144);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path204 || (_path204 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M8,1C4.1,1,1,4.1,1,8c0,3.9,3.1,7,7,7s7-3.1,7-7C15,4.1,11.9,1,8,1z M7,11L4.3,8.3l0.9-0.8L7,9.3l4-3.9l0.9,0.8L7,11z"
    })), _path205 || (_path205 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M7,11L4.3,8.3l0.9-0.8L7,9.3l4-3.9l0.9,0.8L7,11z",
      "data-icon-path": "inner-path",
      opacity: "0"
    })), children);
  });
  var CheckmarkOutline16 = /*#__PURE__*/React__default["default"].forwardRef(function CheckmarkOutline16(_ref156, ref) {
    var children = _ref156.children,
        rest = _objectWithoutProperties(_ref156, _excluded156);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path236 || (_path236 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M14 21.414L9 16.413 10.413 15 14 18.586 21.585 11 23 12.415 14 21.414z"
    })), _path237 || (_path237 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,26A12,12,0,1,1,28,16,12,12,0,0,1,16,28Z"
    })), children);
  });
  var ChevronDown20 = /*#__PURE__*/React__default["default"].forwardRef(function ChevronDown20(_ref175, ref) {
    var children = _ref175.children,
        rest = _objectWithoutProperties(_ref175, _excluded175);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 20,
      height: 20,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path268 || (_path268 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M16 22L6 12 7.4 10.6 16 19.2 24.6 10.6 26 12z"
    })), children);
  });
  var ChevronDown16 = /*#__PURE__*/React__default["default"].forwardRef(function ChevronDown16(_ref176, ref) {
    var children = _ref176.children,
        rest = _objectWithoutProperties(_ref176, _excluded176);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path269 || (_path269 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M8 11L3 6 3.7 5.3 8 9.6 12.3 5.3 13 6z"
    })), children);
  });
  var ChevronLeft16 = /*#__PURE__*/React__default["default"].forwardRef(function ChevronLeft16(_ref185, ref) {
    var children = _ref185.children,
        rest = _objectWithoutProperties(_ref185, _excluded185);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path282 || (_path282 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M5 8L10 3 10.7 3.7 6.4 8 10.7 12.3 10 13z"
    })), children);
  });
  var ChevronRight20 = /*#__PURE__*/React__default["default"].forwardRef(function ChevronRight20(_ref193, ref) {
    var children = _ref193.children,
        rest = _objectWithoutProperties(_ref193, _excluded193);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 20,
      height: 20,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path290 || (_path290 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M22 16L12 26 10.6 24.6 19.2 16 10.6 7.4 12 6z"
    })), children);
  });
  var ChevronRight16 = /*#__PURE__*/React__default["default"].forwardRef(function ChevronRight16(_ref194, ref) {
    var children = _ref194.children,
        rest = _objectWithoutProperties(_ref194, _excluded194);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path291 || (_path291 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M11 8L6 13 5.3 12.3 9.6 8 5.3 3.7 6 3z"
    })), children);
  });

  var _path80, _path128$1, _path129$1;

  var _excluded50$1 = ["children"],
      _excluded79 = ["children"],
      _excluded80 = ["children"];
  var CircleDash16 = /*#__PURE__*/React__default["default"].forwardRef(function CircleDash16(_ref50, ref) {
    var children = _ref50.children,
        rest = _objectWithoutProperties(_ref50, _excluded50$1);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path80 || (_path80 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M7.7 4.7a14.7 14.7 0 00-3 3.1L6.3 9A13.26 13.26 0 018.9 6.3zM4.6 12.3l-1.9-.6A12.51 12.51 0 002 16H4A11.48 11.48 0 014.6 12.3zM2.7 20.4a14.4 14.4 0 002 3.9l1.6-1.2a12.89 12.89 0 01-1.7-3.3zM7.8 27.3a14.4 14.4 0 003.9 2l.6-1.9A12.89 12.89 0 019 25.7zM11.7 2.7l.6 1.9A11.48 11.48 0 0116 4V2A12.51 12.51 0 0011.7 2.7zM24.2 27.3a15.18 15.18 0 003.1-3.1L25.7 23A11.53 11.53 0 0123 25.7zM27.4 19.7l1.9.6A15.47 15.47 0 0030 16H28A11.48 11.48 0 0127.4 19.7zM29.2 11.6a14.4 14.4 0 00-2-3.9L25.6 8.9a12.89 12.89 0 011.7 3.3zM24.1 4.6a14.4 14.4 0 00-3.9-2l-.6 1.9a12.89 12.89 0 013.3 1.7zM20.3 29.3l-.6-1.9A11.48 11.48 0 0116 28v2A21.42 21.42 0 0020.3 29.3z"
    })), children);
  });
  var Close20 = /*#__PURE__*/React__default["default"].forwardRef(function Close20(_ref79, ref) {
    var children = _ref79.children,
        rest = _objectWithoutProperties(_ref79, _excluded79);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 20,
      height: 20,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path128$1 || (_path128$1 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M17.4141 16L24 9.4141 22.5859 8 16 14.5859 9.4143 8 8 9.4141 14.5859 16 8 22.5859 9.4143 24 16 17.4141 22.5859 24 24 22.5859 17.4141 16z"
    })), children);
  });
  var Close16 = /*#__PURE__*/React__default["default"].forwardRef(function Close16(_ref80, ref) {
    var children = _ref80.children,
        rest = _objectWithoutProperties(_ref80, _excluded80);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path129$1 || (_path129$1 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M17.4141 16L24 9.4141 22.5859 8 16 14.5859 9.4143 8 8 9.4141 14.5859 16 8 22.5859 9.4143 24 16 17.4141 22.5859 24 24 22.5859 17.4141 16z"
    })), children);
  });

  var _path215, _path216;

  var _excluded150 = ["children"];
  var Copy16 = /*#__PURE__*/React__default["default"].forwardRef(function Copy16(_ref150, ref) {
    var children = _ref150.children,
        rest = _objectWithoutProperties(_ref150, _excluded150);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path215 || (_path215 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M28,10V28H10V10H28m0-2H10a2,2,0,0,0-2,2V28a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V10a2,2,0,0,0-2-2Z"
    })), _path216 || (_path216 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M4,18H2V4A2,2,0,0,1,4,2H18V4H4Z"
    })), children);
  });

  var _path262, _path335, _path336, _path337, _path338;

  var _excluded157 = ["children"],
      _excluded212 = ["children"],
      _excluded213 = ["children"];
  var EditOff16 = /*#__PURE__*/React__default["default"].forwardRef(function EditOff16(_ref157, ref) {
    var children = _ref157.children,
        rest = _objectWithoutProperties(_ref157, _excluded157);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path262 || (_path262 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M30 28.6L3.4 2 2 3.4l10.1 10.1L4 21.6V28h6.4l8.1-8.1L28.6 30 30 28.6zM9.6 26H6v-3.6l7.5-7.5 3.6 3.6L9.6 26zM29.4 6.2L29.4 6.2l-3.6-3.6c-.8-.8-2-.8-2.8 0l0 0 0 0-8 8 1.4 1.4L20 8.4l3.6 3.6L20 15.6l1.4 1.4 8-8C30.2 8.2 30.2 7 29.4 6.2L29.4 6.2zM25 10.6L21.4 7l3-3L28 7.6 25 10.6z"
    })), children);
  });
  var ErrorFilled20 = /*#__PURE__*/React__default["default"].forwardRef(function ErrorFilled20(_ref212, ref) {
    var children = _ref212.children,
        rest = _objectWithoutProperties(_ref212, _excluded212);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 20,
      height: 20,
      viewBox: "0 0 20 20",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path335 || (_path335 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M10,1c-5,0-9,4-9,9s4,9,9,9s9-4,9-9S15,1,10,1z M13.5,14.5l-8-8l1-1l8,8L13.5,14.5z"
    })), _path336 || (_path336 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M13.5,14.5l-8-8l1-1l8,8L13.5,14.5z",
      "data-icon-path": "inner-path",
      opacity: "0"
    })), children);
  });
  var ErrorFilled16 = /*#__PURE__*/React__default["default"].forwardRef(function ErrorFilled16(_ref213, ref) {
    var children = _ref213.children,
        rest = _objectWithoutProperties(_ref213, _excluded213);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path337 || (_path337 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M8,1C4.1,1,1,4.1,1,8s3.1,7,7,7s7-3.1,7-7S11.9,1,8,1z M10.7,11.5L4.5,5.3l0.8-0.8l6.2,6.2L10.7,11.5z"
    })), _path338 || (_path338 = /*#__PURE__*/React__default["default"].createElement("path", {
      fill: "none",
      d: "M10.7,11.5L4.5,5.3l0.8-0.8l6.2,6.2L10.7,11.5z",
      "data-icon-path": "inner-path",
      opacity: "0"
    })), children);
  });

  var _path201;

  var _excluded135 = ["children"];
  var Filter16 = /*#__PURE__*/React__default["default"].forwardRef(function Filter16(_ref135, ref) {
    var children = _ref135.children,
        rest = _objectWithoutProperties(_ref135, _excluded135);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path201 || (_path201 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M18,28H14a2,2,0,0,1-2-2V18.41L4.59,11A2,2,0,0,1,4,9.59V6A2,2,0,0,1,6,4H26a2,2,0,0,1,2,2V9.59A2,2,0,0,1,27.41,11L20,18.41V26A2,2,0,0,1,18,28ZM6,6V9.59l8,8V26h4V17.59l8-8V6Z"
    })), children);
  });

  var _path382;

  var _excluded225 = ["children"];
  var Grid16 = /*#__PURE__*/React__default["default"].forwardRef(function Grid16(_ref225, ref) {
    var children = _ref225.children,
        rest = _objectWithoutProperties(_ref225, _excluded225);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path382 || (_path382 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M12 4H6A2 2 0 004 6v6a2 2 0 002 2h6a2 2 0 002-2V6A2 2 0 0012 4zm0 8H6V6h6zM26 4H20a2 2 0 00-2 2v6a2 2 0 002 2h6a2 2 0 002-2V6A2 2 0 0026 4zm0 8H20V6h6zM12 18H6a2 2 0 00-2 2v6a2 2 0 002 2h6a2 2 0 002-2V20A2 2 0 0012 18zm0 8H6V20h6zM26 18H20a2 2 0 00-2 2v6a2 2 0 002 2h6a2 2 0 002-2V20A2 2 0 0026 18zm0 8H20V20h6z"
    })), children);
  });

  var _path37, _path69, _path70, _path83$1, _path84, _path99, _path100;

  var _excluded21 = ["children"],
      _excluded50 = ["children"],
      _excluded57 = ["children"],
      _excluded65 = ["children"];
  var Incomplete16 = /*#__PURE__*/React__default["default"].forwardRef(function Incomplete16(_ref21, ref) {
    var children = _ref21.children,
        rest = _objectWithoutProperties(_ref21, _excluded21);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path37 || (_path37 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M23.7642 6.8593l1.2851-1.5315A13.976 13.976 0 0020.8672 2.887l-.6836 1.8776A11.9729 11.9729 0 0123.7642 6.8593zM27.81 14l1.9677-.4128A13.8888 13.8888 0 0028.14 9.0457L26.4087 10A12.52 12.52 0 0127.81 14zM20.1836 27.2354l.6836 1.8776a13.976 13.976 0 004.1821-2.4408l-1.2851-1.5315A11.9729 11.9729 0 0120.1836 27.2354zM26.4087 22L28.14 23a14.14 14.14 0 001.6382-4.5872L27.81 18.0659A12.1519 12.1519 0 0126.4087 22zM16 30V2a14 14 0 000 28z"
    })), children);
  });
  var Information16 = /*#__PURE__*/React__default["default"].forwardRef(function Information16(_ref50, ref) {
    var children = _ref50.children,
        rest = _objectWithoutProperties(_ref50, _excluded50);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path69 || (_path69 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M8.5 11L8.5 6.5 6.5 6.5 6.5 7.5 7.5 7.5 7.5 11 6 11 6 12 10 12 10 11zM8 3.5c-.4 0-.8.3-.8.8S7.6 5 8 5c.4 0 .8-.3.8-.8S8.4 3.5 8 3.5z"
    })), _path70 || (_path70 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M8,15c-3.9,0-7-3.1-7-7s3.1-7,7-7s7,3.1,7,7S11.9,15,8,15z M8,2C4.7,2,2,4.7,2,8s2.7,6,6,6s6-2.7,6-6S11.3,2,8,2z"
    })), children);
  });
  var InformationFilled20 = /*#__PURE__*/React__default["default"].forwardRef(function InformationFilled20(_ref57, ref) {
    var children = _ref57.children,
        rest = _objectWithoutProperties(_ref57, _excluded57);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 20,
      height: 20,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path83$1 || (_path83$1 = /*#__PURE__*/React__default["default"].createElement("path", {
      fill: "none",
      d: "M16,8a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,13.875H17.125v-8H13v2.25h1.875v5.75H12v2.25h8Z",
      "data-icon-path": "inner-path"
    })), _path84 || (_path84 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,6a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,16.125H12v-2.25h2.875v-5.75H13v-2.25h4.125v8H20Z"
    })), children);
  });
  var InformationSquareFilled20 = /*#__PURE__*/React__default["default"].forwardRef(function InformationSquareFilled20(_ref65, ref) {
    var children = _ref65.children,
        rest = _objectWithoutProperties(_ref65, _excluded65);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 20,
      height: 20,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path99 || (_path99 = /*#__PURE__*/React__default["default"].createElement("path", {
      fill: "none",
      d: "M16,8a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,13.875H17.125v-8H13v2.25h1.875v5.75H12v2.25h8Z",
      "data-icon-path": "inner-path"
    })), _path100 || (_path100 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4ZM16,8a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,16.125H12v-2.25h2.875v-5.75H13v-2.25h4.125v8H20Z"
    })), children);
  });

  var _circle19, _circle20, _path352;

  var _excluded220 = ["children"];
  var ListBulleted16 = /*#__PURE__*/React__default["default"].forwardRef(function ListBulleted16(_ref220, ref) {
    var children = _ref220.children,
        rest = _objectWithoutProperties(_ref220, _excluded220);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _circle19 || (_circle19 = /*#__PURE__*/React__default["default"].createElement("circle", {
      cx: "3.5",
      cy: "4.5",
      r: "1.5"
    })), _circle20 || (_circle20 = /*#__PURE__*/React__default["default"].createElement("circle", {
      cx: "3.5",
      cy: "11.5",
      r: "1.5"
    })), _path352 || (_path352 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M8 11H15V12H8zM8 4H15V5H8z"
    })), children);
  });

  var _path273;

  var _excluded152 = ["children"];
  var Menu20 = /*#__PURE__*/React__default["default"].forwardRef(function Menu20(_ref152, ref) {
    var children = _ref152.children,
        rest = _objectWithoutProperties(_ref152, _excluded152);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 20,
      height: 20,
      viewBox: "0 0 20 20",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path273 || (_path273 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M2 14.8H18V16H2zM2 11.2H18V12.399999999999999H2zM2 7.6H18V8.799999999999999H2zM2 4H18V5.2H2z"
    })), children);
  });

  var _circle34, _circle35, _circle36, _circle46, _circle47, _circle48;

  var _excluded245 = ["children"],
      _excluded249 = ["children"];
  var OverflowMenuHorizontal16 = /*#__PURE__*/React__default["default"].forwardRef(function OverflowMenuHorizontal16(_ref245, ref) {
    var children = _ref245.children,
        rest = _objectWithoutProperties(_ref245, _excluded245);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _circle34 || (_circle34 = /*#__PURE__*/React__default["default"].createElement("circle", {
      cx: "8",
      cy: "16",
      r: "2"
    })), _circle35 || (_circle35 = /*#__PURE__*/React__default["default"].createElement("circle", {
      cx: "16",
      cy: "16",
      r: "2"
    })), _circle36 || (_circle36 = /*#__PURE__*/React__default["default"].createElement("circle", {
      cx: "24",
      cy: "16",
      r: "2"
    })), children);
  });
  var OverflowMenuVertical16 = /*#__PURE__*/React__default["default"].forwardRef(function OverflowMenuVertical16(_ref249, ref) {
    var children = _ref249.children,
        rest = _objectWithoutProperties(_ref249, _excluded249);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _circle46 || (_circle46 = /*#__PURE__*/React__default["default"].createElement("circle", {
      cx: "16",
      cy: "8",
      r: "2"
    })), _circle47 || (_circle47 = /*#__PURE__*/React__default["default"].createElement("circle", {
      cx: "16",
      cy: "16",
      r: "2"
    })), _circle48 || (_circle48 = /*#__PURE__*/React__default["default"].createElement("circle", {
      cx: "16",
      cy: "24",
      r: "2"
    })), children);
  });

  var _path83, _path198, _path199;

  var _excluded55 = ["children"],
      _excluded143 = ["children"];
  var Search16 = /*#__PURE__*/React__default["default"].forwardRef(function Search16(_ref55, ref) {
    var children = _ref55.children,
        rest = _objectWithoutProperties(_ref55, _excluded55);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path83 || (_path83 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M15,14.3L10.7,10c1.9-2.3,1.6-5.8-0.7-7.7S4.2,0.7,2.3,3S0.7,8.8,3,10.7c2,1.7,5,1.7,7,0l4.3,4.3L15,14.3z M2,6.5\tC2,4,4,2,6.5,2S11,4,11,6.5S9,11,6.5,11S2,9,2,6.5z"
    })), children);
  });
  var Settings16 = /*#__PURE__*/React__default["default"].forwardRef(function Settings16(_ref143, ref) {
    var children = _ref143.children,
        rest = _objectWithoutProperties(_ref143, _excluded143);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path198 || (_path198 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M13.5,8.4c0-0.1,0-0.3,0-0.4c0-0.1,0-0.3,0-0.4l1-0.8c0.4-0.3,0.4-0.9,0.2-1.3l-1.2-2C13.3,3.2,13,3,12.6,3\tc-0.1,0-0.2,0-0.3,0.1l-1.2,0.4c-0.2-0.1-0.4-0.3-0.7-0.4l-0.3-1.3C10.1,1.3,9.7,1,9.2,1H6.8c-0.5,0-0.9,0.3-1,0.8L5.6,3.1\tC5.3,3.2,5.1,3.3,4.9,3.4L3.7,3C3.6,3,3.5,3,3.4,3C3,3,2.7,3.2,2.5,3.5l-1.2,2C1.1,5.9,1.2,6.4,1.6,6.8l0.9,0.9c0,0.1,0,0.3,0,0.4\tc0,0.1,0,0.3,0,0.4L1.6,9.2c-0.4,0.3-0.5,0.9-0.2,1.3l1.2,2C2.7,12.8,3,13,3.4,13c0.1,0,0.2,0,0.3-0.1l1.2-0.4\tc0.2,0.1,0.4,0.3,0.7,0.4l0.3,1.3c0.1,0.5,0.5,0.8,1,0.8h2.4c0.5,0,0.9-0.3,1-0.8l0.3-1.3c0.2-0.1,0.4-0.2,0.7-0.4l1.2,0.4\tc0.1,0,0.2,0.1,0.3,0.1c0.4,0,0.7-0.2,0.9-0.5l1.1-2c0.2-0.4,0.2-0.9-0.2-1.3L13.5,8.4z M12.6,12l-1.7-0.6c-0.4,0.3-0.9,0.6-1.4,0.8\tL9.2,14H6.8l-0.4-1.8c-0.5-0.2-0.9-0.5-1.4-0.8L3.4,12l-1.2-2l1.4-1.2c-0.1-0.5-0.1-1.1,0-1.6L2.2,6l1.2-2l1.7,0.6\tC5.5,4.2,6,4,6.5,3.8L6.8,2h2.4l0.4,1.8c0.5,0.2,0.9,0.5,1.4,0.8L12.6,4l1.2,2l-1.4,1.2c0.1,0.5,0.1,1.1,0,1.6l1.4,1.2L12.6,12z"
    })), _path199 || (_path199 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M8,11c-1.7,0-3-1.3-3-3s1.3-3,3-3s3,1.3,3,3C11,9.6,9.7,11,8,11C8,11,8,11,8,11z M8,6C6.9,6,6,6.8,6,7.9C6,7.9,6,8,6,8\tc0,1.1,0.8,2,1.9,2c0,0,0.1,0,0.1,0c1.1,0,2-0.8,2-1.9c0,0,0-0.1,0-0.1C10,6.9,9.2,6,8,6C8.1,6,8,6,8,6z"
    })), children);
  });

  var _path256;

  var _excluded168 = ["children"];
  var Subtract16 = /*#__PURE__*/React__default["default"].forwardRef(function Subtract16(_ref168, ref) {
    var children = _ref168.children,
        rest = _objectWithoutProperties(_ref168, _excluded168);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path256 || (_path256 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M8 15H24V17H8z"
    })), children);
  });

  var _path309, _path310, _path329, _path330;

  var _excluded189 = ["children"],
      _excluded205 = ["children"];
  var View16 = /*#__PURE__*/React__default["default"].forwardRef(function View16(_ref189, ref) {
    var children = _ref189.children,
        rest = _objectWithoutProperties(_ref189, _excluded189);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path309 || (_path309 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M15.5,7.8C14.3,4.7,11.3,2.6,8,2.5C4.7,2.6,1.7,4.7,0.5,7.8c0,0.1,0,0.2,0,0.3c1.2,3.1,4.1,5.2,7.5,5.3\tc3.3-0.1,6.3-2.2,7.5-5.3C15.5,8.1,15.5,7.9,15.5,7.8z M8,12.5c-2.7,0-5.4-2-6.5-4.5c1-2.5,3.8-4.5,6.5-4.5s5.4,2,6.5,4.5\tC13.4,10.5,10.6,12.5,8,12.5z"
    })), _path310 || (_path310 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M8,5C6.3,5,5,6.3,5,8s1.3,3,3,3s3-1.3,3-3S9.7,5,8,5z M8,10c-1.1,0-2-0.9-2-2s0.9-2,2-2s2,0.9,2,2S9.1,10,8,10z"
    })), children);
  });
  var ViewOff16 = /*#__PURE__*/React__default["default"].forwardRef(function ViewOff16(_ref205, ref) {
    var children = _ref205.children,
        rest = _objectWithoutProperties(_ref205, _excluded205);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path329 || (_path329 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M2.6,11.3l0.7-0.7C2.6,9.8,1.9,9,1.5,8c1-2.5,3.8-4.5,6.5-4.5c0.7,0,1.4,0.1,2,0.4l0.8-0.8C9.9,2.7,9,2.5,8,2.5\tC4.7,2.6,1.7,4.7,0.5,7.8c0,0.1,0,0.2,0,0.3C1,9.3,1.7,10.4,2.6,11.3z"
    })), _path330 || (_path330 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M6 7.9c.1-1 .9-1.8 1.8-1.8l.9-.9C7.2 4.7 5.5 5.6 5.1 7.2 5 7.7 5 8.3 5.1 8.8L6 7.9zM15.5 7.8c-.6-1.5-1.6-2.8-2.9-3.7L15 1.7 14.3 1 1 14.3 1.7 15l2.6-2.6c1.1.7 2.4 1 3.7 1.1 3.3-.1 6.3-2.2 7.5-5.3C15.5 8.1 15.5 7.9 15.5 7.8zM10 8c0 1.1-.9 2-2 2-.3 0-.7-.1-1-.3L9.7 7C9.9 7.3 10 7.6 10 8zM8 12.5c-1 0-2.1-.3-3-.8l1.3-1.3c1.4.9 3.2.6 4.2-.8.7-1 .7-2.4 0-3.4l1.4-1.4c1.1.8 2 1.9 2.6 3.2C13.4 10.5 10.6 12.5 8 12.5z"
    })), children);
  });

  var _path128, _path129, _path144, _path145, _path146, _path147, _path148, _path149, _path182, _path183, _path184, _path185;

  var _excluded83 = ["children"],
      _excluded90 = ["children"],
      _excluded91 = ["children"],
      _excluded106 = ["children"],
      _excluded107 = ["children"];
  var Warning16 = /*#__PURE__*/React__default["default"].forwardRef(function Warning16(_ref83, ref) {
    var children = _ref83.children,
        rest = _objectWithoutProperties(_ref83, _excluded83);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path128 || (_path128 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M8,1C4.1,1,1,4.1,1,8s3.1,7,7,7s7-3.1,7-7S11.9,1,8,1z M8,14c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S11.3,14,8,14z"
    })), _path129 || (_path129 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M7.5 4H8.5V9H7.5zM8 10.2c-.4 0-.8.3-.8.8s.3.8.8.8c.4 0 .8-.3.8-.8S8.4 10.2 8 10.2z"
    })), children);
  });
  var WarningAltFilled20 = /*#__PURE__*/React__default["default"].forwardRef(function WarningAltFilled20(_ref90, ref) {
    var children = _ref90.children,
        rest = _objectWithoutProperties(_ref90, _excluded90);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 20,
      height: 20,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path144 || (_path144 = /*#__PURE__*/React__default["default"].createElement("path", {
      fill: "none",
      d: "M16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Zm-1.125-5h2.25V12h-2.25Z",
      "data-icon-path": "inner-path"
    })), _path145 || (_path145 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M16.002,6.1714h-.004L4.6487,27.9966,4.6506,28H27.3494l.0019-.0034ZM14.875,12h2.25v9h-2.25ZM16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Z"
    })), _path146 || (_path146 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M29,30H3a1,1,0,0,1-.8872-1.4614l13-25a1,1,0,0,1,1.7744,0l13,25A1,1,0,0,1,29,30ZM4.6507,28H27.3493l.002-.0033L16.002,6.1714h-.004L4.6487,27.9967Z"
    })), children);
  });
  var WarningAltFilled16 = /*#__PURE__*/React__default["default"].forwardRef(function WarningAltFilled16(_ref91, ref) {
    var children = _ref91.children,
        rest = _objectWithoutProperties(_ref91, _excluded91);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path147 || (_path147 = /*#__PURE__*/React__default["default"].createElement("path", {
      fill: "none",
      d: "M16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Zm-1.125-5h2.25V12h-2.25Z",
      "data-icon-path": "inner-path"
    })), _path148 || (_path148 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M16.002,6.1714h-.004L4.6487,27.9966,4.6506,28H27.3494l.0019-.0034ZM14.875,12h2.25v9h-2.25ZM16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Z"
    })), _path149 || (_path149 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M29,30H3a1,1,0,0,1-.8872-1.4614l13-25a1,1,0,0,1,1.7744,0l13,25A1,1,0,0,1,29,30ZM4.6507,28H27.3493l.002-.0033L16.002,6.1714h-.004L4.6487,27.9967Z"
    })), children);
  });
  var WarningFilled20 = /*#__PURE__*/React__default["default"].forwardRef(function WarningFilled20(_ref106, ref) {
    var children = _ref106.children,
        rest = _objectWithoutProperties(_ref106, _excluded106);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 20,
      height: 20,
      viewBox: "0 0 20 20",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path182 || (_path182 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M10,1c-5,0-9,4-9,9s4,9,9,9s9-4,9-9S15,1,10,1z M9.2,5h1.5v7H9.2V5z M10,16c-0.6,0-1-0.4-1-1s0.4-1,1-1\ts1,0.4,1,1S10.6,16,10,16z"
    })), _path183 || (_path183 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M9.2,5h1.5v7H9.2V5z M10,16c-0.6,0-1-0.4-1-1s0.4-1,1-1s1,0.4,1,1S10.6,16,10,16z",
      "data-icon-path": "inner-path",
      opacity: "0"
    })), children);
  });
  var WarningFilled16 = /*#__PURE__*/React__default["default"].forwardRef(function WarningFilled16(_ref107, ref) {
    var children = _ref107.children,
        rest = _objectWithoutProperties(_ref107, _excluded107);

    return /*#__PURE__*/React__default["default"].createElement(Icon$2, _extends$2({
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "currentColor",
      ref: ref
    }, rest), _path184 || (_path184 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M8,1C4.2,1,1,4.2,1,8s3.2,7,7,7s7-3.1,7-7S11.9,1,8,1z M7.5,4h1v5h-1C7.5,9,7.5,4,7.5,4z M8,12.2\tc-0.4,0-0.8-0.4-0.8-0.8s0.3-0.8,0.8-0.8c0.4,0,0.8,0.4,0.8,0.8S8.4,12.2,8,12.2z"
    })), _path185 || (_path185 = /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M7.5,4h1v5h-1C7.5,9,7.5,4,7.5,4z M8,12.2c-0.4,0-0.8-0.4-0.8-0.8s0.3-0.8,0.8-0.8\tc0.4,0,0.8,0.4,0.8,0.8S8.4,12.2,8,12.2z",
      "data-icon-path": "inner-path",
      opacity: "0"
    })), children);
  });

  var TextDirectionContext = /*#__PURE__*/React.createContext(null);

  var _excluded$2M = ["as", "children", "dir"];

  function Text(_ref) {
    var _ref$as = _ref.as,
        BaseComponent = _ref$as === void 0 ? 'span' : _ref$as,
        children = _ref.children,
        _ref$dir = _ref.dir,
        dir = _ref$dir === void 0 ? 'auto' : _ref$dir,
        rest = _objectWithoutProperties$2(_ref, _excluded$2M);

    var context = React.useContext(TextDirectionContext);
    var textProps = {};

    var value = _objectSpread2$2({}, context);

    if (!context) {
      textProps.dir = dir;
      value.direction = dir;
    } else {
      var parentDirection = context.direction,
          getTextDirection = context.getTextDirection;

      if (getTextDirection && getTextDirection.current) {
        var text = getTextFromChildren(children);
        var override = getTextDirection.current(text);

        if (parentDirection !== override) {
          textProps.dir = override;
          value.direction = override;
        } else if (parentDirection === 'auto') {
          textProps.dir = override;
        }
      } else if (parentDirection !== dir) {
        textProps.dir = dir;
        value.direction = dir;
      } else if (parentDirection === 'auto') {
        textProps.dir = dir;
      }
    }

    return /*#__PURE__*/React__default["default"].createElement(TextDirectionContext.Provider, {
      value: value
    }, /*#__PURE__*/React__default["default"].createElement(BaseComponent, _extends$3({}, rest, textProps), children));
  }

  Text.propTypes = {
    /**
     * Provide a custom element type used to render the outermost node
     */
    as: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].string, PropTypes__default["default"].elementType]),

    /**
     * Provide child elements or text to be rendered inside of this component
     */
    children: PropTypes__default["default"].node.isRequired,

    /**
     * Specify the text direction to be used for this component and any of its
     * children
     */
    dir: PropTypes__default["default"].oneOf(['ltr', 'rtl', 'auto'])
  };

  function getTextFromChildren(children) {
    if (typeof children === 'string') {
      return children;
    }

    var text = React__default["default"].Children.map(children, function (child) {
      if (typeof child === 'string') {
        return child;
      }

      return null;
    }).filter(function (text) {
      return text !== null;
    });

    if (text.length === 1) {
      return text[0];
    }

    return text;
  }

  /**
   * Create a text component wrapper for a given text node type. Useful for
   * returning a `Text` component for a text node like a `<label>`.
   * @param {string} element
   * @param {string} displayName
   */

  function createTextComponent(element, displayName) {
    function TextWrapper(props) {
      return /*#__PURE__*/React__default["default"].createElement(Text, _extends$3({
        as: element
      }, props));
    }

    {
      TextWrapper.displayName = displayName;
    }

    return TextWrapper;
  }

  createTextComponent('label', 'Label');
  var Legend = createTextComponent('legend', 'Legend');

  var Tab$6 = {
    key: 'Tab',
    which: 9,
    keyCode: 9
  };
  var Enter = {
    key: 'Enter',
    which: 13,
    keyCode: 13
  };
  var Escape = {
    key: ['Escape', // IE11 Escape
    'Esc'],
    which: 27,
    keyCode: 27
  };
  var Space = {
    key: ' ',
    which: 32,
    keyCode: 32
  };
  var End = {
    key: 'End',
    which: 35,
    keyCode: 35
  };
  var Home = {
    key: 'Home',
    which: 36,
    keyCode: 36
  };
  var ArrowLeft = {
    key: 'ArrowLeft',
    which: 37,
    keyCode: 37
  };
  var ArrowUp = {
    key: 'ArrowUp',
    which: 38,
    keyCode: 38
  };
  var ArrowRight = {
    key: 'ArrowRight',
    which: 39,
    keyCode: 39
  };
  var ArrowDown = {
    key: 'ArrowDown',
    which: 40,
    keyCode: 40
  };
  var Delete = {
    key: 'Delete',
    which: 8 ,
    keyCode: 8 
  };

  /**
   * @typedef Key
   * @property key {Array<string>|string}
   * @property which {number}
   * @property keyCode {number}
   */

  /**
   * Check to see if at least one key code matches the key code of the
   * given event.
   *
   * @example
   * import * as keys from '../keys';
   * import { matches } from '../match';
   *
   * function handleOnKeyDown(event) {
   *   if (matches(event, [keys.Enter, keys.Space]) {
   *     // ...
   *   }
   * }
   *
   * @param {Event} event
   * @param {Array<Key>} keysToMatch
   * @returns {boolean}
   */
  function matches(event, keysToMatch) {
    for (var i = 0; i < keysToMatch.length; i++) {
      if (match(event, keysToMatch[i])) {
        return true;
      }
    }

    return false;
  }
  /**
   * Check to see if the given key matches the corresponding keyboard event. Also
   * supports passing in the value directly if you can't used the given event.
   *
   * @example
   * import * as keys from '../keys';
   * import { matches } from '../match';
   *
   * function handleOnKeyDown(event) {
   *   if (match(event, keys.Enter) {
   *     // ...
   *   }
   * }
   *
   * @param {Event|number|string} eventOrCode
   * @param {Key} key
   * @returns {boolean}
   */

  function match(eventOrCode) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        key = _ref.key,
        which = _ref.which,
        keyCode = _ref.keyCode;

    if (typeof eventOrCode === 'string') {
      return eventOrCode === key;
    }

    if (typeof eventOrCode === 'number') {
      return eventOrCode === which || eventOrCode === keyCode;
    }

    if (eventOrCode.key && Array.isArray(key)) {
      return key.indexOf(eventOrCode.key) !== -1;
    }

    return eventOrCode.key === key || eventOrCode.which === which || eventOrCode.keyCode === keyCode;
  }

  /**
   * Various utilities to help with a11y work
   */

  /**
   * A "ring buffer" function that takes an array and depending on an ArrowRight
   * or ArrowLeft key input loops from last index to first or first index to last.
   *
   * @param {string} key - the left or right arrow keys
   * @param {number} index - the current index in a given array
   * @param {number} arrayLength - the total length of the array
   *
   * @example
   * 	getNextIndex(keyCodes.RIGHT, 0, 4)
   */

  var getNextIndex$1 = function getNextIndex(key, index, arrayLength) {
    if (match(key, ArrowRight)) {
      return (index + 1) % arrayLength;
    }

    if (match(key, ArrowLeft)) {
      return (index + arrayLength - 1) % arrayLength;
    }
  };
  /**
   * A flag `node.compareDocumentPosition(target)` returns,
   * that indicates `target` is located earlier than `node` in the document or `target` contains `node`.
   */

  var DOCUMENT_POSITION_BROAD_PRECEDING = // Checks `typeof Node` for `react-docgen`
  typeof Node !== 'undefined' && Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINS;
  /**
   * A flag `node.compareDocumentPosition(target)` returns,
   * that indicates `target` is located later than `node` in the document or `node` contains `target`.
   */

  var DOCUMENT_POSITION_BROAD_FOLLOWING = // Checks `typeof Node` for `react-docgen`
  typeof Node !== 'undefined' && Node.DOCUMENT_POSITION_FOLLOWING | Node.DOCUMENT_POSITION_CONTAINED_BY;
  /**
   * CSS selector that selects major nodes that are sequential-focusable.
   */

  var selectorTabbable = "\n  a[href], area[href], input:not([disabled]):not([tabindex='-1']),\n  button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']),\n  textarea:not([disabled]):not([tabindex='-1']),\n  iframe, object, embed, *[tabindex]:not([tabindex='-1']):not([disabled]), *[contenteditable=true]\n";
  /**
   * CSS selector that selects major nodes that are click focusable
   */

  var selectorFocusable = "\n  a[href], area[href], input:not([disabled]),\n  button:not([disabled]),select:not([disabled]),\n  textarea:not([disabled]),\n  iframe, object, embed, *[tabindex]:not([disabled]), *[contenteditable=true]\n";

  /**
   * Generic utility to initialize a method that will return a unique instance id
   * for a component.
   */
  function setupGetInstanceId$2() {
    var instanceId = 0;
    return function getInstanceId() {
      return ++instanceId;
    };
  }

  /**
   * Indicate whether current execution environment can access the DOM.
   *
   * @see https://github.com/facebook/fbjs/blob/4d1751311d3f67af2dcce2e40df8512a23c7b9c6/packages/fbjs/src/core/ExecutionEnvironment.js#L12
   */
  var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

  var getId = setupGetInstanceId$2();
  var useIsomorphicLayoutEffect = canUseDOM ? React.useLayoutEffect : React.useEffect;
  var serverHandoffCompleted = false;
  /**
   * Generate a unique ID with an optional prefix prepended to it
   * @param {string} [prefix]
   * @returns {string}
   */

  function useId() {
    var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'id';

    var _useState = React.useState(function () {
      if (serverHandoffCompleted) {
        return "".concat(prefix, "-").concat(getId());
      }

      return null;
    }),
        _useState2 = _slicedToArray$1(_useState, 2),
        id = _useState2[0],
        setId = _useState2[1];

    useIsomorphicLayoutEffect(function () {
      if (id === null) {
        setId("".concat(prefix, "-").concat(getId()));
      }
    }, [getId]);
    React.useEffect(function () {
      if (serverHandoffCompleted === false) {
        serverHandoffCompleted = true;
      }
    }, []);
    return id;
  }
  /**
   * Generate a unique id if a given `id` is not provided
   * @param {string} id
   * @returns {string}
   */

  function useFallbackId(id) {
    var fallback = useId();
    return id !== null && id !== void 0 ? id : fallback;
  }

  var warning = function warning(condition, format) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'format argument');
    }

    if (!condition) {
      var index = 0;
      var message = format.replace(/%s/g, function () {
        return args[index++];
      });
      console.warn('Warning: ' + message);
    }
  } ;

  var didWarnAboutDeprecation$7 = {};
  function deprecate(propType, message) {
    function checker(props, propName, componentName) {
      if (props[propName] === undefined) {
        return;
      }

      if (!didWarnAboutDeprecation$7[componentName] || !didWarnAboutDeprecation$7[componentName][propName]) {
        didWarnAboutDeprecation$7[componentName] = _objectSpread2$2(_objectSpread2$2({}, didWarnAboutDeprecation$7[componentName]), {}, _defineProperty$2({}, propName, true));
        warning(false, message || "The prop `".concat(propName, "` has been deprecated for the ") + "".concat(componentName, " component. It will be removed in the next major ") + "release") ;
      }

      for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        rest[_key - 3] = arguments[_key];
      }

      return propType.apply(void 0, [props, propName, componentName].concat(rest));
    }

    return checker;
  }

  var _excluded$2L = ["children", "className", "iconDescription", "open", "onHeadingClick", "renderExpando", "renderToggle", "title", "disabled"];

  var defaultRenderToggle = function defaultRenderToggle(props) {
    return /*#__PURE__*/React__default["default"].createElement("button", _extends$3({
      type: "button"
    }, props));
  };

  function AccordionItem(_ref) {
    var _cx;

    var children = _ref.children,
        customClassName = _ref.className;
        _ref.iconDescription;
        var _ref$open = _ref.open,
        open = _ref$open === void 0 ? false : _ref$open,
        onHeadingClick = _ref.onHeadingClick,
        _ref$renderExpando = _ref.renderExpando,
        renderExpando = _ref$renderExpando === void 0 ? defaultRenderToggle : _ref$renderExpando,
        renderToggle = _ref.renderToggle,
        _ref$title = _ref.title,
        title = _ref$title === void 0 ? 'title' : _ref$title,
        disabled = _ref.disabled,
        rest = _objectWithoutProperties$2(_ref, _excluded$2L);

    var _useState = React.useState(open),
        _useState2 = _slicedToArray$1(_useState, 2),
        isOpen = _useState2[0],
        setIsOpen = _useState2[1];

    var _useState3 = React.useState(open),
        _useState4 = _slicedToArray$1(_useState3, 2),
        prevIsOpen = _useState4[0],
        setPrevIsOpen = _useState4[1];

    var _useState5 = React.useState(''),
        _useState6 = _slicedToArray$1(_useState5, 2),
        animation = _useState6[0],
        setAnimation = _useState6[1];

    var id = useId('accordion-item');
    var prefix = usePrefix();
    var className = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--accordion__item"), true), _defineProperty$2(_cx, "".concat(prefix, "--accordion__item--active"), isOpen), _defineProperty$2(_cx, "".concat(prefix, "--accordion__item--").concat(animation), animation), _defineProperty$2(_cx, "".concat(prefix, "--accordion__item--disabled"), disabled), _defineProperty$2(_cx, customClassName, !!customClassName), _cx));
    var Toggle = renderToggle || renderExpando; // remove renderExpando in next major release

    if (open !== prevIsOpen) {
      setAnimation(isOpen ? 'collapsing' : 'expanding');
      setIsOpen(open);
      setPrevIsOpen(open);
    } // When the AccordionItem heading is clicked, toggle the open state of the
    // panel


    function onClick(event) {
      var nextValue = !isOpen;
      setAnimation(isOpen ? 'collapsing' : 'expanding');
      setIsOpen(nextValue);

      if (onHeadingClick) {
        // TODO: normalize signature, potentially:
        // onHeadingClick :: (event: Event, state: { isOpen: Boolean }) => any
        onHeadingClick({
          isOpen: nextValue,
          event: event
        });
      }
    } // If the AccordionItem is open, and the user hits the ESC key, then close it


    function onKeyDown(event) {
      if (isOpen && match(event, Escape)) {
        setIsOpen(false);
      }
    }

    function handleAnimationEnd(event) {
      if (rest.handleAnimationEnd) {
        rest.handleAnimationEnd(event);
      }

      setAnimation('');
    }

    return /*#__PURE__*/React__default["default"].createElement("li", _extends$3({
      className: className
    }, rest, {
      onAnimationEnd: handleAnimationEnd
    }), /*#__PURE__*/React__default["default"].createElement(Toggle, {
      disabled: disabled,
      "aria-controls": id,
      "aria-expanded": isOpen,
      className: "".concat(prefix, "--accordion__heading"),
      onClick: onClick,
      onKeyDown: onKeyDown,
      type: "button"
    }, /*#__PURE__*/React__default["default"].createElement(ChevronRight16, {
      className: "".concat(prefix, "--accordion__arrow")
    }), /*#__PURE__*/React__default["default"].createElement(Text, {
      as: "div",
      className: "".concat(prefix, "--accordion__title")
    }, title)), /*#__PURE__*/React__default["default"].createElement("div", {
      id: id,
      className: "".concat(prefix, "--accordion__content")
    }, children));
  }

  AccordionItem.propTypes = {
    /**
     * Provide the contents of your AccordionItem
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether an individual AccordionItem should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * The description of the expand icon.
     */
    iconDescription: deprecate(PropTypes__default["default"].string, 'The `iconDescription` prop has been deprecated as it is no longer ' + 'required. Feel free to remove this prop from <AccordionItem>. This ' + 'prop will be removed in the next major release of ' + '`carbon-components-react`'),

    /**
     * The handler of the massaged `click` event.
     */
    onClick: PropTypes__default["default"].func,

    /**
     * The handler of the massaged `click` event on the heading.
     */
    onHeadingClick: PropTypes__default["default"].func,

    /**
     * `true` to open the expand.
     */
    open: PropTypes__default["default"].bool,

    /**
     * The callback function to render the expand button.
     * Can be a React component class.
     */
    renderExpando: deprecate(PropTypes__default["default"].func, 'The `renderExpando` prop has been deprecated and will be removed in the next major release of Carbon. Use the `renderToggle` prop instead.'),

    /**
     * The callback function to render the expand button.
     * Can be a React component class.
     */
    renderToggle: PropTypes__default["default"].func,

    /**
     * The accordion title.
     */
    title: PropTypes__default["default"].node
  };

  var _excluded$2K = ["paragraph", "lineCount", "width", "heading", "className"];
  var randoms = [0.973051493507435, 0.15334737213558558, 0.5671034553053769];

  function getRandomInt(min, max, n) {
    return Math.floor(randoms[n % 3] * (max - min + 1)) + min;
  }

  var SkeletonText = function SkeletonText(_ref) {
    var _classNames;

    var paragraph = _ref.paragraph,
        lineCount = _ref.lineCount,
        width = _ref.width,
        heading = _ref.heading,
        className = _ref.className,
        other = _objectWithoutProperties$2(_ref, _excluded$2K);

    var prefix = usePrefix();
    var skeletonTextClasses = cx((_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--skeleton__text"), true), _defineProperty$2(_classNames, "".concat(prefix, "--skeleton__heading"), heading), _defineProperty$2(_classNames, className, className), _classNames));
    var widthNum = parseInt(width, 10);
    var widthPx = width.includes('px');
    var widthPercent = width.includes('%');

    if (widthPercent && paragraph) {
      var lines = [];

      for (var i = 0; i < lineCount; i++) {
        var randomWidth = getRandomInt(0, 75, i) + 'px';
        lines.push( /*#__PURE__*/React__default["default"].createElement("p", _extends$3({
          className: skeletonTextClasses,
          style: {
            width: "calc(".concat(width, " - ").concat(randomWidth, ")")
          },
          key: i
        }, other)));
      }

      return /*#__PURE__*/React__default["default"].createElement("div", null, lines);
    }

    if (widthPx && paragraph) {
      var _lines = [];

      for (var j = 0; j < lineCount; j++) {
        var _randomWidth = getRandomInt(widthNum - 75, widthNum, j) + 'px';

        _lines.push( /*#__PURE__*/React__default["default"].createElement("p", _extends$3({
          className: skeletonTextClasses,
          style: {
            width: _randomWidth
          },
          key: j
        }, other)));
      }

      return /*#__PURE__*/React__default["default"].createElement("div", null, _lines);
    }

    return /*#__PURE__*/React__default["default"].createElement("p", _extends$3({
      className: skeletonTextClasses,
      style: {
        width: width
      }
    }, other));
  };

  SkeletonText.propTypes = {
    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * generates skeleton text at a larger size
     */
    heading: PropTypes__default["default"].bool,

    /**
     * the number of lines in a paragraph
     */
    lineCount: PropTypes__default["default"].number,

    /**
     * will generate multiple lines of text
     */
    paragraph: PropTypes__default["default"].bool,

    /**
     * width (in px or %) of single line of text or max-width of paragraph lines
     */
    width: PropTypes__default["default"].string
  };
  SkeletonText.defaultProps = {
    paragraph: false,
    width: '100%',
    heading: false,
    lineCount: 3
  };
  var SkeletonText$1 = SkeletonText;

  var _excluded$2J = ["align", "open", "count", "className"];

  function AccordionSkeleton(_ref) {
    var align = _ref.align,
        open = _ref.open,
        count = _ref.count,
        className = _ref.className,
        rest = _objectWithoutProperties$2(_ref, _excluded$2J);

    var prefix = usePrefix();
    var classes = cx("".concat(prefix, "--accordion"), "".concat(prefix, "--skeleton"), className, _defineProperty$2({}, "".concat(prefix, "--accordion--").concat(align), align));
    var numSkeletonItems = open ? count - 1 : count;
    return /*#__PURE__*/React__default["default"].createElement("ul", _extends$3({
      className: classes
    }, rest), open && /*#__PURE__*/React__default["default"].createElement("li", {
      className: "".concat(prefix, "--accordion__item ").concat(prefix, "--accordion__item--active")
    }, /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--accordion__heading")
    }, /*#__PURE__*/React__default["default"].createElement(ChevronRight16, {
      className: "".concat(prefix, "--accordion__arrow")
    }), /*#__PURE__*/React__default["default"].createElement(SkeletonText$1, {
      className: "".concat(prefix, "--accordion__title")
    })), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--accordion__content")
    }, /*#__PURE__*/React__default["default"].createElement(SkeletonText$1, {
      width: "90%"
    }), /*#__PURE__*/React__default["default"].createElement(SkeletonText$1, {
      width: "80%"
    }), /*#__PURE__*/React__default["default"].createElement(SkeletonText$1, {
      width: "95%"
    }))), Array.from({
      length: numSkeletonItems
    }).map(function (_, i) {
      return /*#__PURE__*/React__default["default"].createElement(AccordionSkeletonItem, {
        key: i
      });
    }));
  }

  AccordionSkeleton.propTypes = {
    /**
     * Specify the alignment of the accordion heading title and chevron.
     */
    align: PropTypes__default["default"].oneOf(['start', 'end']),

    /**
     * Specify an optional className to add.
     */
    className: PropTypes__default["default"].string,

    /**
     * Set number of items to render
     */
    count: PropTypes__default["default"].number,

    /**
     * `false` to not display the first item opened
     */
    open: PropTypes__default["default"].bool,

    /**
     * Set unique identifier to generate unique item keys
     */
    uid: deprecate(PropTypes__default["default"].any)
  };
  AccordionSkeleton.defaultProps = {
    open: true,
    count: 4,
    align: 'end'
  };

  function AccordionSkeletonItem() {
    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("li", {
      className: "".concat(prefix, "--accordion__item")
    }, /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--accordion__heading")
    }, /*#__PURE__*/React__default["default"].createElement(ChevronRight16, {
      className: "".concat(prefix, "--accordion__arrow")
    }), /*#__PURE__*/React__default["default"].createElement(SkeletonText$1, {
      className: "".concat(prefix, "--accordion__title")
    })));
  }

  var _excluded$2I = ["as", "className", "children", "ratio"];
  /**
   * The AspectRatio component provides a `ratio` prop that will be used to
   * specify the aspect ratio that the children you provide will be displayed in.
   * This is often useful alongside our grid components, or for media assets like
   * images or videos.
   */

  function AspectRatio(_ref) {
    var _ref$as = _ref.as,
        BaseComponent = _ref$as === void 0 ? 'div' : _ref$as,
        containerClassName = _ref.className,
        children = _ref.children,
        _ref$ratio = _ref.ratio,
        ratio = _ref$ratio === void 0 ? '1x1' : _ref$ratio,
        rest = _objectWithoutProperties$2(_ref, _excluded$2I);

    var prefix = usePrefix();
    var className = cx(containerClassName, "".concat(prefix, "--aspect-ratio"), "".concat(prefix, "--aspect-ratio--").concat(ratio));
    return /*#__PURE__*/React__default["default"].createElement(BaseComponent, _extends$3({
      className: className
    }, rest), children);
  }

  AspectRatio.propTypes = {
    /**
     * Provide a custom component or string to be rendered as the outermost node
     * of the component. This is useful if you want to deviate from the default
     * `div` tag, where you could specify `section` or `article` instead.
     *
     * ```jsx
     * <AspectRatio as="article">My content</AspectRatio>
     * ```
     */
    as: PropTypes__default["default"].elementType,

    /**
     * Specify the content that will be placed in the aspect ratio
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify a class name for the outermost node of the component
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the ratio to be used by the aspect ratio container. This will
     * determine what aspect ratio your content will be displayed in.
     */
    ratio: PropTypes__default["default"].oneOf(['16x9', '9x16', '2x1', '1x2', '4x3', '3x4', '1x1'])
  };

  var _excluded$2H = ["aria-label", "children", "className", "noTrailingSlash"];
  var Breadcrumb = /*#__PURE__*/React__default["default"].forwardRef(function Breadcrumb(_ref, ref) {
    var _cx;

    var ariaLabel = _ref['aria-label'],
        children = _ref.children,
        customClassNameNav = _ref.className,
        noTrailingSlash = _ref.noTrailingSlash,
        rest = _objectWithoutProperties$2(_ref, _excluded$2H);

    var prefix = usePrefix();
    var className = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--breadcrumb"), true), _defineProperty$2(_cx, "".concat(prefix, "--breadcrumb--no-trailing-slash"), noTrailingSlash), _cx));
    return /*#__PURE__*/React__default["default"].createElement("nav", _extends$3({
      className: customClassNameNav,
      "aria-label": ariaLabel ? ariaLabel : 'Breadcrumb',
      ref: ref
    }, rest), /*#__PURE__*/React__default["default"].createElement("ol", {
      className: className
    }, children));
  });
  Breadcrumb.displayName = 'Breadcrumb';
  Breadcrumb.propTypes = {
    /**
     * Specify the label for the breadcrumb container
     */
    'aria-label': PropTypes__default["default"].string,

    /**
     * Pass in the BreadcrumbItem's for your Breadcrumb
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Optional prop to omit the trailing slash for the breadcrumbs
     */
    noTrailingSlash: PropTypes__default["default"].bool
  };
  var Breadcrumb$1 = Breadcrumb;

  var _excluded$2G = ["children", "className", "href", "disabled", "inline", "visited", "renderIcon", "size"];
  var Link$2 = /*#__PURE__*/React__default["default"].forwardRef(function Link(_ref, ref) {
    var _cx;

    var children = _ref.children,
        customClassName = _ref.className,
        href = _ref.href,
        disabled = _ref.disabled,
        inline = _ref.inline,
        visited = _ref.visited,
        Icon = _ref.renderIcon,
        size = _ref.size,
        rest = _objectWithoutProperties$2(_ref, _excluded$2G);

    var prefix = usePrefix();
    var className = cx("".concat(prefix, "--link"), customClassName, (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--link--disabled"), disabled), _defineProperty$2(_cx, "".concat(prefix, "--link--inline"), inline), _defineProperty$2(_cx, "".concat(prefix, "--link--visited"), visited), _defineProperty$2(_cx, "".concat(prefix, "--link--").concat(size), size), _cx));
    var rel = rest.target === '_blank' ? 'noopener' : null;
    var linkProps = {
      className: className,
      rel: rel
    }; // Reference for disabled links:
    // https://www.scottohara.me/blog/2021/05/28/disabled-links.html

    if (!disabled) {
      linkProps.href = href;
    } else {
      linkProps.role = 'link';
      linkProps['aria-disabled'] = true;
    }

    return /*#__PURE__*/React__default["default"].createElement("a", _extends$3({
      ref: ref
    }, linkProps, rest), children, !inline && Icon && /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--link__icon")
    }, /*#__PURE__*/React__default["default"].createElement(Icon, null)));
  });
  Link$2.displayName = 'Link';
  Link$2.propTypes = {
    /**
     * Provide the content for the Link
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide a custom className to be applied to the containing `<a>` node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify if the control should be disabled, or not
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Provide the `href` attribute for the `<a>` node
     */
    href: PropTypes__default["default"].string,

    /**
     * Specify whether you want the inline version of this control
     */
    inline: PropTypes__default["default"].bool,

    /**
     * Optional prop to render an icon next to the link.
     * Can be a React component class
     */
    renderIcon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),

    /**
     * Specify the size of the Link. Currently supports either `sm`, 'md' (default) or 'lg` as an option.
     */
    size: PropTypes__default["default"].oneOf(['sm', 'md', 'lg']),

    /**
     * Specify whether you want the link to receive visited styles after the link has been clicked
     */
    visited: PropTypes__default["default"].bool
  };
  var Link$3 = Link$2;

  var _excluded$2F = ["aria-current", "children", "className", "href", "isCurrentPage"];
  var BreadcrumbItem = /*#__PURE__*/React__default["default"].forwardRef(function BreadcrumbItem(_ref, ref) {
    var _cx;

    var ariaCurrent = _ref['aria-current'],
        children = _ref.children,
        customClassName = _ref.className,
        href = _ref.href,
        isCurrentPage = _ref.isCurrentPage,
        rest = _objectWithoutProperties$2(_ref, _excluded$2F);

    var prefix = usePrefix();
    var className = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--breadcrumb-item"), true), _defineProperty$2(_cx, "".concat(prefix, "--breadcrumb-item--current"), isCurrentPage && ariaCurrent !== 'page'), _defineProperty$2(_cx, customClassName, !!customClassName), _cx));

    if (children.type && children.type.displayName !== undefined && children.type.displayName.includes('OverflowMenu')) {
      var horizontalOverflowIcon = /*#__PURE__*/React__default["default"].createElement(OverflowMenuHorizontal16, {
        className: "".concat(prefix, "--overflow-menu__icon")
      });
      return /*#__PURE__*/React__default["default"].createElement("li", _extends$3({
        className: className
      }, rest), /*#__PURE__*/React__default["default"].cloneElement(children, {
        menuOptionsClass: "".concat(prefix, "--breadcrumb-menu-options"),
        menuOffset: {
          top: 10,
          left: 59
        },
        renderIcon: function renderIcon() {
          return horizontalOverflowIcon;
        }
      }));
    }

    if (typeof children === 'string') {
      return /*#__PURE__*/React__default["default"].createElement("li", _extends$3({
        className: className,
        ref: ref
      }, rest), href ? /*#__PURE__*/React__default["default"].createElement(Link$3, {
        href: href,
        "aria-current": ariaCurrent
      }, children) : /*#__PURE__*/React__default["default"].createElement("span", {
        className: "".concat(prefix, "--link")
      }, children));
    }

    return /*#__PURE__*/React__default["default"].createElement("li", _extends$3({
      className: className,
      ref: ref
    }, rest), /*#__PURE__*/React__default["default"].cloneElement(children, {
      'aria-current': ariaCurrent,
      className: cx("".concat(prefix, "--link"), children.props.className)
    }));
  });
  BreadcrumbItem.displayName = 'BreadcrumbItem';
  BreadcrumbItem.propTypes = {
    'aria-current': PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].bool]),

    /**
     * Pass in content that will be inside of the BreadcrumbItem
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Optional string representing the link location for the BreadcrumbItem
     */
    href: PropTypes__default["default"].string,

    /**
     * Provide if this breadcrumb item represents the current page
     */
    isCurrentPage: PropTypes__default["default"].bool
  };
  var BreadcrumbItem$1 = BreadcrumbItem;

  var _excluded$2E = ["className"];

  function Item() {
    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--breadcrumb-item")
    }, /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--link")
    }, "\xA0"));
  }

  function BreadcrumbSkeleton(_ref) {
    var className = _ref.className,
        rest = _objectWithoutProperties$2(_ref, _excluded$2E);

    var prefix = usePrefix();
    var classes = cx("".concat(prefix, "--breadcrumb"), "".concat(prefix, "--skeleton"), className);
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: classes
    }, rest), /*#__PURE__*/React__default["default"].createElement(Item, null), /*#__PURE__*/React__default["default"].createElement(Item, null), /*#__PURE__*/React__default["default"].createElement(Item, null));
  }

  BreadcrumbSkeleton.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes__default["default"].string
  };

  /**
   * Our FeatureFlagContext is used alongside the FeatureFlags component to enable
   * or disable feature flags in a given React tree
   */

  var FeatureFlagContext = /*#__PURE__*/React.createContext(FeatureFlags$1);
  /**
   * Supports an object of feature flag values with the `flags` prop, merging them
   * along with the current `FeatureFlagContext` to provide consumers to check if
   * a feature flag is enabled or disabled in a given React tree
   */

  function FeatureFlags(_ref) {
    var children = _ref.children,
        _ref$flags = _ref.flags,
        flags = _ref$flags === void 0 ? {} : _ref$flags;
    var parentScope = React.useContext(FeatureFlagContext);

    var _useState = React.useState(parentScope),
        _useState2 = _slicedToArray$1(_useState, 2),
        prevParentScope = _useState2[0],
        setPrevParentScope = _useState2[1];

    var _useState3 = React.useState(function () {
      var scope = createScope(flags);
      scope.mergeWithScope(parentScope);
      return scope;
    }),
        _useState4 = _slicedToArray$1(_useState3, 2),
        scope = _useState4[0],
        updateScope = _useState4[1];

    if (parentScope !== prevParentScope) {
      var _scope = createScope(flags);

      _scope.mergeWithScope(parentScope);

      updateScope(_scope);
      setPrevParentScope(parentScope);
    } // We use a custom hook to detect if any of the keys or their values change
    // for flags that are passed in. If they have changed, then we re-create the
    // FeatureFlagScope using the new flags


    useChangedValue(flags, isEqual$1, function (changedFlags) {
      var scope = createScope(changedFlags);
      scope.mergeWithScope(parentScope);
      updateScope(scope);
    });
    return /*#__PURE__*/React__default["default"].createElement(FeatureFlagContext.Provider, {
      value: scope
    }, children);
  }

  FeatureFlags.propTypes = {
    children: PropTypes__default["default"].node,

    /**
     * Provide the feature flags to enabled or disabled in the current React tree
     */
    flags: PropTypes__default["default"].objectOf(PropTypes__default["default"].bool)
  };
  /**
   * This hook will store previous versions of the given `value` and compare the
   * current value to the previous one using the `compare` function. If the
   * compare function returns true, then the given `callback` is invoked in an
   * effect.
   *
   * @param {any} value
   * @param {Function} compare
   * @param {Function} callback
   */

  function useChangedValue(value, compare, callback) {
    var initialRender = React.useRef(false);
    var savedCallback = React.useRef(callback);

    var _useState5 = React.useState(value),
        _useState6 = _slicedToArray$1(_useState5, 2),
        prevValue = _useState6[0],
        setPrevValue = _useState6[1];

    if (!compare(prevValue, value)) {
      setPrevValue(value);
    }

    React.useEffect(function () {
      savedCallback.current = callback;
    });
    React.useEffect(function () {
      // We only want the callback triggered after the first render
      if (initialRender.current) {
        savedCallback.current(prevValue);
      }
    }, [prevValue]);
    React.useEffect(function () {
      initialRender.current = true;
    }, []);
  }
  /**
   * Access whether a given flag is enabled or disabled in a given
   * FeatureFlagContext
   *
   * @returns {boolean}
   */


  function useFeatureFlag(flag) {
    var scope = React.useContext(FeatureFlagContext);
    return scope.enabled(flag);
  }
  /**
   * Access all feature flag information for the given FeatureFlagContext
   *
   * @returns {FeatureFlagScope}
   */


  function useFeatureFlags() {
    return React.useContext(FeatureFlagContext);
  }
  /**
   * Compare two objects and determine if they are equal. This is a shallow
   * comparison since the objects we are comparing are objects with boolean flags
   * from the flags prop in the `FeatureFlags` component
   *
   * @param {object} a
   * @param {object} b
   * @returns {boolean}
   */


  function isEqual$1(a, b) {
    if (a === b) {
      return true;
    }

    for (var _i = 0, _Object$keys = Object.keys(a); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];

      if (a[key] !== b[key]) {
        return false;
      }
    }

    for (var _i2 = 0, _Object$keys2 = Object.keys(b); _i2 < _Object$keys2.length; _i2++) {
      var _key = _Object$keys2[_i2];

      if (b[_key] !== a[_key]) {
        return false;
      }
    }

    return true;
  }

  var _excluded$2D = ["className", "small", "href", "size"];

  var ButtonSkeleton = function ButtonSkeleton(_ref) {
    var _cx;

    var className = _ref.className,
        _ref$small = _ref.small,
        small = _ref$small === void 0 ? false : _ref$small,
        href = _ref.href,
        _ref$size = _ref.size,
        size = _ref$size === void 0 ? enabled('enable-v11-release') ? 'lg' : 'default' : _ref$size,
        rest = _objectWithoutProperties$2(_ref, _excluded$2D);

    var enabled$1 = useFeatureFlag('enable-v11-release');
    var prefix = usePrefix();
    var buttonClasses = cx(className, (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--skeleton"), true), _defineProperty$2(_cx, "".concat(prefix, "--btn"), true), _defineProperty$2(_cx, "".concat(prefix, "--btn--sm"), small || size === 'sm'), _defineProperty$2(_cx, "".concat(prefix, "--btn--md"), size === 'field' || size === 'md'), _defineProperty$2(_cx, "".concat(prefix, "--btn--lg"), enabled$1 ? size === 'xl' : size === 'lg'), _defineProperty$2(_cx, "".concat(prefix, "--btn--xl"), enabled$1 ? size === '2xl' : size === 'xl'), _cx));

    var commonProps = _objectSpread2$2({
      className: buttonClasses
    }, rest);

    var button = /*#__PURE__*/React__default["default"].createElement("div", commonProps);
    var anchor = /*#__PURE__*/React__default["default"].createElement("a", _extends$3({}, commonProps, {
      href: href,
      role: "button"
    })); // eslint-disable-line

    return href ? anchor : button;
  };

  ButtonSkeleton.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes__default["default"].string,

    /**
     * Optionally specify an href for your Button to become an `<a>` element
     */
    href: PropTypes__default["default"].string,

    /**
     * Specify the size of the button, from a list of available sizes.
     * For `default` buttons, this prop can remain unspecified or use `default`.
     * In the next major release of Carbon, `default`, `field`, and `small` will be removed
     */
    size: enabled('enable-v11-release') ? PropTypes__default["default"].oneOf(['sm', 'md', 'lg', 'xl', '2xl']) : PropTypes__default["default"].oneOf(['default', 'field', 'small', 'sm', 'md', 'lg', 'xl', '2xl']),

    /**
     * Specify whether the Button should be a small variant
     */
    small: PropTypes__default["default"].bool
  };
  var ButtonSkeleton$1 = ButtonSkeleton;

  var ButtonKinds = ['primary', 'secondary', 'danger', 'ghost', 'danger--primary', 'danger--ghost', 'danger--tertiary', 'tertiary'];

  /**
   * Generic utility to compose event handlers so that consumers can supply their
   * own event listeners on table components. The default heuristic here is to
   * iterate through the given functions until `preventDefault` is called on the
   * given event.
   *
   * @param {Array<Function>} fns array of functions to apply to the event
   * @returns {Function}
   */
  var composeEventHandlers = function composeEventHandlers(fns) {
    return function (event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      for (var i = 0; i < fns.length; i++) {
        if (event.defaultPrevented) {
          break;
        }

        if (typeof fns[i] === 'function') {
          fns[i].apply(fns, [event].concat(args));
        }
      }
    };
  };

  function toggleClass$1(element, name, add) {
    if (element.classList.contains(name) === !add) {
      element.classList[add ? 'add' : 'remove'](name);
    }
  }

  var _excluded$2C = ["as", "children", "className", "dangerDescription", "disabled", "hasIconOnly", "href", "iconDescription", "isExpressive", "isSelected", "kind", "onBlur", "onClick", "onFocus", "onMouseEnter", "onMouseLeave", "renderIcon", "size", "small", "tabIndex", "tooltipAlignment", "tooltipPosition", "type"];
  var Button = /*#__PURE__*/React__default["default"].forwardRef(function Button(_ref, ref) {
    var _classNames;

    var as = _ref.as,
        children = _ref.children,
        className = _ref.className,
        _ref$dangerDescriptio = _ref.dangerDescription,
        dangerDescription = _ref$dangerDescriptio === void 0 ? 'danger' : _ref$dangerDescriptio,
        _ref$disabled = _ref.disabled,
        disabled = _ref$disabled === void 0 ? false : _ref$disabled,
        _ref$hasIconOnly = _ref.hasIconOnly,
        hasIconOnly = _ref$hasIconOnly === void 0 ? false : _ref$hasIconOnly,
        href = _ref.href,
        iconDescription = _ref.iconDescription,
        _ref$isExpressive = _ref.isExpressive,
        isExpressive = _ref$isExpressive === void 0 ? false : _ref$isExpressive,
        isSelected = _ref.isSelected,
        _ref$kind = _ref.kind,
        kind = _ref$kind === void 0 ? 'primary' : _ref$kind,
        onBlur = _ref.onBlur,
        onClick = _ref.onClick,
        onFocus = _ref.onFocus,
        onMouseEnter = _ref.onMouseEnter,
        onMouseLeave = _ref.onMouseLeave,
        ButtonImageElement = _ref.renderIcon,
        _ref$size = _ref.size,
        size = _ref$size === void 0 ? enabled('enable-v11-release') ? 'lg' : 'default' : _ref$size,
        small = _ref.small,
        _ref$tabIndex = _ref.tabIndex,
        tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex,
        _ref$tooltipAlignment = _ref.tooltipAlignment,
        tooltipAlignment = _ref$tooltipAlignment === void 0 ? 'center' : _ref$tooltipAlignment,
        _ref$tooltipPosition = _ref.tooltipPosition,
        tooltipPosition = _ref$tooltipPosition === void 0 ? 'top' : _ref$tooltipPosition,
        _ref$type = _ref.type,
        type = _ref$type === void 0 ? 'button' : _ref$type,
        rest = _objectWithoutProperties$2(_ref, _excluded$2C);

    var _useState = React.useState(false),
        _useState2 = _slicedToArray$1(_useState, 2),
        allowTooltipVisibility = _useState2[0],
        setAllowTooltipVisibility = _useState2[1];

    var _useState3 = React.useState(false),
        _useState4 = _slicedToArray$1(_useState3, 2),
        isHovered = _useState4[0],
        setIsHovered = _useState4[1];

    var _useState5 = React.useState(false),
        _useState6 = _slicedToArray$1(_useState5, 2),
        isFocused = _useState6[0],
        setIsFocused = _useState6[1];

    var tooltipRef = React.useRef(null);
    var tooltipTimeout = React.useRef(null);
    var prefix = usePrefix();

    var closeTooltips = function closeTooltips(evt) {
      var _document;

      var tooltipNode = (_document = document) === null || _document === void 0 ? void 0 : _document.querySelectorAll(".".concat(prefix, "--tooltip--a11y"));

      _toConsumableArray(tooltipNode).map(function (node) {
        toggleClass$1(node, "".concat(prefix, "--tooltip--hidden"), node !== evt.currentTarget);
      });
    };

    var handleFocus = function handleFocus(evt) {
      if (hasIconOnly) {
        closeTooltips(evt);
        setIsFocused(true);
        setAllowTooltipVisibility(true);
      }
    };

    var handleBlur = function handleBlur() {
      if (hasIconOnly) {
        setIsHovered(false);
        setIsFocused(false);
        setAllowTooltipVisibility(false);
      }
    };

    var handleMouseEnter = function handleMouseEnter(evt) {
      if (hasIconOnly) {
        tooltipTimeout.current && clearTimeout(tooltipTimeout.current);

        if (evt.target === tooltipRef.current) {
          setAllowTooltipVisibility(true);
          return;
        }

        closeTooltips(evt);
        setAllowTooltipVisibility(true);
      }
    };

    var handleMouseLeave = function handleMouseLeave() {
      if (!isFocused && hasIconOnly) {
        tooltipTimeout.current = setTimeout(function () {
          setAllowTooltipVisibility(false);
          setIsHovered(false);
        }, 100);
      }
    };

    var handleClick = function handleClick(evt) {
      // Prevent clicks on the tooltip from triggering the button click event
      setAllowTooltipVisibility(false);

      if (evt.target === tooltipRef.current) {
        evt.preventDefault();
        return;
      }
    };

    React.useEffect(function () {
      var handleEscKeyDown = function handleEscKeyDown(event) {
        if (matches(event, [Escape])) {
          setAllowTooltipVisibility(false);
          setIsHovered(false);
        }
      };

      document.addEventListener('keydown', handleEscKeyDown);
      return function () {
        return document.removeEventListener('keydown', handleEscKeyDown);
      };
    }, []);
    var enabled$1 = useFeatureFlag('enable-v11-release');
    var buttonClasses = cx(className, (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--btn"), true), _defineProperty$2(_classNames, "".concat(prefix, "--btn--sm"), size === 'small' && !isExpressive || size === 'sm' && !isExpressive || small && !isExpressive), _defineProperty$2(_classNames, "".concat(prefix, "--btn--md"), size === 'field' && !isExpressive || size === 'md' && !isExpressive), _defineProperty$2(_classNames, "".concat(prefix, "--btn--lg"), enabled$1 ? size === 'xl' : size === 'lg'), _defineProperty$2(_classNames, "".concat(prefix, "--btn--xl"), enabled$1 ? size === '2xl' : size === 'xl'), _defineProperty$2(_classNames, "".concat(prefix, "--btn--").concat(kind), kind), _defineProperty$2(_classNames, "".concat(prefix, "--btn--disabled"), disabled), _defineProperty$2(_classNames, "".concat(prefix, "--btn--expressive"), isExpressive), _defineProperty$2(_classNames, "".concat(prefix, "--tooltip--visible"), isHovered), _defineProperty$2(_classNames, "".concat(prefix, "--tooltip--hidden"), hasIconOnly && !allowTooltipVisibility), _defineProperty$2(_classNames, "".concat(prefix, "--btn--icon-only"), hasIconOnly), _defineProperty$2(_classNames, "".concat(prefix, "--btn--selected"), hasIconOnly && isSelected && kind === 'ghost'), _defineProperty$2(_classNames, "".concat(prefix, "--tooltip__trigger"), hasIconOnly), _defineProperty$2(_classNames, "".concat(prefix, "--tooltip--a11y"), hasIconOnly), _defineProperty$2(_classNames, "".concat(prefix, "--btn--icon-only--").concat(tooltipPosition), hasIconOnly && tooltipPosition), _defineProperty$2(_classNames, "".concat(prefix, "--tooltip--align-").concat(tooltipAlignment), hasIconOnly && tooltipAlignment), _classNames));
    var commonProps = {
      tabIndex: tabIndex,
      className: buttonClasses,
      ref: ref
    };
    var buttonImage = !ButtonImageElement ? null : /*#__PURE__*/React__default["default"].createElement(ButtonImageElement, {
      "aria-label": iconDescription,
      className: "".concat(prefix, "--btn__icon"),
      "aria-hidden": "true"
    });
    var dangerButtonVariants = ['danger', 'danger--tertiary', 'danger--ghost'];
    var component = 'button';
    var assistiveId = useId('danger-description');
    var otherProps = {
      disabled: disabled,
      type: type,
      'aria-describedby': dangerButtonVariants.includes(kind) ? assistiveId : null,
      'aria-pressed': hasIconOnly && kind === 'ghost' ? isSelected : null
    };
    var anchorProps = {
      href: href
    };
    var assistiveText;

    if (hasIconOnly) {
      assistiveText = /*#__PURE__*/React__default["default"].createElement("div", {
        ref: tooltipRef,
        onMouseEnter: handleMouseEnter,
        className: "".concat(prefix, "--assistive-text")
      }, iconDescription);
    } else if (dangerButtonVariants.includes(kind)) {
      assistiveText = /*#__PURE__*/React__default["default"].createElement("span", {
        id: assistiveId,
        className: "".concat(prefix, "--visually-hidden")
      }, dangerDescription);
    } else {
      assistiveText = null;
    }

    if (as) {
      component = as;
      otherProps = _objectSpread2$2(_objectSpread2$2({}, otherProps), anchorProps);
    } else if (href && !disabled) {
      component = 'a';
      otherProps = anchorProps;
    }

    return /*#__PURE__*/React__default["default"].createElement(component, _objectSpread2$2(_objectSpread2$2(_objectSpread2$2({
      onMouseEnter: composeEventHandlers([onMouseEnter, handleMouseEnter]),
      onMouseLeave: composeEventHandlers([onMouseLeave, handleMouseLeave]),
      onFocus: composeEventHandlers([onFocus, handleFocus]),
      onBlur: composeEventHandlers([onBlur, handleBlur]),
      onClick: composeEventHandlers([onClick, handleClick])
    }, rest), commonProps), otherProps), assistiveText, children, buttonImage);
  });
  Button.displayName = 'Button';
  Button.propTypes = {
    /**
     * Specify how the button itself should be rendered.
     * Make sure to apply all props to the root node and render children appropriately
     */
    as: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].string, PropTypes__default["default"].elementType]),

    /**
     * Specify the content of your Button
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be added to your Button
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the message read by screen readers for the danger button variant
     */
    dangerDescription: PropTypes__default["default"].string,

    /**
     * Specify whether the Button should be disabled, or not
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Specify if the button is an icon-only button
     */
    hasIconOnly: PropTypes__default["default"].bool,

    /**
     * Optionally specify an href for your Button to become an `<a>` element
     */
    href: PropTypes__default["default"].string,

    /**
     * If specifying the `renderIcon` prop, provide a description for that icon that can
     * be read by screen readers
     */
    iconDescription: function iconDescription(props) {
      if (props.renderIcon && !props.children && !props.iconDescription) {
        return new Error('renderIcon property specified without also providing an iconDescription property.');
      }

      return undefined;
    },

    /**
     * Specify whether the Button is expressive, or not
     */
    isExpressive: PropTypes__default["default"].bool,

    /**
     * Specify whether the Button is currently selected. Only applies to the Ghost variant.
     */
    isSelected: PropTypes__default["default"].bool,

    /**
     * Specify the kind of Button you want to create
     */
    kind: PropTypes__default["default"].oneOf(ButtonKinds),

    /**
     * Provide an optional function to be called when the button element
     * loses focus
     */
    onBlur: PropTypes__default["default"].func,

    /**
     * Provide an optional function to be called when the button element
     * is clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Provide an optional function to be called when the button element
     * receives focus
     */
    onFocus: PropTypes__default["default"].func,

    /**
     * Provide an optional function to be called when the mouse
     * enters the button element
     */
    onMouseEnter: PropTypes__default["default"].func,

    /**
     * Provide an optional function to be called when the mouse
     * leaves the button element
     */
    onMouseLeave: PropTypes__default["default"].func,

    /**
     * Optional prop to allow overriding the icon rendering.
     * Can be a React component class
     */
    renderIcon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),

    /**
     * Optional prop to specify the role of the Button
     */
    role: PropTypes__default["default"].string,

    /**
     * Specify the size of the button, from the following list of sizes:
     */
    size: enabled('enable-v11-release') ? PropTypes__default["default"].oneOf(['sm', 'md', 'lg', 'xl', '2xl']) : PropTypes__default["default"].oneOf(['default', 'field', 'small', 'sm', 'md', 'lg', 'xl', '2xl']),

    /**
     * Deprecated in v10 in favor of `size`.
     * Specify whether the Button should be a small variant
     */
    small: deprecate(PropTypes__default["default"].bool, "\nThe prop `small` for Button has been deprecated in favor of `size`. Please use `size=\"sm\"` instead."),

    /**
     * Optional prop to specify the tabIndex of the Button
     */
    tabIndex: PropTypes__default["default"].number,

    /**
     * Specify the alignment of the tooltip to the icon-only button.
     * Can be one of: start, center, or end.
     */
    tooltipAlignment: PropTypes__default["default"].oneOf(['start', 'center', 'end']),

    /**
     * Specify the direction of the tooltip for icon-only buttons.
     * Can be either top, right, bottom, or left.
     */
    tooltipPosition: PropTypes__default["default"].oneOf(['top', 'right', 'bottom', 'left']),

    /**
     * Optional prop to specify the type of the Button
     */
    type: PropTypes__default["default"].oneOf(['button', 'reset', 'submit'])
  };
  var Button$1 = Button;

  var _excluded$2B = ["children", "className", "stacked"];
  var ButtonSet = /*#__PURE__*/React__default["default"].forwardRef(function ButtonSet(_ref, ref) {
    var children = _ref.children,
        className = _ref.className,
        stacked = _ref.stacked,
        rest = _objectWithoutProperties$2(_ref, _excluded$2B);

    var prefix = usePrefix();
    var buttonSetClasses = cx(className, "".concat(prefix, "--btn-set"), _defineProperty$2({}, "".concat(prefix, "--btn-set--stacked"), stacked));
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({}, rest, {
      className: buttonSetClasses,
      ref: ref
    }), children);
  });
  ButtonSet.displayName = 'ButtonSet';
  ButtonSet.propTypes = {
    /**
     * Specify the content of your ButtonSet
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be added to your ButtonSet
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the button arrangement of the set (vertically stacked or
     * horizontal)
     */
    stacked: PropTypes__default["default"].bool
  };
  var ButtonSet$1 = ButtonSet;

  var _excluded$2A = ["className"];

  var CheckboxSkeleton = function CheckboxSkeleton(_ref) {
    var className = _ref.className,
        rest = _objectWithoutProperties$2(_ref, _excluded$2A);

    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: cx("".concat(prefix, "--form-item"), "".concat(prefix, "--checkbox-wrapper"), "".concat(prefix, "--checkbox-label"), className)
    }, rest), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--checkbox-label-text ").concat(prefix, "--skeleton")
    }));
  };

  CheckboxSkeleton.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes__default["default"].string
  };
  var CheckboxSkeleton$1 = CheckboxSkeleton;

  var _excluded$2z = ["className", "id", "labelText", "onChange", "indeterminate", "hideLabel", "wrapperClassName", "title"];
  var Checkbox = /*#__PURE__*/React__default["default"].forwardRef(function Checkbox(_ref, _ref2) {
    var className = _ref.className,
        id = _ref.id,
        labelText = _ref.labelText,
        _onChange = _ref.onChange,
        indeterminate = _ref.indeterminate,
        hideLabel = _ref.hideLabel,
        wrapperClassName = _ref.wrapperClassName,
        _ref$title = _ref.title,
        title = _ref$title === void 0 ? '' : _ref$title,
        other = _objectWithoutProperties$2(_ref, _excluded$2z);

    var enabled = useFeatureFlag('enable-v11-release');
    var prefix = usePrefix();
    var labelClasses = cx("".concat(prefix, "--checkbox-label"), [enabled ? null : className]);
    var innerLabelClasses = cx("".concat(prefix, "--checkbox-label-text"), _defineProperty$2({}, "".concat(prefix, "--visually-hidden"), hideLabel));
    var wrapperClasses = cx("".concat(prefix, "--form-item"), "".concat(prefix, "--checkbox-wrapper"), [enabled ? className : wrapperClassName]);
    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: wrapperClasses
    }, /*#__PURE__*/React__default["default"].createElement("input", _extends$3({}, other, {
      type: "checkbox",
      onChange: function onChange(evt) {
        if (enabled) {
          _onChange(evt, {
            checked: evt.target.checked,
            id: id
          });
        } else {
          _onChange(evt.target.checked, id, evt);
        }
      },
      className: "".concat(prefix, "--checkbox"),
      id: id,
      ref: function ref(el) {
        if (el) {
          el.indeterminate = indeterminate;
        }

        if (typeof _ref2 === 'function') {
          _ref2(el);
        } else if (Object(_ref2) === _ref2) {
          _ref2.current = el;
        }
      }
    })), /*#__PURE__*/React__default["default"].createElement("label", {
      htmlFor: id,
      className: labelClasses,
      title: title || null
    }, /*#__PURE__*/React__default["default"].createElement(Text, {
      className: innerLabelClasses
    }, labelText)));
  });
  Checkbox.propTypes = {
    /**
     * Specify whether the underlying input should be checked
     */
    checked: PropTypes__default["default"].bool,

    /**
     * Specify an optional className to be applied to the <label> node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the underlying input should be checked by default
     */
    defaultChecked: PropTypes__default["default"].bool,

    /**
     * Specify whether the Checkbox should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Specify whether the label should be hidden, or not
     */
    hideLabel: PropTypes__default["default"].bool,

    /**
     * Provide an `id` to uniquely identify the Checkbox input
     */
    id: PropTypes__default["default"].string.isRequired,

    /**
     * Specify whether the Checkbox is in an indeterminate state
     */
    indeterminate: PropTypes__default["default"].bool,

    /**
     * Provide a label to provide a description of the Checkbox input that you are
     * exposing to the user
     */
    labelText: PropTypes__default["default"].node.isRequired,

    /**
     * Receives three arguments: true/false, the checkbox's id, and the dom event.
     * `(value, id, event) => console.log({value, id, event})`
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Specify a title for the <label> node for the Checkbox
     */
    title: PropTypes__default["default"].string,

    /**
     * The CSS class name to be placed on the wrapping element
     */
    wrapperClassName: deprecate(PropTypes__default["default"].string, "\nThe prop `wrapperClassName` for Checkbox will be deprecated in V11 in favor of `className`. `className` will then be placed on the outer wrapper.")
  };
  Checkbox.defaultProps = {
    onChange: function onChange() {},
    indeterminate: false
  };
  Checkbox.displayName = 'Checkbox';
  var Checkbox$1 = Checkbox;

  var _excluded$2y = ["className", "type"];

  function CodeSnippetSkeleton(_ref) {
    var _cx;

    var containerClassName = _ref.className,
        _ref$type = _ref.type,
        type = _ref$type === void 0 ? 'single' : _ref$type,
        rest = _objectWithoutProperties$2(_ref, _excluded$2y);

    var prefix = usePrefix();
    var className = cx(containerClassName, (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--snippet"), true), _defineProperty$2(_cx, "".concat(prefix, "--skeleton"), true), _defineProperty$2(_cx, "".concat(prefix, "--snippet--single"), type === 'single'), _defineProperty$2(_cx, "".concat(prefix, "--snippet--multi"), type === 'multi'), _cx));

    if (type === 'single') {
      return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
        className: className
      }, rest), /*#__PURE__*/React__default["default"].createElement("div", {
        className: "".concat(prefix, "--snippet-container")
      }, /*#__PURE__*/React__default["default"].createElement("span", null)));
    }

    if (type === 'multi') {
      return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
        className: className
      }, rest), /*#__PURE__*/React__default["default"].createElement("div", {
        className: "".concat(prefix, "--snippet-container")
      }, /*#__PURE__*/React__default["default"].createElement("span", null), /*#__PURE__*/React__default["default"].createElement("span", null), /*#__PURE__*/React__default["default"].createElement("span", null)));
    }
  }

  CodeSnippetSkeleton.propTypes = {
    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * The type of the code snippet, including single or multi
     */
    type: PropTypes__default["default"].oneOf(['single', 'multi'])
  };

  /* eslint-disable require-jsdoc, valid-jsdoc */
  var MapShim = function () {
    if (typeof Map !== 'undefined') {
      return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */


    function getIndex(arr, key) {
      var result = -1;
      arr.some(function (entry, index) {
        if (entry[0] === key) {
          result = index;
          return true;
        }

        return false;
      });
      return result;
    }

    return (
      /** @class */
      function () {
        function class_1() {
          this.__entries__ = [];
        }

        Object.defineProperty(class_1.prototype, "size", {
          /**
           * @returns {boolean}
           */
          get: function get() {
            return this.__entries__.length;
          },
          enumerable: true,
          configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */

        class_1.prototype.get = function (key) {
          var index = getIndex(this.__entries__, key);
          var entry = this.__entries__[index];
          return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */


        class_1.prototype.set = function (key, value) {
          var index = getIndex(this.__entries__, key);

          if (~index) {
            this.__entries__[index][1] = value;
          } else {
            this.__entries__.push([key, value]);
          }
        };
        /**
         * @param {*} key
         * @returns {void}
         */


        class_1.prototype.delete = function (key) {
          var entries = this.__entries__;
          var index = getIndex(entries, key);

          if (~index) {
            entries.splice(index, 1);
          }
        };
        /**
         * @param {*} key
         * @returns {void}
         */


        class_1.prototype.has = function (key) {
          return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */


        class_1.prototype.clear = function () {
          this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */


        class_1.prototype.forEach = function (callback, ctx) {
          if (ctx === void 0) {
            ctx = null;
          }

          for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
            var entry = _a[_i];
            callback.call(ctx, entry[1], entry[0]);
          }
        };

        return class_1;
      }()
    );
  }();
  /**
   * Detects whether window and document objects are available in current environment.
   */


  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document; // Returns global object of a current environment.

  var global$1 = function () {
    if (typeof global !== 'undefined' && global.Math === Math) {
      return global;
    }

    if (typeof self !== 'undefined' && self.Math === Math) {
      return self;
    }

    if (typeof window !== 'undefined' && window.Math === Math) {
      return window;
    } // eslint-disable-next-line no-new-func


    return Function('return this')();
  }();
  /**
   * A shim for the requestAnimationFrame which falls back to the setTimeout if
   * first one is not supported.
   *
   * @returns {number} Requests' identifier.
   */


  var requestAnimationFrame$1 = function () {
    if (typeof requestAnimationFrame === 'function') {
      // It's required to use a bounded function because IE sometimes throws
      // an "Invalid calling object" error if rAF is invoked without the global
      // object on the left hand side.
      return requestAnimationFrame.bind(global$1);
    }

    return function (callback) {
      return setTimeout(function () {
        return callback(Date.now());
      }, 1000 / 60);
    };
  }(); // Defines minimum timeout before adding a trailing call.


  var trailingTimeout = 2;
  /**
   * Creates a wrapper function which ensures that provided callback will be
   * invoked only once during the specified delay period.
   *
   * @param {Function} callback - Function to be invoked after the delay period.
   * @param {number} delay - Delay after which to invoke callback.
   * @returns {Function}
   */

  function throttle$1(callback, delay) {
    var leadingCall = false,
        trailingCall = false,
        lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */

    function resolvePending() {
      if (leadingCall) {
        leadingCall = false;
        callback();
      }

      if (trailingCall) {
        proxy();
      }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */


    function timeoutCallback() {
      requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */


    function proxy() {
      var timeStamp = Date.now();

      if (leadingCall) {
        // Reject immediately following calls.
        if (timeStamp - lastCallTime < trailingTimeout) {
          return;
        } // Schedule new call to be in invoked when the pending one is resolved.
        // This is important for "transitions" which never actually start
        // immediately so there is a chance that we might miss one if change
        // happens amids the pending invocation.


        trailingCall = true;
      } else {
        leadingCall = true;
        trailingCall = false;
        setTimeout(timeoutCallback, delay);
      }

      lastCallTime = timeStamp;
    }

    return proxy;
  } // Minimum delay before invoking the update of observers.


  var REFRESH_DELAY = 20; // A list of substrings of CSS properties used to find transition events that
  // might affect dimensions of observed elements.

  var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight']; // Check if MutationObserver is available.

  var mutationObserverSupported = typeof MutationObserver !== 'undefined';
  /**
   * Singleton controller class which handles updates of ResizeObserver instances.
   */

  var ResizeObserverController =
  /** @class */
  function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
      /**
       * Indicates whether DOM listeners have been added.
       *
       * @private {boolean}
       */
      this.connected_ = false;
      /**
       * Tells that controller has subscribed for Mutation Events.
       *
       * @private {boolean}
       */

      this.mutationEventsAdded_ = false;
      /**
       * Keeps reference to the instance of MutationObserver.
       *
       * @private {MutationObserver}
       */

      this.mutationsObserver_ = null;
      /**
       * A list of connected observers.
       *
       * @private {Array<ResizeObserverSPI>}
       */

      this.observers_ = [];
      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
      this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */


    ResizeObserverController.prototype.addObserver = function (observer) {
      if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
      } // Add listeners if they haven't been added yet.


      if (!this.connected_) {
        this.connect_();
      }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */


    ResizeObserverController.prototype.removeObserver = function (observer) {
      var observers = this.observers_;
      var index = observers.indexOf(observer); // Remove observer if it's present in registry.

      if (~index) {
        observers.splice(index, 1);
      } // Remove listeners if controller has no connected observers.


      if (!observers.length && this.connected_) {
        this.disconnect_();
      }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */


    ResizeObserverController.prototype.refresh = function () {
      var changesDetected = this.updateObservers_(); // Continue running updates if changes have been detected as there might
      // be future ones caused by CSS transitions.

      if (changesDetected) {
        this.refresh();
      }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */


    ResizeObserverController.prototype.updateObservers_ = function () {
      // Collect observers that have active observations.
      var activeObservers = this.observers_.filter(function (observer) {
        return observer.gatherActive(), observer.hasActive();
      }); // Deliver notifications in a separate cycle in order to avoid any
      // collisions between observers, e.g. when multiple instances of
      // ResizeObserver are tracking the same element and the callback of one
      // of them changes content dimensions of the observed target. Sometimes
      // this may result in notifications being blocked for the rest of observers.

      activeObservers.forEach(function (observer) {
        return observer.broadcastActive();
      });
      return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */


    ResizeObserverController.prototype.connect_ = function () {
      // Do nothing if running in a non-browser environment or if listeners
      // have been already added.
      if (!isBrowser || this.connected_) {
        return;
      } // Subscription to the "Transitionend" event is used as a workaround for
      // delayed transitions. This way it's possible to capture at least the
      // final state of an element.


      document.addEventListener('transitionend', this.onTransitionEnd_);
      window.addEventListener('resize', this.refresh);

      if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        this.mutationsObserver_.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      } else {
        document.addEventListener('DOMSubtreeModified', this.refresh);
        this.mutationEventsAdded_ = true;
      }

      this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */


    ResizeObserverController.prototype.disconnect_ = function () {
      // Do nothing if running in a non-browser environment or if listeners
      // have been already removed.
      if (!isBrowser || !this.connected_) {
        return;
      }

      document.removeEventListener('transitionend', this.onTransitionEnd_);
      window.removeEventListener('resize', this.refresh);

      if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
      }

      if (this.mutationEventsAdded_) {
        document.removeEventListener('DOMSubtreeModified', this.refresh);
      }

      this.mutationsObserver_ = null;
      this.mutationEventsAdded_ = false;
      this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */


    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
      var _b = _a.propertyName,
          propertyName = _b === void 0 ? '' : _b; // Detect whether transition may affect dimensions of an element.

      var isReflowProperty = transitionKeys.some(function (key) {
        return !!~propertyName.indexOf(key);
      });

      if (isReflowProperty) {
        this.refresh();
      }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */


    ResizeObserverController.getInstance = function () {
      if (!this.instance_) {
        this.instance_ = new ResizeObserverController();
      }

      return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */


    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
  }();
  /**
   * Defines non-writable/enumerable properties of the provided target object.
   *
   * @param {Object} target - Object for which to define properties.
   * @param {Object} props - Properties to be defined.
   * @returns {Object} Target object.
   */


  var defineConfigurable = function defineConfigurable(target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
      var key = _a[_i];
      Object.defineProperty(target, key, {
        value: props[key],
        enumerable: false,
        writable: false,
        configurable: true
      });
    }

    return target;
  };
  /**
   * Returns the global object associated with provided element.
   *
   * @param {Object} target
   * @returns {Object}
   */


  var getWindowOf = function getWindowOf(target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView; // Return the local global object if it's not possible extract one from
    // provided element.

    return ownerGlobal || global$1;
  }; // Placeholder of an empty content rectangle.


  var emptyRect = createRectInit(0, 0, 0, 0);
  /**
   * Converts provided string to a number.
   *
   * @param {number|string} value
   * @returns {number}
   */

  function toFloat(value) {
    return parseFloat(value) || 0;
  }
  /**
   * Extracts borders size from provided styles.
   *
   * @param {CSSStyleDeclaration} styles
   * @param {...string} positions - Borders positions (top, right, ...)
   * @returns {number}
   */


  function getBordersSize(styles) {
    var positions = [];

    for (var _i = 1; _i < arguments.length; _i++) {
      positions[_i - 1] = arguments[_i];
    }

    return positions.reduce(function (size, position) {
      var value = styles['border-' + position + '-width'];
      return size + toFloat(value);
    }, 0);
  }
  /**
   * Extracts paddings sizes from provided styles.
   *
   * @param {CSSStyleDeclaration} styles
   * @returns {Object} Paddings box.
   */


  function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};

    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
      var position = positions_1[_i];
      var value = styles['padding-' + position];
      paddings[position] = toFloat(value);
    }

    return paddings;
  }
  /**
   * Calculates content rectangle of provided SVG element.
   *
   * @param {SVGGraphicsElement} target - Element content rectangle of which needs
   *      to be calculated.
   * @returns {DOMRectInit}
   */


  function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
  }
  /**
   * Calculates content rectangle of provided HTMLElement.
   *
   * @param {HTMLElement} target - Element for which to calculate the content rectangle.
   * @returns {DOMRectInit}
   */


  function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth,
        clientHeight = target.clientHeight; // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.

    if (!clientWidth && !clientHeight) {
      return emptyRect;
    }

    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom; // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.

    var width = toFloat(styles.width),
        height = toFloat(styles.height); // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).

    if (styles.boxSizing === 'border-box') {
      // Following conditions are required to handle Internet Explorer which
      // doesn't include paddings and borders to computed CSS dimensions.
      //
      // We can say that if CSS dimensions + paddings are equal to the "client"
      // properties then it's either IE, and thus we don't need to subtract
      // anything, or an element merely doesn't have paddings/borders styles.
      if (Math.round(width + horizPad) !== clientWidth) {
        width -= getBordersSize(styles, 'left', 'right') + horizPad;
      }

      if (Math.round(height + vertPad) !== clientHeight) {
        height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
      }
    } // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.


    if (!isDocumentElement(target)) {
      // In some browsers (only in Firefox, actually) CSS width & height
      // include scroll bars size which can be removed at this step as scroll
      // bars are the only difference between rounded dimensions + paddings
      // and "client" properties, though that is not always true in Chrome.
      var vertScrollbar = Math.round(width + horizPad) - clientWidth;
      var horizScrollbar = Math.round(height + vertPad) - clientHeight; // Chrome has a rather weird rounding of "client" properties.
      // E.g. for an element with content width of 314.2px it sometimes gives
      // the client width of 315px and for the width of 314.7px it may give
      // 314px. And it doesn't happen all the time. So just ignore this delta
      // as a non-relevant.

      if (Math.abs(vertScrollbar) !== 1) {
        width -= vertScrollbar;
      }

      if (Math.abs(horizScrollbar) !== 1) {
        height -= horizScrollbar;
      }
    }

    return createRectInit(paddings.left, paddings.top, width, height);
  }
  /**
   * Checks whether provided element is an instance of the SVGGraphicsElement.
   *
   * @param {Element} target - Element to be checked.
   * @returns {boolean}
   */


  var isSVGGraphicsElement = function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
      return function (target) {
        return target instanceof getWindowOf(target).SVGGraphicsElement;
      };
    } // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens


    return function (target) {
      return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function';
    };
  }();
  /**
   * Checks whether provided element is a document element (<html>).
   *
   * @param {Element} target - Element to be checked.
   * @returns {boolean}
   */


  function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
  }
  /**
   * Calculates an appropriate content rectangle for provided html or svg element.
   *
   * @param {Element} target - Element content rectangle of which needs to be calculated.
   * @returns {DOMRectInit}
   */


  function getContentRect(target) {
    if (!isBrowser) {
      return emptyRect;
    }

    if (isSVGGraphicsElement(target)) {
      return getSVGContentRect(target);
    }

    return getHTMLElementContentRect(target);
  }
  /**
   * Creates rectangle with an interface of the DOMRectReadOnly.
   * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
   *
   * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
   * @returns {DOMRectReadOnly}
   */


  function createReadOnlyRect(_a) {
    var x = _a.x,
        y = _a.y,
        width = _a.width,
        height = _a.height; // If DOMRectReadOnly is available use it as a prototype for the rectangle.

    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype); // Rectangle's properties are not writable and non-enumerable.

    defineConfigurable(rect, {
      x: x,
      y: y,
      width: width,
      height: height,
      top: y,
      right: x + width,
      bottom: height + y,
      left: x
    });
    return rect;
  }
  /**
   * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
   * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
   *
   * @param {number} x - X coordinate.
   * @param {number} y - Y coordinate.
   * @param {number} width - Rectangle's width.
   * @param {number} height - Rectangle's height.
   * @returns {DOMRectInit}
   */


  function createRectInit(x, y, width, height) {
    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  }
  /**
   * Class that is responsible for computations of the content rectangle of
   * provided DOM element and for keeping track of it's changes.
   */


  var ResizeObservation =
  /** @class */
  function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
      /**
       * Broadcasted width of content rectangle.
       *
       * @type {number}
       */
      this.broadcastWidth = 0;
      /**
       * Broadcasted height of content rectangle.
       *
       * @type {number}
       */

      this.broadcastHeight = 0;
      /**
       * Reference to the last observed content rectangle.
       *
       * @private {DOMRectInit}
       */

      this.contentRect_ = createRectInit(0, 0, 0, 0);
      this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */


    ResizeObservation.prototype.isActive = function () {
      var rect = getContentRect(this.target);
      this.contentRect_ = rect;
      return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */


    ResizeObservation.prototype.broadcastRect = function () {
      var rect = this.contentRect_;
      this.broadcastWidth = rect.width;
      this.broadcastHeight = rect.height;
      return rect;
    };

    return ResizeObservation;
  }();

  var ResizeObserverEntry =
  /** @class */
  function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
      var contentRect = createReadOnlyRect(rectInit); // According to the specification following properties are not writable
      // and are also not enumerable in the native implementation.
      //
      // Property accessors are not being used as they'd require to define a
      // private WeakMap storage which may cause memory leaks in browsers that
      // don't support this type of collections.

      defineConfigurable(this, {
        target: target,
        contentRect: contentRect
      });
    }

    return ResizeObserverEntry;
  }();

  var ResizeObserverSPI =
  /** @class */
  function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
      /**
       * Collection of resize observations that have detected changes in dimensions
       * of elements.
       *
       * @private {Array<ResizeObservation>}
       */
      this.activeObservations_ = [];
      /**
       * Registry of the ResizeObservation instances.
       *
       * @private {Map<Element, ResizeObservation>}
       */

      this.observations_ = new MapShim();

      if (typeof callback !== 'function') {
        throw new TypeError('The callback provided as parameter 1 is not a function.');
      }

      this.callback_ = callback;
      this.controller_ = controller;
      this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */


    ResizeObserverSPI.prototype.observe = function (target) {
      if (!arguments.length) {
        throw new TypeError('1 argument required, but only 0 present.');
      } // Do nothing if current environment doesn't have the Element interface.


      if (typeof Element === 'undefined' || !(Element instanceof Object)) {
        return;
      }

      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }

      var observations = this.observations_; // Do nothing if element is already being observed.

      if (observations.has(target)) {
        return;
      }

      observations.set(target, new ResizeObservation(target));
      this.controller_.addObserver(this); // Force the update of observations.

      this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */


    ResizeObserverSPI.prototype.unobserve = function (target) {
      if (!arguments.length) {
        throw new TypeError('1 argument required, but only 0 present.');
      } // Do nothing if current environment doesn't have the Element interface.


      if (typeof Element === 'undefined' || !(Element instanceof Object)) {
        return;
      }

      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }

      var observations = this.observations_; // Do nothing if element is not being observed.

      if (!observations.has(target)) {
        return;
      }

      observations.delete(target);

      if (!observations.size) {
        this.controller_.removeObserver(this);
      }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */


    ResizeObserverSPI.prototype.disconnect = function () {
      this.clearActive();
      this.observations_.clear();
      this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */


    ResizeObserverSPI.prototype.gatherActive = function () {
      var _this = this;

      this.clearActive();
      this.observations_.forEach(function (observation) {
        if (observation.isActive()) {
          _this.activeObservations_.push(observation);
        }
      });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */


    ResizeObserverSPI.prototype.broadcastActive = function () {
      // Do nothing if observer doesn't have active observations.
      if (!this.hasActive()) {
        return;
      }

      var ctx = this.callbackCtx_; // Create ResizeObserverEntry instance for every active observation.

      var entries = this.activeObservations_.map(function (observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
      });
      this.callback_.call(ctx, entries, ctx);
      this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */


    ResizeObserverSPI.prototype.clearActive = function () {
      this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */


    ResizeObserverSPI.prototype.hasActive = function () {
      return this.activeObservations_.length > 0;
    };

    return ResizeObserverSPI;
  }(); // Registry of internal observers. If WeakMap is not available use current shim
  // for the Map collection as it has all required methods and because WeakMap
  // can't be fully polyfilled anyway.


  var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
  /**
   * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
   * exposing only those methods and properties that are defined in the spec.
   */

  var ResizeObserver$2 =
  /** @class */
  function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
      if (!(this instanceof ResizeObserver)) {
        throw new TypeError('Cannot call a class as a function.');
      }

      if (!arguments.length) {
        throw new TypeError('1 argument required, but only 0 present.');
      }

      var controller = ResizeObserverController.getInstance();
      var observer = new ResizeObserverSPI(callback, controller, this);
      observers.set(this, observer);
    }

    return ResizeObserver;
  }(); // Expose public methods of ResizeObserver.


  ['observe', 'unobserve', 'disconnect'].forEach(function (method) {
    ResizeObserver$2.prototype[method] = function () {
      var _a;

      return (_a = observers.get(this))[method].apply(_a, arguments);
    };
  });

  var index$4 = function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
      return global$1.ResizeObserver;
    }

    return ResizeObserver$2;
  }();

  var ResizeObserver_es = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': index$4
  });

  var require$$0 = /*@__PURE__*/getAugmentedNamespace(ResizeObserver_es);

  function _interopDefault$1(ex) {
    return ex && _typeof(ex) === 'object' && 'default' in ex ? ex['default'] : ex;
  }

  var ResizeObserver$1 = _interopDefault$1(require$$0);

  var react = React__default["default"];

  function _extends$1() {
    _extends$1 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$1.apply(this, arguments);
  }

  function index$3(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        ref = _ref.ref,
        onResize = _ref.onResize; // `defaultRef` Has to be non-conditionally declared here whether or not it'll
    // be used as that's how hooks work.
    // @see https://reactjs.org/docs/hooks-rules.html#explanation


    var defaultRef = react.useRef(null);
    ref = ref || defaultRef;

    var _useState = react.useState({
      width: undefined,
      height: undefined
    }),
        size = _useState[0],
        setSize = _useState[1]; // Using a ref to track the previous width / height to avoid unnecessary renders


    var previous = react.useRef({
      width: undefined,
      height: undefined
    });
    react.useEffect(function () {
      if (_typeof(ref) !== "object" || ref === null || !(ref.current instanceof Element)) {
        return;
      }

      var element = ref.current;
      var resizeObserver = new ResizeObserver$1(function (entries) {
        if (!Array.isArray(entries)) {
          return;
        } // Since we only observe the one element, we don't need to loop over the
        // array


        if (!entries.length) {
          return;
        }

        var entry = entries[0]; // `Math.round` is in line with how CSS resolves sub-pixel values

        var newWidth = Math.round(entry.contentRect.width);
        var newHeight = Math.round(entry.contentRect.height);

        if (previous.current.width !== newWidth || previous.current.height !== newHeight) {
          var newSize = {
            width: newWidth,
            height: newHeight
          };

          if (onResize) {
            onResize(newSize);
          } else {
            previous.current.width = newWidth;
            previous.current.height = newHeight;
            setSize(newSize);
          }
        }
      });
      resizeObserver.observe(element);
      return function () {
        return resizeObserver.unobserve(element);
      };
    }, [ref, onResize]);
    return react.useMemo(function () {
      return _extends$1({
        ref: ref
      }, size);
    }, [ref, size ? size.width : null, size ? size.height : null]);
  }

  var polyfilled = index$3;
  var useResizeObserver = polyfilled;

  var _excluded$2x = ["children", "className", "feedback", "feedbackTimeout", "onAnimationEnd", "onClick"];
  function Copy(_ref) {
    var _classnames;

    var children = _ref.children,
        className = _ref.className,
        feedback = _ref.feedback,
        feedbackTimeout = _ref.feedbackTimeout,
        onAnimationEnd = _ref.onAnimationEnd,
        onClick = _ref.onClick,
        other = _objectWithoutProperties$2(_ref, _excluded$2x);

    var _useState = React.useState(''),
        _useState2 = _slicedToArray$1(_useState, 2),
        animation = _useState2[0],
        setAnimation = _useState2[1];

    var prefix = usePrefix();
    var classNames = cx(className, "".concat(prefix, "--copy"), (_classnames = {}, _defineProperty$2(_classnames, "".concat(prefix, "--copy-btn--animating"), animation), _defineProperty$2(_classnames, "".concat(prefix, "--copy-btn--").concat(animation), animation), _classnames)); // eslint-disable-next-line react-hooks/exhaustive-deps

    var handleFadeOut = React.useCallback(debounce$4(function () {
      setAnimation('fade-out');
    }, feedbackTimeout), [feedbackTimeout]);
    var handleClick = React.useCallback(function () {
      setAnimation('fade-in');
      handleFadeOut();
    }, [handleFadeOut]);

    var handleAnimationEnd = function handleAnimationEnd(event) {
      if (event.animationName === 'hide-feedback') {
        setAnimation('');
      }
    };

    React.useEffect(function () {
      return function () {
        handleFadeOut.cancel();
      };
    }, [handleFadeOut]);
    return /*#__PURE__*/React__default["default"].createElement("button", _extends$3({
      type: "button",
      className: classNames,
      onClick: composeEventHandlers([onClick, handleClick]),
      onAnimationEnd: composeEventHandlers([onAnimationEnd, handleAnimationEnd])
    }, other, {
      "aria-live": "polite",
      "aria-label": !children && (animation ? feedback : other['aria-label']) || null
    }), children, animation ? feedback : other['aria-label'], /*#__PURE__*/React__default["default"].createElement("span", {
      "aria-hidden": "true",
      className: "".concat(prefix, "--assistive-text ").concat(prefix, "--copy-btn__feedback")
    }, feedback));
  }
  Copy.propTypes = {
    /**
     * Pass in content to be rendered in the underlying `<button>`
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the underlying `<button>`
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the string that is displayed when the button is clicked and the
     * content is copied
     */
    feedback: PropTypes__default["default"].string,

    /**
     * Specify the time it takes for the feedback message to timeout
     */
    feedbackTimeout: PropTypes__default["default"].number,

    /**
     * Specify an optional `onAnimationEnd` handler that is called when the underlying
     * animation ends
     */
    onAnimationEnd: PropTypes__default["default"].func,

    /**
     * Specify an optional `onClick` handler that is called when the underlying
     * `<button>` is clicked
     */
    onClick: PropTypes__default["default"].func
  };
  Copy.defaultProps = {
    feedback: 'Copied!',
    feedbackTimeout: 2000,
    onClick: function onClick() {}
  };

  var _excluded$2w = ["iconDescription", "className"];
  function CopyButton(_ref) {
    var iconDescription = _ref.iconDescription,
        className = _ref.className,
        other = _objectWithoutProperties$2(_ref, _excluded$2w);

    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement(Copy, _extends$3({
      className: cx(className, "".concat(prefix, "--copy-btn")),
      "aria-label": iconDescription,
      title: iconDescription
    }, other), /*#__PURE__*/React__default["default"].createElement(Copy16, {
      className: "".concat(prefix, "--snippet__icon")
    }));
  }
  CopyButton.propTypes = {
    /**
     * Specify an optional className to be applied to the underlying `<button>`
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the string that is displayed when the button is clicked and the
     * content is copied
     */
    feedback: PropTypes__default["default"].string,

    /**
     * Specify the time it takes for the feedback message to timeout
     */
    feedbackTimeout: PropTypes__default["default"].number,

    /**
     * Provide a description for the icon representing the copy action that can
     * be read by screen readers
     */
    iconDescription: PropTypes__default["default"].string,

    /**
     * Specify an optional `onClick` handler that is called when the underlying
     * `<button>` is clicked
     */
    onClick: PropTypes__default["default"].func
  };
  CopyButton.defaultProps = {
    iconDescription: 'Copy to clipboard',
    feedback: 'Copied!',
    feedbackTimeout: 2000,
    onClick: function onClick() {}
  };

  var lastId = 0;
  function uniqueId() {
    var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'id';
    lastId++;
    return "".concat(prefix).concat(lastId);
  }

  var toggleSelection = function toggleSelection() {
    var selection = document.getSelection();

    if (!selection.rangeCount) {
      return function () {};
    }

    var active = document.activeElement;
    var ranges = [];

    for (var i = 0; i < selection.rangeCount; i++) {
      ranges.push(selection.getRangeAt(i));
    }

    switch (active.tagName.toUpperCase()) {
      // .toUpperCase handles XHTML
      case 'INPUT':
      case 'TEXTAREA':
        active.blur();
        break;

      default:
        active = null;
        break;
    }

    selection.removeAllRanges();
    return function () {
      selection.type === 'Caret' && selection.removeAllRanges();

      if (!selection.rangeCount) {
        ranges.forEach(function (range) {
          selection.addRange(range);
        });
      }

      active && active.focus();
    };
  };

  var deselectCurrent = toggleSelection;
  var clipboardToIE11Formatting = {
    "text/plain": "Text",
    "text/html": "Url",
    "default": "Text"
  };
  var defaultMessage = "Copy to clipboard: #{key}, Enter";

  function format(message) {
    var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
    return message.replace(/#{\s*key\s*}/g, copyKey);
  }

  function copy(text, options) {
    var debug,
        message,
        reselectPrevious,
        range,
        selection,
        mark,
        success = false;

    if (!options) {
      options = {};
    }

    debug = options.debug || false;

    try {
      reselectPrevious = deselectCurrent();
      range = document.createRange();
      selection = document.getSelection();
      mark = document.createElement("span");
      mark.textContent = text; // reset user styles for span element

      mark.style.all = "unset"; // prevents scrolling to the end of the page

      mark.style.position = "fixed";
      mark.style.top = 0;
      mark.style.clip = "rect(0, 0, 0, 0)"; // used to preserve spaces and line breaks

      mark.style.whiteSpace = "pre"; // do not inherit user-select (it may be `none`)

      mark.style.webkitUserSelect = "text";
      mark.style.MozUserSelect = "text";
      mark.style.msUserSelect = "text";
      mark.style.userSelect = "text";
      mark.addEventListener("copy", function (e) {
        e.stopPropagation();

        if (options.format) {
          e.preventDefault();

          if (typeof e.clipboardData === "undefined") {
            // IE 11
            debug && console.warn("unable to use e.clipboardData");
            debug && console.warn("trying IE specific stuff");
            window.clipboardData.clearData();
            var format = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
            window.clipboardData.setData(format, text);
          } else {
            // all other browsers
            e.clipboardData.clearData();
            e.clipboardData.setData(options.format, text);
          }
        }

        if (options.onCopy) {
          e.preventDefault();
          options.onCopy(e.clipboardData);
        }
      });
      document.body.appendChild(mark);
      range.selectNodeContents(mark);
      selection.addRange(range);
      var successful = document.execCommand("copy");

      if (!successful) {
        throw new Error("copy command was unsuccessful");
      }

      success = true;
    } catch (err) {
      debug && console.error("unable to copy using execCommand: ", err);
      debug && console.warn("trying IE specific stuff");

      try {
        window.clipboardData.setData(options.format || "text", text);
        options.onCopy && options.onCopy(window.clipboardData);
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using clipboardData: ", err);
        debug && console.error("falling back to prompt");
        message = format("message" in options ? options.message : defaultMessage);
        window.prompt(message, text);
      }
    } finally {
      if (selection) {
        if (typeof selection.removeRange == "function") {
          selection.removeRange(range);
        } else {
          selection.removeAllRanges();
        }
      }

      if (mark) {
        document.body.removeChild(mark);
      }

      reselectPrevious();
    }

    return success;
  }

  var copyToClipboard = copy;

  var _excluded$2v = ["className", "type", "children", "disabled", "feedback", "feedbackTimeout", "onClick", "ariaLabel", "copyText", "copyLabel", "copyButtonDescription", "light", "showMoreText", "showLessText", "hideCopyButton", "wrapText", "maxCollapsedNumberOfRows", "maxExpandedNumberOfRows", "minCollapsedNumberOfRows", "minExpandedNumberOfRows"];
  var rowHeightInPixels = 16;
  var defaultMaxCollapsedNumberOfRows = 15;
  var defaultMaxExpandedNumberOfRows = 0;
  var defaultMinCollapsedNumberOfRows = 3;
  var defaultMinExpandedNumberOfRows = 16;

  function CodeSnippet(_ref) {
    var _classNames;

    var className = _ref.className,
        type = _ref.type,
        children = _ref.children,
        disabled = _ref.disabled,
        feedback = _ref.feedback,
        feedbackTimeout = _ref.feedbackTimeout,
        onClick = _ref.onClick,
        ariaLabel = _ref.ariaLabel,
        copyText = _ref.copyText,
        copyLabel = _ref.copyLabel,
        copyButtonDescription = _ref.copyButtonDescription,
        light = _ref.light,
        showMoreText = _ref.showMoreText,
        showLessText = _ref.showLessText,
        hideCopyButton = _ref.hideCopyButton,
        wrapText = _ref.wrapText,
        _ref$maxCollapsedNumb = _ref.maxCollapsedNumberOfRows,
        maxCollapsedNumberOfRows = _ref$maxCollapsedNumb === void 0 ? defaultMaxCollapsedNumberOfRows : _ref$maxCollapsedNumb,
        _ref$maxExpandedNumbe = _ref.maxExpandedNumberOfRows,
        maxExpandedNumberOfRows = _ref$maxExpandedNumbe === void 0 ? defaultMaxExpandedNumberOfRows : _ref$maxExpandedNumbe,
        _ref$minCollapsedNumb = _ref.minCollapsedNumberOfRows,
        minCollapsedNumberOfRows = _ref$minCollapsedNumb === void 0 ? defaultMinCollapsedNumberOfRows : _ref$minCollapsedNumb,
        _ref$minExpandedNumbe = _ref.minExpandedNumberOfRows,
        minExpandedNumberOfRows = _ref$minExpandedNumbe === void 0 ? defaultMinExpandedNumberOfRows : _ref$minExpandedNumbe,
        rest = _objectWithoutProperties$2(_ref, _excluded$2v);

    var _useState = React.useState(false),
        _useState2 = _slicedToArray$1(_useState, 2),
        expandedCode = _useState2[0],
        setExpandedCode = _useState2[1];

    var _useState3 = React.useState(false),
        _useState4 = _slicedToArray$1(_useState3, 2),
        shouldShowMoreLessBtn = _useState4[0],
        setShouldShowMoreLessBtn = _useState4[1];

    var _useRef = React.useRef(uniqueId()),
        uid = _useRef.current;

    var codeContentRef = React.useRef();
    var codeContainerRef = React.useRef();
    var innerCodeRef = React.useRef();

    var _useState5 = React.useState(false),
        _useState6 = _slicedToArray$1(_useState5, 2),
        hasLeftOverflow = _useState6[0],
        setHasLeftOverflow = _useState6[1];

    var _useState7 = React.useState(false),
        _useState8 = _slicedToArray$1(_useState7, 2),
        hasRightOverflow = _useState8[0],
        setHasRightOverflow = _useState8[1];

    var getCodeRef = React.useCallback(function () {
      if (type === 'single') {
        return codeContainerRef;
      }

      if (type === 'multi') {
        return codeContentRef;
      }
    }, [type]);
    var prefix = usePrefix();
    var getCodeRefDimensions = React.useCallback(function () {
      var _getCodeRef$current = getCodeRef().current,
          codeClientWidth = _getCodeRef$current.clientWidth,
          codeScrollLeft = _getCodeRef$current.scrollLeft,
          codeScrollWidth = _getCodeRef$current.scrollWidth;
      return {
        horizontalOverflow: codeScrollWidth > codeClientWidth,
        codeClientWidth: codeClientWidth,
        codeScrollWidth: codeScrollWidth,
        codeScrollLeft: codeScrollLeft
      };
    }, [getCodeRef]);
    var handleScroll = React.useCallback(function () {
      if (type === 'inline' || type === 'single' && !(codeContainerRef !== null && codeContainerRef !== void 0 && codeContainerRef.current) || type === 'multi' && !(codeContentRef !== null && codeContentRef !== void 0 && codeContentRef.current)) {
        return;
      }

      var _getCodeRefDimensions = getCodeRefDimensions(),
          horizontalOverflow = _getCodeRefDimensions.horizontalOverflow,
          codeClientWidth = _getCodeRefDimensions.codeClientWidth,
          codeScrollWidth = _getCodeRefDimensions.codeScrollWidth,
          codeScrollLeft = _getCodeRefDimensions.codeScrollLeft;

      setHasLeftOverflow(horizontalOverflow && !!codeScrollLeft);
      setHasRightOverflow(horizontalOverflow && codeScrollLeft + codeClientWidth !== codeScrollWidth);
    }, [type, getCodeRefDimensions]);
    useResizeObserver({
      ref: getCodeRef(),
      onResize: function onResize() {
        if (codeContentRef !== null && codeContentRef !== void 0 && codeContentRef.current && type === 'multi') {
          var _codeContentRef$curre = codeContentRef.current.getBoundingClientRect(),
              height = _codeContentRef$curre.height;

          if (maxCollapsedNumberOfRows > 0 && (maxExpandedNumberOfRows <= 0 || maxExpandedNumberOfRows > maxCollapsedNumberOfRows) && height > maxCollapsedNumberOfRows * rowHeightInPixels) {
            setShouldShowMoreLessBtn(true);
          } else {
            setShouldShowMoreLessBtn(false);
          }

          if (expandedCode && minExpandedNumberOfRows > 0 && height <= minExpandedNumberOfRows * rowHeightInPixels) {
            setExpandedCode(false);
          }
        }

        if (codeContentRef !== null && codeContentRef !== void 0 && codeContentRef.current && type === 'multi' || codeContainerRef !== null && codeContainerRef !== void 0 && codeContainerRef.current && type === 'single') {
          handleScroll();
        }
      }
    }, [type, maxCollapsedNumberOfRows, maxExpandedNumberOfRows, minExpandedNumberOfRows, rowHeightInPixels]);
    React.useEffect(function () {
      handleScroll();
    }, [handleScroll]);

    var handleCopyClick = function handleCopyClick(evt) {
      if (copyText || innerCodeRef !== null && innerCodeRef !== void 0 && innerCodeRef.current) {
        var _innerCodeRef$current;

        copyToClipboard(copyText !== null && copyText !== void 0 ? copyText : innerCodeRef === null || innerCodeRef === void 0 ? void 0 : (_innerCodeRef$current = innerCodeRef.current) === null || _innerCodeRef$current === void 0 ? void 0 : _innerCodeRef$current.innerText);
      }

      if (onClick) {
        onClick(evt);
      }
    };

    var codeSnippetClasses = cx(className, "".concat(prefix, "--snippet"), (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--snippet--").concat(type), type), _defineProperty$2(_classNames, "".concat(prefix, "--snippet--disabled"), type !== 'inline' && disabled), _defineProperty$2(_classNames, "".concat(prefix, "--snippet--expand"), expandedCode), _defineProperty$2(_classNames, "".concat(prefix, "--snippet--light"), light), _defineProperty$2(_classNames, "".concat(prefix, "--snippet--no-copy"), hideCopyButton), _defineProperty$2(_classNames, "".concat(prefix, "--snippet--wraptext"), wrapText), _classNames));
    var expandCodeBtnText = expandedCode ? showLessText : showMoreText;

    if (type === 'inline') {
      if (hideCopyButton) {
        return /*#__PURE__*/React__default["default"].createElement("span", {
          className: codeSnippetClasses
        }, /*#__PURE__*/React__default["default"].createElement("code", {
          id: uid,
          ref: innerCodeRef
        }, children));
      }

      return /*#__PURE__*/React__default["default"].createElement(Copy, _extends$3({}, rest, {
        onClick: handleCopyClick,
        "aria-label": copyLabel || ariaLabel,
        "aria-describedby": uid,
        className: codeSnippetClasses,
        feedback: feedback,
        feedbackTimeout: feedbackTimeout
      }), /*#__PURE__*/React__default["default"].createElement("code", {
        id: uid,
        ref: innerCodeRef
      }, children));
    }

    var containerStyle = {};

    if (type === 'multi') {
      var styles = {};

      if (expandedCode) {
        if (maxExpandedNumberOfRows > 0) {
          styles.maxHeight = maxExpandedNumberOfRows * rowHeightInPixels;
        }

        if (minExpandedNumberOfRows > 0) {
          styles.minHeight = minExpandedNumberOfRows * rowHeightInPixels;
        }
      } else {
        if (maxCollapsedNumberOfRows > 0) {
          styles.maxHeight = maxCollapsedNumberOfRows * rowHeightInPixels;
        }

        if (minCollapsedNumberOfRows > 0) {
          styles.minHeight = minCollapsedNumberOfRows * rowHeightInPixels;
        }
      }

      if (Object.keys(styles).length) {
        containerStyle.style = styles;
      }
    }

    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({}, rest, {
      className: codeSnippetClasses
    }), /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      ref: codeContainerRef,
      role: type === 'single' || type === 'multi' ? 'textbox' : null,
      tabIndex: (type === 'single' || type === 'multi') && !disabled ? 0 : null,
      className: "".concat(prefix, "--snippet-container"),
      "aria-label": ariaLabel || copyLabel || 'code-snippet',
      "aria-readonly": type === 'single' || type === 'multi' ? true : null,
      "aria-multiline": type === 'multi' ? true : null,
      onScroll: type === 'single' && handleScroll || null
    }, containerStyle), /*#__PURE__*/React__default["default"].createElement("pre", {
      ref: codeContentRef,
      onScroll: type === 'multi' && handleScroll || null
    }, /*#__PURE__*/React__default["default"].createElement("code", {
      ref: innerCodeRef
    }, children))), hasLeftOverflow && /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--snippet__overflow-indicator--left")
    }), hasRightOverflow && /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--snippet__overflow-indicator--right")
    }), !hideCopyButton && /*#__PURE__*/React__default["default"].createElement(CopyButton, {
      disabled: disabled,
      onClick: handleCopyClick,
      feedback: feedback,
      feedbackTimeout: feedbackTimeout,
      iconDescription: copyButtonDescription
    }), shouldShowMoreLessBtn && /*#__PURE__*/React__default["default"].createElement(Button$1, {
      kind: "ghost",
      size: "field",
      className: "".concat(prefix, "--snippet-btn--expand"),
      disabled: disabled,
      onClick: function onClick() {
        return setExpandedCode(!expandedCode);
      }
    }, /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--snippet-btn--text")
    }, expandCodeBtnText), /*#__PURE__*/React__default["default"].createElement(ChevronDown16, {
      "aria-label": expandCodeBtnText,
      className: "".concat(prefix, "--icon-chevron--down ").concat(prefix, "--snippet__icon"),
      name: "chevron--down",
      role: "img"
    })));
  }

  CodeSnippet.propTypes = {
    /**
     * Specify a label to be read by screen readers on the containing <textbox>
     * node
     */
    ariaLabel: PropTypes__default["default"].string,

    /**
     * Provide the content of your CodeSnippet as a node or string
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the description for the Copy Button
     */
    copyButtonDescription: PropTypes__default["default"].string,

    /**
     * Specify a label to be read by screen readers on the containing <textbox>
     * node
     */
    copyLabel: PropTypes__default["default"].string,

    /**
     * Optional text to copy. If not specified, the `children` node's `innerText`
     * will be used as the copy value.
     */
    copyText: PropTypes__default["default"].string,

    /**
     * Specify whether or not the CodeSnippet should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Specify the string displayed when the snippet is copied
     */
    feedback: PropTypes__default["default"].string,

    /**
     * Specify the time it takes for the feedback message to timeout
     */
    feedbackTimeout: PropTypes__default["default"].number,

    /**
     * Specify whether or not a copy button should be used/rendered.
     */
    hideCopyButton: PropTypes__default["default"].bool,

    /**
     * Specify whether you are using the light variant of the Code Snippet,
     * typically used for inline snippet to display an alternate color
     */
    light: PropTypes__default["default"].bool,

    /**
     * Specify the maximum number of rows to be shown when in collapsed view
     */
    maxCollapsedNumberOfRows: PropTypes__default["default"].number,

    /**
     * Specify the maximum number of rows to be shown when in expanded view
     */
    maxExpandedNumberOfRows: PropTypes__default["default"].number,

    /**
     * Specify the minimum number of rows to be shown when in collapsed view
     */
    minCollapsedNumberOfRows: PropTypes__default["default"].number,

    /**
     * Specify the minimum number of rows to be shown when in expanded view
     */
    minExpandedNumberOfRows: PropTypes__default["default"].number,

    /**
     * An optional handler to listen to the `onClick` even fired by the Copy
     * Button
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Specify a string that is displayed when the Code Snippet has been
     * interacted with to show more lines
     */
    showLessText: PropTypes__default["default"].string,

    /**
     * Specify a string that is displayed when the Code Snippet text is more
     * than 15 lines
     */
    showMoreText: PropTypes__default["default"].string,

    /**
     * Provide the type of Code Snippet
     */
    type: PropTypes__default["default"].oneOf(['single', 'inline', 'multi']),

    /**
     * Specify whether or not to wrap the text.
     */
    wrapText: PropTypes__default["default"].bool
  };
  CodeSnippet.defaultProps = {
    type: 'single',
    showMoreText: 'Show more',
    showLessText: 'Show less',
    wrapText: false
  };

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }

  var reactIs = {exports: {}};

  if ("function" === typeof Symbol && Symbol.for) {
    var x = Symbol.for;
    x("react.element");
    x("react.portal");
    x("react.fragment");
    x("react.strict_mode");
    x("react.profiler");
    x("react.provider");
    x("react.context");
    x("react.forward_ref");
    x("react.suspense");
    x("react.suspense_list");
    x("react.memo");
    x("react.lazy");
    x("react.block");
    x("react.server.block");
    x("react.fundamental");
    x("react.debug_trace_mode");
    x("react.legacy_hidden");
  }

  var reactIs_development = {};

  {
    (function () {
      // When adding new symbols to this file,
      // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
      // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
      // nor polyfill, then a plain number is used for performance.

      var REACT_ELEMENT_TYPE = 0xeac7;
      var REACT_PORTAL_TYPE = 0xeaca;
      var REACT_FRAGMENT_TYPE = 0xeacb;
      var REACT_STRICT_MODE_TYPE = 0xeacc;
      var REACT_PROFILER_TYPE = 0xead2;
      var REACT_PROVIDER_TYPE = 0xeacd;
      var REACT_CONTEXT_TYPE = 0xeace;
      var REACT_FORWARD_REF_TYPE = 0xead0;
      var REACT_SUSPENSE_TYPE = 0xead1;
      var REACT_SUSPENSE_LIST_TYPE = 0xead8;
      var REACT_MEMO_TYPE = 0xead3;
      var REACT_LAZY_TYPE = 0xead4;
      var REACT_BLOCK_TYPE = 0xead9;
      var REACT_SERVER_BLOCK_TYPE = 0xeada;
      var REACT_FUNDAMENTAL_TYPE = 0xead5;
      var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
      var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

      if (typeof Symbol === 'function' && Symbol.for) {
        var symbolFor = Symbol.for;
        REACT_ELEMENT_TYPE = symbolFor('react.element');
        REACT_PORTAL_TYPE = symbolFor('react.portal');
        REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
        REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
        REACT_PROFILER_TYPE = symbolFor('react.profiler');
        REACT_PROVIDER_TYPE = symbolFor('react.provider');
        REACT_CONTEXT_TYPE = symbolFor('react.context');
        REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
        REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
        REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
        REACT_MEMO_TYPE = symbolFor('react.memo');
        REACT_LAZY_TYPE = symbolFor('react.lazy');
        REACT_BLOCK_TYPE = symbolFor('react.block');
        REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
        REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
        symbolFor('react.scope');
        symbolFor('react.opaque.id');
        REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
        symbolFor('react.offscreen');
        REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
      } // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.


      var enableScopeAPI = false; // Experimental Create Event Handle API.

      function isValidElementType(type) {
        if (typeof type === 'string' || typeof type === 'function') {
          return true;
        } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
          return true;
        }

        if (_typeof(type) === 'object' && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
            return true;
          }
        }

        return false;
      }

      function typeOf(object) {
        if (_typeof(object) === 'object' && object !== null) {
          var $$typeof = object.$$typeof;

          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;

              switch (type) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                  return type;

                default:
                  var $$typeofType = type && type.$$typeof;

                  switch ($$typeofType) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;

                    default:
                      return $$typeof;
                  }

              }

            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }

        return undefined;
      }

      var ContextConsumer = REACT_CONTEXT_TYPE;
      var ContextProvider = REACT_PROVIDER_TYPE;
      var Element = REACT_ELEMENT_TYPE;
      var ForwardRef = REACT_FORWARD_REF_TYPE;
      var Fragment = REACT_FRAGMENT_TYPE;
      var Lazy = REACT_LAZY_TYPE;
      var Memo = REACT_MEMO_TYPE;
      var Portal = REACT_PORTAL_TYPE;
      var Profiler = REACT_PROFILER_TYPE;
      var StrictMode = REACT_STRICT_MODE_TYPE;
      var Suspense = REACT_SUSPENSE_TYPE;
      var hasWarnedAboutDeprecatedIsAsyncMode = false;
      var hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated

      function isAsyncMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

            console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
          }
        }
        return false;
      }

      function isConcurrentMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
            hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint

            console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
          }
        }
        return false;
      }

      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }

      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }

      function isElement(object) {
        return _typeof(object) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }

      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }

      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }

      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }

      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }

      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }

      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }

      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }

      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }

      reactIs_development.ContextConsumer = ContextConsumer;
      reactIs_development.ContextProvider = ContextProvider;
      reactIs_development.Element = Element;
      reactIs_development.ForwardRef = ForwardRef;
      reactIs_development.Fragment = Fragment;
      reactIs_development.Lazy = Lazy;
      reactIs_development.Memo = Memo;
      reactIs_development.Portal = Portal;
      reactIs_development.Profiler = Profiler;
      reactIs_development.StrictMode = StrictMode;
      reactIs_development.Suspense = Suspense;
      reactIs_development.isAsyncMode = isAsyncMode;
      reactIs_development.isConcurrentMode = isConcurrentMode;
      reactIs_development.isContextConsumer = isContextConsumer;
      reactIs_development.isContextProvider = isContextProvider;
      reactIs_development.isElement = isElement;
      reactIs_development.isForwardRef = isForwardRef;
      reactIs_development.isFragment = isFragment;
      reactIs_development.isLazy = isLazy;
      reactIs_development.isMemo = isMemo;
      reactIs_development.isPortal = isPortal;
      reactIs_development.isProfiler = isProfiler;
      reactIs_development.isStrictMode = isStrictMode;
      reactIs_development.isSuspense = isSuspense;
      reactIs_development.isValidElementType = isValidElementType;
      reactIs_development.typeOf = typeOf;
    })();
  }

  {
    reactIs.exports = reactIs_development;
  }

  function t(t) {
    return "object" == _typeof(t) && null != t && 1 === t.nodeType;
  }

  function e(t, e) {
    return (!e || "hidden" !== t) && "visible" !== t && "clip" !== t;
  }

  function n(t, n) {
    if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) {
      var r = getComputedStyle(t, null);
      return e(r.overflowY, n) || e(r.overflowX, n) || function (t) {
        var e = function (t) {
          if (!t.ownerDocument || !t.ownerDocument.defaultView) return null;

          try {
            return t.ownerDocument.defaultView.frameElement;
          } catch (t) {
            return null;
          }
        }(t);

        return !!e && (e.clientHeight < t.scrollHeight || e.clientWidth < t.scrollWidth);
      }(t);
    }

    return !1;
  }

  function r(t, e, n, r, i, o, l, d) {
    return o < t && l > e || o > t && l < e ? 0 : o <= t && d <= n || l >= e && d >= n ? o - t - r : l > e && d < n || o < t && d > n ? l - e + i : 0;
  }

  function computeScrollIntoView (e, i) {
    var o = window,
        l = i.scrollMode,
        d = i.block,
        u = i.inline,
        h = i.boundary,
        a = i.skipOverflowHiddenElements,
        c = "function" == typeof h ? h : function (t) {
      return t !== h;
    };
    if (!t(e)) throw new TypeError("Invalid target");

    for (var f = document.scrollingElement || document.documentElement, s = [], p = e; t(p) && c(p);) {
      if ((p = p.parentElement) === f) {
        s.push(p);
        break;
      }

      null != p && p === document.body && n(p) && !n(document.documentElement) || null != p && n(p, a) && s.push(p);
    }

    for (var m = o.visualViewport ? o.visualViewport.width : innerWidth, g = o.visualViewport ? o.visualViewport.height : innerHeight, w = window.scrollX || pageXOffset, v = window.scrollY || pageYOffset, W = e.getBoundingClientRect(), b = W.height, H = W.width, y = W.top, E = W.right, M = W.bottom, V = W.left, x = "start" === d || "nearest" === d ? y : "end" === d ? M : y + b / 2, I = "center" === u ? V + H / 2 : "end" === u ? E : V, C = [], T = 0; T < s.length; T++) {
      var k = s[T],
          B = k.getBoundingClientRect(),
          D = B.height,
          O = B.width,
          R = B.top,
          X = B.right,
          Y = B.bottom,
          L = B.left;
      if ("if-needed" === l && y >= 0 && V >= 0 && M <= g && E <= m && y >= R && M <= Y && V >= L && E <= X) return C;
      var S = getComputedStyle(k),
          j = parseInt(S.borderLeftWidth, 10),
          q = parseInt(S.borderTopWidth, 10),
          z = parseInt(S.borderRightWidth, 10),
          A = parseInt(S.borderBottomWidth, 10),
          F = 0,
          G = 0,
          J = "offsetWidth" in k ? k.offsetWidth - k.clientWidth - j - z : 0,
          K = "offsetHeight" in k ? k.offsetHeight - k.clientHeight - q - A : 0;
      if (f === k) F = "start" === d ? x : "end" === d ? x - g : "nearest" === d ? r(v, v + g, g, q, A, v + x, v + x + b, b) : x - g / 2, G = "start" === u ? I : "center" === u ? I - m / 2 : "end" === u ? I - m : r(w, w + m, m, j, z, w + I, w + I + H, H), F = Math.max(0, F + v), G = Math.max(0, G + w);else {
        F = "start" === d ? x - R - q : "end" === d ? x - Y + A + K : "nearest" === d ? r(R, Y, D, q, A + K, x, x + b, b) : x - (R + D / 2) + K / 2, G = "start" === u ? I - L - j : "center" === u ? I - (L + O / 2) + J / 2 : "end" === u ? I - X + z + J : r(L, X, O, j, z + J, I, I + H, H);
        var N = k.scrollLeft,
            P = k.scrollTop;
        x += P - (F = Math.max(0, Math.min(P + F, k.scrollHeight - D + K))), I += N - (G = Math.max(0, Math.min(N + G, k.scrollWidth - O + J)));
      }
      C.push({
        el: k,
        top: F,
        left: G
      });
    }

    return C;
  }

  var idCounter = 0;
  /**
   * Accepts a parameter and returns it if it's a function
   * or a noop function if it's not. This allows us to
   * accept a callback, but not worry about it if it's not
   * passed.
   * @param {Function} cb the callback
   * @return {Function} a function
   */

  function cbToCb(cb) {
    return typeof cb === 'function' ? cb : noop$2;
  }

  function noop$2() {}
  /**
   * Scroll node into view if necessary
   * @param {HTMLElement} node the element that should scroll into view
   * @param {HTMLElement} menuNode the menu element of the component
   */


  function scrollIntoView(node, menuNode) {
    if (node === null) {
      return;
    }

    var actions = computeScrollIntoView(node, {
      boundary: menuNode,
      block: 'nearest',
      scrollMode: 'if-needed'
    });
    actions.forEach(function (_ref) {
      var el = _ref.el,
          top = _ref.top,
          left = _ref.left;
      el.scrollTop = top;
      el.scrollLeft = left;
    });
  }
  /**
   * @param {HTMLElement} parent the parent node
   * @param {HTMLElement} child the child node
   * @return {Boolean} whether the parent is the child or the child is in the parent
   */


  function isOrContainsNode(parent, child) {
    return parent === child || parent.contains && parent.contains(child);
  }
  /**
   * Simple debounce implementation. Will call the given
   * function once after the time given has passed since
   * it was last called.
   * @param {Function} fn the function to call after the time
   * @param {Number} time the time to wait
   * @return {Function} the debounced function
   */


  function debounce$2(fn, time) {
    var timeoutId;

    function cancel() {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    }

    function wrapper() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      cancel();
      timeoutId = setTimeout(function () {
        timeoutId = null;
        fn.apply(void 0, args);
      }, time);
    }

    wrapper.cancel = cancel;
    return wrapper;
  }
  /**
   * This is intended to be used to compose event handlers.
   * They are executed in order until one of them sets
   * `event.preventDownshiftDefault = true`.
   * @param {...Function} fns the event handler functions
   * @return {Function} the event handler to add to an element
   */


  function callAllEventHandlers() {
    for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      fns[_key2] = arguments[_key2];
    }

    return function (event) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      return fns.some(function (fn) {
        if (fn) {
          fn.apply(void 0, [event].concat(args));
        }

        return event.preventDownshiftDefault || event.hasOwnProperty('nativeEvent') && event.nativeEvent.preventDownshiftDefault;
      });
    };
  }

  function handleRefs() {
    for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      refs[_key4] = arguments[_key4];
    }

    return function (node) {
      refs.forEach(function (ref) {
        if (typeof ref === 'function') {
          ref(node);
        } else if (ref) {
          ref.current = node;
        }
      });
    };
  }
  /**
   * This generates a unique ID for an instance of Downshift
   * @return {String} the unique ID
   */


  function generateId() {
    return String(idCounter++);
  }
  /**
   * Default implementation for status message. Only added when menu is open.
   * Will specift if there are results in the list, and if so, how many,
   * and what keys are relevant.
   *
   * @param {Object} param the downshift state and other relevant properties
   * @return {String} the a11y status message
   */


  function getA11yStatusMessage(_ref2) {
    var isOpen = _ref2.isOpen,
        resultCount = _ref2.resultCount,
        previousResultCount = _ref2.previousResultCount;

    if (!isOpen) {
      return '';
    }

    if (!resultCount) {
      return 'No results are available.';
    }

    if (resultCount !== previousResultCount) {
      return resultCount + " result" + (resultCount === 1 ? ' is' : 's are') + " available, use up and down arrow keys to navigate. Press Enter key to select.";
    }

    return '';
  }
  /**
   * Takes an argument and if it's an array, returns the first item in the array
   * otherwise returns the argument
   * @param {*} arg the maybe-array
   * @param {*} defaultValue the value if arg is falsey not defined
   * @return {*} the arg or it's first item
   */


  function unwrapArray(arg, defaultValue) {
    arg = Array.isArray(arg) ?
    /* istanbul ignore next (preact) */
    arg[0] : arg;

    if (!arg && defaultValue) {
      return defaultValue;
    } else {
      return arg;
    }
  }
  /**
   * @param {Object} element (P)react element
   * @return {Boolean} whether it's a DOM element
   */


  function isDOMElement(element) {
    // then we assume this is react
    return typeof element.type === 'string';
  }
  /**
   * @param {Object} element (P)react element
   * @return {Object} the props
   */


  function getElementProps(element) {
    return element.props;
  }
  /**
   * Throws a helpful error message for required properties. Useful
   * to be used as a default in destructuring or object params.
   * @param {String} fnName the function name
   * @param {String} propName the prop name
   */


  function requiredProp(fnName, propName) {
    // eslint-disable-next-line no-console
    console.error("The property \"" + propName + "\" is required in \"" + fnName + "\"");
  }

  var stateKeys = ['highlightedIndex', 'inputValue', 'isOpen', 'selectedItem', 'type'];
  /**
   * @param {Object} state the state object
   * @return {Object} state that is relevant to downshift
   */

  function pickState(state) {
    if (state === void 0) {
      state = {};
    }

    var result = {};
    stateKeys.forEach(function (k) {
      if (state.hasOwnProperty(k)) {
        result[k] = state[k];
      }
    });
    return result;
  }
  /**
   * This will perform a shallow merge of the given state object
   * with the state coming from props
   * (for the controlled component scenario)
   * This is used in state updater functions so they're referencing
   * the right state regardless of where it comes from.
   *
   * @param {Object} state The state of the component/hook.
   * @param {Object} props The props that may contain controlled values.
   * @returns {Object} The merged controlled state.
   */


  function getState(state, props) {
    return Object.keys(state).reduce(function (prevState, key) {
      prevState[key] = isControlledProp(props, key) ? props[key] : state[key];
      return prevState;
    }, {});
  }
  /**
   * This determines whether a prop is a "controlled prop" meaning it is
   * state which is controlled by the outside of this component rather
   * than within this component.
   *
   * @param {Object} props The props that may contain controlled values.
   * @param {String} key the key to check
   * @return {Boolean} whether it is a controlled controlled prop
   */


  function isControlledProp(props, key) {
    return props[key] !== undefined;
  }
  /**
   * Normalizes the 'key' property of a KeyboardEvent in IE/Edge
   * @param {Object} event a keyboardEvent object
   * @return {String} keyboard key
   */


  function normalizeArrowKey(event) {
    var key = event.key,
        keyCode = event.keyCode;
    /* istanbul ignore next (ie) */

    if (keyCode >= 37 && keyCode <= 40 && key.indexOf('Arrow') !== 0) {
      return "Arrow" + key;
    }

    return key;
  }
  /**
   * Simple check if the value passed is object literal
   * @param {*} obj any things
   * @return {Boolean} whether it's object literal
   */


  function isPlainObject(obj) {
    return Object.prototype.toString.call(obj) === '[object Object]';
  }
  /**
   * Returns the new index in the list, in a circular way. If next value is out of bonds from the total,
   * it will wrap to either 0 or itemCount - 1.
   *
   * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.
   * @param {number} baseIndex The initial position to move from.
   * @param {number} itemCount The total number of items.
   * @param {Function} getItemNodeFromIndex Used to check if item is disabled.
   * @param {boolean} circular Specify if navigation is circular. Default is true.
   * @returns {number} The new index after the move.
   */


  function getNextWrappingIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {
    if (circular === void 0) {
      circular = true;
    }

    var itemsLastIndex = itemCount - 1;

    if (typeof baseIndex !== 'number' || baseIndex < 0 || baseIndex >= itemCount) {
      baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;
    }

    var newIndex = baseIndex + moveAmount;

    if (newIndex < 0) {
      newIndex = circular ? itemsLastIndex : 0;
    } else if (newIndex > itemsLastIndex) {
      newIndex = circular ? 0 : itemsLastIndex;
    }

    var nonDisabledNewIndex = getNextNonDisabledIndex(moveAmount, newIndex, itemCount, getItemNodeFromIndex, circular);
    return nonDisabledNewIndex === -1 ? baseIndex : nonDisabledNewIndex;
  }
  /**
   * Returns the next index in the list of an item that is not disabled.
   *
   * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.
   * @param {number} baseIndex The initial position to move from.
   * @param {number} itemCount The total number of items.
   * @param {Function} getItemNodeFromIndex Used to check if item is disabled.
   * @param {boolean} circular Specify if navigation is circular. Default is true.
   * @returns {number} The new index. Returns baseIndex if item is not disabled. Returns next non-disabled item otherwise. If no non-disabled found it will return -1.
   */


  function getNextNonDisabledIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {
    var currentElementNode = getItemNodeFromIndex(baseIndex);

    if (!currentElementNode || !currentElementNode.hasAttribute('disabled')) {
      return baseIndex;
    }

    if (moveAmount > 0) {
      for (var index = baseIndex + 1; index < itemCount; index++) {
        if (!getItemNodeFromIndex(index).hasAttribute('disabled')) {
          return index;
        }
      }
    } else {
      for (var _index = baseIndex - 1; _index >= 0; _index--) {
        if (!getItemNodeFromIndex(_index).hasAttribute('disabled')) {
          return _index;
        }
      }
    }

    if (circular) {
      return moveAmount > 0 ? getNextNonDisabledIndex(1, 0, itemCount, getItemNodeFromIndex, false) : getNextNonDisabledIndex(-1, itemCount - 1, itemCount, getItemNodeFromIndex, false);
    }

    return -1;
  }
  /**
   * Checks if event target is within the downshift elements.
   *
   * @param {EventTarget} target Target to check.
   * @param {HTMLElement[]} downshiftElements The elements that form downshift (list, toggle button etc).
   * @param {Document} document The document.
   * @param {boolean} checkActiveElement Whether to also check activeElement.
   *
   * @returns {boolean} Whether or not the target is within downshift elements.
   */


  function targetWithinDownshift(target, downshiftElements, document, checkActiveElement) {
    if (checkActiveElement === void 0) {
      checkActiveElement = true;
    }

    return downshiftElements.some(function (contextNode) {
      return contextNode && (isOrContainsNode(contextNode, target) || checkActiveElement && isOrContainsNode(contextNode, document.activeElement));
    });
  }

  var cleanupStatus = debounce$2(function () {
    getStatusDiv().textContent = '';
  }, 500);
  /**
   * @param {String} status the status message
   * @param {Object} documentProp document passed by the user.
   */

  function setStatus(status, documentProp) {
    var div = getStatusDiv(documentProp);

    if (!status) {
      return;
    }

    div.textContent = status;
    cleanupStatus();
  }
  /**
   * Get the status node or create it if it does not already exist.
   * @param {Object} documentProp document passed by the user.
   * @return {HTMLElement} the status node.
   */


  function getStatusDiv(documentProp) {
    if (documentProp === void 0) {
      documentProp = document;
    }

    var statusDiv = documentProp.getElementById('a11y-status-message');

    if (statusDiv) {
      return statusDiv;
    }

    statusDiv = documentProp.createElement('div');
    statusDiv.setAttribute('id', 'a11y-status-message');
    statusDiv.setAttribute('role', 'status');
    statusDiv.setAttribute('aria-live', 'polite');
    statusDiv.setAttribute('aria-relevant', 'additions text');
    Object.assign(statusDiv.style, {
      border: '0',
      clip: 'rect(0 0 0 0)',
      height: '1px',
      margin: '-1px',
      overflow: 'hidden',
      padding: '0',
      position: 'absolute',
      width: '1px'
    });
    documentProp.body.appendChild(statusDiv);
    return statusDiv;
  }

  var unknown = '__autocomplete_unknown__' ;
  var mouseUp = '__autocomplete_mouseup__' ;
  var itemMouseEnter = '__autocomplete_item_mouseenter__' ;
  var keyDownArrowUp = '__autocomplete_keydown_arrow_up__' ;
  var keyDownArrowDown = '__autocomplete_keydown_arrow_down__' ;
  var keyDownEscape = '__autocomplete_keydown_escape__' ;
  var keyDownEnter = '__autocomplete_keydown_enter__' ;
  var keyDownHome = '__autocomplete_keydown_home__' ;
  var keyDownEnd = '__autocomplete_keydown_end__' ;
  var clickItem = '__autocomplete_click_item__' ;
  var blurInput = '__autocomplete_blur_input__' ;
  var changeInput = '__autocomplete_change_input__' ;
  var keyDownSpaceButton = '__autocomplete_keydown_space_button__' ;
  var clickButton = '__autocomplete_click_button__' ;
  var blurButton = '__autocomplete_blur_button__' ;
  var controlledPropUpdatedSelectedItem = '__autocomplete_controlled_prop_updated_selected_item__' ;
  var touchEnd = '__autocomplete_touchend__' ;
  var stateChangeTypes = /*#__PURE__*/Object.freeze({
    __proto__: null,
    unknown: unknown,
    mouseUp: mouseUp,
    itemMouseEnter: itemMouseEnter,
    keyDownArrowUp: keyDownArrowUp,
    keyDownArrowDown: keyDownArrowDown,
    keyDownEscape: keyDownEscape,
    keyDownEnter: keyDownEnter,
    keyDownHome: keyDownHome,
    keyDownEnd: keyDownEnd,
    clickItem: clickItem,
    blurInput: blurInput,
    changeInput: changeInput,
    keyDownSpaceButton: keyDownSpaceButton,
    clickButton: clickButton,
    blurButton: blurButton,
    controlledPropUpdatedSelectedItem: controlledPropUpdatedSelectedItem,
    touchEnd: touchEnd
  });

  var Downshift = /*#__PURE__*/function () {
    var Downshift = /*#__PURE__*/function (_Component) {
      _inheritsLoose(Downshift, _Component);

      function Downshift(_props) {
        var _this = _Component.call(this, _props) || this;

        _this.id = _this.props.id || "downshift-" + generateId();
        _this.menuId = _this.props.menuId || _this.id + "-menu";
        _this.labelId = _this.props.labelId || _this.id + "-label";
        _this.inputId = _this.props.inputId || _this.id + "-input";

        _this.getItemId = _this.props.getItemId || function (index) {
          return _this.id + "-item-" + index;
        };

        _this.input = null;
        _this.items = [];
        _this.itemCount = null;
        _this.previousResultCount = 0;
        _this.timeoutIds = [];

        _this.internalSetTimeout = function (fn, time) {
          var id = setTimeout(function () {
            _this.timeoutIds = _this.timeoutIds.filter(function (i) {
              return i !== id;
            });
            fn();
          }, time);

          _this.timeoutIds.push(id);
        };

        _this.setItemCount = function (count) {
          _this.itemCount = count;
        };

        _this.unsetItemCount = function () {
          _this.itemCount = null;
        };

        _this.setHighlightedIndex = function (highlightedIndex, otherStateToSet) {
          if (highlightedIndex === void 0) {
            highlightedIndex = _this.props.defaultHighlightedIndex;
          }

          if (otherStateToSet === void 0) {
            otherStateToSet = {};
          }

          otherStateToSet = pickState(otherStateToSet);

          _this.internalSetState(_extends({
            highlightedIndex: highlightedIndex
          }, otherStateToSet));
        };

        _this.clearSelection = function (cb) {
          _this.internalSetState({
            selectedItem: null,
            inputValue: '',
            highlightedIndex: _this.props.defaultHighlightedIndex,
            isOpen: _this.props.defaultIsOpen
          }, cb);
        };

        _this.selectItem = function (item, otherStateToSet, cb) {
          otherStateToSet = pickState(otherStateToSet);

          _this.internalSetState(_extends({
            isOpen: _this.props.defaultIsOpen,
            highlightedIndex: _this.props.defaultHighlightedIndex,
            selectedItem: item,
            inputValue: _this.props.itemToString(item)
          }, otherStateToSet), cb);
        };

        _this.selectItemAtIndex = function (itemIndex, otherStateToSet, cb) {
          var item = _this.items[itemIndex];

          if (item == null) {
            return;
          }

          _this.selectItem(item, otherStateToSet, cb);
        };

        _this.selectHighlightedItem = function (otherStateToSet, cb) {
          return _this.selectItemAtIndex(_this.getState().highlightedIndex, otherStateToSet, cb);
        };

        _this.internalSetState = function (stateToSet, cb) {
          var isItemSelected, onChangeArg;
          var onStateChangeArg = {};
          var isStateToSetFunction = typeof stateToSet === 'function'; // we want to call `onInputValueChange` before the `setState` call
          // so someone controlling the `inputValue` state gets notified of
          // the input change as soon as possible. This avoids issues with
          // preserving the cursor position.
          // See https://github.com/downshift-js/downshift/issues/217 for more info.

          if (!isStateToSetFunction && stateToSet.hasOwnProperty('inputValue')) {
            _this.props.onInputValueChange(stateToSet.inputValue, _extends({}, _this.getStateAndHelpers(), {}, stateToSet));
          }

          return _this.setState(function (state) {
            state = _this.getState(state);
            var newStateToSet = isStateToSetFunction ? stateToSet(state) : stateToSet; // Your own function that could modify the state that will be set.

            newStateToSet = _this.props.stateReducer(state, newStateToSet); // checks if an item is selected, regardless of if it's different from
            // what was selected before
            // used to determine if onSelect and onChange callbacks should be called

            isItemSelected = newStateToSet.hasOwnProperty('selectedItem'); // this keeps track of the object we want to call with setState

            var nextState = {}; // this is just used to tell whether the state changed

            var nextFullState = {}; // we need to call on change if the outside world is controlling any of our state
            // and we're trying to update that state. OR if the selection has changed and we're
            // trying to update the selection

            if (isItemSelected && newStateToSet.selectedItem !== state.selectedItem) {
              onChangeArg = newStateToSet.selectedItem;
            }

            newStateToSet.type = newStateToSet.type || unknown;
            Object.keys(newStateToSet).forEach(function (key) {
              // onStateChangeArg should only have the state that is
              // actually changing
              if (state[key] !== newStateToSet[key]) {
                onStateChangeArg[key] = newStateToSet[key];
              } // the type is useful for the onStateChangeArg
              // but we don't actually want to set it in internal state.
              // this is an undocumented feature for now... Not all internalSetState
              // calls support it and I'm not certain we want them to yet.
              // But it enables users controlling the isOpen state to know when
              // the isOpen state changes due to mouseup events which is quite handy.


              if (key === 'type') {
                return;
              }

              nextFullState[key] = newStateToSet[key]; // if it's coming from props, then we don't care to set it internally

              if (!isControlledProp(_this.props, key)) {
                nextState[key] = newStateToSet[key];
              }
            }); // if stateToSet is a function, then we weren't able to call onInputValueChange
            // earlier, so we'll call it now that we know what the inputValue state will be.

            if (isStateToSetFunction && newStateToSet.hasOwnProperty('inputValue')) {
              _this.props.onInputValueChange(newStateToSet.inputValue, _extends({}, _this.getStateAndHelpers(), {}, newStateToSet));
            }

            return nextState;
          }, function () {
            // call the provided callback if it's a function
            cbToCb(cb)(); // only call the onStateChange and onChange callbacks if
            // we have relevant information to pass them.

            var hasMoreStateThanType = Object.keys(onStateChangeArg).length > 1;

            if (hasMoreStateThanType) {
              _this.props.onStateChange(onStateChangeArg, _this.getStateAndHelpers());
            }

            if (isItemSelected) {
              _this.props.onSelect(stateToSet.selectedItem, _this.getStateAndHelpers());
            }

            if (onChangeArg !== undefined) {
              _this.props.onChange(onChangeArg, _this.getStateAndHelpers());
            } // this is currently undocumented and therefore subject to change
            // We'll try to not break it, but just be warned.


            _this.props.onUserAction(onStateChangeArg, _this.getStateAndHelpers());
          });
        };

        _this.rootRef = function (node) {
          return _this._rootNode = node;
        };

        _this.getRootProps = function (_temp, _temp2) {
          var _extends2;

          var _ref = _temp === void 0 ? {} : _temp,
              _ref$refKey = _ref.refKey,
              refKey = _ref$refKey === void 0 ? 'ref' : _ref$refKey,
              ref = _ref.ref,
              rest = _objectWithoutPropertiesLoose(_ref, ["refKey", "ref"]);

          var _ref2 = _temp2 === void 0 ? {} : _temp2,
              _ref2$suppressRefErro = _ref2.suppressRefError,
              suppressRefError = _ref2$suppressRefErro === void 0 ? false : _ref2$suppressRefErro; // this is used in the render to know whether the user has called getRootProps.
          // It uses that to know whether to apply the props automatically


          _this.getRootProps.called = true;
          _this.getRootProps.refKey = refKey;
          _this.getRootProps.suppressRefError = suppressRefError;

          var _this$getState = _this.getState(),
              isOpen = _this$getState.isOpen;

          return _extends((_extends2 = {}, _extends2[refKey] = handleRefs(ref, _this.rootRef), _extends2.role = 'combobox', _extends2['aria-expanded'] = isOpen, _extends2['aria-haspopup'] = 'listbox', _extends2['aria-owns'] = isOpen ? _this.menuId : null, _extends2['aria-labelledby'] = _this.labelId, _extends2), rest);
        };

        _this.keyDownHandlers = {
          ArrowDown: function ArrowDown(event) {
            var _this2 = this;

            event.preventDefault();

            if (this.getState().isOpen) {
              var amount = event.shiftKey ? 5 : 1;
              this.moveHighlightedIndex(amount, {
                type: keyDownArrowDown
              });
            } else {
              this.internalSetState({
                isOpen: true,
                type: keyDownArrowDown
              }, function () {
                var itemCount = _this2.getItemCount();

                if (itemCount > 0) {
                  var _this2$getState = _this2.getState(),
                      highlightedIndex = _this2$getState.highlightedIndex;

                  var nextHighlightedIndex = getNextWrappingIndex(1, highlightedIndex, itemCount, function (index) {
                    return _this2.getItemNodeFromIndex(index);
                  });

                  _this2.setHighlightedIndex(nextHighlightedIndex, {
                    type: keyDownArrowDown
                  });
                }
              });
            }
          },
          ArrowUp: function ArrowUp(event) {
            var _this3 = this;

            event.preventDefault();

            if (this.getState().isOpen) {
              var amount = event.shiftKey ? -5 : -1;
              this.moveHighlightedIndex(amount, {
                type: keyDownArrowUp
              });
            } else {
              this.internalSetState({
                isOpen: true,
                type: keyDownArrowUp
              }, function () {
                var itemCount = _this3.getItemCount();

                if (itemCount > 0) {
                  var _this3$getState = _this3.getState(),
                      highlightedIndex = _this3$getState.highlightedIndex;

                  var nextHighlightedIndex = getNextWrappingIndex(-1, highlightedIndex, itemCount, function (index) {
                    return _this3.getItemNodeFromIndex(index);
                  });

                  _this3.setHighlightedIndex(nextHighlightedIndex, {
                    type: keyDownArrowUp
                  });
                }
              });
            }
          },
          Enter: function Enter(event) {
            if (event.which === 229) {
              return;
            }

            var _this$getState2 = this.getState(),
                isOpen = _this$getState2.isOpen,
                highlightedIndex = _this$getState2.highlightedIndex;

            if (isOpen && highlightedIndex != null) {
              event.preventDefault();
              var item = this.items[highlightedIndex];
              var itemNode = this.getItemNodeFromIndex(highlightedIndex);

              if (item == null || itemNode && itemNode.hasAttribute('disabled')) {
                return;
              }

              this.selectHighlightedItem({
                type: keyDownEnter
              });
            }
          },
          Escape: function Escape(event) {
            event.preventDefault();
            this.reset({
              type: keyDownEscape,
              selectedItem: null,
              inputValue: ''
            });
          }
        };
        _this.buttonKeyDownHandlers = _extends({}, _this.keyDownHandlers, {
          ' ': function _(event) {
            event.preventDefault();
            this.toggleMenu({
              type: keyDownSpaceButton
            });
          }
        });
        _this.inputKeyDownHandlers = _extends({}, _this.keyDownHandlers, {
          Home: function Home(event) {
            var _this4 = this;

            event.preventDefault();
            var itemCount = this.getItemCount();

            var _this$getState3 = this.getState(),
                isOpen = _this$getState3.isOpen;

            if (itemCount <= 0 || !isOpen) {
              return;
            } // get next non-disabled starting downwards from 0 if that's disabled.


            var newHighlightedIndex = getNextNonDisabledIndex(1, 0, itemCount, function (index) {
              return _this4.getItemNodeFromIndex(index);
            }, false);
            this.setHighlightedIndex(newHighlightedIndex, {
              type: keyDownHome
            });
          },
          End: function End(event) {
            var _this5 = this;

            event.preventDefault();
            var itemCount = this.getItemCount();

            var _this$getState4 = this.getState(),
                isOpen = _this$getState4.isOpen;

            if (itemCount <= 0 || !isOpen) {
              return;
            } // get next non-disabled starting upwards from last index if that's disabled.


            var newHighlightedIndex = getNextNonDisabledIndex(-1, itemCount - 1, itemCount, function (index) {
              return _this5.getItemNodeFromIndex(index);
            }, false);
            this.setHighlightedIndex(newHighlightedIndex, {
              type: keyDownEnd
            });
          }
        });

        _this.getToggleButtonProps = function (_temp3) {
          var _ref3 = _temp3 === void 0 ? {} : _temp3,
              onClick = _ref3.onClick;
              _ref3.onPress;
              var onKeyDown = _ref3.onKeyDown,
              onKeyUp = _ref3.onKeyUp,
              onBlur = _ref3.onBlur,
              rest = _objectWithoutPropertiesLoose(_ref3, ["onClick", "onPress", "onKeyDown", "onKeyUp", "onBlur"]);

          var _this$getState5 = _this.getState(),
              isOpen = _this$getState5.isOpen;

          var enabledEventHandlers = {
            onClick: callAllEventHandlers(onClick, _this.buttonHandleClick),
            onKeyDown: callAllEventHandlers(onKeyDown, _this.buttonHandleKeyDown),
            onKeyUp: callAllEventHandlers(onKeyUp, _this.buttonHandleKeyUp),
            onBlur: callAllEventHandlers(onBlur, _this.buttonHandleBlur)
          };
          var eventHandlers = rest.disabled ? {} : enabledEventHandlers;
          return _extends({
            type: 'button',
            role: 'button',
            'aria-label': isOpen ? 'close menu' : 'open menu',
            'aria-haspopup': true,
            'data-toggle': true
          }, eventHandlers, {}, rest);
        };

        _this.buttonHandleKeyUp = function (event) {
          // Prevent click event from emitting in Firefox
          event.preventDefault();
        };

        _this.buttonHandleKeyDown = function (event) {
          var key = normalizeArrowKey(event);

          if (_this.buttonKeyDownHandlers[key]) {
            _this.buttonKeyDownHandlers[key].call(_assertThisInitialized(_this), event);
          }
        };

        _this.buttonHandleClick = function (event) {
          event.preventDefault(); // handle odd case for Safari and Firefox which
          // don't give the button the focus properly.

          /* istanbul ignore if (can't reasonably test this) */

          if (_this.props.environment.document.activeElement === _this.props.environment.document.body) {
            event.target.focus();
          } // to simplify testing components that use downshift, we'll not wrap this in a setTimeout
          // if the NODE_ENV is test. With the proper build system, this should be dead code eliminated
          // when building for production and should therefore have no impact on production code.


          {
            // Ensure that toggle of menu occurs after the potential blur event in iOS
            _this.internalSetTimeout(function () {
              return _this.toggleMenu({
                type: clickButton
              });
            });
          }
        };

        _this.buttonHandleBlur = function (event) {
          var blurTarget = event.target; // Save blur target for comparison with activeElement later
          // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not body element

          _this.internalSetTimeout(function () {
            if (!_this.isMouseDown && (_this.props.environment.document.activeElement == null || _this.props.environment.document.activeElement.id !== _this.inputId) && _this.props.environment.document.activeElement !== blurTarget // Do nothing if we refocus the same element again (to solve issue in Safari on iOS)
            ) {
              _this.reset({
                type: blurButton
              });
            }
          });
        };

        _this.getLabelProps = function (props) {
          return _extends({
            htmlFor: _this.inputId,
            id: _this.labelId
          }, props);
        };

        _this.getInputProps = function (_temp4) {
          var _ref4 = _temp4 === void 0 ? {} : _temp4,
              onKeyDown = _ref4.onKeyDown,
              onBlur = _ref4.onBlur,
              onChange = _ref4.onChange,
              onInput = _ref4.onInput;
              _ref4.onChangeText;
              var rest = _objectWithoutPropertiesLoose(_ref4, ["onKeyDown", "onBlur", "onChange", "onInput", "onChangeText"]);

          var onChangeKey;
          var eventHandlers = {};
          /* istanbul ignore next (preact) */

          onChangeKey = 'onChange';

          var _this$getState6 = _this.getState(),
              inputValue = _this$getState6.inputValue,
              isOpen = _this$getState6.isOpen,
              highlightedIndex = _this$getState6.highlightedIndex;

          if (!rest.disabled) {
            var _eventHandlers;

            eventHandlers = (_eventHandlers = {}, _eventHandlers[onChangeKey] = callAllEventHandlers(onChange, onInput, _this.inputHandleChange), _eventHandlers.onKeyDown = callAllEventHandlers(onKeyDown, _this.inputHandleKeyDown), _eventHandlers.onBlur = callAllEventHandlers(onBlur, _this.inputHandleBlur), _eventHandlers);
          }
          /* istanbul ignore if (react-native) */


          return _extends({
            'aria-autocomplete': 'list',
            'aria-activedescendant': isOpen && typeof highlightedIndex === 'number' && highlightedIndex >= 0 ? _this.getItemId(highlightedIndex) : null,
            'aria-controls': isOpen ? _this.menuId : null,
            'aria-labelledby': _this.labelId,
            // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion
            // revert back since autocomplete="nope" is ignored on latest Chrome and Opera
            autoComplete: 'off',
            value: inputValue,
            id: _this.inputId
          }, eventHandlers, {}, rest);
        };

        _this.inputHandleKeyDown = function (event) {
          var key = normalizeArrowKey(event);

          if (key && _this.inputKeyDownHandlers[key]) {
            _this.inputKeyDownHandlers[key].call(_assertThisInitialized(_this), event);
          }
        };

        _this.inputHandleChange = function (event) {
          _this.internalSetState({
            type: changeInput,
            isOpen: true,
            inputValue: event.target.value,
            highlightedIndex: _this.props.defaultHighlightedIndex
          });
        };

        _this.inputHandleBlur = function () {
          // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not the body element
          _this.internalSetTimeout(function () {
            var downshiftButtonIsActive = _this.props.environment.document && !!_this.props.environment.document.activeElement && !!_this.props.environment.document.activeElement.dataset && _this.props.environment.document.activeElement.dataset.toggle && _this._rootNode && _this._rootNode.contains(_this.props.environment.document.activeElement);

            if (!_this.isMouseDown && !downshiftButtonIsActive) {
              _this.reset({
                type: blurInput
              });
            }
          });
        };

        _this.menuRef = function (node) {
          _this._menuNode = node;
        };

        _this.getMenuProps = function (_temp5, _temp6) {
          var _extends3;

          var _ref5 = _temp5 === void 0 ? {} : _temp5,
              _ref5$refKey = _ref5.refKey,
              refKey = _ref5$refKey === void 0 ? 'ref' : _ref5$refKey,
              ref = _ref5.ref,
              props = _objectWithoutPropertiesLoose(_ref5, ["refKey", "ref"]);

          var _ref6 = _temp6 === void 0 ? {} : _temp6,
              _ref6$suppressRefErro = _ref6.suppressRefError,
              suppressRefError = _ref6$suppressRefErro === void 0 ? false : _ref6$suppressRefErro;

          _this.getMenuProps.called = true;
          _this.getMenuProps.refKey = refKey;
          _this.getMenuProps.suppressRefError = suppressRefError;
          return _extends((_extends3 = {}, _extends3[refKey] = handleRefs(ref, _this.menuRef), _extends3.role = 'listbox', _extends3['aria-labelledby'] = props && props['aria-label'] ? null : _this.labelId, _extends3.id = _this.menuId, _extends3), props);
        };

        _this.getItemProps = function (_temp7) {
          var _enabledEventHandlers;

          var _ref7 = _temp7 === void 0 ? {} : _temp7,
              onMouseMove = _ref7.onMouseMove,
              onMouseDown = _ref7.onMouseDown,
              onClick = _ref7.onClick;
              _ref7.onPress;
              var index = _ref7.index,
              _ref7$item = _ref7.item,
              item = _ref7$item === void 0 ? requiredProp('getItemProps', 'item') : _ref7$item,
              rest = _objectWithoutPropertiesLoose(_ref7, ["onMouseMove", "onMouseDown", "onClick", "onPress", "index", "item"]);

          if (index === undefined) {
            _this.items.push(item);

            index = _this.items.indexOf(item);
          } else {
            _this.items[index] = item;
          }

          var onSelectKey = 'onClick';
          var customClickHandler = onClick;
          var enabledEventHandlers = (_enabledEventHandlers = {
            // onMouseMove is used over onMouseEnter here. onMouseMove
            // is only triggered on actual mouse movement while onMouseEnter
            // can fire on DOM changes, interrupting keyboard navigation
            onMouseMove: callAllEventHandlers(onMouseMove, function () {
              if (index === _this.getState().highlightedIndex) {
                return;
              }

              _this.setHighlightedIndex(index, {
                type: itemMouseEnter
              }); // We never want to manually scroll when changing state based
              // on `onMouseMove` because we will be moving the element out
              // from under the user which is currently scrolling/moving the
              // cursor


              _this.avoidScrolling = true;

              _this.internalSetTimeout(function () {
                return _this.avoidScrolling = false;
              }, 250);
            }),
            onMouseDown: callAllEventHandlers(onMouseDown, function (event) {
              // This prevents the activeElement from being changed
              // to the item so it can remain with the current activeElement
              // which is a more common use case.
              event.preventDefault();
            })
          }, _enabledEventHandlers[onSelectKey] = callAllEventHandlers(customClickHandler, function () {
            _this.selectItemAtIndex(index, {
              type: clickItem
            });
          }), _enabledEventHandlers); // Passing down the onMouseDown handler to prevent redirect
          // of the activeElement if clicking on disabled items

          var eventHandlers = rest.disabled ? {
            onMouseDown: enabledEventHandlers.onMouseDown
          } : enabledEventHandlers;
          return _extends({
            id: _this.getItemId(index),
            role: 'option',
            'aria-selected': _this.getState().highlightedIndex === index
          }, eventHandlers, {}, rest);
        };

        _this.clearItems = function () {
          _this.items = [];
        };

        _this.reset = function (otherStateToSet, cb) {
          if (otherStateToSet === void 0) {
            otherStateToSet = {};
          }

          otherStateToSet = pickState(otherStateToSet);

          _this.internalSetState(function (_ref8) {
            var selectedItem = _ref8.selectedItem;
            return _extends({
              isOpen: _this.props.defaultIsOpen,
              highlightedIndex: _this.props.defaultHighlightedIndex,
              inputValue: _this.props.itemToString(selectedItem)
            }, otherStateToSet);
          }, cb);
        };

        _this.toggleMenu = function (otherStateToSet, cb) {
          if (otherStateToSet === void 0) {
            otherStateToSet = {};
          }

          otherStateToSet = pickState(otherStateToSet);

          _this.internalSetState(function (_ref9) {
            var isOpen = _ref9.isOpen;
            return _extends({
              isOpen: !isOpen
            }, isOpen && {
              highlightedIndex: _this.props.defaultHighlightedIndex
            }, {}, otherStateToSet);
          }, function () {
            var _this$getState7 = _this.getState(),
                isOpen = _this$getState7.isOpen,
                highlightedIndex = _this$getState7.highlightedIndex;

            if (isOpen) {
              if (_this.getItemCount() > 0 && typeof highlightedIndex === 'number') {
                _this.setHighlightedIndex(highlightedIndex, otherStateToSet);
              }
            }

            cbToCb(cb)();
          });
        };

        _this.openMenu = function (cb) {
          _this.internalSetState({
            isOpen: true
          }, cb);
        };

        _this.closeMenu = function (cb) {
          _this.internalSetState({
            isOpen: false
          }, cb);
        };

        _this.updateStatus = debounce$2(function () {
          var state = _this.getState();

          var item = _this.items[state.highlightedIndex];

          var resultCount = _this.getItemCount();

          var status = _this.props.getA11yStatusMessage(_extends({
            itemToString: _this.props.itemToString,
            previousResultCount: _this.previousResultCount,
            resultCount: resultCount,
            highlightedItem: item
          }, state));

          _this.previousResultCount = resultCount;
          setStatus(status, _this.props.environment.document);
        }, 200); // fancy destructuring + defaults + aliases
        // this basically says each value of state should either be set to
        // the initial value or the default value if the initial value is not provided

        var _this$props = _this.props,
            defaultHighlightedIndex = _this$props.defaultHighlightedIndex,
            _this$props$initialHi = _this$props.initialHighlightedIndex,
            _highlightedIndex = _this$props$initialHi === void 0 ? defaultHighlightedIndex : _this$props$initialHi,
            defaultIsOpen = _this$props.defaultIsOpen,
            _this$props$initialIs = _this$props.initialIsOpen,
            _isOpen = _this$props$initialIs === void 0 ? defaultIsOpen : _this$props$initialIs,
            _this$props$initialIn = _this$props.initialInputValue,
            _inputValue = _this$props$initialIn === void 0 ? '' : _this$props$initialIn,
            _this$props$initialSe = _this$props.initialSelectedItem,
            _selectedItem = _this$props$initialSe === void 0 ? null : _this$props$initialSe;

        var _state = _this.getState({
          highlightedIndex: _highlightedIndex,
          isOpen: _isOpen,
          inputValue: _inputValue,
          selectedItem: _selectedItem
        });

        if (_state.selectedItem != null && _this.props.initialInputValue === undefined) {
          _state.inputValue = _this.props.itemToString(_state.selectedItem);
        }

        _this.state = _state;
        return _this;
      }

      var _proto = Downshift.prototype;
      /**
       * Clear all running timeouts
       */

      _proto.internalClearTimeouts = function internalClearTimeouts() {
        this.timeoutIds.forEach(function (id) {
          clearTimeout(id);
        });
        this.timeoutIds = [];
      }
      /**
       * Gets the state based on internal state or props
       * If a state value is passed via props, then that
       * is the value given, otherwise it's retrieved from
       * stateToMerge
       *
       * @param {Object} stateToMerge defaults to this.state
       * @return {Object} the state
       */
      ;

      _proto.getState = function getState$1(stateToMerge) {
        if (stateToMerge === void 0) {
          stateToMerge = this.state;
        }

        return getState(stateToMerge, this.props);
      };

      _proto.getItemCount = function getItemCount() {
        // things read better this way. They're in priority order:
        // 1. `this.itemCount`
        // 2. `this.props.itemCount`
        // 3. `this.items.length`
        var itemCount = this.items.length;

        if (this.itemCount != null) {
          itemCount = this.itemCount;
        } else if (this.props.itemCount !== undefined) {
          itemCount = this.props.itemCount;
        }

        return itemCount;
      };

      _proto.getItemNodeFromIndex = function getItemNodeFromIndex(index) {
        return this.props.environment.document.getElementById(this.getItemId(index));
      };

      _proto.scrollHighlightedItemIntoView = function scrollHighlightedItemIntoView() {
        /* istanbul ignore else (react-native) */
        {
          var node = this.getItemNodeFromIndex(this.getState().highlightedIndex);
          this.props.scrollIntoView(node, this._menuNode);
        }
      };

      _proto.moveHighlightedIndex = function moveHighlightedIndex(amount, otherStateToSet) {
        var _this6 = this;

        var itemCount = this.getItemCount();

        var _this$getState8 = this.getState(),
            highlightedIndex = _this$getState8.highlightedIndex;

        if (itemCount > 0) {
          var nextHighlightedIndex = getNextWrappingIndex(amount, highlightedIndex, itemCount, function (index) {
            return _this6.getItemNodeFromIndex(index);
          });
          this.setHighlightedIndex(nextHighlightedIndex, otherStateToSet);
        }
      };

      _proto.getStateAndHelpers = function getStateAndHelpers() {
        var _this$getState9 = this.getState(),
            highlightedIndex = _this$getState9.highlightedIndex,
            inputValue = _this$getState9.inputValue,
            selectedItem = _this$getState9.selectedItem,
            isOpen = _this$getState9.isOpen;

        var itemToString = this.props.itemToString;
        var id = this.id;
        var getRootProps = this.getRootProps,
            getToggleButtonProps = this.getToggleButtonProps,
            getLabelProps = this.getLabelProps,
            getMenuProps = this.getMenuProps,
            getInputProps = this.getInputProps,
            getItemProps = this.getItemProps,
            openMenu = this.openMenu,
            closeMenu = this.closeMenu,
            toggleMenu = this.toggleMenu,
            selectItem = this.selectItem,
            selectItemAtIndex = this.selectItemAtIndex,
            selectHighlightedItem = this.selectHighlightedItem,
            setHighlightedIndex = this.setHighlightedIndex,
            clearSelection = this.clearSelection,
            clearItems = this.clearItems,
            reset = this.reset,
            setItemCount = this.setItemCount,
            unsetItemCount = this.unsetItemCount,
            setState = this.internalSetState;
        return {
          // prop getters
          getRootProps: getRootProps,
          getToggleButtonProps: getToggleButtonProps,
          getLabelProps: getLabelProps,
          getMenuProps: getMenuProps,
          getInputProps: getInputProps,
          getItemProps: getItemProps,
          // actions
          reset: reset,
          openMenu: openMenu,
          closeMenu: closeMenu,
          toggleMenu: toggleMenu,
          selectItem: selectItem,
          selectItemAtIndex: selectItemAtIndex,
          selectHighlightedItem: selectHighlightedItem,
          setHighlightedIndex: setHighlightedIndex,
          clearSelection: clearSelection,
          clearItems: clearItems,
          setItemCount: setItemCount,
          unsetItemCount: unsetItemCount,
          setState: setState,
          // props
          itemToString: itemToString,
          // derived
          id: id,
          // state
          highlightedIndex: highlightedIndex,
          inputValue: inputValue,
          isOpen: isOpen,
          selectedItem: selectedItem
        };
      } //////////////////////////// ROOT
      ;

      _proto.componentDidMount = function componentDidMount() {
        var _this7 = this;
        /* istanbul ignore if (react-native) */


        if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {
          validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);
        }
        /* istanbul ignore if (react-native) */


        {
          // this.isMouseDown helps us track whether the mouse is currently held down.
          // This is useful when the user clicks on an item in the list, but holds the mouse
          // down long enough for the list to disappear (because the blur event fires on the input)
          // this.isMouseDown is used in the blur handler on the input to determine whether the blur event should
          // trigger hiding the menu.
          var onMouseDown = function onMouseDown() {
            _this7.isMouseDown = true;
          };

          var onMouseUp = function onMouseUp(event) {
            _this7.isMouseDown = false; // if the target element or the activeElement is within a downshift node
            // then we don't want to reset downshift

            var contextWithinDownshift = targetWithinDownshift(event.target, [_this7._rootNode, _this7._menuNode], _this7.props.environment.document);

            if (!contextWithinDownshift && _this7.getState().isOpen) {
              _this7.reset({
                type: mouseUp
              }, function () {
                return _this7.props.onOuterClick(_this7.getStateAndHelpers());
              });
            }
          }; // Touching an element in iOS gives focus and hover states, but touching out of
          // the element will remove hover, and persist the focus state, resulting in the
          // blur event not being triggered.
          // this.isTouchMove helps us track whether the user is tapping or swiping on a touch screen.
          // If the user taps outside of Downshift, the component should be reset,
          // but not if the user is swiping


          var onTouchStart = function onTouchStart() {
            _this7.isTouchMove = false;
          };

          var onTouchMove = function onTouchMove() {
            _this7.isTouchMove = true;
          };

          var onTouchEnd = function onTouchEnd(event) {
            var contextWithinDownshift = targetWithinDownshift(event.target, [_this7._rootNode, _this7._menuNode], _this7.props.environment.document, false);

            if (!_this7.isTouchMove && !contextWithinDownshift && _this7.getState().isOpen) {
              _this7.reset({
                type: touchEnd
              }, function () {
                return _this7.props.onOuterClick(_this7.getStateAndHelpers());
              });
            }
          };

          var environment = this.props.environment;
          environment.addEventListener('mousedown', onMouseDown);
          environment.addEventListener('mouseup', onMouseUp);
          environment.addEventListener('touchstart', onTouchStart);
          environment.addEventListener('touchmove', onTouchMove);
          environment.addEventListener('touchend', onTouchEnd);

          this.cleanup = function () {
            _this7.internalClearTimeouts();

            _this7.updateStatus.cancel();

            environment.removeEventListener('mousedown', onMouseDown);
            environment.removeEventListener('mouseup', onMouseUp);
            environment.removeEventListener('touchstart', onTouchStart);
            environment.removeEventListener('touchmove', onTouchMove);
            environment.removeEventListener('touchend', onTouchEnd);
          };
        }
      };

      _proto.shouldScroll = function shouldScroll(prevState, prevProps) {
        var _ref10 = this.props.highlightedIndex === undefined ? this.getState() : this.props,
            currentHighlightedIndex = _ref10.highlightedIndex;

        var _ref11 = prevProps.highlightedIndex === undefined ? prevState : prevProps,
            prevHighlightedIndex = _ref11.highlightedIndex;

        var scrollWhenOpen = currentHighlightedIndex && this.getState().isOpen && !prevState.isOpen;
        return scrollWhenOpen || currentHighlightedIndex !== prevHighlightedIndex;
      };

      _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
        {
          validateControlledUnchanged(prevProps, this.props);
          /* istanbul ignore if (react-native) */

          if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {
            validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);
          }
        }

        if (isControlledProp(this.props, 'selectedItem') && this.props.selectedItemChanged(prevProps.selectedItem, this.props.selectedItem)) {
          this.internalSetState({
            type: controlledPropUpdatedSelectedItem,
            inputValue: this.props.itemToString(this.props.selectedItem)
          });
        }

        if (!this.avoidScrolling && this.shouldScroll(prevState, prevProps)) {
          this.scrollHighlightedItemIntoView();
        }
        /* istanbul ignore else (react-native) */


        this.updateStatus();
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        this.cleanup(); // avoids memory leak
      };

      _proto.render = function render() {
        var children = unwrapArray(this.props.children, noop$2); // because the items are rerendered every time we call the children
        // we clear this out each render and it will be populated again as
        // getItemProps is called.

        this.clearItems(); // we reset this so we know whether the user calls getRootProps during
        // this render. If they do then we don't need to do anything,
        // if they don't then we need to clone the element they return and
        // apply the props for them.

        this.getRootProps.called = false;
        this.getRootProps.refKey = undefined;
        this.getRootProps.suppressRefError = undefined; // we do something similar for getMenuProps

        this.getMenuProps.called = false;
        this.getMenuProps.refKey = undefined;
        this.getMenuProps.suppressRefError = undefined; // we do something similar for getLabelProps

        this.getLabelProps.called = false; // and something similar for getInputProps

        this.getInputProps.called = false;
        var element = unwrapArray(children(this.getStateAndHelpers()));

        if (!element) {
          return null;
        }

        if (this.getRootProps.called || this.props.suppressRefError) {
          if (!this.getRootProps.suppressRefError && !this.props.suppressRefError) {
            validateGetRootPropsCalledCorrectly(element, this.getRootProps);
          }

          return element;
        } else if (isDOMElement(element)) {
          // they didn't apply the root props, but we can clone
          // this and apply the props ourselves
          return /*#__PURE__*/React.cloneElement(element, this.getRootProps(getElementProps(element)));
        }
        /* istanbul ignore else */


        {
          // they didn't apply the root props, but they need to
          // otherwise we can't query around the autocomplete
          throw new Error('downshift: If you return a non-DOM element, you must apply the getRootProps function');
        }
      };

      return Downshift;
    }(React.Component);

    Downshift.defaultProps = {
      defaultHighlightedIndex: null,
      defaultIsOpen: false,
      getA11yStatusMessage: getA11yStatusMessage,
      itemToString: function itemToString(i) {
        if (i == null) {
          return '';
        }

        if (isPlainObject(i) && !i.hasOwnProperty('toString')) {
          // eslint-disable-next-line no-console
          console.warn('downshift: An object was passed to the default implementation of `itemToString`. You should probably provide your own `itemToString` implementation. Please refer to the `itemToString` API documentation.', 'The object that was passed:', i);
        }

        return String(i);
      },
      onStateChange: noop$2,
      onInputValueChange: noop$2,
      onUserAction: noop$2,
      onChange: noop$2,
      onSelect: noop$2,
      onOuterClick: noop$2,
      selectedItemChanged: function selectedItemChanged(prevItem, item) {
        return prevItem !== item;
      },
      environment: typeof window === 'undefined'
      /* istanbul ignore next (ssr) */
      ? {} : window,
      stateReducer: function stateReducer(state, stateToSet) {
        return stateToSet;
      },
      suppressRefError: false,
      scrollIntoView: scrollIntoView
    };
    Downshift.stateChangeTypes = stateChangeTypes;
    return Downshift;
  }();

  Downshift.propTypes = {
    children: PropTypes__default["default"].func,
    defaultHighlightedIndex: PropTypes__default["default"].number,
    defaultIsOpen: PropTypes__default["default"].bool,
    initialHighlightedIndex: PropTypes__default["default"].number,
    initialSelectedItem: PropTypes__default["default"].any,
    initialInputValue: PropTypes__default["default"].string,
    initialIsOpen: PropTypes__default["default"].bool,
    getA11yStatusMessage: PropTypes__default["default"].func,
    itemToString: PropTypes__default["default"].func,
    onChange: PropTypes__default["default"].func,
    onSelect: PropTypes__default["default"].func,
    onStateChange: PropTypes__default["default"].func,
    onInputValueChange: PropTypes__default["default"].func,
    onUserAction: PropTypes__default["default"].func,
    onOuterClick: PropTypes__default["default"].func,
    selectedItemChanged: PropTypes__default["default"].func,
    stateReducer: PropTypes__default["default"].func,
    itemCount: PropTypes__default["default"].number,
    id: PropTypes__default["default"].string,
    environment: PropTypes__default["default"].shape({
      addEventListener: PropTypes__default["default"].func,
      removeEventListener: PropTypes__default["default"].func,
      document: PropTypes__default["default"].shape({
        getElementById: PropTypes__default["default"].func,
        activeElement: PropTypes__default["default"].any,
        body: PropTypes__default["default"].any
      })
    }),
    suppressRefError: PropTypes__default["default"].bool,
    scrollIntoView: PropTypes__default["default"].func,
    // things we keep in state for uncontrolled components
    // but can accept as props for controlled components

    /* eslint-disable react/no-unused-prop-types */
    selectedItem: PropTypes__default["default"].any,
    isOpen: PropTypes__default["default"].bool,
    inputValue: PropTypes__default["default"].string,
    highlightedIndex: PropTypes__default["default"].number,
    labelId: PropTypes__default["default"].string,
    inputId: PropTypes__default["default"].string,
    menuId: PropTypes__default["default"].string,
    getItemId: PropTypes__default["default"].func
    /* eslint-enable react/no-unused-prop-types */

  } ;

  function validateGetMenuPropsCalledCorrectly(node, _ref12) {
    var refKey = _ref12.refKey;

    if (!node) {
      // eslint-disable-next-line no-console
      console.error("downshift: The ref prop \"" + refKey + "\" from getMenuProps was not applied correctly on your menu element.");
    }
  }

  function validateGetRootPropsCalledCorrectly(element, _ref13) {
    var refKey = _ref13.refKey;
    var refKeySpecified = refKey !== 'ref';
    var isComposite = !isDOMElement(element);

    if (isComposite && !refKeySpecified && !reactIs.exports.isForwardRef(element)) {
      // eslint-disable-next-line no-console
      console.error('downshift: You returned a non-DOM element. You must specify a refKey in getRootProps');
    } else if (!isComposite && refKeySpecified) {
      // eslint-disable-next-line no-console
      console.error("downshift: You returned a DOM element. You should not specify a refKey in getRootProps. You specified \"" + refKey + "\"");
    }

    if (!reactIs.exports.isForwardRef(element) && !getElementProps(element)[refKey]) {
      // eslint-disable-next-line no-console
      console.error("downshift: You must apply the ref prop \"" + refKey + "\" from getRootProps onto your root element.");
    }
  }

  function validateControlledUnchanged(prevProps, nextProps) {
    var warningDescription = "This prop should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Downshift element for the lifetime of the component. More info: https://github.com/downshift-js/downshift#control-props";
    ['selectedItem', 'isOpen', 'inputValue', 'highlightedIndex'].forEach(function (propKey) {
      if (prevProps[propKey] !== undefined && nextProps[propKey] === undefined) {
        // eslint-disable-next-line no-console
        console.error("downshift: A component has changed the controlled prop \"" + propKey + "\" to be uncontrolled. " + warningDescription);
      } else if (prevProps[propKey] === undefined && nextProps[propKey] !== undefined) {
        // eslint-disable-next-line no-console
        console.error("downshift: A component has changed the uncontrolled prop \"" + propKey + "\" to be controlled. " + warningDescription);
      }
    });
  }

  var dropdownDefaultStateValues = {
    highlightedIndex: -1,
    isOpen: false,
    selectedItem: null,
    inputValue: ''
  };

  function callOnChangeProps(action, state, newState) {
    var props = action.props,
        type = action.type;
    var changes = {};
    Object.keys(state).forEach(function (key) {
      invokeOnChangeHandler(key, props, state, newState);

      if (newState[key] !== state[key]) {
        changes[key] = newState[key];
      }
    });

    if (props.onStateChange && Object.keys(changes).length) {
      props.onStateChange(_extends({
        type: type
      }, changes));
    }
  }

  function invokeOnChangeHandler(key, props, state, newState) {
    var handler = "on" + capitalizeString(key) + "Change";

    if (props[handler] && newState[key] !== undefined && newState[key] !== state[key]) {
      props[handler](newState);
    }
  }
  /**
   * Default state reducer that returns the changes.
   *
   * @param {Object} s state.
   * @param {Object} a action with changes.
   * @returns {Object} changes.
   */


  function stateReducer(s, a) {
    return a.changes;
  }
  /**
   * Returns a message to be added to aria-live region when item is selected.
   *
   * @param {Object} selectionParameters Parameters required to build the message.
   * @returns {string} The a11y message.
   */


  function getA11ySelectionMessage(selectionParameters) {
    var selectedItem = selectionParameters.selectedItem,
        itemToStringLocal = selectionParameters.itemToString;
    return selectedItem ? itemToStringLocal(selectedItem) + " has been selected." : '';
  }
  /**
   * Debounced call for updating the a11y message.
   */


  var updateA11yStatus = debounce$2(function (getA11yMessage, document) {
    setStatus(getA11yMessage(), document);
  }, 200);

  function getElementIds(_ref) {
    var id = _ref.id,
        labelId = _ref.labelId,
        menuId = _ref.menuId,
        getItemId = _ref.getItemId,
        toggleButtonId = _ref.toggleButtonId;
    var uniqueId = id === undefined ? "downshift-" + generateId() : id;
    return {
      labelId: labelId || uniqueId + "-label",
      menuId: menuId || uniqueId + "-menu",
      getItemId: getItemId || function (index) {
        return uniqueId + "-item-" + index;
      },
      toggleButtonId: toggleButtonId || uniqueId + "-toggle-button"
    };
  }

  function getItemIndex(index, item, items) {
    if (index !== undefined) {
      return index;
    }

    if (items.length === 0) {
      return -1;
    }

    return items.indexOf(item);
  }

  function itemToString$1(item) {
    return item ? String(item) : '';
  }

  function getPropTypesValidator(caller, propTypes) {
    // istanbul ignore next
    return function (options) {
      if (options === void 0) {
        options = {};
      }

      Object.keys(propTypes).forEach(function (key) {
        PropTypes__default["default"].checkPropTypes(propTypes, options, key, caller.name);
      });
    };
  }

  function isAcceptedCharacterKey(key) {
    return /^\S{1}$/.test(key);
  }

  function capitalizeString(string) {
    return "" + string.slice(0, 1).toUpperCase() + string.slice(1);
  }
  /**
   * Computes the controlled state using a the previous state, props,
   * two reducers, one from downshift and an optional one from the user.
   * Also calls the onChange handlers for state values that have changed.
   *
   * @param {Function} reducer Reducer function from downshift.
   * @param {Object} initialState Initial state of the hook.
   * @param {Object} props The hook props.
   * @returns {Array} An array with the state and an action dispatcher.
   */


  function useControlledState(reducer, initialState, props) {
    var _useState = React.useState(initialState),
        uncontrolledState = _useState[0],
        setState = _useState[1];

    var state = getState(uncontrolledState, props);

    var dispatch = function dispatch(action) {
      var stateReducerFromProps = action.props.stateReducer;
      var changes = reducer(state, action);
      var newState = stateReducerFromProps(state, _extends({}, action, {
        changes: changes
      }));
      callOnChangeProps(action, state, newState);
      setState(newState);
    };

    return [getState(state, props), function dispatchWithProps(action) {
      return dispatch(_extends({
        props: props
      }, action));
    }];
  }

  var defaultProps = {
    itemToString: itemToString$1,
    stateReducer: stateReducer,
    getA11ySelectionMessage: getA11ySelectionMessage,
    scrollIntoView: scrollIntoView,
    circularNavigation: false,
    environment: typeof window === 'undefined'
    /* istanbul ignore next (ssr) */
    ? {} : window
  };

  function getDefaultValue(props, propKey, defaultStateValues) {
    if (defaultStateValues === void 0) {
      defaultStateValues = dropdownDefaultStateValues;
    }

    var defaultPropKey = "default" + capitalizeString(propKey);

    if (defaultPropKey in props) {
      return props[defaultPropKey];
    }

    return defaultStateValues[propKey];
  }

  function getInitialValue(props, propKey, defaultStateValues) {
    if (defaultStateValues === void 0) {
      defaultStateValues = dropdownDefaultStateValues;
    }

    if (propKey in props) {
      return props[propKey];
    }

    var initialPropKey = "initial" + capitalizeString(propKey);

    if (initialPropKey in props) {
      return props[initialPropKey];
    }

    return getDefaultValue(props, propKey, defaultStateValues);
  }

  function getInitialState(props) {
    var selectedItem = getInitialValue(props, 'selectedItem');
    var isOpen = getInitialValue(props, 'isOpen');
    var highlightedIndex = getInitialValue(props, 'highlightedIndex');
    var inputValue = getInitialValue(props, 'inputValue');
    return {
      highlightedIndex: highlightedIndex < 0 && selectedItem ? props.items.indexOf(selectedItem) : highlightedIndex,
      isOpen: isOpen,
      selectedItem: selectedItem,
      inputValue: inputValue
    };
  }

  function getHighlightedIndexOnOpen(props, state, offset, getItemNodeFromIndex) {
    var items = props.items,
        initialHighlightedIndex = props.initialHighlightedIndex,
        defaultHighlightedIndex = props.defaultHighlightedIndex;
    var selectedItem = state.selectedItem,
        highlightedIndex = state.highlightedIndex; // initialHighlightedIndex will give value to highlightedIndex on initial state only.

    if (initialHighlightedIndex !== undefined && highlightedIndex === initialHighlightedIndex) {
      return initialHighlightedIndex;
    }

    if (defaultHighlightedIndex !== undefined) {
      return defaultHighlightedIndex;
    }

    if (selectedItem) {
      if (offset === 0) {
        return items.indexOf(selectedItem);
      }

      return getNextWrappingIndex(offset, items.indexOf(selectedItem), items.length, getItemNodeFromIndex, false);
    }

    if (offset === 0) {
      return -1;
    }

    return offset < 0 ? items.length - 1 : 0;
  }

  function getItemIndexByCharacterKey(keysSoFar, highlightedIndex, items, itemToStringParam, getItemNodeFromIndex) {
    var lowerCasedItemStrings = items.map(function (item) {
      return itemToStringParam(item).toLowerCase();
    });
    var lowerCasedKeysSoFar = keysSoFar.toLowerCase();

    var isValid = function isValid(itemString, index) {
      var element = getItemNodeFromIndex(index);
      return itemString.startsWith(lowerCasedKeysSoFar) && !(element && element.hasAttribute('disabled'));
    };

    for (var index = highlightedIndex + 1; index < lowerCasedItemStrings.length; index++) {
      var itemString = lowerCasedItemStrings[index];

      if (isValid(itemString, index)) {
        return index;
      }
    }

    for (var _index = 0; _index < highlightedIndex; _index++) {
      var _itemString = lowerCasedItemStrings[_index];

      if (isValid(_itemString, _index)) {
        return _index;
      }
    }

    return highlightedIndex;
  }

  var propTypes = {
    items: PropTypes__default["default"].array.isRequired,
    itemToString: PropTypes__default["default"].func,
    getA11yStatusMessage: PropTypes__default["default"].func,
    getA11ySelectionMessage: PropTypes__default["default"].func,
    circularNavigation: PropTypes__default["default"].bool,
    highlightedIndex: PropTypes__default["default"].number,
    defaultHighlightedIndex: PropTypes__default["default"].number,
    initialHighlightedIndex: PropTypes__default["default"].number,
    isOpen: PropTypes__default["default"].bool,
    defaultIsOpen: PropTypes__default["default"].bool,
    initialIsOpen: PropTypes__default["default"].bool,
    selectedItem: PropTypes__default["default"].any,
    initialSelectedItem: PropTypes__default["default"].any,
    defaultSelectedItem: PropTypes__default["default"].any,
    id: PropTypes__default["default"].string,
    labelId: PropTypes__default["default"].string,
    menuId: PropTypes__default["default"].string,
    getItemId: PropTypes__default["default"].func,
    toggleButtonId: PropTypes__default["default"].string,
    stateReducer: PropTypes__default["default"].func,
    onSelectedItemChange: PropTypes__default["default"].func,
    onHighlightedIndexChange: PropTypes__default["default"].func,
    onStateChange: PropTypes__default["default"].func,
    onIsOpenChange: PropTypes__default["default"].func,
    environment: PropTypes__default["default"].shape({
      addEventListener: PropTypes__default["default"].func,
      removeEventListener: PropTypes__default["default"].func,
      document: PropTypes__default["default"].shape({
        getElementById: PropTypes__default["default"].func,
        activeElement: PropTypes__default["default"].any,
        body: PropTypes__default["default"].any
      })
    })
  };
  /**
   * Default implementation for status message. Only added when menu is open.
   * Will specift if there are results in the list, and if so, how many,
   * and what keys are relevant.
   *
   * @param {Object} param the downshift state and other relevant properties
   * @return {String} the a11y status message
   */

  function getA11yStatusMessage$1(_ref) {
    var isOpen = _ref.isOpen,
        resultCount = _ref.resultCount,
        previousResultCount = _ref.previousResultCount;

    if (!isOpen) {
      return '';
    }

    if (!resultCount) {
      return 'No results are available.';
    }

    if (resultCount !== previousResultCount) {
      return resultCount + " result" + (resultCount === 1 ? ' is' : 's are') + " available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select.";
    }

    return '';
  }

  var defaultProps$1 = _extends({}, defaultProps, {
    getA11yStatusMessage: getA11yStatusMessage$1
  });

  var MenuKeyDownArrowDown$1 = '__menu_keydown_arrow_down__' ;
  var MenuKeyDownArrowUp$1 = '__menu_keydown_arrow_up__' ;
  var MenuKeyDownEscape$1 = '__menu_keydown_escape__' ;
  var MenuKeyDownHome = '__menu_keydown_home__' ;
  var MenuKeyDownEnd = '__menu_keydown_end__' ;
  var MenuKeyDownEnter$1 = '__menu_keydown_enter__' ;
  var MenuKeyDownSpaceButton$1 = '__menu_keydown_space_button__' ;
  var MenuKeyDownCharacter = '__menu_keydown_character__' ;
  var MenuBlur$1 = '__menu_blur__' ;
  var MenuMouseLeave = '__menu_mouse_leave__' ;
  var ItemMouseMove = '__item_mouse_move__' ;
  var ItemClick$1 = '__item_click__' ;
  var ToggleButtonClick$1 = '__togglebutton_click__' ;
  var ToggleButtonKeyDownArrowDown = '__togglebutton_keydown_arrow_down__' ;
  var ToggleButtonKeyDownArrowUp = '__togglebutton_keydown_arrow_up__' ;
  var ToggleButtonKeyDownCharacter = '__togglebutton_keydown_character__' ;
  var FunctionToggleMenu = '__function_toggle_menu__' ;
  var FunctionOpenMenu = '__function_open_menu__' ;
  var FunctionCloseMenu = '__function_close_menu__' ;
  var FunctionSetHighlightedIndex = '__function_set_highlighted_index__' ;
  var FunctionSelectItem = '__function_select_item__' ;
  var FunctionSetInputValue = '__function_set_input_value__' ;
  var FunctionReset = '__function_reset__' ;
  var stateChangeTypes$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    MenuKeyDownArrowDown: MenuKeyDownArrowDown$1,
    MenuKeyDownArrowUp: MenuKeyDownArrowUp$1,
    MenuKeyDownEscape: MenuKeyDownEscape$1,
    MenuKeyDownHome: MenuKeyDownHome,
    MenuKeyDownEnd: MenuKeyDownEnd,
    MenuKeyDownEnter: MenuKeyDownEnter$1,
    MenuKeyDownSpaceButton: MenuKeyDownSpaceButton$1,
    MenuKeyDownCharacter: MenuKeyDownCharacter,
    MenuBlur: MenuBlur$1,
    MenuMouseLeave: MenuMouseLeave,
    ItemMouseMove: ItemMouseMove,
    ItemClick: ItemClick$1,
    ToggleButtonClick: ToggleButtonClick$1,
    ToggleButtonKeyDownArrowDown: ToggleButtonKeyDownArrowDown,
    ToggleButtonKeyDownArrowUp: ToggleButtonKeyDownArrowUp,
    ToggleButtonKeyDownCharacter: ToggleButtonKeyDownCharacter,
    FunctionToggleMenu: FunctionToggleMenu,
    FunctionOpenMenu: FunctionOpenMenu,
    FunctionCloseMenu: FunctionCloseMenu,
    FunctionSetHighlightedIndex: FunctionSetHighlightedIndex,
    FunctionSelectItem: FunctionSelectItem,
    FunctionSetInputValue: FunctionSetInputValue,
    FunctionReset: FunctionReset
  });
  /* eslint-disable complexity */

  function downshiftSelectReducer(state, action) {
    var type = action.type,
        props = action.props,
        shiftKey = action.shiftKey;
    var changes;

    switch (type) {
      case ItemMouseMove:
        changes = {
          highlightedIndex: action.index
        };
        break;

      case ItemClick$1:
        changes = {
          isOpen: getDefaultValue(props, 'isOpen'),
          highlightedIndex: getDefaultValue(props, 'highlightedIndex'),
          selectedItem: props.items[action.index]
        };
        break;

      case ToggleButtonKeyDownCharacter:
        {
          var lowercasedKey = action.key;
          var inputValue = "" + state.inputValue + lowercasedKey;
          var itemIndex = getItemIndexByCharacterKey(inputValue, state.selectedItem ? props.items.indexOf(state.selectedItem) : -1, props.items, props.itemToString, action.getItemNodeFromIndex);
          changes = _extends({
            inputValue: inputValue
          }, itemIndex >= 0 && {
            selectedItem: props.items[itemIndex]
          });
        }
        break;

      case ToggleButtonKeyDownArrowDown:
        changes = {
          highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),
          isOpen: true
        };
        break;

      case ToggleButtonKeyDownArrowUp:
        changes = {
          highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),
          isOpen: true
        };
        break;

      case MenuKeyDownEnter$1:
      case MenuKeyDownSpaceButton$1:
        changes = _extends({
          isOpen: getDefaultValue(props, 'isOpen'),
          highlightedIndex: getDefaultValue(props, 'highlightedIndex')
        }, state.highlightedIndex >= 0 && {
          selectedItem: props.items[state.highlightedIndex]
        });
        break;

      case MenuKeyDownHome:
        changes = {
          highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)
        };
        break;

      case MenuKeyDownEnd:
        changes = {
          highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)
        };
        break;

      case MenuKeyDownEscape$1:
        changes = {
          isOpen: false,
          highlightedIndex: -1
        };
        break;

      case MenuBlur$1:
        changes = {
          isOpen: false,
          highlightedIndex: -1
        };
        break;

      case MenuKeyDownCharacter:
        {
          var _lowercasedKey = action.key;

          var _inputValue = "" + state.inputValue + _lowercasedKey;

          var highlightedIndex = getItemIndexByCharacterKey(_inputValue, state.highlightedIndex, props.items, props.itemToString, action.getItemNodeFromIndex);
          changes = _extends({
            inputValue: _inputValue
          }, highlightedIndex >= 0 && {
            highlightedIndex: highlightedIndex
          });
        }
        break;

      case MenuKeyDownArrowDown$1:
        changes = {
          highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)
        };
        break;

      case MenuKeyDownArrowUp$1:
        changes = {
          highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)
        };
        break;

      case MenuMouseLeave:
        changes = {
          highlightedIndex: -1
        };
        break;

      case ToggleButtonClick$1:
      case FunctionToggleMenu:
        changes = {
          isOpen: !state.isOpen,
          highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)
        };
        break;

      case FunctionOpenMenu:
        changes = {
          isOpen: true,
          highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)
        };
        break;

      case FunctionCloseMenu:
        changes = {
          isOpen: false
        };
        break;

      case FunctionSetHighlightedIndex:
        changes = {
          highlightedIndex: action.highlightedIndex
        };
        break;

      case FunctionSelectItem:
        changes = {
          selectedItem: action.selectedItem
        };
        break;

      case FunctionSetInputValue:
        changes = {
          inputValue: action.inputValue
        };
        break;

      case FunctionReset:
        changes = {
          highlightedIndex: getDefaultValue(props, 'highlightedIndex'),
          isOpen: getDefaultValue(props, 'isOpen'),
          selectedItem: getDefaultValue(props, 'selectedItem'),
          inputValue: getDefaultValue(props, 'inputValue')
        };
        break;

      default:
        throw new Error('Reducer called without proper action type.');
    }

    return _extends({}, state, {}, changes);
  }
  /* eslint-enable complexity */


  var validatePropTypes = getPropTypesValidator(useSelect, propTypes);
  useSelect.stateChangeTypes = stateChangeTypes$1;

  function useSelect(userProps) {
    if (userProps === void 0) {
      userProps = {};
    }
    /* istanbul ignore else */


    {
      validatePropTypes(userProps);
    } // Props defaults and destructuring.


    var props = _extends({}, defaultProps$1, {}, userProps);

    var items = props.items,
        scrollIntoView = props.scrollIntoView,
        environment = props.environment,
        initialIsOpen = props.initialIsOpen,
        defaultIsOpen = props.defaultIsOpen,
        itemToString = props.itemToString,
        getA11ySelectionMessage = props.getA11ySelectionMessage,
        getA11yStatusMessage = props.getA11yStatusMessage; // Initial state depending on controlled props.

    var initialState = getInitialState(props); // Reducer init.

    var _useControlledState = useControlledState(downshiftSelectReducer, initialState, props),
        _useControlledState$ = _useControlledState[0],
        isOpen = _useControlledState$.isOpen,
        highlightedIndex = _useControlledState$.highlightedIndex,
        selectedItem = _useControlledState$.selectedItem,
        inputValue = _useControlledState$.inputValue,
        dispatch = _useControlledState[1]; // Refs


    var toggleButtonRef = React.useRef(null);
    var menuRef = React.useRef(null);
    var isInitialMount = React.useRef(true);
    var shouldScroll = React.useRef(true);
    var clearTimeout = React.useRef(null);
    var mouseAndTouchTrackers = React.useRef({
      isMouseDown: false,
      isTouchMove: false
    });
    var elementIds = React.useRef(getElementIds(props));
    var previousResultCountRef = React.useRef(); // Some utils.

    var getItemNodeFromIndex = function getItemNodeFromIndex(index) {
      return environment.document.getElementById(elementIds.current.getItemId(index));
    }; // Effects.

    /* Sets a11y status message on changes in state. */


    React.useEffect(function () {
      if (isInitialMount.current) {
        return;
      }

      var previousResultCount = previousResultCountRef.current;
      updateA11yStatus(function () {
        return getA11yStatusMessage({
          isOpen: isOpen,
          highlightedIndex: highlightedIndex,
          selectedItem: selectedItem,
          inputValue: inputValue,
          highlightedItem: items[highlightedIndex],
          resultCount: items.length,
          itemToString: itemToString,
          previousResultCount: previousResultCount
        });
      }, environment.document); // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isOpen, highlightedIndex, selectedItem, inputValue]);
    /* Sets a11y status message on changes in selectedItem. */

    React.useEffect(function () {
      if (isInitialMount.current) {
        return;
      }

      var previousResultCount = previousResultCountRef.current;
      updateA11yStatus(function () {
        return getA11ySelectionMessage({
          isOpen: isOpen,
          highlightedIndex: highlightedIndex,
          selectedItem: selectedItem,
          inputValue: inputValue,
          highlightedItem: items[highlightedIndex],
          resultCount: items.length,
          itemToString: itemToString,
          previousResultCount: previousResultCount
        });
      }, environment.document); // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [selectedItem]);
    /* Sets cleanup for the keysSoFar after 500ms. */

    React.useEffect(function () {
      // init the clean function here as we need access to dispatch.
      if (isInitialMount.current) {
        clearTimeout.current = debounce$2(function (outerDispatch) {
          outerDispatch({
            type: FunctionSetInputValue,
            inputValue: ''
          });
        }, 500);
      }

      if (!inputValue) {
        return;
      }

      clearTimeout.current(dispatch); // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [inputValue]);
    /* Controls the focus on the menu or the toggle button. */

    React.useEffect(function () {
      // Don't focus menu on first render.
      if (isInitialMount.current) {
        // Unless it was initialised as open.
        if ((initialIsOpen || defaultIsOpen || isOpen) && menuRef.current) {
          menuRef.current.focus();
        }

        return;
      } // Focus menu on open.
      // istanbul ignore next


      if (isOpen && menuRef.current) {
        menuRef.current.focus(); // Focus toggleButton on close.
      } else if (environment.document.activeElement === menuRef.current && toggleButtonRef.current) {
        toggleButtonRef.current.focus();
      } // eslint-disable-next-line react-hooks/exhaustive-deps

    }, [isOpen]);
    /* Scroll on highlighted item if change comes from keyboard. */

    React.useEffect(function () {
      if (highlightedIndex < 0 || !isOpen || !items.length) {
        return;
      }

      if (shouldScroll.current === false) {
        shouldScroll.current = true;
      } else {
        scrollIntoView(getItemNodeFromIndex(highlightedIndex), menuRef.current);
      } // eslint-disable-next-line react-hooks/exhaustive-deps

    }, [highlightedIndex]);
    React.useEffect(function () {
      if (isInitialMount.current) {
        return;
      }

      previousResultCountRef.current = items.length;
    });
    /* Make initial ref false. */

    React.useEffect(function () {
      isInitialMount.current = false;
    }, []);
    /* Add mouse/touch events to document. */

    React.useEffect(function () {
      // The same strategy for checking if a click occurred inside or outside downsift
      // as in downshift.js.
      var onMouseDown = function onMouseDown() {
        mouseAndTouchTrackers.current.isMouseDown = true;
      };

      var onMouseUp = function onMouseUp(event) {
        mouseAndTouchTrackers.current.isMouseDown = false;

        if (isOpen && !targetWithinDownshift(event.target, [toggleButtonRef.current, menuRef.current], environment.document)) {
          dispatch({
            type: MenuBlur$1
          });
        }
      };

      var onTouchStart = function onTouchStart() {
        mouseAndTouchTrackers.current.isTouchMove = false;
      };

      var onTouchMove = function onTouchMove() {
        mouseAndTouchTrackers.current.isTouchMove = true;
      };

      var onTouchEnd = function onTouchEnd(event) {
        if (isOpen && !mouseAndTouchTrackers.current.isTouchMove && !targetWithinDownshift(event.target, [toggleButtonRef.current, menuRef.current], environment.document, false)) {
          dispatch({
            type: MenuBlur$1
          });
        }
      };

      environment.addEventListener('mousedown', onMouseDown);
      environment.addEventListener('mouseup', onMouseUp);
      environment.addEventListener('touchstart', onTouchStart);
      environment.addEventListener('touchmove', onTouchMove);
      environment.addEventListener('touchend', onTouchEnd);
      return function () {
        environment.removeEventListener('mousedown', onMouseDown);
        environment.removeEventListener('mouseup', onMouseUp);
        environment.removeEventListener('touchstart', onTouchStart);
        environment.removeEventListener('touchmove', onTouchMove);
        environment.removeEventListener('touchend', onTouchEnd);
      };
    }); // Event handler functions.

    var toggleButtonKeyDownHandlers = {
      ArrowDown: function ArrowDown(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownArrowDown,
          getItemNodeFromIndex: getItemNodeFromIndex,
          shiftKey: event.shiftKey
        });
      },
      ArrowUp: function ArrowUp(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownArrowUp,
          getItemNodeFromIndex: getItemNodeFromIndex,
          shiftKey: event.shiftKey
        });
      }
    };
    var menuKeyDownHandlers = {
      ArrowDown: function ArrowDown(event) {
        event.preventDefault();
        dispatch({
          type: MenuKeyDownArrowDown$1,
          getItemNodeFromIndex: getItemNodeFromIndex,
          shiftKey: event.shiftKey
        });
      },
      ArrowUp: function ArrowUp(event) {
        event.preventDefault();
        dispatch({
          type: MenuKeyDownArrowUp$1,
          getItemNodeFromIndex: getItemNodeFromIndex,
          shiftKey: event.shiftKey
        });
      },
      Home: function Home(event) {
        event.preventDefault();
        dispatch({
          type: MenuKeyDownHome,
          getItemNodeFromIndex: getItemNodeFromIndex
        });
      },
      End: function End(event) {
        event.preventDefault();
        dispatch({
          type: MenuKeyDownEnd,
          getItemNodeFromIndex: getItemNodeFromIndex
        });
      },
      Escape: function Escape() {
        dispatch({
          type: MenuKeyDownEscape$1
        });
      },
      Enter: function Enter(event) {
        event.preventDefault();
        dispatch({
          type: MenuKeyDownEnter$1
        });
      },
      ' ': function _(event) {
        event.preventDefault();
        dispatch({
          type: MenuKeyDownSpaceButton$1
        });
      }
    }; // Event handlers.

    var menuHandleKeyDown = function menuHandleKeyDown(event) {
      var key = normalizeArrowKey(event);

      if (key && menuKeyDownHandlers[key]) {
        menuKeyDownHandlers[key](event);
      } else if (isAcceptedCharacterKey(key)) {
        dispatch({
          type: MenuKeyDownCharacter,
          key: key,
          getItemNodeFromIndex: getItemNodeFromIndex
        });
      }
    };

    var menuHandleBlur = function menuHandleBlur() {
      var shouldBlur = !mouseAndTouchTrackers.current.isMouseDown;
      /* istanbul ignore else */

      if (shouldBlur) {
        dispatch({
          type: MenuBlur$1
        });
      }
    };

    var menuHandleMouseLeave = function menuHandleMouseLeave() {
      dispatch({
        type: MenuMouseLeave
      });
    };

    var toggleButtonHandleClick = function toggleButtonHandleClick() {
      dispatch({
        type: ToggleButtonClick$1
      });
    };

    var toggleButtonHandleKeyDown = function toggleButtonHandleKeyDown(event) {
      var key = normalizeArrowKey(event);

      if (key && toggleButtonKeyDownHandlers[key]) {
        toggleButtonKeyDownHandlers[key](event);
      } else if (isAcceptedCharacterKey(key)) {
        dispatch({
          type: ToggleButtonKeyDownCharacter,
          key: key,
          getItemNodeFromIndex: getItemNodeFromIndex
        });
      }
    };

    var itemHandleMouseMove = function itemHandleMouseMove(index) {
      if (index === highlightedIndex) {
        return;
      }

      shouldScroll.current = false;
      dispatch({
        type: ItemMouseMove,
        index: index
      });
    };

    var itemHandleClick = function itemHandleClick(index) {
      dispatch({
        type: ItemClick$1,
        index: index
      });
    }; // Action functions.


    return {
      // prop getters.
      getToggleButtonProps: function getToggleButtonProps(_temp2) {
        var _extends3;

        var _ref2 = _temp2 === void 0 ? {} : _temp2,
            onClick = _ref2.onClick,
            onKeyDown = _ref2.onKeyDown,
            _ref2$refKey = _ref2.refKey,
            refKey = _ref2$refKey === void 0 ? 'ref' : _ref2$refKey,
            ref = _ref2.ref,
            rest = _objectWithoutPropertiesLoose(_ref2, ["onClick", "onKeyDown", "refKey", "ref"]);

        var toggleProps = _extends((_extends3 = {}, _extends3[refKey] = handleRefs(ref, function (toggleButtonNode) {
          toggleButtonRef.current = toggleButtonNode;
        }), _extends3.id = elementIds.current.toggleButtonId, _extends3['aria-haspopup'] = 'listbox', _extends3['aria-expanded'] = isOpen, _extends3['aria-labelledby'] = elementIds.current.labelId + " " + elementIds.current.toggleButtonId, _extends3), rest);

        if (!rest.disabled) {
          toggleProps.onClick = callAllEventHandlers(onClick, toggleButtonHandleClick);
          toggleProps.onKeyDown = callAllEventHandlers(onKeyDown, toggleButtonHandleKeyDown);
        }

        return toggleProps;
      },
      getLabelProps: function getLabelProps(labelProps) {
        return _extends({
          id: elementIds.current.labelId,
          htmlFor: elementIds.current.toggleButtonId
        }, labelProps);
      },
      getMenuProps: function getMenuProps(_temp) {
        var _extends2;

        var _ref = _temp === void 0 ? {} : _temp,
            onMouseLeave = _ref.onMouseLeave,
            _ref$refKey = _ref.refKey,
            refKey = _ref$refKey === void 0 ? 'ref' : _ref$refKey,
            onKeyDown = _ref.onKeyDown,
            onBlur = _ref.onBlur,
            ref = _ref.ref,
            rest = _objectWithoutPropertiesLoose(_ref, ["onMouseLeave", "refKey", "onKeyDown", "onBlur", "ref"]);

        return _extends((_extends2 = {}, _extends2[refKey] = handleRefs(ref, function (menuNode) {
          menuRef.current = menuNode;
        }), _extends2.id = elementIds.current.menuId, _extends2.role = 'listbox', _extends2['aria-labelledby'] = elementIds.current.labelId, _extends2.tabIndex = -1, _extends2), isOpen && highlightedIndex > -1 && {
          'aria-activedescendant': elementIds.current.getItemId(highlightedIndex)
        }, {
          onMouseLeave: callAllEventHandlers(onMouseLeave, menuHandleMouseLeave),
          onKeyDown: callAllEventHandlers(onKeyDown, menuHandleKeyDown),
          onBlur: callAllEventHandlers(onBlur, menuHandleBlur)
        }, rest);
      },
      getItemProps: function getItemProps(_temp3) {
        var _ref3 = _temp3 === void 0 ? {} : _temp3,
            item = _ref3.item,
            index = _ref3.index,
            onMouseMove = _ref3.onMouseMove,
            onClick = _ref3.onClick,
            rest = _objectWithoutPropertiesLoose(_ref3, ["item", "index", "onMouseMove", "onClick"]);

        var itemIndex = getItemIndex(index, item, items);

        if (itemIndex < 0) {
          throw new Error('Pass either item or item index in getItemProps!');
        }

        var itemProps = _extends({
          role: 'option',
          'aria-selected': "" + (itemIndex === highlightedIndex),
          id: elementIds.current.getItemId(itemIndex)
        }, rest);

        if (!rest.disabled) {
          itemProps.onMouseMove = callAllEventHandlers(onMouseMove, function () {
            return itemHandleMouseMove(itemIndex);
          });
          itemProps.onClick = callAllEventHandlers(onClick, function () {
            return itemHandleClick(itemIndex);
          });
        }

        return itemProps;
      },
      // actions.
      toggleMenu: function toggleMenu() {
        dispatch({
          type: FunctionToggleMenu
        });
      },
      openMenu: function openMenu() {
        dispatch({
          type: FunctionOpenMenu
        });
      },
      closeMenu: function closeMenu() {
        dispatch({
          type: FunctionCloseMenu
        });
      },
      setHighlightedIndex: function setHighlightedIndex(newHighlightedIndex) {
        dispatch({
          type: FunctionSetHighlightedIndex,
          highlightedIndex: newHighlightedIndex
        });
      },
      selectItem: function selectItem(newSelectedItem) {
        dispatch({
          type: FunctionSelectItem,
          selectedItem: newSelectedItem
        });
      },
      reset: function reset() {
        dispatch({
          type: FunctionReset
        });
      },
      setInputValue: function setInputValue(newInputValue) {
        dispatch({
          type: FunctionSetInputValue,
          inputValue: newInputValue
        });
      },
      // state.
      highlightedIndex: highlightedIndex,
      isOpen: isOpen,
      selectedItem: selectedItem,
      inputValue: inputValue
    };
  }

  ({
    items: PropTypes__default["default"].array.isRequired,
    itemToString: PropTypes__default["default"].func,
    getA11yStatusMessage: PropTypes__default["default"].func,
    getA11ySelectionMessage: PropTypes__default["default"].func,
    circularNavigation: PropTypes__default["default"].bool,
    highlightedIndex: PropTypes__default["default"].number,
    defaultHighlightedIndex: PropTypes__default["default"].number,
    initialHighlightedIndex: PropTypes__default["default"].number,
    isOpen: PropTypes__default["default"].bool,
    defaultIsOpen: PropTypes__default["default"].bool,
    initialIsOpen: PropTypes__default["default"].bool,
    selectedItem: PropTypes__default["default"].any,
    initialSelectedItem: PropTypes__default["default"].any,
    defaultSelectedItem: PropTypes__default["default"].any,
    inputValue: PropTypes__default["default"].string,
    defaultInputValue: PropTypes__default["default"].string,
    initialInputValue: PropTypes__default["default"].string,
    id: PropTypes__default["default"].string,
    labelId: PropTypes__default["default"].string,
    menuId: PropTypes__default["default"].string,
    getItemId: PropTypes__default["default"].func,
    inputId: PropTypes__default["default"].string,
    toggleButtonId: PropTypes__default["default"].string,
    stateReducer: PropTypes__default["default"].func,
    onSelectedItemChange: PropTypes__default["default"].func,
    onHighlightedIndexChange: PropTypes__default["default"].func,
    onStateChange: PropTypes__default["default"].func,
    onIsOpenChange: PropTypes__default["default"].func,
    onInputValueChange: PropTypes__default["default"].func,
    environment: PropTypes__default["default"].shape({
      addEventListener: PropTypes__default["default"].func,
      removeEventListener: PropTypes__default["default"].func,
      document: PropTypes__default["default"].shape({
        getElementById: PropTypes__default["default"].func,
        activeElement: PropTypes__default["default"].any,
        body: PropTypes__default["default"].any
      })
    })
  });

  _extends({}, defaultProps, {
    getA11yStatusMessage: getA11yStatusMessage,
    circularNavigation: true
  });
  /**
   * Returns a message to be added to aria-live region when item is removed.
   *
   * @param {Object} selectionParameters Parameters required to build the message.
   * @returns {string} The a11y message.
   */


  function getA11yRemovalMessage(selectionParameters) {
    var removedSelectedItem = selectionParameters.removedSelectedItem,
        itemToStringLocal = selectionParameters.itemToString;
    return itemToStringLocal(removedSelectedItem) + " has been removed.";
  }

  ({
    selectedItems: PropTypes__default["default"].array,
    initialSelectedItems: PropTypes__default["default"].array,
    defaultSelectedItems: PropTypes__default["default"].array,
    itemToString: PropTypes__default["default"].func,
    getA11yRemovalMessage: PropTypes__default["default"].func,
    stateReducer: PropTypes__default["default"].func,
    activeIndex: PropTypes__default["default"].number,
    initialActiveIndex: PropTypes__default["default"].number,
    defaultActiveIndex: PropTypes__default["default"].number,
    onActiveIndexChange: PropTypes__default["default"].func,
    onSelectedItemsChange: PropTypes__default["default"].func,
    keyNavigationNext: PropTypes__default["default"].string,
    keyNavigationPrevious: PropTypes__default["default"].string,
    environment: PropTypes__default["default"].shape({
      addEventListener: PropTypes__default["default"].func,
      removeEventListener: PropTypes__default["default"].func,
      document: PropTypes__default["default"].shape({
        getElementById: PropTypes__default["default"].func,
        activeElement: PropTypes__default["default"].any,
        body: PropTypes__default["default"].any
      })
    })
  });
  ({
    itemToString: defaultProps.itemToString,
    stateReducer: defaultProps.stateReducer,
    environment: defaultProps.environment,
    getA11yRemovalMessage: getA11yRemovalMessage,
    keyNavigationNext: 'ArrowRight',
    keyNavigationPrevious: 'ArrowLeft'
  });

  var Downshift$1 = Downshift;

  var ListBoxType = PropTypes__default["default"].oneOf(['default', 'inline']);
  var ListBoxSize = enabled('enable-v11-release') ? PropTypes__default["default"].oneOf(['sm', 'md', 'lg']) : PropTypes__default["default"].oneOf(['sm', 'md', 'lg', 'xl']);

  var _excluded$2u = ["children", "className", "disabled", "type", "size", "invalid", "invalidText", "warn", "warnText", "light", "isOpen"];

  var handleOnKeyDown = function handleOnKeyDown(event) {
    if (event.keyCode === 27) {
      event.stopPropagation();
    }
  };

  var handleClick = function handleClick(event) {
    event.preventDefault();
    event.stopPropagation();
  };
  /**
   * `ListBox` is a generic container component that handles creating the
   * container class name in response to certain props.
   */


  var ListBox = /*#__PURE__*/React__default["default"].forwardRef(function ListBox(_ref, ref) {
    var _cx;

    var children = _ref.children,
        containerClassName = _ref.className,
        disabled = _ref.disabled,
        type = _ref.type,
        size = _ref.size,
        invalid = _ref.invalid,
        invalidText = _ref.invalidText,
        warn = _ref.warn,
        warnText = _ref.warnText,
        light = _ref.light,
        isOpen = _ref.isOpen,
        rest = _objectWithoutProperties$2(_ref, _excluded$2u);

    var prefix = usePrefix();
    var showWarning = !invalid && warn;
    var className = cx((_cx = {}, _defineProperty$2(_cx, containerClassName, !!containerClassName), _defineProperty$2(_cx, "".concat(prefix, "--list-box"), true), _defineProperty$2(_cx, "".concat(prefix, "--list-box--").concat(size), size), _defineProperty$2(_cx, "".concat(prefix, "--list-box--inline"), type === 'inline'), _defineProperty$2(_cx, "".concat(prefix, "--list-box--disabled"), disabled), _defineProperty$2(_cx, "".concat(prefix, "--list-box--light"), light), _defineProperty$2(_cx, "".concat(prefix, "--list-box--expanded"), isOpen), _defineProperty$2(_cx, "".concat(prefix, "--list-box--warning"), showWarning), _cx));
    return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("div", _extends$3({}, rest, {
      className: className,
      ref: ref,
      onKeyDown: handleOnKeyDown,
      onClick: handleClick,
      "data-invalid": invalid || undefined
    }), children), invalid ? /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--form-requirement")
    }, invalidText) : null, showWarning ? /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--form-requirement")
    }, warnText) : null);
  });
  ListBox.displayName = 'ListBox';
  ListBox.propTypes = {
    /**
     * Provide the contents of your ListBox
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify a class name to be applied on the containing list box node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the ListBox is currently disabled
     */
    disabled: PropTypes__default["default"].bool.isRequired,

    /**
     * Specify whether the control is currently invalid
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * Specify the text to be displayed when the control is invalid
     */
    invalidText: PropTypes__default["default"].node,

    /**
     * Specify if the control should render open
     */
    isOpen: PropTypes__default["default"].bool,

    /**
     * `true` to use the light version. For use on $ui-01 backgrounds only.
     * Don't use this to make tile background color same as container background color.
     */
    light: PropTypes__default["default"].bool,

    /**
     * Specify the size of the ListBox. Currently supports either `sm`, `md` or `lg` as an option.
     */
    size: ListBoxSize,

    /**
     * Specify the "type" of the ListBox. Currently supports either `default` or
     * `inline` as an option.
     */
    type: ListBoxType.isRequired,

    /**
     * Specify whether the control is currently in warning state
     */
    warn: PropTypes__default["default"].bool,

    /**
     * Provide the text that is displayed when the control is in warning state
     */
    warnText: PropTypes__default["default"].node
  };
  ListBox.defaultProps = {
    disabled: false,
    type: 'default'
  };
  var ListBox$1 = ListBox;

  var _excluded$2t = ["children", "disabled", "tabIndex"];
  /**
   * `ListBoxField` is responsible for creating the containing node for valid
   * elements inside of a field. It also provides a11y-related attributes like
   * `role` to make sure a user can focus the given field.
   */

  function ListBoxField(_ref) {
    var children = _ref.children,
        disabled = _ref.disabled,
        tabIndex = _ref.tabIndex,
        rest = _objectWithoutProperties$2(_ref, _excluded$2t);

    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: "".concat(prefix, "--list-box__field"),
      tabIndex: !disabled && tabIndex || -1
    }, rest), children);
  }

  ListBoxField.propTypes = {
    /**
     * Typically set by `getToggleButtonProps`, this should specify whether the
     * field has a popup.
     */
    'aria-haspopup': PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].bool]),

    /**
     * Provide the contents of your ListBoxField
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify if the parent <ListBox> is disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * The role for the component, should be set by `getToggleButtonProps` coming
     * from Downshift
     */
    role: PropTypes__default["default"].string,

    /**
     * Optional prop to specify the tabIndex of the <ListBox> trigger button
     */
    tabIndex: PropTypes__default["default"].oneOfType([PropTypes__default["default"].number, PropTypes__default["default"].string])
  };

  var _excluded$2s = ["children", "isActive", "isHighlighted", "title"];

  function useIsTruncated(ref) {
    var _useState = React.useState(false),
        _useState2 = _slicedToArray$1(_useState, 2),
        isTruncated = _useState2[0],
        setIsTruncated = _useState2[1];

    React.useEffect(function () {
      var _ref$current = ref.current,
          offsetWidth = _ref$current.offsetWidth,
          scrollWidth = _ref$current.scrollWidth;
      setIsTruncated(offsetWidth < scrollWidth);
    }, [ref, setIsTruncated]);
    return isTruncated;
  }
  /**
   * `ListBoxMenuItem` is a helper component for managing the container class
   * name, alongside any classes for any corresponding states, for a generic list
   * box menu item.
   */


  var ListBoxMenuItem = /*#__PURE__*/React__default["default"].forwardRef(function ListBoxMenuItem(_ref, forwardedRef) {
    var _cx;

    var children = _ref.children,
        isActive = _ref.isActive,
        isHighlighted = _ref.isHighlighted,
        title = _ref.title,
        rest = _objectWithoutProperties$2(_ref, _excluded$2s);

    var prefix = usePrefix();
    var ref = React.useRef(null);
    var isTruncated = useIsTruncated((forwardedRef === null || forwardedRef === void 0 ? void 0 : forwardedRef.menuItemOptionRef) || ref);
    var className = cx("".concat(prefix, "--list-box__menu-item"), (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--list-box__menu-item--active"), isActive), _defineProperty$2(_cx, "".concat(prefix, "--list-box__menu-item--highlighted"), isHighlighted), _cx));
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({}, rest, {
      className: className,
      title: isTruncated ? title : undefined,
      tabIndex: "-1"
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--list-box__menu-item__option"),
      ref: (forwardedRef === null || forwardedRef === void 0 ? void 0 : forwardedRef.menuItemOptionRef) || ref
    }, children));
  });
  ListBoxMenuItem.displayName = 'ListBoxMenuItem';
  ListBoxMenuItem.propTypes = {
    /**
     * Specify any children nodes that should be rendered inside of the ListBox
     * Menu Item
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify whether the current menu item is "active".
     */
    isActive: PropTypes__default["default"].bool.isRequired,

    /**
     * Specify whether the current menu item is "highlighted".
     */
    isHighlighted: PropTypes__default["default"].bool.isRequired,

    /**
     * Provide an optional tooltip for the ListBoxMenuItem
     */
    title: PropTypes__default["default"].string
  };
  ListBoxMenuItem.defaultProps = {
    isActive: false,
    isHighlighted: false
  };
  var ListBoxMenuItem$1 = ListBoxMenuItem;

  var _excluded$2r = ["children", "id"];
  /**
   * `ListBoxMenu` is a simple container node that isolates the `list-box__menu`
   * class into a single component. It is also being used to validate given
   * `children` components.
   */

  var ListBoxMenu = /*#__PURE__*/React__default["default"].forwardRef(function ListBoxMenu(_ref, ref) {
    var children = _ref.children,
        id = _ref.id,
        rest = _objectWithoutProperties$2(_ref, _excluded$2r);

    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      ref: ref,
      id: id,
      className: "".concat(prefix, "--list-box__menu"),
      role: "listbox"
    }, rest), children);
  });
  ListBoxMenu.displayName = 'ListBoxMenu';
  ListBoxMenu.propTypes = {
    /**
     * Provide the contents of your ListBoxMenu
     */
    children: PropTypes__default["default"].oneOfType([PropTypes__default["default"].node, PropTypes__default["default"].arrayOf(ListBoxMenuItem$1),
    /**
     * allow single item using the workaround for functional components
     * https://github.com/facebook/react/issues/2979#issuecomment-222379916
     */
    PropTypes__default["default"].shape({
      type: PropTypes__default["default"].oneOf([ListBoxMenuItem$1])
    }), PropTypes__default["default"].bool // used in Dropdown for closed state
    ]),

    /**
     * Specify a custom `id`
     */
    id: PropTypes__default["default"].string.isRequired
  };
  var ListBoxMenu$1 = ListBoxMenu;

  var _defaultTranslations$6;
  var translationIds$6 = {
    'close.menu': 'close.menu',
    'open.menu': 'open.menu'
  };
  var defaultTranslations$7 = (_defaultTranslations$6 = {}, _defineProperty$2(_defaultTranslations$6, translationIds$6['close.menu'], 'Close menu'), _defineProperty$2(_defaultTranslations$6, translationIds$6['open.menu'], 'Open menu'), _defaultTranslations$6);
  /**
   * `ListBoxMenuIcon` is used to orient the icon up or down depending on the
   * state of the menu for a given `ListBox`
   */

  var ListBoxMenuIcon = function ListBoxMenuIcon(_ref) {
    var isOpen = _ref.isOpen,
        t = _ref.translateWithId;
    var prefix = usePrefix();
    var className = cx("".concat(prefix, "--list-box__menu-icon"), _defineProperty$2({}, "".concat(prefix, "--list-box__menu-icon--open"), isOpen));
    var description = isOpen ? t('close.menu') : t('open.menu');
    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: className
    }, /*#__PURE__*/React__default["default"].createElement(ChevronDown16, {
      name: "chevron--down",
      "aria-label": description
    }, /*#__PURE__*/React__default["default"].createElement("title", null, description)));
  };

  ListBoxMenuIcon.propTypes = {
    /**
     * Specify whether the menu is currently open, which will influence the
     * direction of the menu icon
     */
    isOpen: PropTypes__default["default"].bool.isRequired,

    /**
     * i18n hook used to provide the appropriate description for the given menu
     * icon. This function takes in an id defined in `translationIds` and should
     * return a string message for that given message id.
     */
    translateWithId: PropTypes__default["default"].func.isRequired
  };
  ListBoxMenuIcon.defaultProps = {
    translateWithId: function translateWithId(id) {
      return defaultTranslations$7[id];
    }
  };
  var ListBoxMenuIcon$1 = ListBoxMenuIcon;

  var _defaultTranslations$5;
  /**
   * `ListBoxSelection` is used to provide controls for clearing a selection, in
   * addition to conditionally rendering a badge if the control has more than one
   * selection.
   */

  var ListBoxSelection$1 = function ListBoxSelection(_ref) {
    var _cx;

    var clearSelection = _ref.clearSelection,
        selectionCount = _ref.selectionCount,
        t = _ref.translateWithId,
        disabled = _ref.disabled,
        onClearSelection = _ref.onClearSelection;
    var prefix = usePrefix();
    var className = cx("".concat(prefix, "--list-box__selection"), (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--tag--filter"), selectionCount), _defineProperty$2(_cx, "".concat(prefix, "--list-box__selection--multi"), selectionCount), _cx));

    var handleOnClick = function handleOnClick(event) {
      event.stopPropagation();

      if (disabled) {
        return;
      }

      clearSelection(event);

      if (onClearSelection) {
        onClearSelection(event);
      }
    };

    var description = selectionCount ? t('clear.all') : t('clear.selection');
    var tagClasses = cx("".concat(prefix, "--tag"), "".concat(prefix, "--tag--filter"), "".concat(prefix, "--tag--high-contrast"), _defineProperty$2({}, "".concat(prefix, "--tag--disabled"), disabled));
    /* eslint-disable jsx-a11y/click-events-have-key-events */

    return selectionCount ? /*#__PURE__*/React__default["default"].createElement("div", {
      className: tagClasses
    }, /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--tag__label"),
      title: selectionCount
    }, selectionCount), /*#__PURE__*/React__default["default"].createElement("div", {
      role: "button",
      tabIndex: -1,
      className: "".concat(prefix, "--tag__close-icon"),
      onClick: handleOnClick,
      disabled: disabled,
      "aria-label": t('clear.all'),
      title: description
    }, /*#__PURE__*/React__default["default"].createElement(Close16, null))) : /*#__PURE__*/React__default["default"].createElement("div", {
      role: "button",
      className: className,
      tabIndex: -1,
      onClick: handleOnClick,
      "aria-label": description,
      title: description
    }, selectionCount, /*#__PURE__*/React__default["default"].createElement(Close16, null));
  };

  var translationIds$5 = {
    'clear.all': 'clear.all',
    'clear.selection': 'clear.selection'
  };
  var defaultTranslations$6 = (_defaultTranslations$5 = {}, _defineProperty$2(_defaultTranslations$5, translationIds$5['clear.all'], 'Clear all selected items'), _defineProperty$2(_defaultTranslations$5, translationIds$5['clear.selection'], 'Clear selected item'), _defaultTranslations$5);
  ListBoxSelection$1.propTypes = {
    /**
     * Specify a function to be invoked when a user interacts with the clear
     * selection element.
     */
    clearSelection: PropTypes__default["default"].func.isRequired,

    /**
     * Specify whether or not the clear selection element should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Specify an optional `onClearSelection` handler that is called when the underlying
     * element is cleared
     */
    onClearSelection: PropTypes__default["default"].func,

    /**
     * Specify an optional `onClick` handler that is called when the underlying
     * clear selection element is clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Specify an optional `onKeyDown` handler that is called when the underlying
     * clear selection element fires a keydown event
     */
    onKeyDown: PropTypes__default["default"].func,

    /**
     * Specify an optional `selectionCount` value that will be used to determine
     * whether the selection should display a badge or a single clear icon.
     */
    selectionCount: PropTypes__default["default"].number,

    /**
     * i18n hook used to provide the appropriate description for the given menu
     * icon. This function takes in an id defined in `translationIds` and should
     * return a string message for that given message id.
     */
    translateWithId: PropTypes__default["default"].func.isRequired
  };
  ListBoxSelection$1.defaultProps = {
    translateWithId: function translateWithId(id) {
      return defaultTranslations$6[id];
    }
  };
  var ListBoxSelection$2 = ListBoxSelection$1;

  ListBox$1.Field = ListBoxField;
  ListBox$1.Menu = ListBoxMenu$1;
  ListBox$1.MenuIcon = ListBoxMenuIcon$1;
  ListBox$1.MenuItem = ListBoxMenuItem$1;
  ListBox$1.Selection = ListBoxSelection$2;

  var _defaultTranslations$4;

  var _excluded$2q = ["clearSelection", "selectionCount", "translateWithId", "disabled", "onClearSelection"];
  /**
   * `ListBoxSelection` is used to provide controls for clearing a selection, in
   * addition to conditionally rendering a badge if the control has more than one
   * selection.
   */

  function ListBoxSelection(_ref) {
    var _cx;

    var clearSelection = _ref.clearSelection,
        selectionCount = _ref.selectionCount,
        t = _ref.translateWithId,
        disabled = _ref.disabled,
        onClearSelection = _ref.onClearSelection,
        rest = _objectWithoutProperties$2(_ref, _excluded$2q);

    var prefix = usePrefix();
    var className = cx("".concat(prefix, "--list-box__selection"), (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--tag--filter"), selectionCount), _defineProperty$2(_cx, "".concat(prefix, "--list-box__selection--multi"), selectionCount), _cx));
    var description = selectionCount ? t('clear.all') : t('clear.selection');
    var tagClasses = cx("".concat(prefix, "--tag"), "".concat(prefix, "--tag--filter"), "".concat(prefix, "--tag--high-contrast"), _defineProperty$2({}, "".concat(prefix, "--tag--disabled"), disabled));

    function onClick(event) {
      event.stopPropagation();

      if (disabled) {
        return;
      }

      clearSelection(event);

      if (onClearSelection) {
        onClearSelection(event);
      }
    }

    if (selectionCount) {
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: tagClasses
      }, /*#__PURE__*/React__default["default"].createElement("span", {
        className: "".concat(prefix, "--tag__label"),
        title: selectionCount
      }, selectionCount), /*#__PURE__*/React__default["default"].createElement("button", {
        "aria-label": description,
        className: "".concat(prefix, "--tag__close-icon"),
        disabled: disabled,
        onClick: onClick,
        tabIndex: -1,
        title: description,
        type: "button"
      }, /*#__PURE__*/React__default["default"].createElement(Close16, null)));
    }

    return /*#__PURE__*/React__default["default"].createElement("button", _extends$3({}, rest, {
      "aria-label": description,
      className: className,
      onClick: onClick,
      tabIndex: -1,
      title: description,
      type: "button"
    }), /*#__PURE__*/React__default["default"].createElement(Close16, null));
  }

  var translationIds$4 = {
    'clear.all': 'clear.all',
    'clear.selection': 'clear.selection'
  };
  var defaultTranslations$5 = (_defaultTranslations$4 = {}, _defineProperty$2(_defaultTranslations$4, translationIds$4['clear.all'], 'Clear all selected items'), _defineProperty$2(_defaultTranslations$4, translationIds$4['clear.selection'], 'Clear selected item'), _defaultTranslations$4);
  ListBoxSelection.propTypes = {
    /**
     * Specify a function to be invoked when a user interacts with the clear
     * selection element.
     */
    clearSelection: PropTypes__default["default"].func.isRequired,

    /**
     * Specify whether or not the clear selection element should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Specify an optional `onClearSelection` handler that is called when the underlying
     * element is cleared
     */
    onClearSelection: PropTypes__default["default"].func,

    /**
     * Specify an optional `onClick` handler that is called when the underlying
     * clear selection element is clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Specify an optional `onKeyDown` handler that is called when the underlying
     * clear selection element fires a keydown event
     */
    onKeyDown: PropTypes__default["default"].func,

    /**
     * Specify an optional `selectionCount` value that will be used to determine
     * whether the selection should display a badge or a single clear icon.
     */
    selectionCount: PropTypes__default["default"].number,

    /**
     * i18n hook used to provide the appropriate description for the given menu
     * icon. This function takes in an id defined in `translationIds` and should
     * return a string message for that given message id.
     */
    translateWithId: PropTypes__default["default"].func.isRequired
  };
  ListBoxSelection.defaultProps = {
    translateWithId: function translateWithId(id) {
      return defaultTranslations$5[id];
    }
  };

  var _excluded$2p = ["isOpen", "translateWithId"];

  var _defaultTranslations$3;
  var translationIds$3 = {
    'close.menu': 'close.menu',
    'open.menu': 'open.menu'
  };
  var defaultTranslations$4 = (_defaultTranslations$3 = {}, _defineProperty$2(_defaultTranslations$3, translationIds$3['close.menu'], 'Close'), _defineProperty$2(_defaultTranslations$3, translationIds$3['open.menu'], 'Open'), _defaultTranslations$3);
  /**
   * `ListBoxTrigger` is used to orient the icon up or down depending on the
   * state of the menu for a given `ListBox`
   */

  var ListBoxTrigger = function ListBoxTrigger(_ref) {
    var _cx;

    var isOpen = _ref.isOpen,
        t = _ref.translateWithId,
        rest = _objectWithoutProperties$2(_ref, _excluded$2p);

    var prefix = usePrefix();
    var className = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--list-box__menu-icon"), true), _defineProperty$2(_cx, "".concat(prefix, "--list-box__menu-icon--open"), isOpen), _cx));
    var description = isOpen ? t('close.menu') : t('open.menu');
    return /*#__PURE__*/React__default["default"].createElement("button", _extends$3({}, rest, {
      "aria-label": description,
      title: description,
      className: className,
      type: "button",
      tabIndex: "-1"
    }), /*#__PURE__*/React__default["default"].createElement(ChevronDown16, null));
  };

  ListBoxTrigger.propTypes = {
    /**
     * Specify whether the menu is currently open, which will influence the
     * direction of the menu icon
     */
    isOpen: PropTypes__default["default"].bool.isRequired,

    /**
     * i18n hook used to provide the appropriate description for the given menu
     * icon. This function takes in an id defined in `translationIds` and should
     * return a string message for that given message id.
     */
    translateWithId: PropTypes__default["default"].func.isRequired
  };
  ListBoxTrigger.defaultProps = {
    translateWithId: function translateWithId(id) {
      return defaultTranslations$4[id];
    }
  };
  var ListBoxTrigger$1 = ListBoxTrigger;

  /**
   * Copyright IBM Corp. 2016, 2018
   *
   * This source code is licensed under the Apache-2.0 license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * Create an adapter that converts an object of props with potentially deprecated
   * prop names to the replacement prop names in a newer version. Useful for guarding
   * against breaking changes when a prop has been renamed
   *
   * @param {Array} spec - an array of options which specify a text or regex
   * matcher alongside a replacement if there is a match
   * @returns {Function}
   */
  function createPropAdapter(spec) {
    // if props aren't passed in we should default the prop to empty object
    return function () {
      var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var output = {};
      Object.keys(input).forEach(function (key) {
        var match = spec.find(function (_ref) {
          var _ref2 = _slicedToArray$1(_ref, 1),
              regex = _ref2[0];

          return key.match(regex);
        });

        if (match) {
          var _match = _slicedToArray$1(match, 2),
              regex = _match[0],
              replacer = _match[1];

          output[key.replace(regex, replacer)] = input[key];
          return;
        }

        output[key] = input[key];
      });
      return output;
    };
  }
  /**
   * TODO: REMOVE IN v11
   * props staring with "default..." were changed to "initial..." in Downshift v3
   *
   * @see https://github.com/downshift-js/downshift/releases/tag/v3.0.0
   */


  var mapDownshiftProps = createPropAdapter([[/^default/g, 'initial']]);

  /**
   * @param {...Ref<Element>} refs List of React refs to merge.
   * @returns {Ref<Element>} Merged React ref.
   */
  var mergeRefs = function mergeRefs() {
    for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
      refs[_key] = arguments[_key];
    }

    return function (el) {
      refs.forEach(function (ref) {
        // https://github.com/facebook/react/issues/13029#issuecomment-410002316
        if (typeof ref === 'function') {
          ref(el);
        } else if (Object(ref) === ref) {
          ref.current = el;
        }
      });
    };
  };

  var mergeRefs$1 = mergeRefs;

  var _excluded$2o = ["ariaLabel", "className", "direction", "disabled", "downshiftProps", "helperText", "id", "initialSelectedItem", "invalid", "invalidText", "items", "itemToElement", "itemToString", "light", "onChange", "onInputChange", "onToggleClick", "placeholder", "selectedItem", "shouldFilterItem", "size", "titleText", "translateWithId", "type", "warn", "warnText", "onStateChange"];

  var defaultItemToString$2 = function defaultItemToString(item) {
    if (typeof item === 'string') {
      return item;
    }

    return item && item.label;
  };

  var defaultShouldFilterItem = function defaultShouldFilterItem() {
    return true;
  };

  var getInputValue = function getInputValue(_ref) {
    var initialSelectedItem = _ref.initialSelectedItem,
        inputValue = _ref.inputValue,
        itemToString = _ref.itemToString,
        selectedItem = _ref.selectedItem;

    if (selectedItem) {
      return itemToString(selectedItem);
    } // TODO: consistent `initialSelectedItem` behavior with other listbox components in v11


    if (initialSelectedItem) {
      return itemToString(initialSelectedItem);
    }

    return inputValue || '';
  };

  var findHighlightedIndex = function findHighlightedIndex(_ref2, inputValue) {
    var items = _ref2.items,
        itemToString = _ref2.itemToString;

    if (!inputValue) {
      return -1;
    }

    var searchValue = inputValue.toLowerCase();

    for (var i = 0; i < items.length; i++) {
      var item = itemToString(items[i]).toLowerCase();

      if (item.indexOf(searchValue) !== -1) {
        return i;
      }
    }

    return -1;
  };

  var getInstanceId$i = setupGetInstanceId$2();
  var ComboBox = /*#__PURE__*/React__default["default"].forwardRef(function (props, ref) {
    var _cx;

    var ariaLabel = props.ariaLabel,
        containerClassName = props.className,
        direction = props.direction,
        disabled = props.disabled,
        downshiftProps = props.downshiftProps,
        helperText = props.helperText,
        id = props.id,
        initialSelectedItem = props.initialSelectedItem,
        invalid = props.invalid,
        invalidText = props.invalidText,
        items = props.items,
        itemToElement = props.itemToElement,
        itemToString = props.itemToString,
        light = props.light,
        onChange = props.onChange,
        onInputChange = props.onInputChange,
        onToggleClick = props.onToggleClick,
        placeholder = props.placeholder,
        selectedItem = props.selectedItem,
        shouldFilterItem = props.shouldFilterItem,
        size = props.size,
        titleText = props.titleText,
        translateWithId = props.translateWithId;
        props.type;
        var warn = props.warn,
        warnText = props.warnText;
        props.onStateChange;
        var rest = _objectWithoutProperties$2(props, _excluded$2o);

    var prefix = usePrefix();
    var textInput = React.useRef();
    var comboBoxInstanceId = getInstanceId$i();

    var _useState = React.useState(getInputValue({
      initialSelectedItem: initialSelectedItem,
      inputValue: '',
      itemToString: itemToString,
      selectedItem: selectedItem
    })),
        _useState2 = _slicedToArray$1(_useState, 2),
        inputValue = _useState2[0],
        setInputValue = _useState2[1];

    var _useState3 = React.useState(null),
        _useState4 = _slicedToArray$1(_useState3, 2),
        prevSelectedItem = _useState4[0],
        setPrevSelectedItem = _useState4[1];

    var _useState5 = React.useState(null),
        _useState6 = _slicedToArray$1(_useState5, 2),
        doneInitialSelectedItem = _useState6[0],
        setDoneInitialSelectedItem = _useState6[1];

    var savedOnInputChange = React.useRef(onInputChange);

    if (!doneInitialSelectedItem || prevSelectedItem !== selectedItem) {
      setDoneInitialSelectedItem(true);
      setPrevSelectedItem(selectedItem);
      setInputValue(getInputValue({
        initialSelectedItem: initialSelectedItem,
        inputValue: inputValue,
        itemToString: itemToString,
        selectedItem: selectedItem
      }));
    }

    var filterItems = function filterItems(items, itemToString, inputValue) {
      return items.filter(function (item) {
        return shouldFilterItem({
          item: item,
          itemToString: itemToString,
          inputValue: inputValue
        });
      });
    };

    var handleOnChange = function handleOnChange(selectedItem) {
      if (onChange) {
        onChange({
          selectedItem: selectedItem
        });
      }
    };

    var handleOnInputValueChange = function handleOnInputValueChange(inputValue) {
      setInputValue(inputValue || '');
    };

    React.useEffect(function () {
      savedOnInputChange.current = onInputChange;
    }, [onInputChange]);
    React.useEffect(function () {
      if (savedOnInputChange.current) {
        savedOnInputChange.current(inputValue);
      }
    }, [inputValue]);

    var handleSelectionClear = function handleSelectionClear() {
      if (textInput !== null && textInput !== void 0 && textInput.current) {
        textInput.current.focus();
      }
    };

    var handleOnStateChange = function handleOnStateChange(newState, _ref3) {
      var setHighlightedIndex = _ref3.setHighlightedIndex;

      if (Object.prototype.hasOwnProperty.call(newState, 'inputValue')) {
        var _inputValue = newState.inputValue;
        var filteredItems = filterItems(items, itemToString, _inputValue);
        setHighlightedIndex(findHighlightedIndex(_objectSpread2$2(_objectSpread2$2({}, props), {}, {
          items: filteredItems
        }), _inputValue));
      }
    };

    var handleToggleClick = function handleToggleClick(isOpen) {
      return function (event) {
        if (onToggleClick) {
          onToggleClick(event);
        }

        if (event.target === textInput.current && isOpen) {
          event.preventDownshiftDefault = true;
          event.persist();
        }
      };
    };

    var enabled = useFeatureFlag('enable-v11-release');
    var showWarning = !invalid && warn;
    var className = cx("".concat(prefix, "--combo-box"), [enabled ? null : containerClassName], (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--list-box--up"), direction === 'top'), _defineProperty$2(_cx, "".concat(prefix, "--combo-box--warning"), showWarning), _cx));
    var titleClasses = cx("".concat(prefix, "--label"), _defineProperty$2({}, "".concat(prefix, "--label--disabled"), disabled));
    var comboBoxHelperId = !helperText ? undefined : "combobox-helper-text-".concat(comboBoxInstanceId);
    var helperClasses = cx("".concat(prefix, "--form__helper-text"), _defineProperty$2({}, "".concat(prefix, "--form__helper-text--disabled"), disabled));
    var wrapperClasses = cx("".concat(prefix, "--list-box__wrapper"), [enabled ? containerClassName : null]);
    var inputClasses = cx("".concat(prefix, "--text-input"), _defineProperty$2({}, "".concat(prefix, "--text-input--empty"), !inputValue)); // needs to be Capitalized for react to render it correctly

    var ItemToElement = itemToElement;
    return /*#__PURE__*/React__default["default"].createElement(Downshift$1, _extends$3({}, mapDownshiftProps(downshiftProps), {
      onChange: handleOnChange,
      onInputValueChange: handleOnInputValueChange,
      onStateChange: function onStateChange() {
        var _downshiftProps$onSta;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        handleOnStateChange.apply(void 0, args);
        downshiftProps === null || downshiftProps === void 0 ? void 0 : (_downshiftProps$onSta = downshiftProps.onStateChange) === null || _downshiftProps$onSta === void 0 ? void 0 : _downshiftProps$onSta.call.apply(_downshiftProps$onSta, [downshiftProps].concat(args));
      },
      inputValue: inputValue || '',
      itemToString: itemToString,
      initialSelectedItem: initialSelectedItem,
      inputId: id,
      selectedItem: selectedItem
    }), function (_ref4) {
      var _textInput$current;

      var getInputProps = _ref4.getInputProps,
          getItemProps = _ref4.getItemProps,
          getLabelProps = _ref4.getLabelProps,
          getMenuProps = _ref4.getMenuProps,
          getRootProps = _ref4.getRootProps,
          getToggleButtonProps = _ref4.getToggleButtonProps,
          isOpen = _ref4.isOpen,
          inputValue = _ref4.inputValue,
          selectedItem = _ref4.selectedItem,
          highlightedIndex = _ref4.highlightedIndex,
          clearSelection = _ref4.clearSelection,
          toggleMenu = _ref4.toggleMenu;
      var rootProps = getRootProps({}, {
        suppressRefError: true
      });
      var labelProps = getLabelProps();
      var buttonProps = getToggleButtonProps({
        disabled: disabled,
        onClick: handleToggleClick(isOpen),
        // When we moved the "root node" of Downshift to the <input> for
        // ARIA 1.2 compliance, we unfortunately hit this branch for the
        // "mouseup" event that downshift listens to:
        // https://github.com/downshift-js/downshift/blob/v5.2.1/src/downshift.js#L1051-L1065
        //
        // As a result, it will reset the state of the component and so we
        // stop the event from propagating to prevent this if the menu is already open.
        // This allows the toggleMenu behavior for the toggleButton to correctly open and
        // close the menu.
        onMouseUp: function onMouseUp(event) {
          if (isOpen) {
            event.stopPropagation();
          }
        }
      });
      var inputProps = getInputProps({
        // Remove excess aria `aria-labelledby`. HTML <label for> provides this aria information.
        'aria-labelledby': null,
        disabled: disabled,
        placeholder: placeholder,
        onClick: function onClick() {
          toggleMenu();
        },
        onKeyDown: function onKeyDown(event) {
          if (match(event, Space)) {
            event.stopPropagation();
          }

          if (match(event, Enter) && !inputValue) {
            toggleMenu();
          }

          if (match(event, Escape) && inputValue) {
            if (event.target === textInput.current && isOpen) {
              toggleMenu();
              event.preventDownshiftDefault = true;
              event.persist();
            }
          }
        }
      });
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: wrapperClasses
      }, titleText && /*#__PURE__*/React__default["default"].createElement(Text, _extends$3({
        as: "label",
        className: titleClasses
      }, labelProps), titleText), /*#__PURE__*/React__default["default"].createElement(ListBox$1, {
        className: className,
        disabled: disabled,
        invalid: invalid,
        invalidText: invalidText,
        isOpen: isOpen,
        light: light,
        size: size,
        warn: warn,
        warnText: warnText
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: "".concat(prefix, "--list-box__field")
      }, /*#__PURE__*/React__default["default"].createElement("input", _extends$3({
        role: "combobox",
        disabled: disabled,
        className: inputClasses,
        type: "text",
        tabIndex: "0",
        "aria-autocomplete": "list",
        "aria-expanded": rootProps['aria-expanded'],
        "aria-haspopup": "listbox",
        "aria-controls": inputProps['aria-controls'],
        title: textInput === null || textInput === void 0 ? void 0 : (_textInput$current = textInput.current) === null || _textInput$current === void 0 ? void 0 : _textInput$current.value
      }, inputProps, rest, {
        ref: mergeRefs$1(textInput, ref),
        "aria-describedby": helperText && !invalid && !warn ? comboBoxHelperId : undefined
      })), invalid && /*#__PURE__*/React__default["default"].createElement(WarningFilled16, {
        className: "".concat(prefix, "--list-box__invalid-icon")
      }), showWarning && /*#__PURE__*/React__default["default"].createElement(WarningAltFilled16, {
        className: "".concat(prefix, "--list-box__invalid-icon ").concat(prefix, "--list-box__invalid-icon--warning")
      }), inputValue && /*#__PURE__*/React__default["default"].createElement(ListBoxSelection, {
        clearSelection: clearSelection,
        translateWithId: translateWithId,
        disabled: disabled,
        onClearSelection: handleSelectionClear
      }), /*#__PURE__*/React__default["default"].createElement(ListBoxTrigger$1, _extends$3({}, buttonProps, {
        isOpen: isOpen,
        translateWithId: translateWithId
      }))), /*#__PURE__*/React__default["default"].createElement(ListBox$1.Menu, getMenuProps({
        'aria-label': ariaLabel
      }), isOpen ? filterItems(items, itemToString, inputValue).map(function (item, index) {
        var _getItemProps;

        var itemProps = getItemProps((_getItemProps = {
          item: item,
          index: index
        }, _defineProperty$2(_getItemProps, 'aria-current', selectedItem === item ? true : null), _defineProperty$2(_getItemProps, 'aria-selected', highlightedIndex === index ? true : null), _defineProperty$2(_getItemProps, "disabled", item.disabled), _getItemProps));
        return /*#__PURE__*/React__default["default"].createElement(ListBox$1.MenuItem, _extends$3({
          key: itemProps.id,
          isActive: selectedItem === item,
          isHighlighted: highlightedIndex === index || (selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.id) && (selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.id) === item.id || false,
          title: itemToElement ? item.text : itemToString(item)
        }, itemProps), itemToElement ? /*#__PURE__*/React__default["default"].createElement(ItemToElement, _extends$3({
          key: itemProps.id
        }, item)) : itemToString(item), selectedItem === item && /*#__PURE__*/React__default["default"].createElement(Checkmark16, {
          className: "".concat(prefix, "--list-box__menu-item__selected-icon")
        }));
      }) : null)), helperText && !invalid && !warn && /*#__PURE__*/React__default["default"].createElement(Text, {
        as: "div",
        id: comboBoxHelperId,
        className: helperClasses
      }, helperText));
    });
  });
  ComboBox.displayName = 'ComboBox';
  ComboBox.propTypes = {
    /**
     * 'aria-label' of the ListBox component.
     */
    ariaLabel: PropTypes__default["default"].string,

    /**
     * An optional className to add to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the direction of the combobox dropdown. Can be either top or bottom.
     */
    direction: PropTypes__default["default"].oneOf(['top', 'bottom']),

    /**
     * Specify if the control should be disabled, or not
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Additional props passed to Downshift
     */
    downshiftProps: PropTypes__default["default"].shape(Downshift$1.propTypes),

    /**
     * Provide helper text that is used alongside the control label for
     * additional help
     */
    helperText: PropTypes__default["default"].string,

    /**
     * Specify a custom `id` for the input
     */
    id: PropTypes__default["default"].string.isRequired,

    /**
     * Allow users to pass in an arbitrary item or a string (in case their items are an array of strings)
     * from their collection that are pre-selected
     */
    initialSelectedItem: PropTypes__default["default"].oneOfType([PropTypes__default["default"].object, PropTypes__default["default"].string, PropTypes__default["default"].number]),

    /**
     * Specify if the currently selected value is invalid.
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * Message which is displayed if the value is invalid.
     */
    invalidText: PropTypes__default["default"].node,

    /**
     * Optional function to render items as custom components instead of strings.
     * Defaults to null and is overridden by a getter
     */
    itemToElement: PropTypes__default["default"].func,

    /**
     * Helper function passed to downshift that allows the library to render a
     * given item to a string label. By default, it extracts the `label` field
     * from a given item to serve as the item label in the list
     */
    itemToString: PropTypes__default["default"].func,

    /**
     * We try to stay as generic as possible here to allow individuals to pass
     * in a collection of whatever kind of data structure they prefer
     */
    items: PropTypes__default["default"].array.isRequired,

    /**
     * should use "light theme" (white background)?
     */
    light: PropTypes__default["default"].bool,

    /**
     * `onChange` is a utility for this controlled component to communicate to a
     * consuming component when a specific dropdown item is selected.
     * @param {{ selectedItem }}
     */
    onChange: PropTypes__default["default"].func.isRequired,

    /**
     * Callback function to notify consumer when the text input changes.
     * This provides support to change available items based on the text.
     * @param {string} inputText
     */
    onInputChange: PropTypes__default["default"].func,

    /**
     * Helper function passed to Downshift that allows the user to observe internal
     * state changes
     */
    onStateChange: PropTypes__default["default"].func,

    /**
     * Callback function that fires when the combobox menu toggle is clicked
     * @param {MouseEvent} event
     */
    onToggleClick: PropTypes__default["default"].func,

    /**
     * Used to provide a placeholder text node before a user enters any input.
     * This is only present if the control has no items selected
     */
    placeholder: PropTypes__default["default"].string,

    /**
     * For full control of the selection
     */
    selectedItem: PropTypes__default["default"].oneOfType([PropTypes__default["default"].object, PropTypes__default["default"].string, PropTypes__default["default"].number]),

    /**
     * Specify your own filtering logic by passing in a `shouldFilterItem`
     * function that takes in the current input and an item and passes back
     * whether or not the item should be filtered.
     */
    shouldFilterItem: PropTypes__default["default"].func,

    /**
     * Specify the size of the ListBox. Currently supports either `sm`, `md` or `lg` as an option.
     */
    size: ListBoxSize,

    /**
     * Provide text to be used in a `<label>` element that is tied to the
     * combobox via ARIA attributes.
     */
    titleText: PropTypes__default["default"].node,

    /**
     * Specify a custom translation function that takes in a message identifier
     * and returns the localized string for the message
     */
    translateWithId: PropTypes__default["default"].func,

    /**
     * Currently supports either the default type, or an inline variant
     */
    type: ListBoxType,

    /**
     * Specify whether the control is currently in warning state
     */
    warn: PropTypes__default["default"].bool,

    /**
     * Provide the text that is displayed when the control is in warning state
     */
    warnText: PropTypes__default["default"].node
  };
  ComboBox.defaultProps = {
    disabled: false,
    itemToString: defaultItemToString$2,
    itemToElement: null,
    shouldFilterItem: defaultShouldFilterItem,
    type: 'default',
    ariaLabel: 'Choose an item',
    light: false,
    direction: 'bottom'
  };
  var ComboBox$1 = ComboBox;

  var _excluded$2n = ["buttonOnClick", "children", "className", "closeClassName", "closeIconClassName", "closeModal", "iconDescription", "label", "labelClassName", "title", "titleClassName"];
  var ModalHeader$2 = /*#__PURE__*/React__default["default"].forwardRef(function ModalHeader(_ref, ref) {
    var _cx, _cx2, _cx3, _cx4, _cx5;

    var buttonOnClick = _ref.buttonOnClick,
        children = _ref.children,
        customClassName = _ref.className,
        closeClassName = _ref.closeClassName,
        closeIconClassName = _ref.closeIconClassName,
        closeModal = _ref.closeModal,
        iconDescription = _ref.iconDescription,
        label = _ref.label,
        labelClassName = _ref.labelClassName,
        title = _ref.title,
        titleClassName = _ref.titleClassName,
        rest = _objectWithoutProperties$2(_ref, _excluded$2n);

    var prefix = usePrefix();

    function handleCloseButtonClick(evt) {
      closeModal(evt);
      buttonOnClick();
    }

    var headerClass = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--modal-header"), true), _defineProperty$2(_cx, customClassName, customClassName), _cx));
    var labelClass = cx((_cx2 = {}, _defineProperty$2(_cx2, "".concat(prefix, "--modal-header__label ").concat(prefix, "--type-delta"), true), _defineProperty$2(_cx2, labelClassName, labelClassName), _cx2));
    var titleClass = cx((_cx3 = {}, _defineProperty$2(_cx3, "".concat(prefix, "--modal-header__heading ").concat(prefix, "--type-beta"), true), _defineProperty$2(_cx3, titleClassName, titleClassName), _cx3));
    var closeClass = cx((_cx4 = {}, _defineProperty$2(_cx4, "".concat(prefix, "--modal-close"), true), _defineProperty$2(_cx4, closeClassName, closeClassName), _cx4));
    var closeIconClass = cx((_cx5 = {}, _defineProperty$2(_cx5, "".concat(prefix, "--modal-close__icon"), true), _defineProperty$2(_cx5, closeIconClassName, closeIconClassName), _cx5));
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: headerClass
    }, rest, {
      ref: ref
    }), label && /*#__PURE__*/React__default["default"].createElement("h2", {
      className: labelClass
    }, label), title && /*#__PURE__*/React__default["default"].createElement("h3", {
      className: titleClass
    }, title), children, /*#__PURE__*/React__default["default"].createElement("button", {
      onClick: handleCloseButtonClick,
      className: closeClass,
      title: iconDescription,
      "aria-label": iconDescription,
      type: "button"
    }, /*#__PURE__*/React__default["default"].createElement(Close20, {
      className: closeIconClass
    })));
  });
  ModalHeader$2.propTypes = {
    /**
     * Provide an optional function to be called when the close button is
     * clicked
     */
    buttonOnClick: PropTypes__default["default"].func,

    /**
     * Specify the content to be placed in the ModalHeader
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the modal header
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify an optional className to be applied to the modal close node
     */
    closeClassName: PropTypes__default["default"].string,

    /**
     * Specify an optional className to be applied to the modal close icon node
     */
    closeIconClassName: PropTypes__default["default"].string,

    /**
     * Provide an optional function to be called when the modal is closed
     */
    closeModal: PropTypes__default["default"].func,

    /**
     * Specify a description for the close icon that can be read by screen
     * readers
     */
    iconDescription: PropTypes__default["default"].string,

    /**
     * Specify an optional label to be displayed
     */
    label: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the modal header label
     */
    labelClassName: PropTypes__default["default"].string,

    /**
     * Specify an optional title to be displayed
     */
    title: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the modal heading
     */
    titleClassName: PropTypes__default["default"].string
  };
  ModalHeader$2.defaultProps = {
    iconDescription: 'Close',
    buttonOnClick: function buttonOnClick() {},
    closeModal: function closeModal() {}
  };

  var _excluded$2m = ["children", "className", "closeModal", "danger", "inputref", "onRequestClose", "onRequestSubmit", "primaryButtonDisabled", "primaryButtonText", "primaryClassName", "secondaryButtonText", "secondaryButtons", "secondaryClassName"];

  function SecondaryButtonSet(_ref) {
    var secondaryButtons = _ref.secondaryButtons,
        secondaryButtonText = _ref.secondaryButtonText,
        secondaryClassName = _ref.secondaryClassName,
        closeModal = _ref.closeModal,
        onRequestClose = _ref.onRequestClose;

    function handleRequestClose(evt) {
      closeModal(evt);
      onRequestClose(evt);
    }

    if (Array.isArray(secondaryButtons) && secondaryButtons.length <= 2) {
      return secondaryButtons.map(function (_ref2, i) {
        var buttonText = _ref2.buttonText,
            onButtonClick = _ref2.onClick;
        return /*#__PURE__*/React__default["default"].createElement(Button$1, {
          key: "".concat(buttonText, "-").concat(i),
          className: secondaryClassName,
          kind: "secondary",
          onClick: onButtonClick || handleRequestClose
        }, buttonText);
      });
    }

    if (secondaryButtonText) {
      return /*#__PURE__*/React__default["default"].createElement(Button$1, {
        className: secondaryClassName,
        onClick: handleRequestClose,
        kind: "secondary"
      }, secondaryButtonText);
    }

    return null;
  }

  SecondaryButtonSet.propTypes = {
    closeModal: PropTypes__default["default"].func,
    onRequestClose: PropTypes__default["default"].func,
    secondaryButtonText: PropTypes__default["default"].string,
    secondaryButtons: function secondaryButtons(props, propName, componentName) {
      if (props.secondaryButtons) {
        if (!Array.isArray(props.secondaryButtons) || props.secondaryButtons.length !== 2) {
          return new Error("".concat(propName, " needs to be an array of two button config objects"));
        }

        var shape = {
          buttonText: PropTypes__default["default"].node,
          onClick: PropTypes__default["default"].func
        };
        props[propName].forEach(function (secondaryButton) {
          PropTypes__default["default"].checkPropTypes(shape, secondaryButton, propName, componentName);
        });
      }

      return null;
    },
    secondaryClassName: PropTypes__default["default"].string
  };
  var ModalFooter$2 = /*#__PURE__*/React__default["default"].forwardRef(function ModalFooter(_ref3, ref) {
    var _cx;

    var children = _ref3.children,
        customClassName = _ref3.className,
        closeModal = _ref3.closeModal,
        danger = _ref3.danger,
        inputref = _ref3.inputref,
        onRequestClose = _ref3.onRequestClose,
        onRequestSubmit = _ref3.onRequestSubmit,
        primaryButtonDisabled = _ref3.primaryButtonDisabled,
        primaryButtonText = _ref3.primaryButtonText,
        primaryClassName = _ref3.primaryClassName,
        secondaryButtonText = _ref3.secondaryButtonText,
        secondaryButtons = _ref3.secondaryButtons,
        secondaryClassName = _ref3.secondaryClassName,
        rest = _objectWithoutProperties$2(_ref3, _excluded$2m);

    var prefix = usePrefix();
    var footerClass = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--modal-footer"), true), _defineProperty$2(_cx, customClassName, customClassName), _defineProperty$2(_cx, "".concat(prefix, "--modal-footer--three-button"), Array.isArray(secondaryButtons) && secondaryButtons.length === 2), _cx));
    var secondaryButtonProps = {
      closeModal: closeModal,
      secondaryButtons: secondaryButtons,
      secondaryButtonText: secondaryButtonText,
      secondaryClassName: secondaryClassName,
      onRequestClose: onRequestClose
    };
    return /*#__PURE__*/React__default["default"].createElement(ButtonSet$1, _extends$3({
      className: footerClass
    }, rest, {
      ref: ref
    }), /*#__PURE__*/React__default["default"].createElement(SecondaryButtonSet, secondaryButtonProps), primaryButtonText && /*#__PURE__*/React__default["default"].createElement(Button$1, {
      onClick: onRequestSubmit,
      className: primaryClassName,
      disabled: primaryButtonDisabled,
      kind: danger ? 'danger' : 'primary',
      ref: inputref
    }, primaryButtonText), children);
  });
  ModalFooter$2.propTypes = {
    /**
     * Pass in content that will be rendered in the Modal Footer
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify a custom className to be applied to the Modal Footer container
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify an optional function that is called whenever the modal is closed
     */
    closeModal: PropTypes__default["default"].func,

    /**
     * Specify whether the primary button should be replaced with danger button.
     * Note that this prop is not applied if you render primary/danger button by yourself
     */
    danger: PropTypes__default["default"].bool,

    /**
     * The `ref` callback for the primary button.
     */
    inputref: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].shape({
      current: PropTypes__default["default"].any
    })]),

    /**
     * Specify an optional function for when the modal is requesting to be
     * closed
     */
    onRequestClose: PropTypes__default["default"].func,

    /**
     * Specify an optional function for when the modal is requesting to be
     * submitted
     */
    onRequestSubmit: PropTypes__default["default"].func,

    /**
     * Specify whether the primary button should be disabled
     */
    primaryButtonDisabled: PropTypes__default["default"].bool,

    /**
     * Specify the text for the primary button
     */
    primaryButtonText: PropTypes__default["default"].string,

    /**
     * Specify a custom className to be applied to the primary button
     */
    primaryClassName: PropTypes__default["default"].string,

    /**
     * Specify the text for the secondary button
     */
    secondaryButtonText: PropTypes__default["default"].string,

    /**
     * Specify an array of config objects for secondary buttons
     * (`Array<{
     *   buttonText: string,
     *   onClick: function,
     * }>`).
     */
    secondaryButtons: function secondaryButtons(props, propName, componentName) {
      if (props.secondaryButtons) {
        if (!Array.isArray(props.secondaryButtons) || props.secondaryButtons.length !== 2) {
          return new Error("".concat(propName, " needs to be an array of two button config objects"));
        }

        var shape = {
          buttonText: PropTypes__default["default"].node,
          onClick: PropTypes__default["default"].func
        };
        props[propName].forEach(function (secondaryButton) {
          PropTypes__default["default"].checkPropTypes(shape, secondaryButton, propName, componentName);
        });
      }

      return null;
    },

    /**
     * Specify a custom className to be applied to the secondary button
     */
    secondaryClassName: PropTypes__default["default"].string
  };
  ModalFooter$2.defaultProps = {
    onRequestClose: function onRequestClose() {},
    onRequestSubmit: function onRequestSubmit() {},
    closeModal: function closeModal() {}
  };

  /**
   * @param {Function} name The name of the prop that must exist to validate
   * the current prop.
   * @param {Function} propType The original prop type checker.
   * @returns {Function} The new prop type checker for the current prop that
   * becomes required if the prop corresponding to the provided prop name exists.
   */
  function requiredIfGivenPropIsTruthy(name, propType) {
    return function check(props, propName, componentName) {
      if (props[name] == true && props[propName] == null) {
        return new Error("You must provide a value for `".concat(propName, "` in `").concat(componentName, "` if `").concat(name, "` exists."));
      }

      for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        rest[_key - 3] = arguments[_key];
      }

      return propType.apply(void 0, [props, propName, componentName].concat(rest));
    };
  }

  var lodash_findlast = {exports: {}};

  (function (module, exports) {
    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;
    /** Used as the `TypeError` message for "Functions" methods. */

    var FUNC_ERROR_TEXT = 'Expected a function';
    /** Used to stand-in for `undefined` hash values. */

    var HASH_UNDEFINED = '__lodash_hash_undefined__';
    /** Used to compose bitmasks for comparison styles. */

    var UNORDERED_COMPARE_FLAG = 1,
        PARTIAL_COMPARE_FLAG = 2;
    /** Used as references for various `Number` constants. */

    var INFINITY = 1 / 0,
        MAX_SAFE_INTEGER = 9007199254740991,
        MAX_INTEGER = 1.7976931348623157e+308,
        NAN = 0 / 0;
    /** `Object#toString` result references. */

    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        promiseTag = '[object Promise]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]',
        weakMapTag = '[object WeakMap]';
    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
    /** Used to match property names within property paths. */

    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/,
        reLeadingDot = /^\./,
        rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */

    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    /** Used to match leading and trailing whitespace. */

    var reTrim = /^\s+|\s+$/g;
    /** Used to match backslashes in property paths. */

    var reEscapeChar = /\\(\\)?/g;
    /** Used to detect bad signed hexadecimal string values. */

    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    /** Used to detect binary string values. */

    var reIsBinary = /^0b[01]+$/i;
    /** Used to detect host constructors (Safari). */

    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    /** Used to detect octal string values. */

    var reIsOctal = /^0o[0-7]+$/i;
    /** Used to detect unsigned integer values. */

    var reIsUint = /^(?:0|[1-9]\d*)$/;
    /** Used to identify `toStringTag` values of typed arrays. */

    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    /** Built-in method references without a dependency on `root`. */

    var freeParseInt = parseInt;
    /** Detect free variable `global` from Node.js. */

    var freeGlobal = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    /** Detect free variable `self`. */

    var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
    /** Used as a reference to the global object. */

    var root = freeGlobal || freeSelf || Function('return this')();
    /** Detect free variable `exports`. */

    var freeExports = exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Detect free variable `process` from Node.js. */

    var freeProcess = moduleExports && freeGlobal.process;
    /** Used to access faster Node.js helpers. */

    var nodeUtil = function () {
      try {
        return freeProcess && freeProcess.binding('util');
      } catch (e) {}
    }();
    /* Node.js helper references. */


    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */

    function arraySome(array, predicate) {
      var index = -1,
          length = array ? array.length : 0;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }

      return false;
    }
    /**
     * The base implementation of `_.findIndex` and `_.findLastIndex` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {number} fromIndex The index to search from.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */


    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length,
          index = fromIndex + (fromRight ? 1 : -1);

      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }

      return -1;
    }
    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new accessor function.
     */


    function baseProperty(key) {
      return function (object) {
        return object == null ? undefined : object[key];
      };
    }
    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */


    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }

      return result;
    }
    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */


    function baseUnary(func) {
      return function (value) {
        return func(value);
      };
    }
    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */


    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }
    /**
     * Checks if `value` is a host object in IE < 9.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
     */


    function isHostObject(value) {
      // Many host objects are `Object` objects that can coerce to strings
      // despite having improperly defined `toString` methods.
      var result = false;

      if (value != null && typeof value.toString != 'function') {
        try {
          result = !!(value + '');
        } catch (e) {}
      }

      return result;
    }
    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */


    function mapToArray(map) {
      var index = -1,
          result = Array(map.size);
      map.forEach(function (value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */


    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg));
      };
    }
    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */


    function setToArray(set) {
      var index = -1,
          result = Array(set.size);
      set.forEach(function (value) {
        result[++index] = value;
      });
      return result;
    }
    /** Used for built-in method references. */


    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;
    /** Used to detect overreaching core-js shims. */

    var coreJsData = root['__core-js_shared__'];
    /** Used to detect methods masquerading as native. */

    var maskSrcKey = function () {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? 'Symbol(src)_1.' + uid : '';
    }();
    /** Used to resolve the decompiled source of functions. */


    var funcToString = funcProto.toString;
    /** Used to check objects for own properties. */

    var hasOwnProperty = objectProto.hasOwnProperty;
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */

    var objectToString = objectProto.toString;
    /** Used to detect if a method is native. */

    var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
    /** Built-in value references. */

    var _Symbol = root.Symbol,
        Uint8Array = root.Uint8Array,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice;
    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min;
    /* Built-in method references that are verified to be native. */

    var DataView = getNative(root, 'DataView'),
        Map = getNative(root, 'Map'),
        Promise = getNative(root, 'Promise'),
        Set = getNative(root, 'Set'),
        WeakMap = getNative(root, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');
    /** Used to detect maps, sets, and weakmaps. */

    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);
    /** Used to convert symbols to primitives and strings. */

    var symbolProto = _Symbol ? _Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;
    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function Hash(entries) {
      var index = -1,
          length = entries ? entries.length : 0;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */


    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function hashGet(key) {
      var data = this.__data__;

      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }

      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }
    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
    }
    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */


    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
      return this;
    } // Add methods to `Hash`.


    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function ListCache(entries) {
      var index = -1,
          length = entries ? entries.length : 0;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */


    function listCacheClear() {
      this.__data__ = [];
    }
    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }

      var lastIndex = data.length - 1;

      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }

      return true;
    }
    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);
      return index < 0 ? undefined : data[index][1];
    }
    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */


    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }

      return this;
    } // Add methods to `ListCache`.


    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function MapCache(entries) {
      var index = -1,
          length = entries ? entries.length : 0;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */


    function mapCacheClear() {
      this.__data__ = {
        'hash': new Hash(),
        'map': new (Map || ListCache)(),
        'string': new Hash()
      };
    }
    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function mapCacheDelete(key) {
      return getMapData(this, key)['delete'](key);
    }
    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */


    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    } // Add methods to `MapCache`.


    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */

    function SetCache(values) {
      var index = -1,
          length = values ? values.length : 0;
      this.__data__ = new MapCache();

      while (++index < length) {
        this.add(values[index]);
      }
    }
    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */


    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);

      return this;
    }
    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */


    function setCacheHas(value) {
      return this.__data__.has(value);
    } // Add methods to `SetCache`.


    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */


    function stackClear() {
      this.__data__ = new ListCache();
    }
    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function stackDelete(key) {
      return this.__data__['delete'](key);
    }
    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function stackGet(key) {
      return this.__data__.get(key);
    }
    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function stackHas(key) {
      return this.__data__.has(key);
    }
    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */


    function stackSet(key, value) {
      var cache = this.__data__;

      if (cache instanceof ListCache) {
        var pairs = cache.__data__;

        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }

        cache = this.__data__ = new MapCache(pairs);
      }

      cache.set(key, value);
      return this;
    } // Add methods to `Stack`.


    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */

    function arrayLikeKeys(value, inherited) {
      // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
      // Safari 9 makes `arguments.length` enumerable in strict mode.
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length,
          skipIndexes = !!length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
          result.push(key);
        }
      }

      return result;
    }
    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */


    function assocIndexOf(array, key) {
      var length = array.length;

      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }

      return -1;
    }
    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */


    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }

      return index && index == length ? object : undefined;
    }
    /**
     * The base implementation of `getTag`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */


    function baseGetTag(value) {
      return objectToString.call(value);
    }
    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */


    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {boolean} [bitmask] The bitmask of comparison flags.
     *  The bitmask may be composed of the following flags:
     *     1 - Unordered comparison
     *     2 - Partial comparison
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */


    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }

      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }

      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */


    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = arrayTag,
          othTag = arrayTag;

      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }

      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }

      var objIsObj = objTag == objectTag && !isHostObject(object),
          othIsObj = othTag == objectTag && !isHostObject(other),
          isSameTag = objTag == othTag;

      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }

      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }

      if (!isSameTag) {
        return false;
      }

      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */


    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }

      object = Object(object);

      while (index--) {
        var data = matchData[index];

        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }

      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();

          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }

          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }

      return true;
    }
    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */


    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }

      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */


    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */


    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }

      if (value == null) {
        return identity;
      }

      if (_typeof(value) == 'object') {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }

      return property(value);
    }
    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */


    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }

      var result = [];

      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }

      return result;
    }
    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */


    function baseMatches(source) {
      var matchData = getMatchData(source);

      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }

      return function (object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */


    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }

      return function (object) {
        var objValue = get(object, path);
        return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */


    function basePropertyDeep(path) {
      return function (object) {
        return baseGet(object, path);
      };
    }
    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */


    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }

      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }

      var result = value + '';
      return result == '0' && 1 / value == -INFINITY ? '-0' : result;
    }
    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast property path array.
     */


    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */


    function createFind(findIndexFunc) {
      return function (collection, predicate, fromIndex) {
        var iterable = Object(collection);

        if (!isArrayLike(collection)) {
          var iteratee = baseIteratee(predicate);
          collection = keys(collection);

          predicate = function predicate(key) {
            return iteratee(iterable[key], key, iterable);
          };
        }

        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }
    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} customizer The function to customize comparisons.
     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */


    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(array);

      if (stacked && stack.get(other)) {
        return stacked == other;
      }

      var index = -1,
          result = true,
          seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;
      stack.set(array, other);
      stack.set(other, array); // Ignore non-index properties.

      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }

        if (compared !== undefined) {
          if (compared) {
            continue;
          }

          result = false;
          break;
        } // Recursively compare arrays (susceptible to call stack limits).


        if (seen) {
          if (!arraySome(other, function (othValue, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }

      stack['delete'](array);
      stack['delete'](other);
      return result;
    }
    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} customizer The function to customize comparisons.
     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */


    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }

          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }

          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == other + '';

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          } // Assume cyclic values are equal.


          var stacked = stack.get(object);

          if (stacked) {
            return stacked == other;
          }

          bitmask |= UNORDERED_COMPARE_FLAG; // Recursively compare objects (susceptible to call stack limits).

          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }

      }

      return false;
    }
    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} customizer The function to customize comparisons.
     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */


    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
          objProps = keys(object),
          objLength = objProps.length,
          othProps = keys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }

      var index = objLength;

      while (index--) {
        var key = objProps[index];

        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked && stack.get(other)) {
        return stacked == other;
      }

      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;

      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        } // Recursively compare objects (susceptible to call stack limits).


        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }

        skipCtor || (skipCtor = key == 'constructor');
      }

      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

        if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }

      stack['delete'](object);
      stack['delete'](other);
      return result;
    }
    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */


    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
    }
    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */


    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }

      return result;
    }
    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */


    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }
    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */


    var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11,
    // for data views in Edge < 14, and promises in Node.js.

    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function getTag(value) {
        var result = objectToString.call(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : undefined;

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;

            case mapCtorString:
              return mapTag;

            case promiseCtorString:
              return promiseTag;

            case setCtorString:
              return setTag;

            case weakMapCtorString:
              return weakMapTag;
          }
        }

        return result;
      };
    }
    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */


    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result,
          index = -1,
          length = path.length;

      while (++index < length) {
        var key = toKey(path[index]);

        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }

        object = object[key];
      }

      if (result) {
        return result;
      }

      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */


    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
    }
    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */


    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }

      var type = _typeof(value);

      if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
        return true;
      }

      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */


    function isKeyable(value) {
      var type = _typeof(value);

      return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
    }
    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */


    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */


    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
      return value === proto;
    }
    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */


    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */


    function matchesStrictComparable(key, srcValue) {
      return function (object) {
        if (object == null) {
          return false;
        }

        return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
      };
    }
    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */


    var stringToPath = memoize(function (string) {
      string = toString(string);
      var result = [];

      if (reLeadingDot.test(string)) {
        result.push('');
      }

      string.replace(rePropName, function (match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
      });
      return result;
    });
    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */

    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }

      var result = value + '';
      return result == '0' && 1 / value == -INFINITY ? '-0' : result;
    }
    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to process.
     * @returns {string} Returns the source code.
     */


    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}

        try {
          return func + '';
        } catch (e) {}
      }

      return '';
    }
    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */


    function findLastIndex(array, predicate, fromIndex) {
      var length = array ? array.length : 0;

      if (!length) {
        return -1;
      }

      var index = length - 1;

      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }

      return baseFindIndex(array, baseIteratee(predicate), index, true);
    }
    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */


    var findLast = createFind(findLastIndex);
    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */

    function memoize(func, resolver) {
      if (typeof func != 'function' || resolver && typeof resolver != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }

      var memoized = function memoized() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }

        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };

      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    } // Assign cache to `_.memoize`.


    memoize.Cache = MapCache;
    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */

    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */


    function isArguments(value) {
      // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
      return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
    }
    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */


    var isArray = Array.isArray;
    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */

    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */


    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */


    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8-9 which returns 'object' for typed array and other constructors.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */


    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */


    function isObject(value) {
      var type = _typeof(value);

      return !!value && (type == 'object' || type == 'function');
    }
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */


    function isObjectLike(value) {
      return !!value && _typeof(value) == 'object';
    }
    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */


    function isSymbol(value) {
      return _typeof(value) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */


    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */

    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }

      value = toNumber(value);

      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }

      return value === value ? value : 0;
    }
    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */


    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */


    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }

      if (isSymbol(value)) {
        return NAN;
      }

      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? other + '' : other;
      }

      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }

      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */


    function toString(value) {
      return value == null ? '' : baseToString(value);
    }
    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */


    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }
    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */


    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */


    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */


    function identity(value) {
      return value;
    }
    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */


    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    module.exports = findLast;
  })(lodash_findlast, lodash_findlast.exports);

  var findLast = lodash_findlast.exports;

  var prefix$5 = settings_1.prefix;
  /**
   * @param {Node} node A DOM node.
   * @param {string[]} selectorsFloatingMenus The CSS selectors that matches floating menus.
   * @returns {boolean} `true` of the given `node` is in a floating menu.
   */

  function elementOrParentIsFloatingMenu(node) {
    var selectorsFloatingMenus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    if (node && typeof node.closest === 'function') {
      var allSelectorsFloatingMenus = [".".concat(prefix$5, "--overflow-menu-options"), ".".concat(prefix$5, "--tooltip"), '.flatpickr-calendar'].concat(_toConsumableArray(selectorsFloatingMenus));
      return allSelectorsFloatingMenus.some(function (selector) {
        return node.closest(selector);
      });
    }
  }
  /**
   * Ensures the focus is kept in the given `modalNode`, implementing "focus-wrap" behavior.
   * @param {object} options The options.
   * @param {Node} options.bodyNode
   * @param {Node} options.startTrapNode The DOM node of the focus sentinel the is placed earlier next to `modalNode`.
   * @param {Node} options.endTrapNode The DOM node of the focus sentinel the is placed next to `modalNode`.
   * @param {Node} options.currentActiveNode The DOM node that has focus.
   * @param {Node} options.oldActiveNode The DOM node that previously had focus.
   * @param {Node} [options.selectorsFloatingMenus] The CSS selectors that matches floating menus.
   */


  function wrapFocus(_ref) {
    var bodyNode = _ref.bodyNode,
        startTrapNode = _ref.startTrapNode,
        endTrapNode = _ref.endTrapNode,
        currentActiveNode = _ref.currentActiveNode,
        oldActiveNode = _ref.oldActiveNode,
        selectorsFloatingMenus = _ref.selectorsFloatingMenus;

    if (bodyNode && currentActiveNode && oldActiveNode && !bodyNode.contains(currentActiveNode) && !elementOrParentIsFloatingMenu(currentActiveNode, selectorsFloatingMenus)) {
      var comparisonResult = oldActiveNode.compareDocumentPosition(currentActiveNode);

      if (currentActiveNode === startTrapNode || comparisonResult & DOCUMENT_POSITION_BROAD_PRECEDING) {
        var tabbable = findLast(bodyNode.querySelectorAll(selectorTabbable), function (elem) {
          return Boolean(elem.offsetParent);
        });

        if (tabbable) {
          tabbable.focus();
        } else if (bodyNode !== oldActiveNode) {
          bodyNode.focus();
        }
      } else if (currentActiveNode === endTrapNode || comparisonResult & DOCUMENT_POSITION_BROAD_FOLLOWING) {
        var _tabbable = Array.prototype.find.call(bodyNode.querySelectorAll(selectorTabbable), function (elem) {
          return Boolean(elem.offsetParent);
        });

        if (_tabbable) {
          _tabbable.focus();
        } else if (bodyNode !== oldActiveNode) {
          bodyNode.focus();
        }
      }
    }
  }

  var _defineProperty2$5, _ModalBody$propTypes$1;

  var _excluded$2l = ["aria-labelledby", "aria-label", "className", "containerClassName", "children", "danger", "preventCloseOnClickOutside", "selectorPrimaryFocus", "selectorsFloatingMenus", "size", "forwardedRef"],
      _excluded2$f = ["className", "labelClassName", "titleClassName", "closeClassName", "closeIconClassName", "label", "title", "children", "iconDescription", "closeModal", "buttonOnClick", "preventCloseOnClickOutside", "forwardedRef"],
      _excluded3$a = ["className", "children", "hasForm", "hasScrollingContent", "preventCloseOnClickOutside"],
      _excluded4$9 = ["className", "primaryClassName", "secondaryButtons", "secondaryClassName", "secondaryButtonText", "primaryButtonText", "primaryButtonDisabled", "closeModal", "onRequestClose", "onRequestSubmit", "children", "danger", "inputref", "forwardedRef"];

  var ComposedModal$1 = /*#__PURE__*/function (_Component) {
    _inherits(ComposedModal, _Component);

    var _super = _createSuper(ComposedModal);

    function ComposedModal() {
      var _this;

      _classCallCheck$1(this, ComposedModal);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty$2(_assertThisInitialized$1(_this), "state", {});

      _defineProperty$2(_assertThisInitialized$1(_this), "outerModal", /*#__PURE__*/React__default["default"].createRef());

      _defineProperty$2(_assertThisInitialized$1(_this), "innerModal", /*#__PURE__*/React__default["default"].createRef());

      _defineProperty$2(_assertThisInitialized$1(_this), "button", /*#__PURE__*/React__default["default"].createRef());

      _defineProperty$2(_assertThisInitialized$1(_this), "startSentinel", /*#__PURE__*/React__default["default"].createRef());

      _defineProperty$2(_assertThisInitialized$1(_this), "endSentinel", /*#__PURE__*/React__default["default"].createRef());

      _defineProperty$2(_assertThisInitialized$1(_this), "handleKeyDown", function (evt) {
        // Esc key
        if (evt.which === 27) {
          _this.closeModal(evt);
        }

        _this.props.onKeyDown(evt);
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleClick", function (evt) {
        if (!_this.innerModal.current.contains(evt.target) && _this.props.preventCloseOnClickOutside) {
          return;
        }

        if (_this.innerModal.current && !_this.innerModal.current.contains(evt.target)) {
          _this.closeModal(evt);
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleBlur", function (_ref) {
        var oldActiveNode = _ref.target,
            currentActiveNode = _ref.relatedTarget;
        var _this$props = _this.props,
            open = _this$props.open,
            selectorsFloatingMenus = _this$props.selectorsFloatingMenus;

        if (open && currentActiveNode && oldActiveNode) {
          var bodyNode = _this.innerModal.current;
          var startSentinelNode = _this.startSentinel.current;
          var endSentinelNode = _this.endSentinel.current;
          wrapFocus({
            bodyNode: bodyNode,
            startSentinelNode: startSentinelNode,
            endSentinelNode: endSentinelNode,
            currentActiveNode: currentActiveNode,
            oldActiveNode: oldActiveNode,
            selectorsFloatingMenus: selectorsFloatingMenus
          });
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "focusButton", function (focusContainerElement) {
        if (focusContainerElement) {
          var primaryFocusElement = focusContainerElement.querySelector(_this.props.selectorPrimaryFocus);

          if (primaryFocusElement) {
            primaryFocusElement.focus();
            return;
          }

          if (_this.button.current) {
            _this.button.current.focus();
          }
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleTransitionEnd", function (evt) {
        if (_this.outerModal.current.offsetWidth && _this.outerModal.current.offsetHeight && _this.beingOpen) {
          _this.focusButton(evt.currentTarget);

          _this.beingOpen = false;
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "closeModal", function (evt) {
        var onClose = _this.props.onClose;

        if (!onClose || onClose(evt) !== false) {
          _this.setState({
            open: false
          });
        }
      });

      return _this;
    }

    _createClass$1(ComposedModal, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps, prevState) {
        if (!prevState.open && this.state.open) {
          this.beingOpen = true;
        } else if (prevState.open && !this.state.open) {
          this.beingOpen = false;
        }

        if (prevState.open !== this.state.open) {
          toggleClass$1(document.body, "".concat(this.context, "--body--with-modal-open"), this.state.open);
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        toggleClass$1(document.body, "".concat(this.context, "--body--with-modal-open"), false);
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        toggleClass$1(document.body, "".concat(this.context, "--body--with-modal-open"), this.props.open);

        if (!this.props.open) {
          return;
        }

        if (this.innerModal.current) {
          this.focusButton(this.innerModal.current);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _classNames,
            _classNames2,
            _this2 = this;

        var open = this.state.open;
        var prefix = this.context;

        var _this$props2 = this.props,
            ariaLabelledBy = _this$props2['aria-labelledby'],
            ariaLabel = _this$props2['aria-label'],
            className = _this$props2.className,
            containerClassName = _this$props2.containerClassName,
            children = _this$props2.children,
            danger = _this$props2.danger;
            _this$props2.preventCloseOnClickOutside;
            _this$props2.selectorPrimaryFocus;
            _this$props2.selectorsFloatingMenus;
            var size = _this$props2.size,
            forwardedRef = _this$props2.forwardedRef,
            other = _objectWithoutProperties$2(_this$props2, _excluded$2l);

        var modalClass = cx((_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--modal"), true), _defineProperty$2(_classNames, 'is-visible', open), _defineProperty$2(_classNames, className, className), _defineProperty$2(_classNames, "".concat(prefix, "--modal--danger"), danger), _classNames));
        var containerClass = cx((_classNames2 = {}, _defineProperty$2(_classNames2, "".concat(prefix, "--modal-container"), true), _defineProperty$2(_classNames2, "".concat(prefix, "--modal-container--").concat(size), size), _defineProperty$2(_classNames2, containerClassName, containerClassName), _classNames2)); // Generate aria-label based on Modal Header label if one is not provided (L253)

        var generatedAriaLabel;
        var childrenWithProps = React__default["default"].Children.toArray(children).map(function (child) {
          switch (child.type) {
            case React__default["default"].createElement(ModalHeader$1).type:
              generatedAriaLabel = child.props.label;
              return /*#__PURE__*/React__default["default"].cloneElement(child, {
                closeModal: _this2.closeModal
              });

            case React__default["default"].createElement(ModalFooter$1).type:
              return /*#__PURE__*/React__default["default"].cloneElement(child, {
                closeModal: _this2.closeModal,
                inputref: _this2.button
              });

            default:
              return child;
          }
        });
        return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({}, other, {
          role: "presentation",
          ref: function ref(node) {
            if (node) {
              _this2.outerModal.current = node;

              if (typeof forwardedRef === 'function') {
                forwardedRef(node);
              } else if (_typeof(forwardedRef) === 'object') {
                forwardedRef.current = node;
              }
            }
          },
          "aria-hidden": !open,
          onBlur: this.handleBlur,
          onClick: this.handleClick,
          onKeyDown: this.handleKeyDown,
          onTransitionEnd: open ? this.handleTransitionEnd : undefined,
          className: modalClass
        }), /*#__PURE__*/React__default["default"].createElement("div", {
          className: containerClass,
          role: "dialog",
          "aria-modal": "true",
          "aria-label": ariaLabel ? ariaLabel : generatedAriaLabel,
          "aria-labelledby": ariaLabelledBy
        }, /*#__PURE__*/React__default["default"].createElement("button", {
          type: "button",
          ref: this.startSentinel,
          className: "".concat(prefix, "--visually-hidden")
        }, "Focus sentinel"), /*#__PURE__*/React__default["default"].createElement("div", {
          ref: this.innerModal,
          className: "".concat(prefix, "--modal-container-body")
        }, childrenWithProps), /*#__PURE__*/React__default["default"].createElement("button", {
          type: "button",
          ref: this.endSentinel,
          className: "".concat(prefix, "--visually-hidden")
        }, "Focus sentinel")));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref2, state) {
        var open = _ref2.open;
        var prevOpen = state.prevOpen;
        return prevOpen === open ? null : {
          open: open,
          prevOpen: open
        };
      }
    }]);

    return ComposedModal;
  }(React.Component);

  _defineProperty$2(ComposedModal$1, "contextType", PrefixContext);

  _defineProperty$2(ComposedModal$1, "defaultProps", {
    onKeyDown: function onKeyDown() {},
    selectorPrimaryFocus: '[data-modal-primary-focus]'
  });

  _defineProperty$2(ComposedModal$1, "propTypes", (_defineProperty2$5 = {}, _defineProperty$2(_defineProperty2$5, 'aria-label', PropTypes__default["default"].string), _defineProperty$2(_defineProperty2$5, 'aria-labelledby', PropTypes__default["default"].string), _defineProperty$2(_defineProperty2$5, "children", PropTypes__default["default"].node), _defineProperty$2(_defineProperty2$5, "className", PropTypes__default["default"].string), _defineProperty$2(_defineProperty2$5, "containerClassName", PropTypes__default["default"].string), _defineProperty$2(_defineProperty2$5, "danger", PropTypes__default["default"].bool), _defineProperty$2(_defineProperty2$5, "onClose", PropTypes__default["default"].func), _defineProperty$2(_defineProperty2$5, "onKeyDown", PropTypes__default["default"].func), _defineProperty$2(_defineProperty2$5, "open", PropTypes__default["default"].bool), _defineProperty$2(_defineProperty2$5, "preventCloseOnClickOutside", PropTypes__default["default"].bool), _defineProperty$2(_defineProperty2$5, "selectorPrimaryFocus", PropTypes__default["default"].string), _defineProperty$2(_defineProperty2$5, "selectorsFloatingMenus", PropTypes__default["default"].arrayOf(PropTypes__default["default"].string)), _defineProperty$2(_defineProperty2$5, "size", PropTypes__default["default"].oneOf(['xs', 'sm', 'md', 'lg'])), _defineProperty2$5));
  var ModalHeader$1 = /*#__PURE__*/function (_Component2) {
    _inherits(ModalHeader, _Component2);

    var _super2 = _createSuper(ModalHeader);

    function ModalHeader() {
      var _this3;

      _classCallCheck$1(this, ModalHeader);

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      _this3 = _super2.call.apply(_super2, [this].concat(args));

      _defineProperty$2(_assertThisInitialized$1(_this3), "handleCloseButtonClick", function (evt) {
        _this3.props.closeModal(evt);

        _this3.props.buttonOnClick();
      });

      return _this3;
    }

    _createClass$1(ModalHeader, [{
      key: "render",
      value: function render() {
        var _classNames3, _classNames4, _classNames5, _classNames6, _classNames7;

        var _this$props3 = this.props,
            className = _this$props3.className,
            labelClassName = _this$props3.labelClassName,
            titleClassName = _this$props3.titleClassName,
            closeClassName = _this$props3.closeClassName,
            closeIconClassName = _this$props3.closeIconClassName,
            label = _this$props3.label,
            title = _this$props3.title,
            children = _this$props3.children,
            iconDescription = _this$props3.iconDescription;
            _this$props3.closeModal;
            _this$props3.buttonOnClick;
            _this$props3.preventCloseOnClickOutside;
            var forwardedRef = _this$props3.forwardedRef,
            other = _objectWithoutProperties$2(_this$props3, _excluded2$f);

        var prefix = this.context;
        var headerClass = cx((_classNames3 = {}, _defineProperty$2(_classNames3, "".concat(prefix, "--modal-header"), true), _defineProperty$2(_classNames3, className, className), _classNames3));
        var labelClass = cx((_classNames4 = {}, _defineProperty$2(_classNames4, "".concat(prefix, "--modal-header__label ").concat(prefix, "--type-delta"), true), _defineProperty$2(_classNames4, labelClassName, labelClassName), _classNames4));
        var titleClass = cx((_classNames5 = {}, _defineProperty$2(_classNames5, "".concat(prefix, "--modal-header__heading ").concat(prefix, "--type-beta"), true), _defineProperty$2(_classNames5, titleClassName, titleClassName), _classNames5));
        var closeClass = cx((_classNames6 = {}, _defineProperty$2(_classNames6, "".concat(prefix, "--modal-close"), true), _defineProperty$2(_classNames6, closeClassName, closeClassName), _classNames6));
        var closeIconClass = cx((_classNames7 = {}, _defineProperty$2(_classNames7, "".concat(prefix, "--modal-close__icon"), true), _defineProperty$2(_classNames7, closeIconClassName, closeIconClassName), _classNames7));
        return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
          className: headerClass
        }, other, {
          ref: forwardedRef
        }), label && /*#__PURE__*/React__default["default"].createElement("h2", {
          className: labelClass
        }, label), title && /*#__PURE__*/React__default["default"].createElement("h3", {
          className: titleClass
        }, title), children, /*#__PURE__*/React__default["default"].createElement("button", {
          onClick: this.handleCloseButtonClick,
          className: closeClass,
          title: iconDescription,
          "aria-label": iconDescription,
          type: "button"
        }, /*#__PURE__*/React__default["default"].createElement(Close20, {
          className: closeIconClass
        })));
      }
    }]);

    return ModalHeader;
  }(React.Component);

  _defineProperty$2(ModalHeader$1, "propTypes", {
    /**
     * Provide an optional function to be called when the close button is
     * clicked
     */
    buttonOnClick: PropTypes__default["default"].func,

    /**
     * Specify the content to be placed in the ModalHeader
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the modal header
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify an optional className to be applied to the modal close node
     */
    closeClassName: PropTypes__default["default"].string,

    /**
     * Specify an optional className to be applied to the modal close icon node
     */
    closeIconClassName: PropTypes__default["default"].string,

    /**
     * Provide an optional function to be called when the modal is closed
     */
    closeModal: PropTypes__default["default"].func,

    /**
     * Specify a description for the close icon that can be read by screen
     * readers
     */
    iconDescription: PropTypes__default["default"].string,

    /**
     * Specify an optional label to be displayed
     */
    label: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the modal header label
     */
    labelClassName: PropTypes__default["default"].string,

    /**
     * Specify an optional title to be displayed
     */
    title: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the modal heading
     */
    titleClassName: PropTypes__default["default"].string
  });

  _defineProperty$2(ModalHeader$1, "contextType", PrefixContext);

  _defineProperty$2(ModalHeader$1, "defaultProps", {
    iconDescription: 'Close',
    buttonOnClick: function buttonOnClick() {}
  });

  var ModalBody$1 = /*#__PURE__*/React__default["default"].forwardRef(function ModalBody(props, ref) {
    var _classNames8;

    var className = props.className,
        children = props.children,
        hasForm = props.hasForm,
        hasScrollingContent = props.hasScrollingContent;
        props.preventCloseOnClickOutside;
        var other = _objectWithoutProperties$2(props, _excluded3$a);

    var prefix = usePrefix();
    var contentClass = cx((_classNames8 = {}, _defineProperty$2(_classNames8, "".concat(prefix, "--modal-content"), true), _defineProperty$2(_classNames8, "".concat(prefix, "--modal-content--with-form"), hasForm), _defineProperty$2(_classNames8, "".concat(prefix, "--modal-scroll-content"), hasScrollingContent), _defineProperty$2(_classNames8, className, className), _classNames8));
    var hasScrollingContentProps = hasScrollingContent ? {
      tabIndex: 0,
      role: 'region'
    } : {};
    return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: contentClass
    }, hasScrollingContentProps, other, {
      ref: ref
    }), children), hasScrollingContent && /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--modal-content--overflow-indicator")
    }));
  });
  ModalBody$1.propTypes = (_ModalBody$propTypes$1 = {}, _defineProperty$2(_ModalBody$propTypes$1, 'aria-label', requiredIfGivenPropIsTruthy('hasScrollingContent', PropTypes__default["default"].string)), _defineProperty$2(_ModalBody$propTypes$1, "children", PropTypes__default["default"].node), _defineProperty$2(_ModalBody$propTypes$1, "className", PropTypes__default["default"].string), _defineProperty$2(_ModalBody$propTypes$1, "hasForm", PropTypes__default["default"].bool), _defineProperty$2(_ModalBody$propTypes$1, "hasScrollingContent", PropTypes__default["default"].bool), _ModalBody$propTypes$1);
  var ModalFooter$1 = /*#__PURE__*/function (_Component3) {
    _inherits(ModalFooter, _Component3);

    var _super3 = _createSuper(ModalFooter);

    function ModalFooter() {
      var _this4;

      _classCallCheck$1(this, ModalFooter);

      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      _this4 = _super3.call.apply(_super3, [this].concat(args));

      _defineProperty$2(_assertThisInitialized$1(_this4), "handleRequestClose", function (evt) {
        _this4.props.closeModal(evt);

        _this4.props.onRequestClose(evt);
      });

      return _this4;
    }

    _createClass$1(ModalFooter, [{
      key: "render",
      value: function render() {
        var _classNames9,
            _this5 = this;

        var _this$props4 = this.props,
            className = _this$props4.className,
            primaryClassName = _this$props4.primaryClassName,
            secondaryButtons = _this$props4.secondaryButtons,
            secondaryClassName = _this$props4.secondaryClassName,
            secondaryButtonText = _this$props4.secondaryButtonText,
            primaryButtonText = _this$props4.primaryButtonText,
            primaryButtonDisabled = _this$props4.primaryButtonDisabled;
            _this$props4.closeModal;
            _this$props4.onRequestClose;
            var onRequestSubmit = _this$props4.onRequestSubmit,
            children = _this$props4.children,
            danger = _this$props4.danger,
            inputref = _this$props4.inputref,
            forwardedRef = _this$props4.forwardedRef,
            other = _objectWithoutProperties$2(_this$props4, _excluded4$9);

        var prefix = this.context;
        var footerClass = cx((_classNames9 = {}, _defineProperty$2(_classNames9, "".concat(prefix, "--modal-footer"), true), _defineProperty$2(_classNames9, className, className), _defineProperty$2(_classNames9, "".concat(prefix, "--modal-footer--three-button"), Array.isArray(secondaryButtons) && secondaryButtons.length === 2), _classNames9));
        var primaryClass = cx(_defineProperty$2({}, primaryClassName, primaryClassName));
        var secondaryClass = cx(_defineProperty$2({}, secondaryClassName, secondaryClassName));

        var SecondaryButtonSet = function SecondaryButtonSet() {
          if (Array.isArray(secondaryButtons) && secondaryButtons.length <= 2) {
            return secondaryButtons.map(function (_ref3, i) {
              var buttonText = _ref3.buttonText,
                  onButtonClick = _ref3.onClick;
              return /*#__PURE__*/React__default["default"].createElement(Button$1, {
                key: "".concat(buttonText, "-").concat(i),
                className: secondaryClass,
                kind: "secondary",
                onClick: onButtonClick || _this5.handleRequestClose
              }, buttonText);
            });
          }

          if (secondaryButtonText) {
            return /*#__PURE__*/React__default["default"].createElement(Button$1, {
              className: secondaryClass,
              onClick: _this5.handleRequestClose,
              kind: "secondary"
            }, secondaryButtonText);
          }

          return null;
        };

        return /*#__PURE__*/React__default["default"].createElement(ButtonSet$1, _extends$3({
          className: footerClass
        }, other, {
          ref: forwardedRef
        }), /*#__PURE__*/React__default["default"].createElement(SecondaryButtonSet, null), primaryButtonText && /*#__PURE__*/React__default["default"].createElement(Button$1, {
          onClick: onRequestSubmit,
          className: primaryClass,
          disabled: primaryButtonDisabled,
          kind: danger ? 'danger' : 'primary',
          ref: inputref
        }, primaryButtonText), children);
      }
    }]);

    return ModalFooter;
  }(React.Component);

  _defineProperty$2(ModalFooter$1, "propTypes", {
    /**
     * Pass in content that will be rendered in the Modal Footer
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify a custom className to be applied to the Modal Footer container
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify an optional function that is called whenever the modal is closed
     */
    closeModal: PropTypes__default["default"].func,

    /**
     * Specify whether the primary button should be replaced with danger button.
     * Note that this prop is not applied if you render primary/danger button by yourself
     */
    danger: PropTypes__default["default"].bool,

    /**
     * The `ref` callback for the primary button.
     */
    inputref: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].shape({
      current: PropTypes__default["default"].any
    })]),

    /**
     * Specify an optional function for when the modal is requesting to be
     * closed
     */
    onRequestClose: PropTypes__default["default"].func,

    /**
     * Specify an optional function for when the modal is requesting to be
     * submitted
     */
    onRequestSubmit: PropTypes__default["default"].func,

    /**
     * Specify whether the primary button should be disabled
     */
    primaryButtonDisabled: PropTypes__default["default"].bool,

    /**
     * Specify the text for the primary button
     */
    primaryButtonText: PropTypes__default["default"].string,

    /**
     * Specify a custom className to be applied to the primary button
     */
    primaryClassName: PropTypes__default["default"].string,

    /**
     * Specify the text for the secondary button
     */
    secondaryButtonText: PropTypes__default["default"].string,

    /**
     * Specify an array of config objects for secondary buttons
     * (`Array<{
     *   buttonText: string,
     *   onClick: function,
     * }>`).
     */
    secondaryButtons: function secondaryButtons(props, propName, componentName) {
      if (props.secondaryButtons) {
        if (!Array.isArray(props.secondaryButtons) || props.secondaryButtons.length !== 2) {
          return new Error("".concat(propName, " needs to be an array of two button config objects"));
        }

        var shape = {
          buttonText: PropTypes__default["default"].node,
          onClick: PropTypes__default["default"].func
        };
        props[propName].forEach(function (secondaryButton) {
          PropTypes__default["default"].checkPropTypes(shape, secondaryButton, propName, componentName);
        });
      }

      return null;
    },

    /**
     * Specify a custom className to be applied to the secondary button
     */
    secondaryClassName: PropTypes__default["default"].string
  });

  _defineProperty$2(ModalFooter$1, "defaultProps", {
    onRequestClose: function onRequestClose() {},
    onRequestSubmit: function onRequestSubmit() {}
  });

  _defineProperty$2(ModalFooter$1, "contextType", PrefixContext);

  var _ModalBody$propTypes, _ComposedModal$propTy;

  var _excluded$2k = ["className", "children", "hasForm", "hasScrollingContent"],
      _excluded2$e = ["aria-labelledby", "aria-label", "children", "className", "containerClassName", "danger", "onClose", "onKeyDown", "open", "preventCloseOnClickOutside", "selectorPrimaryFocus", "selectorsFloatingMenus", "size"];
  var ModalBody = /*#__PURE__*/React__default["default"].forwardRef(function ModalBody(_ref, ref) {
    var _cx;

    var customClassName = _ref.className,
        children = _ref.children,
        hasForm = _ref.hasForm,
        hasScrollingContent = _ref.hasScrollingContent,
        rest = _objectWithoutProperties$2(_ref, _excluded$2k);

    var prefix = usePrefix();
    var contentClass = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--modal-content"), true), _defineProperty$2(_cx, "".concat(prefix, "--modal-content--with-form"), hasForm), _defineProperty$2(_cx, "".concat(prefix, "--modal-scroll-content"), hasScrollingContent), _defineProperty$2(_cx, customClassName, customClassName), _cx));
    var hasScrollingContentProps = hasScrollingContent ? {
      tabIndex: 0,
      role: 'region'
    } : {};
    return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: contentClass
    }, hasScrollingContentProps, rest, {
      ref: ref
    }), children), hasScrollingContent && /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--modal-content--overflow-indicator")
    }));
  });
  ModalBody.propTypes = (_ModalBody$propTypes = {}, _defineProperty$2(_ModalBody$propTypes, 'aria-label', requiredIfGivenPropIsTruthy('hasScrollingContent', PropTypes__default["default"].string)), _defineProperty$2(_ModalBody$propTypes, "children", PropTypes__default["default"].node), _defineProperty$2(_ModalBody$propTypes, "className", PropTypes__default["default"].string), _defineProperty$2(_ModalBody$propTypes, "hasForm", PropTypes__default["default"].bool), _defineProperty$2(_ModalBody$propTypes, "hasScrollingContent", PropTypes__default["default"].bool), _ModalBody$propTypes);
  var ComposedModal = /*#__PURE__*/React__default["default"].forwardRef(function ComposedModal(_ref2, ref) {
    var _cx2, _cx3;

    var ariaLabelledBy = _ref2['aria-labelledby'],
        ariaLabel = _ref2['aria-label'],
        children = _ref2.children,
        customClassName = _ref2.className,
        containerClassName = _ref2.containerClassName,
        danger = _ref2.danger,
        onClose = _ref2.onClose,
        onKeyDown = _ref2.onKeyDown,
        open = _ref2.open,
        preventCloseOnClickOutside = _ref2.preventCloseOnClickOutside,
        selectorPrimaryFocus = _ref2.selectorPrimaryFocus,
        selectorsFloatingMenus = _ref2.selectorsFloatingMenus,
        size = _ref2.size,
        rest = _objectWithoutProperties$2(_ref2, _excluded2$e);

    var prefix = usePrefix();

    var _useState = React.useState(open),
        _useState2 = _slicedToArray$1(_useState, 2),
        isOpen = _useState2[0],
        setisOpen = _useState2[1];

    var _useState3 = React.useState(open),
        _useState4 = _slicedToArray$1(_useState3, 2),
        prevOpen = _useState4[0],
        setPrevOpen = _useState4[1];

    var innerModal = React.useRef();
    var button = React.useRef();
    var startSentinel = React.useRef();
    var endSentinel = React.useRef();

    if (open !== prevOpen) {
      setisOpen(open);
      setPrevOpen(open);
    }

    function handleKeyDown(evt) {
      // Esc key
      if (evt.which === 27) {
        closeModal(evt);
      }

      onKeyDown(evt);
    }

    function handleClick(evt) {
      if (!innerModal.current.contains(evt.target) && preventCloseOnClickOutside) {
        return;
      }

      if (innerModal.current && !innerModal.current.contains(evt.target)) {
        closeModal(evt);
      }
    }

    function handleBlur(_ref3) {
      var oldActiveNode = _ref3.target,
          currentActiveNode = _ref3.relatedTarget;

      if (open && currentActiveNode && oldActiveNode) {
        var bodyNode = innerModal.current;
        var startSentinelNode = startSentinel.current;
        var endSentinelNode = endSentinel.current;
        wrapFocus({
          bodyNode: bodyNode,
          startSentinelNode: startSentinelNode,
          endSentinelNode: endSentinelNode,
          currentActiveNode: currentActiveNode,
          oldActiveNode: oldActiveNode,
          selectorsFloatingMenus: selectorsFloatingMenus
        });
      }
    }

    function closeModal(evt) {
      if (!onClose || onClose(evt) !== false) {
        setisOpen(false);
      }
    }

    var modalClass = cx((_cx2 = {}, _defineProperty$2(_cx2, "".concat(prefix, "--modal"), true), _defineProperty$2(_cx2, 'is-visible', isOpen), _defineProperty$2(_cx2, customClassName, customClassName), _defineProperty$2(_cx2, "".concat(prefix, "--modal--danger"), danger), _cx2));
    var containerClass = cx((_cx3 = {}, _defineProperty$2(_cx3, "".concat(prefix, "--modal-container"), true), _defineProperty$2(_cx3, "".concat(prefix, "--modal-container--").concat(size), size), _defineProperty$2(_cx3, containerClassName, containerClassName), _cx3)); // Generate aria-label based on Modal Header label if one is not provided (L253)

    var generatedAriaLabel;
    var childrenWithProps = React__default["default"].Children.toArray(children).map(function (child) {
      switch (child.type) {
        case React__default["default"].createElement(ModalHeader$2).type:
          generatedAriaLabel = child.props.label;
          return /*#__PURE__*/React__default["default"].cloneElement(child, {
            closeModal: closeModal
          });

        case React__default["default"].createElement(ModalFooter$1).type:
          return /*#__PURE__*/React__default["default"].cloneElement(child, {
            closeModal: closeModal,
            inputref: button
          });

        default:
          return child;
      }
    });
    React.useEffect(function () {
      if (prevOpen !== isOpen) {
        toggleClass$1(document.body, "".concat(prefix, "--body--with-modal-open"), isOpen);
      }
    });
    React.useEffect(function () {
      return function () {
        return toggleClass$1(document.body, "".concat(prefix, "--body--with-modal-open"), false);
      };
    });
    React.useEffect(function () {
      toggleClass$1(document.body, "".concat(prefix, "--body--with-modal-open"), open);
    }, [open, prefix]);
    React.useEffect(function () {
      var focusButton = function focusButton(focusContainerElement) {
        if (focusContainerElement) {
          var primaryFocusElement = focusContainerElement.querySelector(selectorPrimaryFocus);

          if (primaryFocusElement) {
            primaryFocusElement.focus();
            return;
          }

          if (button.current) {
            button.current.focus();
          }
        }
      };

      if (!open) {
        return;
      }

      if (innerModal.current) {
        focusButton(innerModal.current);
      }
    }, [open, selectorPrimaryFocus]);
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({}, rest, {
      role: "presentation",
      ref: ref,
      onBlur: handleBlur,
      onClick: handleClick,
      onKeyDown: handleKeyDown,
      className: modalClass
    }), /*#__PURE__*/React__default["default"].createElement("span", {
      ref: startSentinel,
      tabIndex: "0",
      role: "link",
      className: "".concat(prefix, "--visually-hidden")
    }, "Focus sentinel"), /*#__PURE__*/React__default["default"].createElement("div", {
      ref: innerModal,
      className: containerClass,
      role: "dialog",
      "aria-modal": "true",
      "aria-label": ariaLabel ? ariaLabel : generatedAriaLabel,
      "aria-labelledby": ariaLabelledBy
    }, childrenWithProps), /*#__PURE__*/React__default["default"].createElement("span", {
      ref: endSentinel,
      tabIndex: "0",
      role: "link",
      className: "".concat(prefix, "--visually-hidden")
    }, "Focus sentinel"));
  });
  ComposedModal.propTypes = (_ComposedModal$propTy = {}, _defineProperty$2(_ComposedModal$propTy, 'aria-label', PropTypes__default["default"].string), _defineProperty$2(_ComposedModal$propTy, 'aria-labelledby', PropTypes__default["default"].string), _defineProperty$2(_ComposedModal$propTy, "children", PropTypes__default["default"].node), _defineProperty$2(_ComposedModal$propTy, "className", PropTypes__default["default"].string), _defineProperty$2(_ComposedModal$propTy, "containerClassName", PropTypes__default["default"].string), _defineProperty$2(_ComposedModal$propTy, "danger", PropTypes__default["default"].bool), _defineProperty$2(_ComposedModal$propTy, "onClose", PropTypes__default["default"].func), _defineProperty$2(_ComposedModal$propTy, "onKeyDown", PropTypes__default["default"].func), _defineProperty$2(_ComposedModal$propTy, "open", PropTypes__default["default"].bool), _defineProperty$2(_ComposedModal$propTy, "preventCloseOnClickOutside", PropTypes__default["default"].bool), _defineProperty$2(_ComposedModal$propTy, "selectorPrimaryFocus", PropTypes__default["default"].string), _defineProperty$2(_ComposedModal$propTy, "selectorsFloatingMenus", PropTypes__default["default"].string), _defineProperty$2(_ComposedModal$propTy, "size", PropTypes__default["default"].oneOf(['xs', 'sm', 'md', 'lg'])), _ComposedModal$propTy);
  ComposedModal.defaultProps = {
    onKeyDown: function onKeyDown() {},
    selectorPrimaryFocus: '[data-modal-primary-focus]'
  };
  var ComposedModalNext = ComposedModal;

  var ModalHeader = enabled('enable-v11-release') ? ModalHeader$2 : ModalHeader$1;
  var ModalFooter = enabled('enable-v11-release') ? ModalFooter$2 : ModalFooter$1;
  enabled('enable-v11-release') ? ComposedModalNext : ComposedModal$1;

  var _excluded$2j = ["children", "className", "light", "selectedIndex", "selectionMode", "size"];

  var ContentSwitcher = /*#__PURE__*/function (_React$Component) {
    _inherits(ContentSwitcher, _React$Component);

    var _super = _createSuper(ContentSwitcher);

    function ContentSwitcher() {
      var _this;

      _classCallCheck$1(this, ContentSwitcher);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty$2(_assertThisInitialized$1(_this), "_switchRefs", []);

      _defineProperty$2(_assertThisInitialized$1(_this), "state", {});

      _defineProperty$2(_assertThisInitialized$1(_this), "handleItemRef", function (index) {
        return function (ref) {
          _this._switchRefs[index] = ref;
        };
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleChildChange", function (data) {
        var selectionMode = _this.props.selectionMode; // the currently selected child index

        var selectedIndex = _this.state.selectedIndex; // the newly selected child index

        var index = data.index;
        var key = data.key;

        if (matches(data, [ArrowRight, ArrowLeft])) {
          var nextIndex = getNextIndex$1(key, index, _this.props.children.length);
          var children = React__default["default"].Children.toArray(_this.props.children);

          if (selectionMode === 'manual') {
            var switchRef = _this._switchRefs[nextIndex];
            switchRef && switchRef.focus();
          } else {
            _this.setState({
              selectedIndex: nextIndex
            }, function () {
              var child = children[_this.state.selectedIndex];
              var switchRef = _this._switchRefs[_this.state.selectedIndex];
              switchRef && switchRef.focus();

              _this.props.onChange(_objectSpread2$2(_objectSpread2$2({}, data), {}, {
                index: _this.state.selectedIndex,
                name: child.props.name,
                text: child.props.text
              }));
            });
          }
        } else if (selectedIndex !== index) {
          _this.setState({
            selectedIndex: index
          }, function () {
            var switchRef = _this._switchRefs[index];
            switchRef && switchRef.focus();

            _this.props.onChange(data);
          });
        }
      });

      return _this;
    }

    _createClass$1(ContentSwitcher, [{
      key: "render",
      value: function render() {
        var _classNames,
            _this2 = this;

        var prefix = this.context;

        var _this$props = this.props,
            children = _this$props.children,
            className = _this$props.className,
            light = _this$props.light;
            _this$props.selectedIndex;
            _this$props.selectionMode;
            var size = _this$props.size,
            other = _objectWithoutProperties$2(_this$props, _excluded$2j);

        var classes = cx("".concat(prefix, "--content-switcher"), className, (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--content-switcher--light"), light), _defineProperty$2(_classNames, "".concat(prefix, "--content-switcher--").concat(size), size), _classNames));
        return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({}, other, {
          className: classes,
          role: "tablist"
        }), React__default["default"].Children.map(children, function (child, index) {
          return /*#__PURE__*/React__default["default"].cloneElement(child, {
            index: index,
            onClick: composeEventHandlers([_this2.handleChildChange, child.props.onClick]),
            onKeyDown: _this2.handleChildChange,
            selected: index === _this2.state.selectedIndex,
            ref: _this2.handleItemRef(index)
          });
        }));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, state) {
        var selectedIndex = _ref.selectedIndex;
        var prevSelectedIndex = state.prevSelectedIndex;
        return prevSelectedIndex === selectedIndex ? null : {
          selectedIndex: selectedIndex,
          prevSelectedIndex: selectedIndex
        };
      }
    }]);

    return ContentSwitcher;
  }(React__default["default"].Component);

  _defineProperty$2(ContentSwitcher, "propTypes", {
    /**
     * Pass in Switch components to be rendered in the ContentSwitcher
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be added to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * `true` to use the light variant.
     */
    light: deprecate(PropTypes__default["default"].bool, 'The `light` prop for `ContentSwitcher` is no longer needed and has ' + 'been deprecated. It will be removed in the next major release.'),

    /**
     * Specify an `onChange` handler that is called whenever the ContentSwitcher
     * changes which item is selected
     */
    onChange: PropTypes__default["default"].func.isRequired,

    /**
     * Specify a selected index for the initially selected content
     */
    selectedIndex: PropTypes__default["default"].number,

    /**
     * Choose whether or not to automatically change selection on focus
     */
    selectionMode: PropTypes__default["default"].oneOf(['automatic', 'manual']),

    /**
     * Specify the size of the Content Switcher. Currently supports either `sm`, 'md' (default) or 'lg` as an option.
     * TODO V11: remove `xl` (replaced with lg)
     */
    size: PropTypes__default["default"].oneOf(['sm', 'md', 'lg', 'xl'])
  });

  _defineProperty$2(ContentSwitcher, "contextType", PrefixContext);

  _defineProperty$2(ContentSwitcher, "defaultProps", {
    selectedIndex: 0,
    selectionMode: 'automatic',
    onChange: function onChange() {}
  });

  var DangerButton = function DangerButton(props) {
    return /*#__PURE__*/React__default["default"].createElement(Button$1, _extends$3({
      kind: "danger"
    }, props));
  };

  var DangerButton$1 = DangerButton;

  var lodash_isequal = {exports: {}};

  (function (module, exports) {
    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;
    /** Used to stand-in for `undefined` hash values. */

    var HASH_UNDEFINED = '__lodash_hash_undefined__';
    /** Used to compose bitmasks for value comparisons. */

    var COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2;
    /** Used as references for various `Number` constants. */

    var MAX_SAFE_INTEGER = 9007199254740991;
    /** `Object#toString` result references. */

    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        asyncTag = '[object AsyncFunction]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        nullTag = '[object Null]',
        objectTag = '[object Object]',
        promiseTag = '[object Promise]',
        proxyTag = '[object Proxy]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]',
        undefinedTag = '[object Undefined]',
        weakMapTag = '[object WeakMap]';
    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */

    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    /** Used to detect host constructors (Safari). */

    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    /** Used to detect unsigned integer values. */

    var reIsUint = /^(?:0|[1-9]\d*)$/;
    /** Used to identify `toStringTag` values of typed arrays. */

    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    /** Detect free variable `global` from Node.js. */

    var freeGlobal = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    /** Detect free variable `self`. */

    var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
    /** Used as a reference to the global object. */

    var root = freeGlobal || freeSelf || Function('return this')();
    /** Detect free variable `exports`. */

    var freeExports = exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Detect free variable `process` from Node.js. */

    var freeProcess = moduleExports && freeGlobal.process;
    /** Used to access faster Node.js helpers. */

    var nodeUtil = function () {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }();
    /* Node.js helper references. */


    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    /**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */

    function arrayFilter(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }

      return result;
    }
    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */


    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }

      return array;
    }
    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */


    function arraySome(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }

      return false;
    }
    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */


    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }

      return result;
    }
    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */


    function baseUnary(func) {
      return function (value) {
        return func(value);
      };
    }
    /**
     * Checks if a `cache` value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function cacheHas(cache, key) {
      return cache.has(key);
    }
    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */


    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }
    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */


    function mapToArray(map) {
      var index = -1,
          result = Array(map.size);
      map.forEach(function (value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */


    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg));
      };
    }
    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */


    function setToArray(set) {
      var index = -1,
          result = Array(set.size);
      set.forEach(function (value) {
        result[++index] = value;
      });
      return result;
    }
    /** Used for built-in method references. */


    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;
    /** Used to detect overreaching core-js shims. */

    var coreJsData = root['__core-js_shared__'];
    /** Used to resolve the decompiled source of functions. */

    var funcToString = funcProto.toString;
    /** Used to check objects for own properties. */

    var hasOwnProperty = objectProto.hasOwnProperty;
    /** Used to detect methods masquerading as native. */

    var maskSrcKey = function () {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? 'Symbol(src)_1.' + uid : '';
    }();
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */


    var nativeObjectToString = objectProto.toString;
    /** Used to detect if a method is native. */

    var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
    /** Built-in value references. */

    var Buffer = moduleExports ? root.Buffer : undefined,
        _Symbol = root.Symbol,
        Uint8Array = root.Uint8Array,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeKeys = overArg(Object.keys, Object);
    /* Built-in method references that are verified to be native. */

    var DataView = getNative(root, 'DataView'),
        Map = getNative(root, 'Map'),
        Promise = getNative(root, 'Promise'),
        Set = getNative(root, 'Set'),
        WeakMap = getNative(root, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');
    /** Used to detect maps, sets, and weakmaps. */

    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);
    /** Used to convert symbols to primitives and strings. */

    var symbolProto = _Symbol ? _Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */


    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function hashGet(key) {
      var data = this.__data__;

      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }

      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }
    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
    }
    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */


    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
      return this;
    } // Add methods to `Hash`.


    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */


    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }

      var lastIndex = data.length - 1;

      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }

      --this.size;
      return true;
    }
    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);
      return index < 0 ? undefined : data[index][1];
    }
    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */


    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }

      return this;
    } // Add methods to `ListCache`.


    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */


    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash(),
        'map': new (Map || ListCache)(),
        'string': new Hash()
      };
    }
    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */


    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    } // Add methods to `MapCache`.


    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */

    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();

      while (++index < length) {
        this.add(values[index]);
      }
    }
    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */


    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);

      return this;
    }
    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */


    function setCacheHas(value) {
      return this.__data__.has(value);
    } // Add methods to `SetCache`.


    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */


    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);
      this.size = data.size;
      return result;
    }
    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function stackGet(key) {
      return this.__data__.get(key);
    }
    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function stackHas(key) {
      return this.__data__.has(key);
    }
    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */


    function stackSet(key, value) {
      var data = this.__data__;

      if (data instanceof ListCache) {
        var pairs = data.__data__;

        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }

        data = this.__data__ = new MapCache(pairs);
      }

      data.set(key, value);
      this.size = data.size;
      return this;
    } // Add methods to `Stack`.


    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */

    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
        key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }

      return result;
    }
    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */


    function assocIndexOf(array, key) {
      var length = array.length;

      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }

      return -1;
    }
    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */


    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */


    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }

      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */


    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */


    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }

      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }

      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */


    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }

        objIsArr = true;
        objIsObj = false;
      }

      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }

      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }

      if (!isSameTag) {
        return false;
      }

      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */


    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }

      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */


    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */


    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }

      var result = [];

      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }

      return result;
    }
    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */


    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(array);

      if (stacked && stack.get(other)) {
        return stacked == other;
      }

      var index = -1,
          result = true,
          seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
      stack.set(array, other);
      stack.set(other, array); // Ignore non-index properties.

      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }

        if (compared !== undefined) {
          if (compared) {
            continue;
          }

          result = false;
          break;
        } // Recursively compare arrays (susceptible to call stack limits).


        if (seen) {
          if (!arraySome(other, function (othValue, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }

      stack['delete'](array);
      stack['delete'](other);
      return result;
    }
    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */


    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }

          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }

          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == other + '';

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          } // Assume cyclic values are equal.


          var stacked = stack.get(object);

          if (stacked) {
            return stacked == other;
          }

          bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).

          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }

      }

      return false;
    }
    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */


    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }

      var index = objLength;

      while (index--) {
        var key = objProps[index];

        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked && stack.get(other)) {
        return stacked == other;
      }

      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;

      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        } // Recursively compare objects (susceptible to call stack limits).


        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }

        skipCtor || (skipCtor = key == 'constructor');
      }

      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

        if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }

      stack['delete'](object);
      stack['delete'](other);
      return result;
    }
    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */


    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */


    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
    }
    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */


    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }
    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */


    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);

      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }

      return result;
    }
    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */


    var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
      if (object == null) {
        return [];
      }

      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function (symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */

    var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function getTag(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;

            case mapCtorString:
              return mapTag;

            case promiseCtorString:
              return promiseTag;

            case setCtorString:
              return setTag;

            case weakMapCtorString:
              return weakMapTag;
          }
        }

        return result;
      };
    }
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */


    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
    }
    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */


    function isKeyable(value) {
      var type = _typeof(value);

      return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
    }
    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */


    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */


    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
      return value === proto;
    }
    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */


    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */


    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}

        try {
          return func + '';
        } catch (e) {}
      }

      return '';
    }
    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */


    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */


    var isArguments = baseIsArguments(function () {
      return arguments;
    }()) ? baseIsArguments : function (value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
    };
    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */

    var isArray = Array.isArray;
    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */

    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */


    var isBuffer = nativeIsBuffer || stubFalse;
    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */

    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */


    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      } // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.


      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */


    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */


    function isObject(value) {
      var type = _typeof(value);

      return value != null && (type == 'object' || type == 'function');
    }
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */


    function isObjectLike(value) {
      return value != null && _typeof(value) == 'object';
    }
    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */


    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */

    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */


    function stubArray() {
      return [];
    }
    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */


    function stubFalse() {
      return false;
    }

    module.exports = isEqual;
  })(lodash_isequal, lodash_isequal.exports);

  var isEqual = lodash_isequal.exports;

  /**
   * We currently support the following sorting states for DataTable headers,
   * namely: `NONE` for no sorting being applied, and then `DESC` and `ASC` for
   * the corresponding direction of the sorting order.
   */
  var sortStates = {
    NONE: 'NONE',
    DESC: 'DESC',
    ASC: 'ASC'
  };

  /**
   * Generic helper used to consolidate all call sites for getting a cell id into
   * one method. The strategy currently is that a "cellId" is just the combination
   * of the row id and the header key used to access this field in a row.
   *
   * @param {string} rowId
   * @param {string} header
   * @returns {string}
   */
  var getCellId = function getCellId(rowId, header) {
    return "".concat(rowId, ":").concat(header);
  };

  /**
   * Compare two primitives to determine which comes first. Initially, this method
   * will try and figure out if both entries are the same type. If so, it will
   * apply the default sort algorithm for those types. Otherwise, it defaults to a
   * string conversion.
   *
   * @param {number|string} a
   * @param {number|string} b
   * @param {string} locale
   * @returns {number}
   */

  var compare = function compare(a, b) {
    var locale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'en';

    if (typeof a === 'number' && typeof b === 'number') {
      return a - b;
    }

    if (typeof a === 'string' && typeof b === 'string') {
      return compareStrings(a, b, locale);
    }

    return compareStrings('' + a, '' + b, locale);
  };
  /**
   * Use the built-in `localeCompare` function available on strings to compare two
   * strings.
   *
   * @param {string} a
   * @param {string} b
   * @param {string} locale
   * @returns {number}
   */

  var compareStrings = function compareStrings(a, b) {
    var locale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'en';

    // Only set `numeric: true` if the string only contains numbers
    // https://stackoverflow.com/a/175787
    if (!isNaN(a) && !isNaN(parseFloat(a))) {
      return a.localeCompare(b, locale, {
        numeric: true
      });
    }

    return a.localeCompare(b, locale);
  };
  /**
   * Default implementation of how we sort rows internally. The idea behind this
   * implementation is to use the given list of row ids to look up the cells in
   * the row by the given key. We then use the value of these cells and pipe them
   * into our local `compareStrings` method, including the locale where
   * appropriate.
   *
   * @param {object} config
   * @param {Array[string]} config.rowIds array of all the row ids in the table
   * @param {object} config.cellsById object containing a mapping of cell id to
   * cell
   * @param {string} config.key the header key that we use to lookup the cell
   * @param {string} [config.locale] optional locale used in the comparison
   * function
   * @param {string} config.sortDirection the sort direction used to determine the
   * order the comparison is called in
   * @param {Function} config.sortRow
   * @returns {Array[string]} array of sorted rowIds
   */

  var sortRows = function sortRows(_ref) {
    var rowIds = _ref.rowIds,
        cellsById = _ref.cellsById,
        sortDirection = _ref.sortDirection,
        key = _ref.key,
        locale = _ref.locale,
        sortRow = _ref.sortRow;
    return rowIds.slice().sort(function (a, b) {
      var cellA = cellsById[getCellId(a, key)];
      var cellB = cellsById[getCellId(b, key)];
      return sortRow(cellA && cellA.value, cellB && cellB.value, {
        key: key,
        sortDirection: sortDirection,
        locale: locale,
        sortStates: sortStates,
        compare: compare,
        rowIds: [a, b]
      });
    });
  };
  var defaultSortRow = function defaultSortRow(cellA, cellB, _ref2) {
    var sortDirection = _ref2.sortDirection,
        sortStates = _ref2.sortStates,
        locale = _ref2.locale;

    if (sortDirection === sortStates.ASC) {
      return compare(cellA, cellB, locale);
    }

    return compare(cellB, cellA, locale);
  };

  // different initialSortState

  var initialSortState = sortStates.NONE;
  /**
   * Utility used to get the next sort state given the following pieces of
   * information:
   *
   * @param {string} prevHeader the value of the previous header
   * @param {string} header the value of the currently selected header
   * @param {string} prevState the previous sort state of the table
   * @returns {string}
   */

  var getNextSortDirection = function getNextSortDirection(prevHeader, header, prevState) {
    // If the previous header is equivalent to the current header, we know that we
    // have to derive the next sort state from the previous sort state
    if (prevHeader === header) {
      // When transitioning, we know that the sequence of states is as follows:
      // NONE -> ASC -> DESC -> NONE
      if (prevState === 'NONE') {
        return sortStates.ASC;
      }

      if (prevState === 'ASC') {
        return sortStates.DESC;
      }

      return sortStates.NONE;
    } // Otherwise, we have selected a new header and need to start off by sorting
    // in descending order by default


    return sortStates.ASC;
  };
  var getNextSortState = function getNextSortState(props, state, _ref) {
    var key = _ref.key;
    var sortDirection = state.sortDirection,
        sortHeaderKey = state.sortHeaderKey;
    var nextSortDirection = getNextSortDirection(key, sortHeaderKey, sortDirection);
    return getSortedState(props, state, key, nextSortDirection);
  };
  /**
   * Derive the set of sorted state fields from props and state for the given
   * header key and sortDirection
   *
   * @param {object} props
   * @param {string} props.locale The current locale
   * @param {Function} props.sortRows Method to handle sorting a collection of
   * rows
   * @param {object} state
   * @param {Array<string>} state.rowIds Array of row ids
   * @param {object} state.cellsById Lookup object for cells by id
   * @param {Array<string>} state.initialRowOrder Initial row order for the
   * current set of rows
   * @param {string} key The key for the given header we are serving the
   * sorted state for
   * @param {string} sortDirection The sortState that we want to order by
   * @returns {object}
   */

  var getSortedState = function getSortedState(props, state, key, sortDirection) {
    var rowIds = state.rowIds,
        cellsById = state.cellsById,
        initialRowOrder = state.initialRowOrder;
    var locale = props.locale,
        sortRow = props.sortRow;
    var nextRowIds = sortDirection !== sortStates.NONE ? sortRows({
      rowIds: rowIds,
      cellsById: cellsById,
      sortDirection: sortDirection,
      key: key,
      locale: locale,
      sortRow: sortRow
    }) : initialRowOrder;
    return {
      sortHeaderKey: key,
      sortDirection: sortDirection,
      rowIds: nextRowIds
    };
  };

  /**
   * Normalize a collection of rows with the given headers.
   *
   * @param {Array<object>} rows
   * @param {Array<object>} headers
   * @returns {object}
   */

  var normalize = function normalize(rows, headers) {
    var prevState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var prevRowsByIds = prevState.rowsById;
    var rowIds = new Array(rows.length);
    var rowsById = {};
    var cellsById = {};
    rows.forEach(function (row, i) {
      rowIds[i] = row.id; // Initialize the row info and state values, namely for selection and
      // expansion

      var id = row.id,
          _row$isSelected = row.isSelected,
          isSelected = _row$isSelected === void 0 ? false : _row$isSelected,
          _row$isExpanded = row.isExpanded,
          isExpanded = _row$isExpanded === void 0 ? false : _row$isExpanded,
          _row$disabled = row.disabled,
          disabled = _row$disabled === void 0 ? false : _row$disabled;
      rowsById[id] = {
        id: id,
        isSelected: isSelected,
        isExpanded: isExpanded,
        disabled: disabled,
        cells: new Array(headers.length)
      }; // If we have a previous state, and the row existed in that previous state,
      // then we'll set the state values of the row to the previous state values.

      if (prevRowsByIds && prevRowsByIds[row.id] !== undefined) {
        rowsById[row.id].isSelected = prevRowsByIds[row.id].isSelected;
        rowsById[row.id].isExpanded = prevRowsByIds[row.id].isExpanded;
      }

      headers.forEach(function (_ref, i) {
        var key = _ref.key;
        var id = getCellId(row.id, key); // Initialize the cell info and state values, namely for editing

        cellsById[id] = {
          id: id,
          value: row[key],
          isEditable: false,
          isEditing: false,
          isValid: true,
          errors: null,
          info: {
            header: key
          }
        }; // TODO: When working on inline edits, we'll need to derive the state
        // values similarly to rows above.

        rowsById[row.id].cells[i] = id;
      });
    });
    return {
      rowIds: rowIds,
      rowsById: rowsById,
      cellsById: cellsById
    };
  };

  var normalize$1 = normalize;

  /**
   * Helper to derive the next state from the given props and the
   * prevState. Potential future-facing API hook for React v17.
   *
   * Currently, it's being used as a way to normalize the incoming data that we
   * are receiving for rows
   */

  var getDerivedStateFromProps = function getDerivedStateFromProps(props, prevState) {
    var _normalize = normalize$1(props.rows, props.headers, prevState),
        rowIds = _normalize.rowIds,
        rowsById = _normalize.rowsById,
        cellsById = _normalize.cellsById;

    var state = {
      rowIds: rowIds,
      rowsById: rowsById,
      cellsById: cellsById,
      sortDirection: prevState.sortDirection || initialSortState,
      sortHeaderKey: prevState.sortHeaderKey || null,
      // Copy over rowIds so the reference doesn't mutate the stored
      // `initialRowOrder`
      initialRowOrder: rowIds.slice(),
      filterInputValue: prevState.filterInputValue || null,
      // Optional state field to indicate whether a consumer should show a
      // batch actions menu
      shouldShowBatchActions: prevState.shouldShowBatchActions || false
    };

    if (prevState.sortDirection && prevState.sortHeaderKey) {
      var _getSortedState = getSortedState(props, state, prevState.sortHeaderKey, prevState.sortDirection),
          _rowIds = _getSortedState.rowIds;

      state.rowIds = _rowIds;
    }

    return state;
  };

  var getDerivedStateFromProps$1 = getDerivedStateFromProps;

  /**
   * Copyright IBM Corp. 2016, 2018
   *
   * This source code is licensed under the Apache-2.0 license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * Counterpart to `normalize` for a collection of rows. This method unravels the
   * normalization step that we use to build the given parameters in order to
   * return a natural interface to working with rows for a consumer.
   *
   * The default heuristic here is to map through all the row ids and return the
   * value of the row for the given id, in addition to adding a `cells` key that
   * contains the results of mapping over the rows cells and getting individual
   * cell info.
   *
   * @param {Array<string>} rowIds array of row ids in the table
   * @param {object} rowsById object containing lookups for rows by id
   * @param {object} cellsById object containing lookups for cells by id
   */
  var denormalize = function denormalize(rowIds, rowsById, cellsById) {
    return rowIds.map(function (id) {
      return _objectSpread2$2(_objectSpread2$2({}, rowsById[id]), {}, {
        cells: rowsById[id].cells.map(function (cellId) {
          return cellsById[cellId];
        })
      });
    });
  };

  var denormalize$1 = denormalize;

  /**
   * Default implementation of how we filter rows internally. The idea behind this
   * implementation is to use the given list of row ids and headers to get the
   * individual cell values for a row. Then, we go through each cell value and see
   * if any of them includes the given inputValue.
   *
   * @param {object} config
   * @param {Array<string>} config.rowIds array of all the row ids in the table
   * @param {Array<object>} config.headers
   * @param {object} config.cellsById object containing a map of cell id to cell
   * @param {string} config.inputValue the current input value in the Table Search
   * @param {Function} config.getCellId
   * @returns {Array<string>} rowIds
   */
  var defaultFilterRows = function defaultFilterRows(_ref) {
    var rowIds = _ref.rowIds,
        headers = _ref.headers,
        cellsById = _ref.cellsById,
        inputValue = _ref.inputValue,
        getCellId = _ref.getCellId;
    return rowIds.filter(function (rowId) {
      return headers.some(function (_ref2) {
        var key = _ref2.key;
        var id = getCellId(rowId, key);

        if (typeof cellsById[id].value === 'boolean') {
          return false;
        }

        return ('' + cellsById[id].value).toLowerCase().includes(inputValue.toLowerCase());
      });
    });
  };

  /**
   * Generic utility to initialize a method that will return a unique instance id
   * for a component.
   */
  var setupGetInstanceId = function setupGetInstanceId() {
    var instanceId = 0;
    return function getInstanceId() {
      return ++instanceId;
    };
  };

  var setupGetInstanceId$1 = setupGetInstanceId;

  var _excluded$2i = ["header", "onClick", "isSortable"],
      _excluded2$d = ["onClick"],
      _excluded3$9 = ["row", "onClick"],
      _excluded4$8 = ["onClick", "row"];

  var _defaultTranslations$2;
  var getInstanceId$h = setupGetInstanceId$1();
  var translationKeys$3 = {
    expandRow: 'carbon.table.row.expand',
    collapseRow: 'carbon.table.row.collapse',
    expandAll: 'carbon.table.all.expand',
    collapseAll: 'carbon.table.all.collapse',
    selectAll: 'carbon.table.all.select',
    unselectAll: 'carbon.table.all.unselect',
    selectRow: 'carbon.table.row.select',
    unselectRow: 'carbon.table.row.unselect'
  };
  var defaultTranslations$3 = (_defaultTranslations$2 = {}, _defineProperty$2(_defaultTranslations$2, translationKeys$3.expandAll, 'Expand all rows'), _defineProperty$2(_defaultTranslations$2, translationKeys$3.collapseAll, 'Collapse all rows'), _defineProperty$2(_defaultTranslations$2, translationKeys$3.expandRow, 'Expand current row'), _defineProperty$2(_defaultTranslations$2, translationKeys$3.collapseRow, 'Collapse current row'), _defineProperty$2(_defaultTranslations$2, translationKeys$3.selectAll, 'Select all rows'), _defineProperty$2(_defaultTranslations$2, translationKeys$3.unselectAll, 'Unselect all rows'), _defineProperty$2(_defaultTranslations$2, translationKeys$3.selectRow, 'Select row'), _defineProperty$2(_defaultTranslations$2, translationKeys$3.unselectRow, 'Unselect row'), _defaultTranslations$2);

  var translateWithId$5 = function translateWithId(id) {
    return defaultTranslations$3[id];
  };
  /**
   * Data Tables are used to represent a collection of resources, displaying a
   * subset of their fields in columns, or headers. We prioritize direct updates
   * to the state of what we're rendering, so internally we end up normalizing the
   * given data and then denormalizing it when rendering.
   *
   * As a result, each part of the DataTable is accessible through look-up by id,
   * and updating the state of the single entity will cascade updates to the
   * consumer.
   */


  var DataTable$1 = /*#__PURE__*/function (_React$Component) {
    _inherits(DataTable, _React$Component);

    var _super = _createSuper(DataTable);

    function DataTable(_props) {
      var _this;

      _classCallCheck$1(this, DataTable);

      _this = _super.call(this, _props);

      _defineProperty$2(_assertThisInitialized$1(_this), "getHeaderProps", function (_ref) {
        var header = _ref.header,
            _onClick = _ref.onClick,
            _ref$isSortable = _ref.isSortable,
            isSortable = _ref$isSortable === void 0 ? _this.props.isSortable : _ref$isSortable,
            rest = _objectWithoutProperties$2(_ref, _excluded$2i);

        var _this$state = _this.state,
            sortDirection = _this$state.sortDirection,
            sortHeaderKey = _this$state.sortHeaderKey;
        return _objectSpread2$2(_objectSpread2$2({}, rest), {}, {
          key: header.key,
          sortDirection: sortDirection,
          isSortable: isSortable,
          isSortHeader: sortHeaderKey === header.key,
          onClick: function onClick(event) {
            var nextSortState = getNextSortState(_this.props, _this.state, {
              key: header.key
            });

            _this.setState(nextSortState, function () {
              _onClick && _this.handleOnHeaderClick(_onClick, {
                sortHeaderKey: header.key,
                sortDirection: nextSortState.sortDirection
              })(event);
            });
          }
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "getExpandHeaderProps", function () {
        var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            onClick = _ref2.onClick,
            rest = _objectWithoutProperties$2(_ref2, _excluded2$d);

        var t = _this.props.translateWithId;
        var _this$state2 = _this.state,
            isExpandedAll = _this$state2.isExpandedAll,
            rowIds = _this$state2.rowIds,
            rowsById = _this$state2.rowsById;
        var isExpanded = isExpandedAll || rowIds.every(function (id) {
          return rowsById[id].isExpanded;
        });
        var translationKey = isExpanded ? translationKeys$3.collapseAll : translationKeys$3.expandAll;
        return _objectSpread2$2(_objectSpread2$2({}, rest), {}, {
          ariaLabel: t(translationKey),
          isExpanded: isExpanded,
          // Compose the event handlers so we don't overwrite a consumer's `onClick`
          // handler
          onExpand: composeEventHandlers([_this.handleOnExpandAll, onClick ? _this.handleOnExpandHeaderClick(onClick, {
            isExpanded: isExpanded
          }) : null])
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOnHeaderClick", function (onClick, sortParams) {
        return function (e) {
          return onClick(e, sortParams);
        };
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOnExpandHeaderClick", function (onClick, expandParams) {
        return function (e) {
          return onClick(e, expandParams);
        };
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "getRowProps", function (_ref3) {
        var row = _ref3.row,
            onClick = _ref3.onClick,
            rest = _objectWithoutProperties$2(_ref3, _excluded3$9);

        var t = _this.props.translateWithId;
        var translationKey = row.isExpanded ? translationKeys$3.collapseRow : translationKeys$3.expandRow;
        return _objectSpread2$2(_objectSpread2$2({}, rest), {}, {
          key: row.id,
          // Compose the event handlers so we don't overwrite a consumer's `onClick`
          // handler
          onExpand: composeEventHandlers([_this.handleOnExpandRow(row.id), onClick]),
          isExpanded: row.isExpanded,
          ariaLabel: t(translationKey),
          isSelected: row.isSelected,
          disabled: row.disabled
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "getSelectionProps", function () {
        var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            onClick = _ref4.onClick,
            row = _ref4.row,
            rest = _objectWithoutProperties$2(_ref4, _excluded4$8);

        var t = _this.props.translateWithId; // If we're given a row, return the selection state values for that row

        if (row) {
          var _translationKey = row.isSelected ? translationKeys$3.unselectRow : translationKeys$3.selectRow;

          return _objectSpread2$2(_objectSpread2$2({}, rest), {}, {
            checked: row.isSelected,
            onSelect: composeEventHandlers([_this.handleOnSelectRow(row.id), onClick]),
            id: "".concat(_this.getTablePrefix(), "__select-row-").concat(row.id),
            name: "select-row-".concat(row.id),
            ariaLabel: t(_translationKey),
            disabled: row.disabled,
            radio: _this.props.radio || null
          });
        } // Otherwise, we're working on `TableSelectAll` which handles toggling the
        // selection state of all rows.


        var rowCount = _this.state.rowIds.length;

        var selectedRowCount = _this.getSelectedRows().length;

        var checked = rowCount > 0 && selectedRowCount === rowCount;
        var indeterminate = rowCount > 0 && selectedRowCount > 0 && selectedRowCount !== rowCount;
        var translationKey = checked || indeterminate ? translationKeys$3.unselectAll : translationKeys$3.selectAll;
        return _objectSpread2$2(_objectSpread2$2({}, rest), {}, {
          ariaLabel: t(translationKey),
          checked: checked,
          id: "".concat(_this.getTablePrefix(), "__select-all"),
          indeterminate: indeterminate,
          name: 'select-all',
          onSelect: composeEventHandlers([_this.handleSelectAll, onClick])
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "getToolbarProps", function () {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var size = _this.props.size; // Remove compact, short in V11

        var isSmall = size === 'compact' || size === 'short' || size === 'xs' || size === 'sm';
        return _objectSpread2$2(_objectSpread2$2({}, props), {}, {
          size: isSmall ? 'small' : 'normal'
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "getBatchActionProps", function () {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var shouldShowBatchActions = _this.state.shouldShowBatchActions;

        var totalSelected = _this.getSelectedRows().length;

        return _objectSpread2$2(_objectSpread2$2({}, props), {}, {
          shouldShowBatchActions: shouldShowBatchActions && totalSelected > 0,
          totalSelected: totalSelected,
          onCancel: _this.handleOnCancel
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "getTableProps", function () {
        var _this$props = _this.props,
            useZebraStyles = _this$props.useZebraStyles,
            size = _this$props.size,
            isSortable = _this$props.isSortable,
            useStaticWidth = _this$props.useStaticWidth,
            shouldShowBorder = _this$props.shouldShowBorder,
            stickyHeader = _this$props.stickyHeader,
            overflowMenuOnHover = _this$props.overflowMenuOnHover;
        return {
          useZebraStyles: useZebraStyles,
          size: size,
          isSortable: isSortable,
          useStaticWidth: useStaticWidth,
          shouldShowBorder: shouldShowBorder,
          stickyHeader: stickyHeader,
          overflowMenuOnHover: overflowMenuOnHover
        };
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "getTableContainerProps", function () {
        var _this$props2 = _this.props,
            stickyHeader = _this$props2.stickyHeader,
            useStaticWidth = _this$props2.useStaticWidth;
        return {
          stickyHeader: stickyHeader,
          useStaticWidth: useStaticWidth
        };
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "getSelectedRows", function () {
        return _this.state.rowIds.filter(function (id) {
          var row = _this.state.rowsById[id];
          return row.isSelected && !row.disabled;
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "getFilteredRowIds", function () {
        var filteredRowIds = typeof _this.state.filterInputValue === 'string' ? _this.props.filterRows({
          rowIds: _this.state.rowIds,
          headers: _this.props.headers,
          cellsById: _this.state.cellsById,
          inputValue: _this.state.filterInputValue,
          getCellId: getCellId
        }) : _this.state.rowIds;

        if (filteredRowIds.length == 0) {
          return [];
        }

        return filteredRowIds;
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "getTablePrefix", function () {
        return "data-table-".concat(_this.instanceId);
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "setAllSelectedState", function (initialState, isSelected, filteredRowIds) {
        var rowIds = initialState.rowIds;
        return {
          rowsById: rowIds.reduce(function (acc, id) {
            return _objectSpread2$2(_objectSpread2$2({}, acc), {}, _defineProperty$2({}, id, _objectSpread2$2(_objectSpread2$2({}, initialState.rowsById[id]), !initialState.rowsById[id].disabled && {
              isSelected: filteredRowIds.includes(id) && isSelected
            })));
          }, {})
        };
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOnCancel", function () {
        _this.setState(function (state) {
          return _objectSpread2$2({
            shouldShowBatchActions: false
          }, _this.setAllSelectedState(state, false, _this.getFilteredRowIds()));
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleSelectAll", function () {
        _this.setState(function (state) {
          var filteredRowIds = _this.getFilteredRowIds();

          var rowsById = state.rowsById;
          var isSelected = !(Object.values(rowsById).filter(function (row) {
            return row.isSelected && !row.disabled;
          }).length > 0);
          return _objectSpread2$2({
            shouldShowBatchActions: isSelected
          }, _this.setAllSelectedState(state, isSelected, filteredRowIds));
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOnSelectRow", function (rowId) {
        return function () {
          _this.setState(function (state) {
            var row = state.rowsById[rowId];

            if (_this.props.radio) {
              // deselect all radio buttons
              var rowsById = Object.entries(state.rowsById).reduce(function (p, c) {
                var _c = _slicedToArray$1(c, 2),
                    key = _c[0],
                    val = _c[1];

                val.isSelected = false;
                p[key] = val;
                return p;
              }, {});
              return {
                shouldShowBatchActions: false,
                rowsById: _objectSpread2$2(_objectSpread2$2({}, rowsById), {}, _defineProperty$2({}, rowId, _objectSpread2$2(_objectSpread2$2({}, row), {}, {
                  isSelected: !row.isSelected
                })))
              };
            }

            var selectedRows = state.rowIds.filter(function (id) {
              return state.rowsById[id].isSelected;
            }).length; // Predict the length of the selected rows after this change occurs

            var selectedRowsCount = !row.isSelected ? selectedRows + 1 : selectedRows - 1;
            return {
              // Basic assumption here is that we want to show the batch action bar if
              // the row is being selected. If it's being unselected, then see if we
              // have a non-zero number of selected rows that batch actions could
              // still apply to
              shouldShowBatchActions: !row.isSelected || selectedRowsCount > 0,
              rowsById: _objectSpread2$2(_objectSpread2$2({}, state.rowsById), {}, _defineProperty$2({}, rowId, _objectSpread2$2(_objectSpread2$2({}, row), {}, {
                isSelected: !row.isSelected
              })))
            };
          });
        };
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOnExpandRow", function (rowId) {
        return function () {
          _this.setState(function (state) {
            var row = state.rowsById[rowId];
            var isExpandedAll = state.isExpandedAll;
            return {
              isExpandedAll: row.isExpanded ? false : isExpandedAll,
              rowsById: _objectSpread2$2(_objectSpread2$2({}, state.rowsById), {}, _defineProperty$2({}, rowId, _objectSpread2$2(_objectSpread2$2({}, row), {}, {
                isExpanded: !row.isExpanded
              })))
            };
          });
        };
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOnExpandAll", function () {
        _this.setState(function (state) {
          var rowIds = state.rowIds,
              isExpandedAll = state.isExpandedAll;
          return {
            isExpandedAll: !isExpandedAll,
            rowsById: rowIds.reduce(function (acc, id) {
              return _objectSpread2$2(_objectSpread2$2({}, acc), {}, _defineProperty$2({}, id, _objectSpread2$2(_objectSpread2$2({}, state.rowsById[id]), {}, {
                isExpanded: !isExpandedAll
              })));
            }, {})
          };
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleSortBy", function (headerKey) {
        return function () {
          _this.setState(function (state) {
            return getNextSortState(_this.props, state, {
              key: headerKey
            });
          });
        };
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOnInputValueChange", function (event, defaultValue) {
        if (event.target) {
          _this.setState({
            filterInputValue: event.target.value
          });
        }

        if (defaultValue) {
          _this.setState({
            filterInputValue: defaultValue
          });
        }
      });

      _this.state = _objectSpread2$2(_objectSpread2$2({}, getDerivedStateFromProps$1(_props, {})), {}, {
        isExpandedAll: false // Start with collapsed state, treat `undefined` as neutral state

      });
      _this.instanceId = getInstanceId$h();
      return _this;
    }

    _createClass$1(DataTable, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var _this2 = this;

        if (prevProps === this.props) {
          return;
        }

        var prevRowIds = prevProps.rows.map(function (row) {
          return row.id;
        });
        var rowIds = this.props.rows.map(function (row) {
          return row.id;
        });

        if (!isEqual(prevRowIds, rowIds)) {
          this.setState(function (state) {
            return getDerivedStateFromProps$1(_this2.props, state);
          });
          return;
        }

        var prevHeaders = prevProps.headers.map(function (header) {
          return header.key;
        });
        var headers = this.props.headers.map(function (header) {
          return header.key;
        });

        if (!isEqual(prevHeaders, headers)) {
          this.setState(function (state) {
            return getDerivedStateFromProps$1(_this2.props, state);
          });
          return;
        }

        if (!isEqual(prevProps.rows, this.props.rows)) {
          this.setState(function (state) {
            return getDerivedStateFromProps$1(_this2.props, state);
          });
          return;
        }
      }
      /**
       * Get the props associated with the given header. Mostly used for adding in
       * sorting behavior.
       *
       * @param {object} config
       * @param {string} config.header the header we want the props for
       * @param {Function} config.onClick a custom click handler for the header
       * @param {boolean} config.isSortable
       * @returns {object}
       */

    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        // eslint-disable-next-line react/prop-types
        var _this$props3 = this.props,
            children = _this$props3.children,
            filterRows = _this$props3.filterRows,
            headers = _this$props3.headers,
            render = _this$props3.render;
        var _this$state3 = this.state,
            filterInputValue = _this$state3.filterInputValue,
            rowIds = _this$state3.rowIds,
            rowsById = _this$state3.rowsById,
            cellsById = _this$state3.cellsById;
        var filteredRowIds = typeof filterInputValue === 'string' ? filterRows({
          rowIds: rowIds,
          headers: headers,
          cellsById: cellsById,
          inputValue: filterInputValue,
          getCellId: getCellId
        }) : rowIds;
        var renderProps = {
          // Data derived from state
          rows: denormalize$1(filteredRowIds, rowsById, cellsById),
          headers: this.props.headers,
          selectedRows: denormalize$1(this.getSelectedRows(), rowsById, cellsById),
          // Prop accessors/getters
          getHeaderProps: this.getHeaderProps,
          getExpandHeaderProps: this.getExpandHeaderProps,
          getRowProps: this.getRowProps,
          getSelectionProps: this.getSelectionProps,
          getToolbarProps: this.getToolbarProps,
          getBatchActionProps: this.getBatchActionProps,
          getTableProps: this.getTableProps,
          getTableContainerProps: this.getTableContainerProps,
          // Custom event handlers
          onInputChange: this.handleOnInputValueChange,
          // Expose internal state change actions
          sortBy: function sortBy(headerKey) {
            return _this3.handleSortBy(headerKey)();
          },
          selectAll: this.handleSelectAll,
          selectRow: function selectRow(rowId) {
            return _this3.handleOnSelectRow(rowId)();
          },
          expandRow: function expandRow(rowId) {
            return _this3.handleOnExpandRow(rowId)();
          },
          expandAll: this.handleOnExpandAll,
          radio: this.props.radio
        };

        if (render !== undefined) {
          return render(renderProps);
        }

        if (children !== undefined) {
          return children(renderProps);
        }

        return null;
      }
    }]);

    return DataTable;
  }(React__default["default"].Component);

  _defineProperty$2(DataTable$1, "propTypes", {
    /**
     * Optional hook to manually control filtering of the rows from the
     * TableToolbarSearch component
     */
    filterRows: PropTypes__default["default"].func,

    /**
     * The `headers` prop represents the order in which the headers should
     * appear in the table. We expect an array of objects to be passed in, where
     * `key` is the name of the key in a row object, and `header` is the name of
     * the header.
     */
    headers: PropTypes__default["default"].arrayOf(PropTypes__default["default"].shape({
      key: PropTypes__default["default"].string.isRequired,
      header: PropTypes__default["default"].node.isRequired
    })).isRequired,

    /**
     * Specify whether the table should be able to be sorted by its headers
     */
    isSortable: PropTypes__default["default"].bool,

    /**
     * Provide a string for the current locale
     */
    locale: PropTypes__default["default"].string,

    /**
     * Specify whether the overflow menu (if it exists) should be shown always, or only on hover
     */
    overflowMenuOnHover: PropTypes__default["default"].bool,

    /**
     * Specify whether the control should be a radio button or inline checkbox
     */
    radio: PropTypes__default["default"].bool,

    /**
     * The `rows` prop is where you provide us with a list of all the rows that
     * you want to render in the table. The only hard requirement is that this
     * is an array of objects, and that each object has a unique `id` field
     * available on it.
     */
    rows: PropTypes__default["default"].arrayOf(PropTypes__default["default"].shape({
      id: PropTypes__default["default"].string.isRequired,
      disabled: PropTypes__default["default"].bool,
      isSelected: PropTypes__default["default"].bool,
      isExpanded: PropTypes__default["default"].bool
    })).isRequired,

    /**
     * `false` If true, will remove the table border
     */
    shouldShowBorder: PropTypes__default["default"].bool,

    /**
     *  Change the row height of table. Currently supports `xs`, `sm`, `md`, `lg`, and `xl`.
     */
    size: enabled('enable-v11-release') ? PropTypes__default["default"].oneOf(['xs', 'sm', 'md', 'lg', 'xl']) : PropTypes__default["default"].oneOf(['compact', 'short', 'normal', 'tall', 'xs', 'sm', 'md', 'lg', 'xl']),

    /**
     * Optional hook to manually control sorting of the rows.
     */
    sortRow: PropTypes__default["default"].func,

    /**
     * Specify whether the header should be sticky.
     * Still experimental: may not work with every combination of table props
     */
    stickyHeader: PropTypes__default["default"].bool,

    /**
     * Optional method that takes in a message id and returns an
     * internationalized string. See `DataTable.translationKeys` for all
     * available message ids.
     */
    translateWithId: PropTypes__default["default"].func,

    /**
     * `false` If true, will use a width of 'auto' instead of 100%
     */
    useStaticWidth: PropTypes__default["default"].bool,

    /**
     * `true` to add useZebraStyles striping.
     */
    useZebraStyles: PropTypes__default["default"].bool
  });

  _defineProperty$2(DataTable$1, "defaultProps", {
    sortRow: defaultSortRow,
    filterRows: defaultFilterRows,
    locale: 'en',
    size: enabled('enable-v11-release') ? 'lg' : 'normal',
    overflowMenuOnHover: true,
    translateWithId: translateWithId$5
  });

  _defineProperty$2(DataTable$1, "translationKeys", Object.values(translationKeys$3));

  function useWindowEvent(eventName, callback) {
    var savedCallback = React.useRef(null);
    React.useEffect(function () {
      savedCallback.current = callback;
    });
    React.useEffect(function () {
      function handler(event) {
        if (savedCallback.current) {
          savedCallback.current(event);
        }
      }

      window.addEventListener(eventName, handler);
      return function () {
        window.removeEventListener(eventName, handler);
      };
    }, [eventName]);
  }

  var _excluded$2h = ["className", "children", "useZebraStyles", "size", "isSortable", "useStaticWidth", "shouldShowBorder", "stickyHeader", "overflowMenuOnHover"];
  var Table = function Table(_ref) {
    var _cx;

    var className = _ref.className,
        children = _ref.children,
        useZebraStyles = _ref.useZebraStyles,
        size = _ref.size,
        isSortable = _ref.isSortable,
        useStaticWidth = _ref.useStaticWidth,
        shouldShowBorder = _ref.shouldShowBorder,
        stickyHeader = _ref.stickyHeader,
        overflowMenuOnHover = _ref.overflowMenuOnHover,
        other = _objectWithoutProperties$2(_ref, _excluded$2h);

    var prefix = usePrefix();

    var _useState = React.useState(true),
        _useState2 = _slicedToArray$1(_useState, 2),
        isScrollable = _useState2[0],
        setIsScrollable = _useState2[1];

    var tableRef = React.useRef(null);
    var componentClass = cx("".concat(prefix, "--data-table"), className, (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--data-table--").concat(size), size), _defineProperty$2(_cx, "".concat(prefix, "--data-table--sort"), isSortable), _defineProperty$2(_cx, "".concat(prefix, "--data-table--zebra"), useZebraStyles), _defineProperty$2(_cx, "".concat(prefix, "--data-table--static"), useStaticWidth), _defineProperty$2(_cx, "".concat(prefix, "--data-table--no-border"), !shouldShowBorder), _defineProperty$2(_cx, "".concat(prefix, "--data-table--sticky-header"), stickyHeader), _defineProperty$2(_cx, "".concat(prefix, "--data-table--visible-overflow-menu"), !overflowMenuOnHover), _cx)); // Used to set a tabIndex when the Table is horizontally scrollable

    var setTabIndex = React.useCallback(function () {
      var _tableRef$current, _tableRef$current2;

      var tableContainer = tableRef === null || tableRef === void 0 ? void 0 : (_tableRef$current = tableRef.current) === null || _tableRef$current === void 0 ? void 0 : _tableRef$current.parentNode;
      var tableHeader = tableRef === null || tableRef === void 0 ? void 0 : (_tableRef$current2 = tableRef.current) === null || _tableRef$current2 === void 0 ? void 0 : _tableRef$current2.firstChild;

      if ((tableHeader === null || tableHeader === void 0 ? void 0 : tableHeader.scrollWidth) > (tableContainer === null || tableContainer === void 0 ? void 0 : tableContainer.clientWidth)) {
        setIsScrollable(true);
      } else {
        setIsScrollable(false);
      }
    }, []);
    var debouncedSetTabIndex = debounce$4(setTabIndex, 100);
    useWindowEvent('resize', debouncedSetTabIndex);
    React.useLayoutEffect(function () {
      setTabIndex();
    }, [setTabIndex]);
    var table = /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--data-table-content") // eslint-disable-next-line jsx-a11y/no-noninteractive-tabindex
      ,
      tabIndex: isScrollable ? 0 : undefined
    }, /*#__PURE__*/React__default["default"].createElement("table", _extends$3({}, other, {
      className: componentClass,
      ref: tableRef
    }), children));
    return stickyHeader ? /*#__PURE__*/React__default["default"].createElement("section", {
      className: "".concat(prefix, "--data-table_inner-container")
    }, table) : table;
  };
  Table.propTypes = {
    /**
     * Pass in the children that will be rendered within the Table
     */
    children: PropTypes__default["default"].node,
    className: PropTypes__default["default"].string,

    /**
     * `false` If true, will apply sorting styles
     */
    isSortable: PropTypes__default["default"].bool,

    /**
     * Specify whether the overflow menu (if it exists) should be shown always, or only on hover
     */
    overflowMenuOnHover: PropTypes__default["default"].bool,

    /**
     * `false` If true, will remove the table border
     */
    shouldShowBorder: deprecate(PropTypes__default["default"].bool, 'The `shouldShowBorder` prop has been deprecated and can be safely removed.' + 'This prop will be removed in the next major release of ' + '`carbon-components-react`'),

    /**
     *  Change the row height of table. Currently supports `xs`, `sm`, `md`, `lg`, and `xl`.
     */
    size: enabled('enable-v11-release') ? PropTypes__default["default"].oneOf(['xs', 'sm', 'md', 'lg', 'xl']) : PropTypes__default["default"].oneOf(['compact', 'short', 'normal', 'tall', 'xs', 'sm', 'md', 'lg', 'xl']),

    /**
     * `false` If true, will keep the header sticky (only data rows will scroll)
     */
    stickyHeader: PropTypes__default["default"].bool,

    /**
     * `false` If true, will use a width of 'auto' instead of 100%
     */
    useStaticWidth: PropTypes__default["default"].bool,

    /**
     * `true` to add useZebraStyles striping.
     */
    useZebraStyles: PropTypes__default["default"].bool
  };
  Table.defaultProps = {
    isSortable: false,
    overflowMenuOnHover: true
  };
  var Table$1 = Table;

  var _excluded$2g = ["className"];

  var wrapComponent = function wrapComponent(_ref) {
    var name = _ref.name,
        className = _ref.className,
        type = _ref.type;

    var Component = function Component(_ref2) {
      var baseClassName = _ref2.className,
          other = _objectWithoutProperties$2(_ref2, _excluded$2g);

      var componentClass = cx(className, baseClassName);
      return /*#__PURE__*/React__default["default"].createElement(type, _objectSpread2$2(_objectSpread2$2({}, other), {}, {
        // Prevent Weird quirk where `cx` will evaluate to an empty string, '',
        // and so we have empty `class` attributes in the resulting markup
        // eslint-disable-next-line no-extra-boolean-cast
        className: !!componentClass ? componentClass : undefined
      }));
    };

    Component.displayName = name;
    Component.propTypes = {
      className: PropTypes__default["default"].string
    };
    return Component;
  };

  var wrapComponent$1 = wrapComponent;

  var prefix$4 = settings_1.prefix;
  var TableActionList = wrapComponent$1({
    name: 'TableActionList',
    type: 'div',
    className: "".concat(prefix$4, "--action-list")
  });
  var TableActionList$1 = TableActionList;

  var TableBatchAction = function TableBatchAction(props) {
    return /*#__PURE__*/React__default["default"].createElement(Button$1, props);
  };

  TableBatchAction.propTypes = {
    /**
     * Specify if the button is an icon-only button
     */
    hasIconOnly: PropTypes__default["default"].bool,

    /**
     * If specifying the `renderIcon` prop, provide a description for that icon that can
     * be read by screen readers
     */
    iconDescription: function iconDescription(props) {
      if (props.renderIcon && !props.children && !props.iconDescription) {
        return new Error('renderIcon property specified without also providing an iconDescription property.');
      }

      return undefined;
    },

    /**
     * Optional function to render your own icon in the underlying button
     */
    renderIcon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object])
  };
  TableBatchAction.defaultProps = {
    renderIcon: AddFilled16
  };
  var TableBatchAction$1 = TableBatchAction;

  var _excluded$2f = ["className", "children", "shouldShowBatchActions", "totalSelected", "onCancel", "translateWithId"];
  var translationKeys$2 = {
    'carbon.table.batch.cancel': 'Cancel',
    'carbon.table.batch.items.selected': 'items selected',
    'carbon.table.batch.item.selected': 'item selected'
  };

  var translateWithId$4 = function translateWithId(id, state) {
    if (id === 'carbon.table.batch.cancel') {
      return translationKeys$2[id];
    }

    return "".concat(state.totalSelected, " ").concat(translationKeys$2[id]);
  };

  var TableBatchActions = function TableBatchActions(_ref) {
    var _cx;

    var className = _ref.className,
        children = _ref.children,
        shouldShowBatchActions = _ref.shouldShowBatchActions,
        totalSelected = _ref.totalSelected,
        onCancel = _ref.onCancel,
        t = _ref.translateWithId,
        rest = _objectWithoutProperties$2(_ref, _excluded$2f);

    var _React$useState = React__default["default"].useState(),
        _React$useState2 = _slicedToArray$1(_React$useState, 2),
        isScrolling = _React$useState2[0],
        setIsScrolling = _React$useState2[1];

    var prefix = usePrefix();
    var batchActionsClasses = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--batch-actions"), true), _defineProperty$2(_cx, "".concat(prefix, "--batch-actions--active"), shouldShowBatchActions), _cx), className);
    var batchSummaryClasses = cx("".concat(prefix, "--batch-summary"), _defineProperty$2({}, "".concat(prefix, "--batch-summary__scroll"), isScrolling));
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      onScroll: function onScroll() {
        setIsScrolling(!isScrolling);
      },
      "aria-hidden": !shouldShowBatchActions,
      className: batchActionsClasses
    }, rest), /*#__PURE__*/React__default["default"].createElement("div", {
      className: batchSummaryClasses
    }, /*#__PURE__*/React__default["default"].createElement("p", {
      className: "".concat(prefix, "--batch-summary__para")
    }, /*#__PURE__*/React__default["default"].createElement(Text, {
      as: "span"
    }, totalSelected > 1 || totalSelected === 0 ? t('carbon.table.batch.items.selected', {
      totalSelected: totalSelected
    }) : t('carbon.table.batch.item.selected', {
      totalSelected: totalSelected
    })))), /*#__PURE__*/React__default["default"].createElement(TableActionList$1, null, children, /*#__PURE__*/React__default["default"].createElement(Button$1, {
      className: "".concat(prefix, "--batch-summary__cancel"),
      tabIndex: shouldShowBatchActions ? 0 : -1,
      onClick: onCancel
    }, t('carbon.table.batch.cancel'))));
  };

  TableBatchActions.translationKeys = Object.keys(translationKeys$2);
  TableBatchActions.propTypes = {
    children: PropTypes__default["default"].node,
    className: PropTypes__default["default"].string,

    /**
     * Hook required to listen for when the user initiates a cancel request
     * through this component
     */
    onCancel: PropTypes__default["default"].func.isRequired,

    /**
     * Boolean specifier for whether or not the batch action bar should be
     * displayed
     */
    shouldShowBatchActions: PropTypes__default["default"].bool,

    /**
     * Numeric representation of the total number of items selected in a table.
     * This number is used to derive the selection message
     */
    totalSelected: PropTypes__default["default"].number.isRequired,

    /**
     * Supply a method to translate internal strings with your i18n tool of
     * choice. Translation keys are available on the `translationKeys` field for
     * this component.
     */
    translateWithId: PropTypes__default["default"].func
  };
  TableBatchActions.defaultProps = {
    translateWithId: translateWithId$4
  };
  var TableBatchActions$1 = TableBatchActions;

  var _excluded$2e = ["children", "className"];

  var TableBody = function TableBody(_ref) {
    var children = _ref.children,
        className = _ref.className,
        rest = _objectWithoutProperties$2(_ref, _excluded$2e);

    return /*#__PURE__*/React__default["default"].createElement("tbody", _extends$3({
      className: className
    }, rest), children);
  };

  TableBody.propTypes = {
    /**
     * `polite` Adjust the notification behavior of screen readers
     */
    'aria-live': PropTypes__default["default"].oneOf(['polite', 'assertive', 'off']),
    children: PropTypes__default["default"].node,
    className: PropTypes__default["default"].string
  };
  TableBody.defaultProps = {
    'aria-live': 'polite'
  };
  var TableBody$1 = TableBody;

  var TableCell = wrapComponent$1({
    name: 'TableCell',
    type: 'td'
  });
  var TableCell$1 = TableCell;

  var _excluded$2d = ["className", "children", "title", "description", "stickyHeader", "useStaticWidth"];

  var TableContainer = function TableContainer(_ref) {
    var _cx;

    var className = _ref.className,
        children = _ref.children,
        title = _ref.title,
        description = _ref.description,
        stickyHeader = _ref.stickyHeader,
        useStaticWidth = _ref.useStaticWidth,
        rest = _objectWithoutProperties$2(_ref, _excluded$2d);

    var prefix = usePrefix();
    var tableContainerClasses = cx(className, "".concat(prefix, "--data-table-container"), (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--data-table--max-width"), stickyHeader), _defineProperty$2(_cx, "".concat(prefix, "--data-table-container--static"), useStaticWidth), _cx));
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({}, rest, {
      className: tableContainerClasses
    }), title && /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--data-table-header")
    }, /*#__PURE__*/React__default["default"].createElement("h4", {
      className: "".concat(prefix, "--data-table-header__title")
    }, title), /*#__PURE__*/React__default["default"].createElement("p", {
      className: "".concat(prefix, "--data-table-header__description")
    }, description)), children);
  };

  TableContainer.propTypes = {
    children: PropTypes__default["default"].node,
    className: PropTypes__default["default"].string,

    /**
     * Optional description text for the Table
     */
    description: PropTypes__default["default"].node,

    /**
     * Specify whether the table should have a sticky header
     */
    stickyHeader: PropTypes__default["default"].bool,

    /**
     * Provide a title for the Table
     */
    title: PropTypes__default["default"].node,

    /**
     * If true, will use a width of 'fit-content' to match the inner table width
     */
    useStaticWidth: PropTypes__default["default"].bool
  };
  var TableContainer$1 = TableContainer;

  var _excluded$2c = ["ariaLabel", "className", "enableExpando", "enableToggle", "isExpanded", "onExpand", "expandIconDescription", "children"];

  var TableExpandHeader = function TableExpandHeader(_ref) {
    var ariaLabel = _ref.ariaLabel,
        headerClassName = _ref.className,
        enableExpando = _ref.enableExpando,
        enableToggle = _ref.enableToggle,
        isExpanded = _ref.isExpanded,
        onExpand = _ref.onExpand,
        expandIconDescription = _ref.expandIconDescription,
        children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, _excluded$2c);

    var prefix = usePrefix();
    var className = cx("".concat(prefix, "--table-expand"), headerClassName);
    var previousValue = isExpanded ? 'collapsed' : undefined;
    return /*#__PURE__*/React__default["default"].createElement("th", _extends$3({
      scope: "col",
      className: className,
      "data-previous-value": previousValue
    }, rest), enableExpando || enableToggle ? /*#__PURE__*/React__default["default"].createElement("button", {
      type: "button",
      className: "".concat(prefix, "--table-expand__button"),
      onClick: onExpand,
      title: expandIconDescription,
      "aria-label": ariaLabel
    }, /*#__PURE__*/React__default["default"].createElement(ChevronRight16, {
      className: "".concat(prefix, "--table-expand__svg"),
      "aria-label": expandIconDescription
    })) : null, children);
  };

  TableExpandHeader.propTypes = {
    /**
     * Specify the string read by a voice reader when the expand trigger is
     * focused
     */
    ariaLabel: PropTypes__default["default"].oneOfType([requiredIfGivenPropIsTruthy('enableExpando', PropTypes__default["default"].string), requiredIfGivenPropIsTruthy('enableToggle', PropTypes__default["default"].string)]),
    children: PropTypes__default["default"].node,
    className: PropTypes__default["default"].string,

    /**
     * The enableExpando prop is being replaced by enableToggle
     */
    enableExpando: deprecate(PropTypes__default["default"].bool, 'The `enableExpando` prop has been deprecated in favor of `enableToggle`. This prop will be removed in the next major release.'),

    /**
     * Specify whether an expand all button should be displayed
     */
    enableToggle: PropTypes__default["default"].bool,

    /**
     * The description of the chevron right icon, to be put in its SVG `<title>` element.
     */
    expandIconDescription: PropTypes__default["default"].string,

    /**
     * Specify whether this row is expanded or not. This helps coordinate data
     * attributes so that `TableExpandRow` and `TableExpandedRow` work together
     */
    isExpanded: PropTypes__default["default"].oneOfType([requiredIfGivenPropIsTruthy('enableExpando', PropTypes__default["default"].bool), requiredIfGivenPropIsTruthy('enableToggle', PropTypes__default["default"].bool)]),

    /**
     * Hook for when a listener initiates a request to expand the given row
     */
    onExpand: PropTypes__default["default"].oneOfType([requiredIfGivenPropIsTruthy('enableExpando', PropTypes__default["default"].func), requiredIfGivenPropIsTruthy('enableToggle', PropTypes__default["default"].func)])
  };
  var TableExpandHeader$1 = TableExpandHeader;

  var _excluded$2b = ["ariaLabel", "className", "children", "isExpanded", "onExpand", "expandIconDescription", "isSelected", "expandHeader"];

  var TableExpandRow = function TableExpandRow(_ref) {
    var _cx;

    var ariaLabel = _ref.ariaLabel,
        rowClassName = _ref.className,
        children = _ref.children,
        isExpanded = _ref.isExpanded,
        onExpand = _ref.onExpand,
        expandIconDescription = _ref.expandIconDescription,
        isSelected = _ref.isSelected,
        expandHeader = _ref.expandHeader,
        rest = _objectWithoutProperties$2(_ref, _excluded$2b);

    var prefix = usePrefix();
    var className = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--parent-row"), true), _defineProperty$2(_cx, "".concat(prefix, "--expandable-row"), isExpanded), _defineProperty$2(_cx, "".concat(prefix, "--data-table--selected"), isSelected), _cx), rowClassName);
    var previousValue = isExpanded ? 'collapsed' : undefined;
    return /*#__PURE__*/React__default["default"].createElement("tr", _extends$3({}, rest, {
      className: className,
      "data-parent-row": true
    }), /*#__PURE__*/React__default["default"].createElement(TableCell$1, {
      className: "".concat(prefix, "--table-expand"),
      "data-previous-value": previousValue,
      headers: expandHeader
    }, /*#__PURE__*/React__default["default"].createElement("button", {
      type: "button",
      className: "".concat(prefix, "--table-expand__button"),
      onClick: onExpand,
      title: expandIconDescription,
      "aria-label": ariaLabel
    }, /*#__PURE__*/React__default["default"].createElement(ChevronRight16, {
      className: "".concat(prefix, "--table-expand__svg"),
      "aria-label": expandIconDescription
    }))), children);
  };

  TableExpandRow.propTypes = {
    /**
     * Specify the string read by a voice reader when the expand trigger is
     * focused
     */
    ariaLabel: PropTypes__default["default"].string.isRequired,
    children: PropTypes__default["default"].node,
    className: PropTypes__default["default"].string,

    /**
     * The id of the matching th node in the table head. Addresses a11y concerns outlined here: https://www.ibm.com/able/guidelines/ci162/info_and_relationships.html and https://www.w3.org/TR/WCAG20-TECHS/H43
     */
    expandHeader: PropTypes__default["default"].string,

    /**
     * The description of the chevron right icon, to be put in its SVG `<title>` element.
     */
    expandIconDescription: PropTypes__default["default"].string,

    /**
     * Specify whether this row is expanded or not. This helps coordinate data
     * attributes so that `TableExpandRow` and `TableExpandedRow` work together
     */
    isExpanded: PropTypes__default["default"].bool.isRequired,

    /**
     * Specify if the row is selected
     */
    isSelected: PropTypes__default["default"].bool,

    /**
     * Hook for when a listener initiates a request to expand the given row
     */
    onExpand: PropTypes__default["default"].func.isRequired
  };
  TableExpandRow.defaultProps = {
    expandHeader: 'expand'
  };
  var TableExpandRow$1 = TableExpandRow;

  var _excluded$2a = ["className", "children", "colSpan"];

  var TableExpandedRow = function TableExpandedRow(_ref) {
    var customClassName = _ref.className,
        children = _ref.children,
        colSpan = _ref.colSpan,
        rest = _objectWithoutProperties$2(_ref, _excluded$2a);

    var rowRef = React.useRef(null);
    var prefix = usePrefix();
    var className = cx("".concat(prefix, "--expandable-row"), customClassName);

    var toggleParentHoverClass = function toggleParentHoverClass(eventType) {
      if (rowRef && rowRef.current && rowRef.current.previousElementSibling) {
        var parentNode = rowRef.current.previousElementSibling;

        if (eventType === 'enter') {
          parentNode.classList.add("".concat(prefix, "--expandable-row--hover"));
        } else {
          parentNode.classList.remove("".concat(prefix, "--expandable-row--hover"));
        }
      }
    };

    return /*#__PURE__*/React__default["default"].createElement("tr", _extends$3({
      ref: rowRef,
      onMouseEnter: function onMouseEnter() {
        return toggleParentHoverClass('enter');
      },
      onMouseLeave: function onMouseLeave() {
        return toggleParentHoverClass('leave');
      }
    }, rest, {
      className: className,
      "data-child-row": true
    }), /*#__PURE__*/React__default["default"].createElement(TableCell$1, {
      colSpan: colSpan
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--child-row-inner-container")
    }, children)));
  };

  TableExpandedRow.propTypes = {
    /**
     * Pass in the contents for your TableExpandedRow
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * The width of the expanded row's internal cell
     */
    colSpan: PropTypes__default["default"].number.isRequired
  };
  var TableExpandedRow$1 = TableExpandedRow;

  var TableHead = wrapComponent$1({
    name: 'TableHead',
    type: 'thead'
  });
  var TableHead$1 = TableHead;

  var _excluded$29 = ["className", "children", "colSpan", "isSortable", "isSortHeader", "onClick", "scope", "sortDirection", "translateWithId", "id"];

  var _sortDirections;
  var translationKeys$1 = {
    buttonDescription: 'carbon.table.header.icon.description'
  };

  var translateWithId$3 = function translateWithId(key, _ref) {
    var header = _ref.header,
        sortDirection = _ref.sortDirection,
        isSortHeader = _ref.isSortHeader,
        sortStates = _ref.sortStates;

    if (key === translationKeys$1.buttonDescription) {
      if (isSortHeader) {
        // When transitioning, we know that the sequence of states is as follows:
        // NONE -> ASC -> DESC -> NONE
        if (sortDirection === sortStates.NONE) {
          return "Click to sort rows by ".concat(header, " header in ascending order");
        }

        if (sortDirection === sortStates.ASC) {
          return "Click to sort rows by ".concat(header, " header in descending order");
        }

        return "Click to unsort rows by ".concat(header, " header");
      }

      return "Click to sort rows by ".concat(header, " header in ascending order");
    }

    return '';
  };

  var sortDirections = (_sortDirections = {}, _defineProperty$2(_sortDirections, sortStates.NONE, 'none'), _defineProperty$2(_sortDirections, sortStates.ASC, 'ascending'), _defineProperty$2(_sortDirections, sortStates.DESC, 'descending'), _sortDirections);
  var TableHeader = /*#__PURE__*/React__default["default"].forwardRef(function TableHeader(_ref2, ref) {
    var _cx;

    var headerClassName = _ref2.className,
        children = _ref2.children,
        colSpan = _ref2.colSpan,
        isSortable = _ref2.isSortable,
        isSortHeader = _ref2.isSortHeader,
        onClick = _ref2.onClick,
        scope = _ref2.scope,
        sortDirection = _ref2.sortDirection,
        t = _ref2.translateWithId,
        id = _ref2.id,
        rest = _objectWithoutProperties$2(_ref2, _excluded$29);

    var prefix = usePrefix();
    var uniqueId = useId('table-sort');

    if (!isSortable) {
      return /*#__PURE__*/React__default["default"].createElement("th", _extends$3({}, rest, {
        id: id,
        className: headerClassName,
        scope: scope,
        colSpan: colSpan,
        ref: ref
      }), children ? /*#__PURE__*/React__default["default"].createElement("div", {
        className: "".concat(prefix, "--table-header-label")
      }, children) : null);
    }

    var className = cx(headerClassName, (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--table-sort"), true), _defineProperty$2(_cx, "".concat(prefix, "--table-sort--active"), isSortHeader && sortDirection !== sortStates.NONE), _defineProperty$2(_cx, "".concat(prefix, "--table-sort--ascending"), isSortHeader && sortDirection === sortStates.DESC), _cx));
    var ariaSort = !isSortHeader ? 'none' : sortDirections[sortDirection];
    var sortDescription = t('carbon.table.header.icon.description', {
      header: children,
      sortDirection: sortDirection,
      isSortHeader: isSortHeader,
      sortStates: sortStates
    });
    return /*#__PURE__*/React__default["default"].createElement("th", {
      id: id,
      "aria-sort": ariaSort,
      className: headerClassName,
      colSpan: colSpan,
      ref: ref,
      scope: scope
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      style: {
        display: 'none'
      },
      id: uniqueId
    }, sortDescription), /*#__PURE__*/React__default["default"].createElement("button", _extends$3({
      type: "button",
      "aria-describedby": uniqueId,
      className: className,
      onClick: onClick
    }, rest), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--table-sort__flex")
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--table-header-label")
    }, children), /*#__PURE__*/React__default["default"].createElement(ArrowUp20, {
      className: "".concat(prefix, "--table-sort__icon")
    }), /*#__PURE__*/React__default["default"].createElement(ArrowsVertical20, {
      className: "".concat(prefix, "--table-sort__icon-unsorted")
    }))));
  });
  TableHeader.propTypes = {
    /**
     * Pass in children that will be embedded in the table header label
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify `colSpan` as a non-negative integer value to indicate how
     * many columns the TableHeader cell extends in a table
     */
    colSpan: PropTypes__default["default"].number,

    /**
     * Supply an id to the th element.
     */
    id: PropTypes__default["default"].string,

    /**
     * Specify whether this header is the header by which a table is being sorted
     * by
     */
    isSortHeader: PropTypes__default["default"].bool,

    /**
     * Specify whether this header is one through which a user can sort the table
     */
    isSortable: PropTypes__default["default"].bool,

    /**
     * Hook that is invoked when the header is clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Specify the scope of this table header. You can find more info about this
     * attribute at the following URL:
     * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th#attr-scope
     */
    scope: PropTypes__default["default"].string.isRequired,

    /**
     * Specify which direction we are currently sorting by, should be one of DESC,
     * NONE, or ASC.
     */
    sortDirection: PropTypes__default["default"].oneOf(Object.values(sortStates)),

    /**
     * Supply a method to translate internal strings with your i18n tool of
     * choice. Translation keys are available on the `translationKeys` field for
     * this component.
     */
    translateWithId: PropTypes__default["default"].func
  };
  TableHeader.defaultProps = {
    isSortable: false,
    scope: 'col',
    translateWithId: translateWithId$3
  };
  TableHeader.translationKeys = Object.values(translationKeys$1);
  TableHeader.displayName = 'TableHeader';
  var TableHeader$1 = TableHeader;

  /** Used as the size to enable large array optimizations. */

  var LARGE_ARRAY_SIZE = 200;
  /** Used to stand-in for `undefined` hash values. */

  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  /** Used as references for various `Number` constants. */

  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991;
  /** `Object#toString` result references. */

  var argsTag = '[object Arguments]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      symbolTag$1 = '[object Symbol]';
  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */

  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  /** Used to detect host constructors (Safari). */

  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  /** Used to detect unsigned integer values. */

  var reIsUint = /^(?:0|[1-9]\d*)$/;
  /** Detect free variable `global` from Node.js. */

  var freeGlobal$1 = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  /** Detect free variable `self`. */

  var freeSelf$1 = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
  /** Used as a reference to the global object. */

  var root$1 = freeGlobal$1 || freeSelf$1 || Function('return this')();
  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */

  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);

      case 1:
        return func.call(thisArg, args[0]);

      case 2:
        return func.call(thisArg, args[0], args[1]);

      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }

    return func.apply(thisArg, args);
  }
  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */


  function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */


  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }

    return false;
  }
  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */


  function arrayMap(array, iteratee) {
    var index = -1,
        length = array ? array.length : 0,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }

    return result;
  }
  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */


  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }

    return array;
  }
  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */


  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }

    return -1;
  }
  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */


  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return baseFindIndex(array, baseIsNaN, fromIndex);
    }

    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }

    return -1;
  }
  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */


  function baseIsNaN(value) {
    return value !== value;
  }
  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */


  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }

    return result;
  }
  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */


  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }
  /**
   * Checks if a cache value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function cacheHas(cache, key) {
    return cache.has(key);
  }
  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */


  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }
  /**
   * Checks if `value` is a host object in IE < 9.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
   */


  function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;

    if (value != null && typeof value.toString != 'function') {
      try {
        result = !!(value + '');
      } catch (e) {}
    }

    return result;
  }
  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */


  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }
  /** Used for built-in method references. */


  var arrayProto = Array.prototype,
      funcProto = Function.prototype,
      objectProto$1 = Object.prototype;
  /** Used to detect overreaching core-js shims. */

  var coreJsData = root$1['__core-js_shared__'];
  /** Used to detect methods masquerading as native. */

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();
  /** Used to resolve the decompiled source of functions. */


  var funcToString = funcProto.toString;
  /** Used to check objects for own properties. */

  var hasOwnProperty = objectProto$1.hasOwnProperty;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var objectToString$1 = objectProto$1.toString;
  /** Used to detect if a method is native. */

  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  /** Built-in value references. */

  var _Symbol = root$1.Symbol,
      getPrototype = overArg(Object.getPrototypeOf, Object),
      propertyIsEnumerable = objectProto$1.propertyIsEnumerable,
      splice = arrayProto.splice,
      spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeGetSymbols = Object.getOwnPropertySymbols,
      nativeMax$1 = Math.max;
  /* Built-in method references that are verified to be native. */

  var Map$1 = getNative(root$1, 'Map'),
      nativeCreate = getNative(Object, 'create');
  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function Hash(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */


  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */


  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */


  function hashGet(key) {
    var data = this.__data__;

    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }

    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }
  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }
  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */


  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  } // Add methods to `Hash`.


  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function ListCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */


  function listCacheClear() {
    this.__data__ = [];
  }
  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */


  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }

    var lastIndex = data.length - 1;

    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }

    return true;
  }
  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */


  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }
  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */


  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }

    return this;
  } // Add methods to `ListCache`.


  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function MapCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */


  function mapCacheClear() {
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map$1 || ListCache)(),
      'string': new Hash()
    };
  }
  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */


  function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
  }
  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */


  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */


  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */


  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  } // Add methods to `MapCache`.


  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */

  function SetCache(values) {
    var index = -1,
        length = values ? values.length : 0;
    this.__data__ = new MapCache();

    while (++index < length) {
      this.add(values[index]);
    }
  }
  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */


  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);

    return this;
  }
  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */


  function setCacheHas(value) {
    return this.__data__.has(value);
  } // Add methods to `SetCache`.


  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */

  function arrayLikeKeys(value, inherited) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    // Safari 9 makes `arguments.length` enumerable in strict mode.
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length,
        skipIndexes = !!length;

    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
        result.push(key);
      }
    }

    return result;
  }
  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */


  function assocIndexOf(array, key) {
    var length = array.length;

    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }

    return -1;
  }
  /**
   * The base implementation of methods like `_.difference` without support
   * for excluding multiple arrays or iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Array} values The values to exclude.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of filtered values.
   */


  function baseDifference(array, values, iteratee, comparator) {
    var index = -1,
        includes = arrayIncludes,
        isCommon = true,
        length = array.length,
        result = [],
        valuesLength = values.length;

    if (!length) {
      return result;
    }

    if (iteratee) {
      values = arrayMap(values, baseUnary(iteratee));
    }

    if (comparator) {
      includes = arrayIncludesWith;
      isCommon = false;
    } else if (values.length >= LARGE_ARRAY_SIZE) {
      includes = cacheHas;
      isCommon = false;
      values = new SetCache(values);
    }

    outer: while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;

      if (isCommon && computed === computed) {
        var valuesIndex = valuesLength;

        while (valuesIndex--) {
          if (values[valuesIndex] === computed) {
            continue outer;
          }
        }

        result.push(value);
      } else if (!includes(values, computed, comparator)) {
        result.push(value);
      }
    }

    return result;
  }
  /**
   * The base implementation of `_.flatten` with support for restricting flattening.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {number} depth The maximum recursion depth.
   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
   * @param {Array} [result=[]] The initial result value.
   * @returns {Array} Returns the new flattened array.
   */


  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1,
        length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);

    while (++index < length) {
      var value = array[index];

      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          // Recursively flatten arrays (susceptible to call stack limits).
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }

    return result;
  }
  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */


  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */


  function baseIsNative(value) {
    if (!isObject$1(value) || isMasked(value)) {
      return false;
    }

    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */


  function baseKeysIn(object) {
    if (!isObject$1(object)) {
      return nativeKeysIn(object);
    }

    var isProto = isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }

    return result;
  }
  /**
   * The base implementation of `_.pick` without support for individual
   * property identifiers.
   *
   * @private
   * @param {Object} object The source object.
   * @param {string[]} props The property identifiers to pick.
   * @returns {Object} Returns the new object.
   */


  function basePick(object, props) {
    object = Object(object);
    return basePickBy(object, props, function (value, key) {
      return key in object;
    });
  }
  /**
   * The base implementation of  `_.pickBy` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The source object.
   * @param {string[]} props The property identifiers to pick from.
   * @param {Function} predicate The function invoked per property.
   * @returns {Object} Returns the new object.
   */


  function basePickBy(object, props, predicate) {
    var index = -1,
        length = props.length,
        result = {};

    while (++index < length) {
      var key = props[index],
          value = object[key];

      if (predicate(value, key)) {
        result[key] = value;
      }
    }

    return result;
  }
  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */


  function baseRest(func, start) {
    start = nativeMax$1(start === undefined ? func.length - 1 : start, 0);
    return function () {
      var args = arguments,
          index = -1,
          length = nativeMax$1(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }

      index = -1;
      var otherArgs = Array(start + 1);

      while (++index < start) {
        otherArgs[index] = args[index];
      }

      otherArgs[start] = array;
      return apply(func, this, otherArgs);
    };
  }
  /**
   * Creates an array of own and inherited enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */


  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
  }
  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */


  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }
  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */


  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }
  /**
   * Creates an array of the own enumerable symbol properties of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */


  var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
  /**
   * Creates an array of the own and inherited enumerable symbol properties
   * of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */

  var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
    var result = [];

    while (object) {
      arrayPush(result, getSymbols(object));
      object = getPrototype(object);
    }

    return result;
  };
  /**
   * Checks if `value` is a flattenable `arguments` object or array.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
   */

  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */


  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }
  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */


  function isKeyable(value) {
    var type = _typeof(value);

    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }
  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */


  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */


  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$1;
    return value === proto;
  }
  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */


  function nativeKeysIn(object) {
    var result = [];

    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }

    return result;
  }
  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */


  function toKey(value) {
    if (typeof value == 'string' || isSymbol$1(value)) {
      return value;
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }
  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to process.
   * @returns {string} Returns the source code.
   */


  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }
  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */


  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */


  function isArguments(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString$1.call(value) == argsTag);
  }
  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */


  var isArray = Array.isArray;
  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */

  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */


  function isArrayLikeObject(value) {
    return isObjectLike$1(value) && isArrayLike(value);
  }
  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */


  function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject$1(value) ? objectToString$1.call(value) : '';
    return tag == funcTag || tag == genTag;
  }
  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */


  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */


  function isObject$1(value) {
    var type = _typeof(value);

    return !!value && (type == 'object' || type == 'function');
  }
  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */


  function isObjectLike$1(value) {
    return !!value && _typeof(value) == 'object';
  }
  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */


  function isSymbol$1(value) {
    return _typeof(value) == 'symbol' || isObjectLike$1(value) && objectToString$1.call(value) == symbolTag$1;
  }
  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */


  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  /**
   * The opposite of `_.pick`; this method creates an object composed of the
   * own and inherited enumerable string keyed properties of `object` that are
   * not omitted.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The source object.
   * @param {...(string|string[])} [props] The property identifiers to omit.
   * @returns {Object} Returns the new object.
   * @example
   *
   * var object = { 'a': 1, 'b': '2', 'c': 3 };
   *
   * _.omit(object, ['a', 'c']);
   * // => { 'b': '2' }
   */


  var omit = baseRest(function (object, props) {
    if (object == null) {
      return {};
    }

    props = arrayMap(baseFlatten(props, 1), toKey);
    return basePick(object, baseDifference(getAllKeysIn(object), props));
  });
  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */

  function stubArray() {
    return [];
  }

  var lodash_omit = omit;

  var TableRow = function TableRow(props) {
    var prefix = usePrefix(); // Remove unnecessary props if provided to this component, these are
    // only useful in `TableExpandRow`

    var className = cx(props.className, _defineProperty$2({}, "".concat(prefix, "--data-table--selected"), props.isSelected));

    var cleanProps = _objectSpread2$2(_objectSpread2$2({}, lodash_omit(props, ['ariaLabel', 'onExpand', 'isExpanded', 'isSelected'])), {}, {
      className: className || undefined
    });

    return /*#__PURE__*/React__default["default"].createElement("tr", cleanProps);
  };

  TableRow.propTypes = {
    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify if the row is selected
     */
    isSelected: PropTypes__default["default"].bool
  };
  var TableRow$1 = TableRow;

  /**
   * Combine multiple refs into a single ref. This use useful when you have two
   * refs from both `React.forwardRef` and `useRef` that you would like to add to
   * the same node.
   *
   * @param {Array} refs
   * @returns {Function}
   */

  function useMergedRefs(refs) {
    return React.useCallback(function (node) {
      refs.forEach(function (ref) {
        if (typeof ref === 'function') {
          ref(node);
        } else if (ref !== null && ref !== undefined) {
          ref.current = node;
        }
      }); // eslint-disable-next-line react-hooks/exhaustive-deps
    }, refs);
  }

  var InlineCheckbox = /*#__PURE__*/React__default["default"].forwardRef(function InlineCheckbox(props, forwardRef) {
    var ariaLabel = props.ariaLabel,
        _props$checked = props.checked,
        checked = _props$checked === void 0 ? false : _props$checked,
        disabled = props.disabled,
        id = props.id,
        indeterminate = props.indeterminate,
        name = props.name,
        _props$onChange = props.onChange,
        _onChange = _props$onChange === void 0 ? function () {} : _props$onChange,
        onClick = props.onClick,
        onKeyDown = props.onKeyDown,
        title = props.title;

    var prefix = usePrefix();
    var inputRef = React.useRef(null);
    var ref = useMergedRefs([inputRef, forwardRef]);
    var inputProps = {
      checked: checked,
      className: "".concat(prefix, "--checkbox"),
      disabled: disabled,
      id: id,
      name: name,
      onClick: onClick,
      onChange: function onChange(evt) {
        _onChange(evt.target.checked, id, evt);
      },
      onKeyDown: onKeyDown,
      ref: ref,
      type: 'checkbox'
    };

    if (indeterminate) {
      inputProps.checked = false;
    }

    React.useEffect(function () {
      inputRef.current.indeterminate = indeterminate;
    }, [indeterminate]);
    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--checkbox--inline")
    }, /*#__PURE__*/React__default["default"].createElement("input", inputProps),
    /*#__PURE__*/

    /* eslint-disable jsx-a11y/label-has-for,jsx-a11y/label-has-associated-control,jsx-a11y/click-events-have-key-events,jsx-a11y/no-noninteractive-element-interactions */
    React__default["default"].createElement("label", {
      htmlFor: id,
      className: "".concat(prefix, "--checkbox-label"),
      title: title,
      onClick: function onClick(evt) {
        evt.stopPropagation();
      }
    }, /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--visually-hidden")
    }, ariaLabel)));
  });
  InlineCheckbox.propTypes = {
    /**
     * Specify the label for the control
     */
    ariaLabel: PropTypes__default["default"].string.isRequired,

    /**
     * Specify whether the underlying control is checked, or not
     */
    checked: PropTypes__default["default"].bool,

    /**
     * Specify whether the underlying input control should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Provide an `id` for the underlying input control
     */
    id: PropTypes__default["default"].string.isRequired,

    /**
     * Specify whether the control is in an indterminate state
     */
    indeterminate: PropTypes__default["default"].bool,

    /**
     * Provide a `name` for the underlying input control
     */
    name: PropTypes__default["default"].string.isRequired,

    /**
     * Provide an optional hook that is called each time the input is updated
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Provide a handler that is invoked when a user clicks on the control
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Provide a handler that is invoked on the key down event for the control
     */
    onKeyDown: PropTypes__default["default"].func,

    /**
     * Provide an optional tooltip for the InlineCheckbox
     */
    title: PropTypes__default["default"].string
  };
  var InlineCheckbox$1 = InlineCheckbox;

  var TableSelectAll = function TableSelectAll(_ref) {
    var ariaLabel = _ref.ariaLabel,
        checked = _ref.checked,
        id = _ref.id,
        indeterminate = _ref.indeterminate,
        name = _ref.name,
        onSelect = _ref.onSelect,
        disabled = _ref.disabled,
        className = _ref.className;
    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("th", {
      scope: "col",
      className: cx("".concat(prefix, "--table-column-checkbox"), className)
    }, /*#__PURE__*/React__default["default"].createElement(InlineCheckbox$1, {
      ariaLabel: ariaLabel,
      checked: checked,
      id: id,
      indeterminate: indeterminate,
      name: name,
      onClick: onSelect,
      disabled: disabled
    }));
  };

  TableSelectAll.propTypes = {
    /**
     * Specify the aria label for the underlying input control
     */
    ariaLabel: PropTypes__default["default"].string.isRequired,

    /**
     * Specify whether all items are selected, or not
     */
    checked: PropTypes__default["default"].bool.isRequired,

    /**
     * The CSS class names of the cell that wraps the underlying input control
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the checkbox input should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Provide an `id` for the underlying input control
     */
    id: PropTypes__default["default"].string.isRequired,

    /**
     * Specify whether the selection only has a subset of all items
     */
    indeterminate: PropTypes__default["default"].bool,

    /**
     * Provide a `name` for the underlying input control
     */
    name: PropTypes__default["default"].string.isRequired,

    /**
     * Provide a handler to listen to when a user initiates a selection request
     */
    onSelect: PropTypes__default["default"].func.isRequired
  };
  TableSelectAll.defaultProps = {
    ariaLabel: 'Select all rows in the table'
  };
  var TableSelectAll$1 = TableSelectAll;

  var _excluded$28 = ["className", "disabled", "hideLabel", "id", "labelPosition", "labelText", "name", "onChange", "value"];
  var RadioButton$3 = /*#__PURE__*/React__default["default"].forwardRef(function RadioButton(_ref, ref) {
    var className = _ref.className,
        disabled = _ref.disabled,
        hideLabel = _ref.hideLabel,
        id = _ref.id,
        _ref$labelPosition = _ref.labelPosition,
        labelPosition = _ref$labelPosition === void 0 ? 'right' : _ref$labelPosition,
        _ref$labelText = _ref.labelText,
        labelText = _ref$labelText === void 0 ? '' : _ref$labelText,
        name = _ref.name,
        _ref$onChange = _ref.onChange,
        onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
        _ref$value = _ref.value,
        value = _ref$value === void 0 ? '' : _ref$value,
        rest = _objectWithoutProperties$2(_ref, _excluded$28);

    var prefix = usePrefix();
    var uid = useId('radio-button');
    var uniqueId = id || uid;

    function handleOnChange(event) {
      onChange(value, name, event);
    }

    var innerLabelClasses = cx(_defineProperty$2({}, "".concat(prefix, "--visually-hidden"), hideLabel));
    var wrapperClasses = cx(className, "".concat(prefix, "--radio-button-wrapper"), _defineProperty$2({}, "".concat(prefix, "--radio-button-wrapper--label-").concat(labelPosition), labelPosition !== 'right'));
    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: wrapperClasses
    }, /*#__PURE__*/React__default["default"].createElement("input", _extends$3({}, rest, {
      type: "radio",
      className: "".concat(prefix, "--radio-button"),
      onChange: handleOnChange,
      id: uniqueId,
      ref: ref,
      disabled: disabled
    })), /*#__PURE__*/React__default["default"].createElement("label", {
      htmlFor: uniqueId,
      className: "".concat(prefix, "--radio-button__label")
    }, /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--radio-button__appearance")
    }), labelText && /*#__PURE__*/React__default["default"].createElement(Text, {
      className: innerLabelClasses
    }, labelText)));
  });
  RadioButton$3.propTypes = {
    /**
     * Specify whether the <RadioButton> is currently checked
     */
    checked: PropTypes__default["default"].bool,

    /**
     * Provide an optional className to be applied to the containing node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the <RadioButton> should be checked by default
     */
    defaultChecked: PropTypes__default["default"].bool,

    /**
     * Specify whether the control is disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Specify whether the label should be hidden, or not
     */
    hideLabel: PropTypes__default["default"].bool,

    /**
     * Provide a unique id for the underlying `<input>` node
     */
    id: PropTypes__default["default"].string,

    /**
     * Provide where label text should be placed
     * NOTE: `top`/`bottom` are deprecated
     */
    labelPosition: PropTypes__default["default"].oneOf(['right', 'left']),

    /**
     * Provide label text to be read by screen readers when interacting with the
     * control
     */
    labelText: PropTypes__default["default"].node.isRequired,

    /**
     * Provide a name for the underlying `<input>` node
     */
    name: PropTypes__default["default"].string,

    /**
     * Provide an optional `onChange` hook that is called each time the value of
     * the underlying `<input>` changes
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Provide a handler that is invoked when a user clicks on the control
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Specify the value of the <RadioButton>
     */
    value: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]).isRequired
  };
  var RadioButtonNext = RadioButton$3;

  var _excluded$27 = ["className", "labelText", "labelPosition", "innerRef", "hideLabel"];

  var RadioButton$2 = /*#__PURE__*/function (_React$Component) {
    _inherits(RadioButton, _React$Component);

    var _super = _createSuper(RadioButton);

    function RadioButton() {
      var _this;

      _classCallCheck$1(this, RadioButton);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty$2(_assertThisInitialized$1(_this), "prefix", _this.context);

      _defineProperty$2(_assertThisInitialized$1(_this), "uid", _this.props.id || uniqueId());

      _defineProperty$2(_assertThisInitialized$1(_this), "handleChange", function (evt) {
        _this.props.onChange(_this.props.value, _this.props.name, evt);
      });

      return _this;
    }

    _createClass$1(RadioButton, [{
      key: "render",
      value: function render() {
        var prefix = this.prefix;

        var _this$props = this.props,
            className = _this$props.className,
            labelText = _this$props.labelText,
            labelPosition = _this$props.labelPosition,
            ref = _this$props.innerRef,
            hideLabel = _this$props.hideLabel,
            other = _objectWithoutProperties$2(_this$props, _excluded$27);

        {
          warning(labelPosition !== 'top' && labelPosition !== 'bottom', '`top`/`bottom` values for `labelPosition` property in the `RadioButton` component is deprecated ' + 'and being removed in the next release of `carbon-components-react`.') ;
        }

        var innerLabelClasses = cx(_defineProperty$2({}, "".concat(prefix, "--visually-hidden"), hideLabel));
        var wrapperClasses = cx(className, "".concat(prefix, "--radio-button-wrapper"), _defineProperty$2({}, "".concat(prefix, "--radio-button-wrapper--label-").concat(labelPosition), labelPosition !== 'right'));
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: wrapperClasses
        }, /*#__PURE__*/React__default["default"].createElement("input", _extends$3({}, other, {
          type: "radio",
          className: "".concat(prefix, "--radio-button"),
          onChange: this.handleChange,
          id: this.uid,
          ref: ref
        })), /*#__PURE__*/React__default["default"].createElement("label", {
          htmlFor: this.uid,
          className: "".concat(prefix, "--radio-button__label")
        }, /*#__PURE__*/React__default["default"].createElement("span", {
          className: "".concat(prefix, "--radio-button__appearance")
        }), labelText && /*#__PURE__*/React__default["default"].createElement(Text, {
          className: innerLabelClasses
        }, labelText)));
      }
    }]);

    return RadioButton;
  }(React__default["default"].Component);

  _defineProperty$2(RadioButton$2, "propTypes", {
    /**
     * Specify whether the <RadioButton> is currently checked
     */
    checked: PropTypes__default["default"].bool,

    /**
     * Provide an optional className to be applied to the containing node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the <RadioButton> should be checked by default
     */
    defaultChecked: PropTypes__default["default"].bool,

    /**
     * Specify whether the control is disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Specify whether the label should be hidden, or not
     */
    hideLabel: PropTypes__default["default"].bool,

    /**
     * Provide a unique id for the underlying `<input>` node
     */
    id: PropTypes__default["default"].string,

    /**
     * Provide where label text should be placed
     * NOTE: `top`/`bottom` are deprecated
     */
    labelPosition: PropTypes__default["default"].oneOf(['top', 'right', 'bottom', 'left']),

    /**
     * Provide label text to be read by screen readers when interacting with the
     * control
     */
    labelText: PropTypes__default["default"].node.isRequired,

    /**
     * Provide a name for the underlying `<input>` node
     */
    name: PropTypes__default["default"].string,

    /**
     * Provide an optional `onChange` hook that is called each time the value of
     * the underlying `<input>` changes
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Provide a handler that is invoked when a user clicks on the control
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Specify the value of the <RadioButton>
     */
    value: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]).isRequired
  });

  _defineProperty$2(RadioButton$2, "contextType", PrefixContext);

  _defineProperty$2(RadioButton$2, "defaultProps", {
    labelText: '',
    labelPosition: 'right',
    onChange: function onChange() {},
    value: ''
  });
  var RadioButtonClassic = (function () {
    var forwardRef = function forwardRef(props, ref) {
      return /*#__PURE__*/React__default["default"].createElement(RadioButton$2, _extends$3({}, props, {
        innerRef: ref
      }));
    };

    forwardRef.displayName = 'RadioButton';
    return /*#__PURE__*/React__default["default"].forwardRef(forwardRef);
  })();

  var _excluded$26 = ["className"];

  function RadioButtonSkeleton(_ref) {
    var className = _ref.className,
        rest = _objectWithoutProperties$2(_ref, _excluded$26);

    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: cx("".concat(prefix, "--radio-button-wrapper"), className)
    }, rest), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--radio-button ").concat(prefix, "--skeleton")
    }), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--radio-button__label ").concat(prefix, "--skeleton")
    }));
  }

  RadioButtonSkeleton.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes__default["default"].string
  };

  var RadioButton = enabled('enable-v11-release') ? RadioButtonNext : RadioButtonClassic;
  var RadioButton$1 = RadioButton;

  var TableSelectRow = function TableSelectRow(_ref) {
    var _classNames;

    var ariaLabel = _ref.ariaLabel,
        checked = _ref.checked,
        id = _ref.id,
        name = _ref.name,
        onSelect = _ref.onSelect,
        onChange = _ref.onChange,
        disabled = _ref.disabled,
        radio = _ref.radio,
        className = _ref.className;
    var prefix = usePrefix();
    var selectionInputProps = {
      id: id,
      name: name,
      onClick: onSelect,
      onChange: onChange,
      checked: checked,
      disabled: disabled
    };
    var InlineInputComponent = radio ? RadioButton$1 : InlineCheckbox$1;
    var tableSelectRowClasses = cx("".concat(prefix, "--table-column-checkbox"), (_classNames = {}, _defineProperty$2(_classNames, className, className), _defineProperty$2(_classNames, "".concat(prefix, "--table-column-radio"), radio), _classNames));
    return /*#__PURE__*/React__default["default"].createElement("td", {
      className: tableSelectRowClasses
    }, /*#__PURE__*/React__default["default"].createElement(InlineInputComponent, _extends$3({}, selectionInputProps, radio && {
      labelText: ariaLabel,
      hideLabel: true
    }, !radio && {
      ariaLabel: ariaLabel
    })));
  };

  TableSelectRow.propTypes = {
    /**
     * Specify the aria label for the underlying input control
     */
    ariaLabel: PropTypes__default["default"].string.isRequired,

    /**
     * Specify whether all items are selected, or not
     */
    checked: PropTypes__default["default"].bool.isRequired,

    /**
     * The CSS class names of the cell that wraps the underlying input control
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the control is disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Provide an `id` for the underlying input control
     */
    id: PropTypes__default["default"].string.isRequired,

    /**
     * Provide a `name` for the underlying input control
     */
    name: PropTypes__default["default"].string.isRequired,

    /**
     * Provide an optional hook that is called each time the input is updated
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Provide a handler to listen to when a user initiates a selection request
     */
    onSelect: PropTypes__default["default"].func.isRequired,

    /**
     * Specify whether the control should be a radio button or inline checkbox
     */
    radio: PropTypes__default["default"].bool
  };
  var TableSelectRow$1 = TableSelectRow;

  /**
   * Copyright IBM Corp. 2016, 2018
   *
   * This source code is licensed under the Apache-2.0 license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * @param {object<string, Function>} propTypes The list of type checkers, keyed by prop names.
   * @returns {object<string, Function>}
   *   The new prop type checkers that checks if one of the given props exist,
   *   in addition to the original type checkings.
   */
  function isRequiredOneOf(propTypes) {
    var names = Object.keys(propTypes);

    var checker = function checker(propType) {
      return function (props, propName, componentName) {
        if (names.every(function (name) {
          return typeof props[name] === 'undefined';
        })) {
          return new Error("".concat(componentName, " requires one of the following props: ").concat(names.join(', ')));
        }

        for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
          rest[_key - 3] = arguments[_key];
        }

        return propType.apply(void 0, [props, propName, componentName].concat(rest));
      };
    };

    return names.reduce(function (o, name) {
      return _objectSpread2$2(_objectSpread2$2({}, o), {}, _defineProperty$2({}, name, checker(propTypes[name])));
    }, {});
  }

  var AriaLabelPropType = isRequiredOneOf({
    'aria-label': PropTypes__default["default"].string,
    'aria-labelledby': PropTypes__default["default"].string
  });

  var _excluded$25 = ["children", "size"];

  var TableToolbar = function TableToolbar(_ref) {
    var _cx;

    var children = _ref.children,
        size = _ref.size,
        rest = _objectWithoutProperties$2(_ref, _excluded$25);

    var prefix = usePrefix();
    var className = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--table-toolbar"), true), _defineProperty$2(_cx, "".concat(prefix, "--table-toolbar--").concat(size), size), _cx));
    return /*#__PURE__*/React__default["default"].createElement("section", _extends$3({}, rest, {
      className: className
    }), children);
  };

  TableToolbar.propTypes = _objectSpread2$2(_objectSpread2$2({}, AriaLabelPropType), {}, {
    /**
     * Pass in the children that will be rendered inside the TableToolbar
     */
    children: PropTypes__default["default"].node,

    /**
     * `lg` Change the row height of table
     */
    size: enabled('enable-v11-release') ? PropTypes__default["default"].oneOf(['sm', 'lg']) : PropTypes__default["default"].oneOf(['small', 'sm', 'normal', 'lg'])
  });
  TableToolbar.defaultProps = {
    'aria-label': 'data table toolbar'
  };
  var TableToolbar$1 = TableToolbar;

  var _excluded$24 = ["href", "className", "itemText", "hasDivider", "isDelete", "disabled", "closeMenu", "onClick", "handleOverflowMenuItemFocus", "onKeyDown", "primaryFocus", "wrapperClassName", "requireTitle", "index", "title"];

  var OverflowMenuItem$1 = /*#__PURE__*/function (_React$Component) {
    _inherits(OverflowMenuItem, _React$Component);

    var _super = _createSuper(OverflowMenuItem);

    function OverflowMenuItem() {
      var _this;

      _classCallCheck$1(this, OverflowMenuItem);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty$2(_assertThisInitialized$1(_this), "overflowMenuItem", /*#__PURE__*/React__default["default"].createRef());

      _defineProperty$2(_assertThisInitialized$1(_this), "setTabFocus", function (evt) {
        if (match(evt, ArrowDown)) {
          _this.props.handleOverflowMenuItemFocus({
            currentIndex: _this.props.index,
            direction: 1
          });
        }

        if (match(evt, ArrowUp)) {
          _this.props.handleOverflowMenuItemFocus({
            currentIndex: _this.props.index,
            direction: -1
          });
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleClick", function (evt) {
        var _this$props = _this.props,
            onClick = _this$props.onClick,
            closeMenu = _this$props.closeMenu;
        onClick(evt);

        if (closeMenu) {
          closeMenu();
        }
      });

      return _this;
    }

    _createClass$1(OverflowMenuItem, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props2 = this.props,
            href = _this$props2.href,
            className = _this$props2.className,
            itemText = _this$props2.itemText,
            hasDivider = _this$props2.hasDivider,
            isDelete = _this$props2.isDelete,
            disabled = _this$props2.disabled,
            closeMenu = _this$props2.closeMenu;
            _this$props2.onClick;
            _this$props2.handleOverflowMenuItemFocus;
            var _onKeyDown = _this$props2.onKeyDown,
            primaryFocus = _this$props2.primaryFocus,
            wrapperClassName = _this$props2.wrapperClassName,
            requireTitle = _this$props2.requireTitle,
            index = _this$props2.index,
            title = _this$props2.title,
            other = _objectWithoutProperties$2(_this$props2, _excluded$24);

        {
          warning(closeMenu, '`<OverflowMenuItem>` detected missing `closeMenu` prop. ' + '`closeMenu` is required to let `<OverflowMenu>` close the menu upon actions on `<OverflowMenuItem>`. ' + 'Please make sure `<OverflowMenuItem>` is a direct child of `<OverflowMenu>.') ;
        }

        return /*#__PURE__*/React__default["default"].createElement(PrefixContext.Consumer, null, function (prefix) {
          var _classNames;

          var overflowMenuBtnClasses = cx("".concat(prefix, "--overflow-menu-options__btn"), className);
          var overflowMenuItemClasses = cx("".concat(prefix, "--overflow-menu-options__option"), (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--overflow-menu--divider"), hasDivider), _defineProperty$2(_classNames, "".concat(prefix, "--overflow-menu-options__option--danger"), isDelete), _defineProperty$2(_classNames, "".concat(prefix, "--overflow-menu-options__option--disabled"), disabled), _classNames), wrapperClassName);
          var TagToUse = href ? 'a' : 'button';

          var OverflowMenuItemContent = function () {
            if (typeof itemText !== 'string') {
              return itemText;
            }

            return /*#__PURE__*/React__default["default"].createElement("div", {
              className: "".concat(prefix, "--overflow-menu-options__option-content")
            }, itemText);
          }();

          return /*#__PURE__*/React__default["default"].createElement("li", {
            className: overflowMenuItemClasses,
            role: "none"
          }, /*#__PURE__*/React__default["default"].createElement(TagToUse, _extends$3({}, other, {
            'data-floating-menu-primary-focus': primaryFocus || null,
            role: "menuitem",
            href: href,
            className: overflowMenuBtnClasses,
            disabled: disabled,
            onClick: _this2.handleClick,
            onKeyDown: function onKeyDown(evt) {
              _this2.setTabFocus(evt);

              _onKeyDown(evt);
            },
            ref: _this2.overflowMenuItem,
            title: requireTitle ? title || itemText : null,
            tabIndex: "-1",
            index: index
          }), OverflowMenuItemContent));
        });
      }
    }]);

    return OverflowMenuItem;
  }(React__default["default"].Component);

  _defineProperty$2(OverflowMenuItem$1, "propTypes", {
    /**
     * The CSS class name to be placed on the button element
     */
    className: PropTypes__default["default"].string,

    /**
     * A callback to tell the parent menu component that the menu should be closed.
     */
    closeMenu: PropTypes__default["default"].func,

    /**
     * `true` to make this menu item disabled.
     */
    disabled: PropTypes__default["default"].bool,
    handleOverflowMenuItemFocus: PropTypes__default["default"].func,

    /**
     * `true` to make this menu item a divider.
     */
    hasDivider: PropTypes__default["default"].bool,

    /**
     * If given, overflow item will render as a link with the given href
     */
    href: PropTypes__default["default"].string,
    index: PropTypes__default["default"].number,

    /**
     * `true` to make this menu item a "danger button".
     */
    isDelete: PropTypes__default["default"].bool,

    /**
     * The text in the menu item.
     */
    itemText: PropTypes__default["default"].node.isRequired,

    /**
     * event handlers
     */
    onBlur: PropTypes__default["default"].func,
    onClick: PropTypes__default["default"].func,
    onFocus: PropTypes__default["default"].func,
    onKeyDown: PropTypes__default["default"].func,
    onKeyUp: PropTypes__default["default"].func,
    onMouseDown: PropTypes__default["default"].func,
    onMouseEnter: PropTypes__default["default"].func,
    onMouseLeave: PropTypes__default["default"].func,
    onMouseUp: PropTypes__default["default"].func,

    /**
     * `true` if this menu item should get focus when the menu gets open.
     */
    primaryFocus: deprecate(PropTypes__default["default"].bool, 'The `primaryFocus` prop has been deprecated as it is no longer used. ' + 'Feel free to remove this prop from <OverflowMenuItem>. This prop will ' + 'be removed in the next major release of `carbon-components-react`. ' + 'Opt for `selectorPrimaryFocus` in `<OverflowMenu>` instead'),

    /**
     * `true` if this menu item has long text and requires a browser tooltip
     */
    requireTitle: PropTypes__default["default"].bool,

    /**
     * Specify a title for the OverflowMenuItem
     */
    title: PropTypes__default["default"].string,

    /**
     * The CSS class name to be placed on the wrapper list item element
     */
    wrapperClassName: PropTypes__default["default"].string
  });

  _defineProperty$2(OverflowMenuItem$1, "defaultProps", {
    hasDivider: false,
    isDelete: false,
    disabled: false,
    itemText: enabled('enable-v11-release') ? null : 'Provide itemText',
    onClick: function onClick() {},
    onKeyDown: function onKeyDown() {}
  });

  var OverflowMenuItem = OverflowMenuItem$1;

  var _excluded$23 = ["children"];
  var TableToolbarAction = /*#__PURE__*/React__default["default"].forwardRef(function (_ref, ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, _excluded$23);

    return /*#__PURE__*/React__default["default"].createElement(OverflowMenuItem, _extends$3({
      ref: ref,
      itemText: children
    }, rest));
  });
  TableToolbarAction.displayName = 'TableToolbarAction';
  TableToolbarAction.propTypes = {
    children: PropTypes__default["default"].node,
    className: PropTypes__default["default"].string,
    onClick: PropTypes__default["default"].func.isRequired
  };
  var TableToolbarAction$1 = TableToolbarAction;

  var prefix$3 = settings_1.prefix;
  var TableToolbarContent = wrapComponent$1({
    name: 'TableToolbarContent',
    type: 'div',
    className: "".concat(prefix$3, "--toolbar-content")
  });
  var TableToolbarContent$1 = TableToolbarContent;

  function focus(elementOrRef) {
    var element = elementOrRef.current || elementOrRef;

    if (element && element.focus && document.activeElement !== element) {
      element.focus();
    }
  }

  var _excluded$22 = ["autoComplete", "className", "closeButtonLabelText", "defaultValue", "disabled", "id", "labelText", "light", "onChange", "onClear", "onKeyDown", "placeHolderText", "placeholder", "renderIcon", "role", "size", "type", "value"];

  function Search$3(_ref) {
    var _cx, _cx2;

    var _ref$autoComplete = _ref.autoComplete,
        autoComplete = _ref$autoComplete === void 0 ? 'off' : _ref$autoComplete,
        className = _ref.className,
        _ref$closeButtonLabel = _ref.closeButtonLabelText,
        closeButtonLabelText = _ref$closeButtonLabel === void 0 ? 'Clear search input' : _ref$closeButtonLabel,
        defaultValue = _ref.defaultValue,
        disabled = _ref.disabled,
        id = _ref.id,
        labelText = _ref.labelText,
        light = _ref.light,
        _ref$onChange = _ref.onChange,
        onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
        _ref$onClear = _ref.onClear,
        onClear = _ref$onClear === void 0 ? function () {} : _ref$onClear,
        onKeyDown = _ref.onKeyDown,
        placeHolderText = _ref.placeHolderText,
        _ref$placeholder = _ref.placeholder,
        placeholder = _ref$placeholder === void 0 ? '' : _ref$placeholder,
        renderIcon = _ref.renderIcon,
        _ref$role = _ref.role,
        role = _ref$role === void 0 ? 'searchbox' : _ref$role,
        _ref$size = _ref.size,
        size = _ref$size === void 0 ? 'md' : _ref$size,
        _ref$type = _ref.type,
        type = _ref$type === void 0 ? 'text' : _ref$type,
        value = _ref.value,
        rest = _objectWithoutProperties$2(_ref, _excluded$22);

    var prefix = usePrefix();
    var input = React.useRef(null);
    var magnifier = React.useRef(null);
    var inputId = useId('search-input');
    var uniqueId = id || inputId;
    var searchId = "".concat(uniqueId, "-search");

    var _useState = React.useState(value || defaultValue || false),
        _useState2 = _slicedToArray$1(_useState, 2),
        hasContent = _useState2[0],
        setHasContent = _useState2[1];

    var _useState3 = React.useState(value),
        _useState4 = _slicedToArray$1(_useState3, 2),
        prevValue = _useState4[0],
        setPrevValue = _useState4[1];

    var searchClasses = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--search"), true), _defineProperty$2(_cx, "".concat(prefix, "--search--sm"), size === 'sm'), _defineProperty$2(_cx, "".concat(prefix, "--search--md"), size === 'md'), _defineProperty$2(_cx, "".concat(prefix, "--search--lg"), size === 'lg'), _defineProperty$2(_cx, "".concat(prefix, "--search--light"), light), _defineProperty$2(_cx, "".concat(prefix, "--search--disabled"), disabled), _defineProperty$2(_cx, className, className), _cx));
    var clearClasses = cx((_cx2 = {}, _defineProperty$2(_cx2, "".concat(prefix, "--search-close"), true), _defineProperty$2(_cx2, "".concat(prefix, "--search-close--hidden"), !hasContent), _cx2));

    if (value !== prevValue) {
      setHasContent(!!value);
      setPrevValue(value);
    }

    function clearInput(event) {
      if (!value) {
        input.current.value = '';
        onChange(event);
      } else {
        var clearedEvt = Object.assign({}, event.target, {
          target: {
            value: ''
          }
        });
        onChange(clearedEvt);
      }

      onClear();
      setHasContent(false);
      focus(input);
    }

    function handleChange(event) {
      setHasContent(event.target.value !== '');
    }

    function handleKeyDown(event) {
      if (match(event, Escape)) {
        event.stopPropagation();
        clearInput(event);
      }
    }

    return /*#__PURE__*/React__default["default"].createElement("div", {
      role: "search",
      "aria-labelledby": searchId,
      className: searchClasses
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--search-magnifier"),
      ref: magnifier
    }, /*#__PURE__*/React__default["default"].createElement(SearchIcon, {
      icon: renderIcon
    })), /*#__PURE__*/React__default["default"].createElement("label", {
      id: searchId,
      htmlFor: uniqueId,
      className: "".concat(prefix, "--label")
    }, labelText), /*#__PURE__*/React__default["default"].createElement("input", _extends$3({}, rest, {
      autoComplete: autoComplete,
      className: "".concat(prefix, "--search-input"),
      defaultValue: defaultValue,
      disabled: disabled,
      role: role,
      ref: input,
      id: uniqueId,
      onChange: composeEventHandlers([onChange, handleChange]),
      onKeyDown: composeEventHandlers([onKeyDown, handleKeyDown]),
      placeholder: placeHolderText || placeholder,
      type: type,
      value: value
    })), /*#__PURE__*/React__default["default"].createElement("button", {
      "aria-label": closeButtonLabelText,
      className: clearClasses,
      disabled: disabled,
      onClick: clearInput,
      type: "button"
    }, /*#__PURE__*/React__default["default"].createElement(Close16, null)));
  }

  Search$3.propTypes = {
    /**
     * Specify an optional value for the `autocomplete` property on the underlying
     * `<input>`, defaults to "off"
     */
    autoComplete: PropTypes__default["default"].string,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify a label to be read by screen readers on the "close" button
     */
    closeButtonLabelText: PropTypes__default["default"].string,

    /**
     * Optionally provide the default value of the `<input>`
     */
    defaultValue: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),

    /**
     * Specify whether the `<input>` should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Specify a custom `id` for the input
     */
    id: PropTypes__default["default"].string,

    /**
     * Provide the label text for the Search icon
     */
    labelText: PropTypes__default["default"].node.isRequired,

    /**
     * Specify light version or default version of this control
     */
    light: PropTypes__default["default"].bool,

    /**
     * Optional callback called when the search value changes.
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Optional callback called when the search value is cleared.
     */
    onClear: PropTypes__default["default"].func,

    /**
     * Provide a handler that is invoked on the key down event for the input
     */
    onKeyDown: PropTypes__default["default"].func,

    /**
     * Deprecated in favor of `placeholder`
     */
    placeHolderText: deprecate(PropTypes__default["default"].string, "\nThe prop `placeHolderText` for Search has been deprecated in favor of `placeholder`. Please use `placeholder` instead."),

    /**
     * Provide an optional placeholder text for the Search.
     * Note: if the label and placeholder differ,
     * VoiceOver on Mac will read both
     */
    placeholder: PropTypes__default["default"].string,

    /**
     * Rendered icon for the Search.
     * Can be a React component class
     */
    renderIcon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),

    /**
     * Specify the role for the underlying `<input>`, defaults to `searchbox`
     */
    role: PropTypes__default["default"].string,

    /**
     * Specify the size of the Search
     */
    size: PropTypes__default["default"].oneOf(['sm', 'md', 'lg']),

    /**
     * Optional prop to specify the type of the `<input>`
     */
    type: PropTypes__default["default"].string,

    /**
     * Specify the value of the `<input>`
     */
    value: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number])
  };

  function SearchIcon(_ref2) {
    var icon = _ref2.icon;
    var prefix = usePrefix();

    if (icon) {
      return /*#__PURE__*/React__default["default"].cloneElement(icon, {
        className: "".concat(prefix, "--search-magnifier-icon")
      });
    }

    return /*#__PURE__*/React__default["default"].createElement(Search16, {
      className: "".concat(prefix, "--search-magnifier-icon")
    });
  }

  SearchIcon.propTypes = {
    /**
     * Rendered icon for the Search. Can be a React component class
     */
    icon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object])
  };

  var _excluded$21 = ["className", "type", "id", "placeHolderText", "placeholder", "labelText", "closeButtonLabelText", "small", "size", "light", "disabled", "onChange", "onKeyDown", "renderIcon", "onClear"];

  var Search$2 = /*#__PURE__*/function (_Component) {
    _inherits(Search, _Component);

    var _super = _createSuper(Search);

    function Search() {
      var _this;

      _classCallCheck$1(this, Search);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty$2(_assertThisInitialized$1(_this), "state", {
        hasContent: _this.props.value || _this.props.defaultValue || false,
        prevValue: _this.props.value
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "clearInput", function (evt) {
        if (!_this.props.value) {
          _this.input.value = '';

          _this.props.onChange(evt);
        } else {
          var clearedEvt = Object.assign({}, evt.target, {
            target: {
              value: ''
            }
          });

          _this.props.onChange(clearedEvt);
        }

        _this.props.onClear();

        _this.setState({
          hasContent: false
        }, function () {
          return _this.input.focus();
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleChange", function (evt) {
        _this.setState({
          hasContent: evt.target.value !== ''
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleKeyDown", function (evt) {
        if (match(evt, Escape)) {
          _this.clearInput(evt);
        }
      });

      return _this;
    }

    _createClass$1(Search, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props = this.props,
            className = _this$props.className,
            type = _this$props.type,
            _this$props$id = _this$props.id,
            id = _this$props$id === void 0 ? this._inputId = this._inputId || "search__input__id_".concat(Math.random().toString(36).substr(2)) : _this$props$id,
            placeHolderText = _this$props.placeHolderText,
            placeholder = _this$props.placeholder,
            labelText = _this$props.labelText,
            closeButtonLabelText = _this$props.closeButtonLabelText,
            small = _this$props.small,
            _this$props$size = _this$props.size,
            size = _this$props$size === void 0 ? !small ? 'xl' : 'sm' : _this$props$size,
            light = _this$props.light,
            disabled = _this$props.disabled,
            onChange = _this$props.onChange,
            onKeyDown = _this$props.onKeyDown,
            renderIcon = _this$props.renderIcon;
            _this$props.onClear;
            var other = _objectWithoutProperties$2(_this$props, _excluded$21);

        var hasContent = this.state.hasContent;
        var scope = this.context;
        var enabled;

        if (scope.enabled) {
          enabled = scope.enabled('enable-v11-release');
        }

        return /*#__PURE__*/React__default["default"].createElement(PrefixContext.Consumer, null, function (prefix) {
          var _classNames, _classNames2;

          var searchClasses = cx((_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--search"), true), _defineProperty$2(_classNames, "".concat(prefix, "--search--sm"), size === 'sm'), _defineProperty$2(_classNames, "".concat(prefix, "--search--lg"), enabled ? size === 'md' : size === 'lg'), _defineProperty$2(_classNames, "".concat(prefix, "--search--xl"), enabled ? size === 'lg' : size === 'xl'), _defineProperty$2(_classNames, "".concat(prefix, "--search--light"), light), _defineProperty$2(_classNames, "".concat(prefix, "--search--disabled"), disabled), _defineProperty$2(_classNames, className, className), _classNames));
          var clearClasses = cx((_classNames2 = {}, _defineProperty$2(_classNames2, "".concat(prefix, "--search-close"), true), _defineProperty$2(_classNames2, "".concat(prefix, "--search-close--hidden"), !hasContent), _classNames2));
          var customIcon;

          if (renderIcon) {
            customIcon = /*#__PURE__*/React__default["default"].cloneElement(renderIcon, {
              className: "".concat(prefix, "--search-magnifier-icon")
            });
          }

          var searchId = "".concat(id, "-search");
          var searchIcon = renderIcon ? customIcon : /*#__PURE__*/React__default["default"].createElement(Search16, {
            className: "".concat(prefix, "--search-magnifier-icon")
          });
          return /*#__PURE__*/React__default["default"].createElement("div", {
            role: "search",
            "aria-labelledby": searchId,
            className: searchClasses
          }, /*#__PURE__*/React__default["default"].createElement("div", {
            className: "".concat(prefix, "--search-magnifier"),
            ref: function ref(magnifier) {
              _this2.magnifier = magnifier;
            }
          }, searchIcon), /*#__PURE__*/React__default["default"].createElement("label", {
            id: searchId,
            htmlFor: id,
            className: "".concat(prefix, "--label")
          }, labelText), /*#__PURE__*/React__default["default"].createElement("input", _extends$3({
            role: "searchbox",
            autoComplete: "off"
          }, other, {
            type: type,
            disabled: disabled,
            className: "".concat(prefix, "--search-input"),
            id: id,
            placeholder: placeHolderText || placeholder,
            onChange: composeEventHandlers([onChange, _this2.handleChange]),
            onKeyDown: composeEventHandlers([onKeyDown, _this2.handleKeyDown]),
            ref: function ref(input) {
              _this2.input = input;
            }
          })), /*#__PURE__*/React__default["default"].createElement("button", {
            className: clearClasses,
            disabled: disabled,
            onClick: _this2.clearInput,
            type: "button",
            "aria-label": closeButtonLabelText
          }, /*#__PURE__*/React__default["default"].createElement(Close16, null)));
        });
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, state) {
        var value = _ref.value;
        var prevValue = state.prevValue;
        return prevValue === value ? null : {
          hasContent: !!value,
          prevValue: value
        };
      }
    }]);

    return Search;
  }(React.Component);

  _defineProperty$2(Search$2, "propTypes", {
    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify a label to be read by screen readers on the "close" button
     */
    closeButtonLabelText: PropTypes__default["default"].string,

    /**
     * Optionally provide the default value of the `<input>`
     */
    defaultValue: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),

    /**
     * Specify whether the `<input>` should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Specify a custom `id` for the input
     */
    id: PropTypes__default["default"].string,

    /**
     * Provide the label text for the Search icon
     */
    labelText: PropTypes__default["default"].node.isRequired,

    /**
     * Specify light version or default version of this control
     */
    light: PropTypes__default["default"].bool,

    /**
     * Optional callback called when the search value changes.
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Optional callback called when the search value is cleared.
     */
    onClear: PropTypes__default["default"].func,

    /**
     * Provide a handler that is invoked on the key down event for the input
     */
    onKeyDown: PropTypes__default["default"].func,

    /**
     * Deprecated in favor of `placeholder`
     */
    placeHolderText: deprecate(PropTypes__default["default"].string, "\nThe prop `placeHolderText` for Search has been deprecated in favor of `placeholder`. Please use `placeholder` instead."),

    /**
     * Provide an optional placeholder text for the Search.
     * Note: if the label and placeholder differ,
     * VoiceOver on Mac will read both
     */
    placeholder: PropTypes__default["default"].string,

    /**
     * Rendered icon for the Search.
     * Can be a React component class
     */
    renderIcon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),

    /**
     * Specify the search size
     */
    size: PropTypes__default["default"].oneOf(['sm', 'md', 'lg', 'xl']),

    /**
     * Specify whether the Search should be a small variant
     */

    /**
     * Specify whether the load was successful
     */
    small: deprecate(PropTypes__default["default"].bool, "\nThe prop `small` for Search has been deprecated in favor of `size`. Please use `size=\"sm\"` instead."),

    /**
     * Optional prop to specify the type of the `<input>`
     */
    type: PropTypes__default["default"].string,

    /**
     * Specify the value of the `<input>`
     */
    value: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number])
  });

  _defineProperty$2(Search$2, "contextType", FeatureFlagContext);

  _defineProperty$2(Search$2, "defaultProps", {
    type: 'text',
    placeholder: '',
    closeButtonLabelText: 'Clear search input',
    onChange: function onChange() {},
    onClear: function onClear() {}
  });

  var _excluded$20 = ["small", "className"];

  var SearchSkeleton = function SearchSkeleton(_ref) {
    var _cx;

    var small = _ref.small,
        className = _ref.className,
        rest = _objectWithoutProperties$2(_ref, _excluded$20);

    var prefix = usePrefix();
    var searchClasses = cx(className, (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--skeleton"), true), _defineProperty$2(_cx, "".concat(prefix, "--search--xl"), !small), _defineProperty$2(_cx, "".concat(prefix, "--search--sm"), small), _cx));
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: searchClasses
    }, rest), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--label")
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--search-input")
    }));
  };

  SearchSkeleton.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the Search should be a small variant
     */
    small: PropTypes__default["default"].bool
  };
  SearchSkeleton.defaultProps = {
    small: false
  };
  var SearchSkeleton$1 = SearchSkeleton;

  var Search = enabled('enable-v11-release') ? Search$3 : Search$2;
  var Search$1 = Search;

  var _excluded$1$ = ["className", "searchContainerClass", "onChange", "onClear", "translateWithId", "placeHolderText", "placeholder", "labelText", "expanded", "defaultExpanded", "defaultValue", "disabled", "onExpand", "persistent", "persistant", "id", "onBlur", "onFocus"];
  var getInstanceId$g = setupGetInstanceId$1();
  var translationKeys = {
    'carbon.table.toolbar.search.label': 'Filter table',
    'carbon.table.toolbar.search.placeholder': 'Filter table'
  };

  var translateWithId$2 = function translateWithId(id) {
    return translationKeys[id];
  };

  var TableToolbarSearch = function TableToolbarSearch(_ref) {
    var _cx;

    var className = _ref.className,
        searchContainerClass = _ref.searchContainerClass,
        onChangeProp = _ref.onChange,
        onClear = _ref.onClear,
        t = _ref.translateWithId,
        placeHolderText = _ref.placeHolderText,
        placeholder = _ref.placeholder,
        labelText = _ref.labelText,
        expandedProp = _ref.expanded,
        defaultExpanded = _ref.defaultExpanded,
        defaultValue = _ref.defaultValue,
        disabled = _ref.disabled,
        onExpand = _ref.onExpand,
        persistent = _ref.persistent,
        persistant = _ref.persistant,
        id = _ref.id,
        onBlur = _ref.onBlur,
        onFocus = _ref.onFocus,
        rest = _objectWithoutProperties$2(_ref, _excluded$1$);

    var _useRef = React.useRef(expandedProp !== undefined),
        controlled = _useRef.current;

    var _useState = React.useState(defaultExpanded || defaultValue),
        _useState2 = _slicedToArray$1(_useState, 2),
        expandedState = _useState2[0],
        setExpandedState = _useState2[1];

    var expanded = controlled ? expandedProp : expandedState;

    var _useState3 = React.useState(defaultValue || ''),
        _useState4 = _slicedToArray$1(_useState3, 2),
        value = _useState4[0],
        setValue = _useState4[1];

    var uniqueId = React.useMemo(getInstanceId$g, []);

    var _useState5 = React.useState(null),
        _useState6 = _slicedToArray$1(_useState5, 2),
        focusTarget = _useState6[0],
        setFocusTarget = _useState6[1];

    var prefix = usePrefix();
    React.useEffect(function () {
      if (focusTarget) {
        focusTarget.current.querySelector('input').focus();
        setFocusTarget(null);
      }
    }, [focusTarget]);
    React.useEffect(function () {
      if (defaultValue) {
        onChangeProp('', defaultValue);
      }
    }, //eslint-disable-next-line react-hooks/exhaustive-deps
    []);
    var searchClasses = cx(className, (_cx = {}, _defineProperty$2(_cx, searchContainerClass, searchContainerClass), _defineProperty$2(_cx, "".concat(prefix, "--toolbar-search-container-active"), expanded), _defineProperty$2(_cx, "".concat(prefix, "--toolbar-search-container-disabled"), disabled), _defineProperty$2(_cx, "".concat(prefix, "--toolbar-search-container-expandable"), !persistent || !persistent && !persistant), _defineProperty$2(_cx, "".concat(prefix, "--toolbar-search-container-persistent"), persistent || persistant), _cx));

    var handleExpand = function handleExpand(event) {
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !expanded;

      if (!disabled) {
        if (!controlled && (!persistent || !persistent && !persistant)) {
          setExpandedState(value);
        }

        if (onExpand) {
          onExpand(event, value);
        }
      }
    };

    var onChange = function onChange(e) {
      setValue(e.target.value);

      if (onChangeProp) {
        onChangeProp(e);
      }
    };

    var handleOnFocus = function handleOnFocus(event) {
      return handleExpand(event, true);
    };

    var handleOnBlur = function handleOnBlur(event) {
      return !value && handleExpand(event, false);
    };

    return /*#__PURE__*/React__default["default"].createElement(Search$1, _extends$3({
      disabled: disabled,
      className: searchClasses,
      value: value,
      id: typeof id !== 'undefined' ? id : uniqueId.toString(),
      labelText: labelText || t('carbon.table.toolbar.search.label'),
      placeholder: placeHolderText || placeholder || t('carbon.table.toolbar.search.placeholder'),
      onChange: onChange,
      onClear: onClear,
      onFocus: onFocus ? function (event) {
        return onFocus(event, handleExpand);
      } : handleOnFocus,
      onBlur: onBlur ? function (event) {
        return onBlur(event, handleExpand);
      } : handleOnBlur
    }, rest));
  };

  TableToolbarSearch.propTypes = {
    children: PropTypes__default["default"].node,

    /**
     * Provide an optional class name for the search container
     */
    className: PropTypes__default["default"].string,

    /**
     * Specifies if the search should initially render in an expanded state
     */
    defaultExpanded: PropTypes__default["default"].bool,

    /**
     * Provide an optional default value for the Search component
     */
    defaultValue: PropTypes__default["default"].string,

    /**
     * Specifies if the search should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Specifies if the search should expand
     */
    expanded: PropTypes__default["default"].bool,

    /**
     * Provide an optional id for the search container
     */
    id: PropTypes__default["default"].string,

    /**
     * Provide an optional label text for the Search component icon
     */
    labelText: PropTypes__default["default"].string,

    /**
     * Provide an optional function to be called when the search input loses focus, this will be
     * passed the event as the first parameter and a function to handle the expanding of the search
     * input as the second
     */
    onBlur: PropTypes__default["default"].func,

    /**
     * Provide an optional hook that is called each time the input is updated
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Optional callback called when the search value is cleared.
     */
    onClear: PropTypes__default["default"].func,

    /**
     * Provide an optional hook that is called each time the input is expanded
     */
    onExpand: PropTypes__default["default"].func,

    /**
     * Provide an optional function to be called when the search input gains focus, this will be
     * passed the event as the first parameter and a function to handle the expanding of the search
     * input as the second.
     */
    onFocus: PropTypes__default["default"].func,
    persistant: deprecate(PropTypes__default["default"].bool, "\nThe prop `persistant` for TableToolbarSearch has been deprecated in favor of `persistent`. Please use `persistent` instead."),

    /**
     * Whether the search should be allowed to expand
     */
    persistent: PropTypes__default["default"].bool,

    /**
     * Deprecated in favor of `placeholder`
     */
    placeHolderText: deprecate(PropTypes__default["default"].string, "\nThe prop `placeHolderText` for TableToolbarSearch has been deprecated in favor of `placeholder`. Please use `placeholder` instead."),

    /**
     * Provide an optional placeholder text for the Search component
     */
    placeholder: PropTypes__default["default"].string,

    /**
     * Provide an optional className for the overall container of the Search
     */
    searchContainerClass: PropTypes__default["default"].string,

    /**
     * Optional prop to specify the tabIndex of the <Search> (in expanded state) or the container (in collapsed state)
     */
    tabIndex: PropTypes__default["default"].oneOfType([PropTypes__default["default"].number, PropTypes__default["default"].string]),

    /**
     * Provide custom text for the component for each translation id
     */
    translateWithId: PropTypes__default["default"].func.isRequired
  };
  TableToolbarSearch.defaultProps = {
    tabIndex: '0',
    translateWithId: translateWithId$2,
    persistent: false,
    onClear: function onClear() {}
  };
  var TableToolbarSearch$1 = TableToolbarSearch;

  var invariant = function invariant(condition, format, a, b, c, d, e, f) {
    {
      if (format === undefined) {
        throw new Error('invariant requires an error message argument');
      }
    }

    if (!condition) {
      var error;

      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }

      error.framesToPop = 1; // we don't care about invariant's own frame

      throw error;
    }
  };

  var invariant_1 = invariant;

  /**
   * Generic component used for reacting to a click event happening outside of a
   * given `children` element.
   */

  var ClickListener = /*#__PURE__*/function (_React$Component) {
    _inherits(ClickListener, _React$Component);

    var _super = _createSuper(ClickListener);

    function ClickListener(props) {
      var _this;

      _classCallCheck$1(this, ClickListener);

      _this = _super.call(this, props); // We manually bind handlers in this Component, versus using class
      // properties, so that we can properly test the `handleRef` handler with
      // enzyme.

      _this.handleRef = _this.handleRef.bind(_assertThisInitialized$1(_this));
      _this.handleDocumentClick = _this.handleDocumentClick.bind(_assertThisInitialized$1(_this));
      return _this;
    }

    _createClass$1(ClickListener, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        document.addEventListener('click', this.handleDocumentClick);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        document.removeEventListener('click', this.handleDocumentClick);
      }
    }, {
      key: "handleDocumentClick",
      value: function handleDocumentClick(evt) {
        if (this.element) {
          if (this.element.contains && !this.element.contains(ClickListener.getEventTarget(evt))) {
            this.props.onClickOutside(evt);
          }
        }
      }
    }, {
      key: "handleRef",
      value: function handleRef(el) {
        var children = this.props.children;
        this.element = el;
        /**
         * One important note, `children.ref` corresponds to a `ref` prop passed in
         * directly to the child, not necessarily a `ref` defined in the component.
         * This means that here we target the following `ref` location:
         *
         * <ClickListener onClickOutside={() => {}}>
         *   <Child ref={targetedRefHere} />
         * </ClickListener>
         */

        if (children.ref && typeof children.ref === 'function') {
          children.ref(el);
        }
      }
    }, {
      key: "render",
      value: function render() {
        return /*#__PURE__*/React__default["default"].cloneElement(this.props.children, {
          ref: this.handleRef
        });
      }
    }], [{
      key: "getEventTarget",
      value: function getEventTarget(evt) {
        // support Shadow DOM
        if (evt.composed && typeof evt.composedPath === 'function') {
          return evt.composedPath()[0];
        }

        return evt.target;
      }
    }]);

    return ClickListener;
  }(React__default["default"].Component);

  _defineProperty$2(ClickListener, "propTypes", {
    children: PropTypes__default["default"].element.isRequired,
    onClickOutside: PropTypes__default["default"].func.isRequired
  });

  var lib = (typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object' && self.self === self && self || _typeof(commonjsGlobal) === 'object' && commonjsGlobal.global === commonjsGlobal && commonjsGlobal || commonjsGlobal;

  // mdn resize function

  var OptimizedResize = function optimizedResize() {
    var callbacks = [];
    var running = false; // run the actual callbacks

    function runCallbacks() {
      callbacks.forEach(function (callback) {
        callback();
      });
      running = false;
    } // fired on resize event


    function resize() {
      if (!running) {
        running = true;
        lib.requestAnimationFrame(runCallbacks);
      }
    } // adds callback to loop


    function addCallback(callback) {
      if (callback) {
        var index = callbacks.indexOf(callback);

        if (index < 0) {
          callbacks.push(callback);
        }
      }
    }

    return {
      // public method to add additional callback
      add: function add(callback) {
        if (!callbacks.length) {
          lib.addEventListener('resize', resize);
        }

        addCallback(callback);
        return {
          release: function release() {
            var index = callbacks.indexOf(callback);

            if (index >= 0) {
              callbacks.splice(index, 1);
            }
          }
        };
      }
    };
  }();

  var OptimizedResize$1 = OptimizedResize;

  /**
   * The structure for the position of floating menu.
   * @typedef {object} FloatingMenu~position
   * @property {number} left The left position.
   * @property {number} top The top position.
   * @property {number} right The right position.
   * @property {number} bottom The bottom position.
   */

  /**
   * The structure for the size of floating menu.
   * @typedef {object} FloatingMenu~size
   * @property {number} width The width.
   * @property {number} height The height.
   */

  /**
   * The structure for the position offset of floating menu.
   * @typedef {object} FloatingMenu~offset
   * @property {number} top The top position.
   * @property {number} left The left position.
   */

  /**
   * The structure for the target container.
   * @typedef {object} FloatingMenu~container
   * @property {DOMRect} rect Return of element.getBoundingClientRect()
   * @property {string} position Position style (static, absolute, relative...)
   */

  var DIRECTION_LEFT = 'left';
  var DIRECTION_TOP = 'top';
  var DIRECTION_RIGHT = 'right';
  var DIRECTION_BOTTOM = 'bottom';
  /**
   * @param {FloatingMenu~offset} [oldMenuOffset={}] The old value.
   * @param {FloatingMenu~offset} [menuOffset={}] The new value.
   * @returns `true` if the parent component wants to change in the adjustment of the floating menu position.
   * @private
   */

  var hasChangeInOffset = function hasChangeInOffset() {
    var oldMenuOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var menuOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (_typeof(oldMenuOffset) !== _typeof(menuOffset)) {
      return true;
    }

    if (Object(menuOffset) === menuOffset && typeof menuOffset !== 'function') {
      return oldMenuOffset.top !== menuOffset.top || oldMenuOffset.left !== menuOffset.left;
    }

    return oldMenuOffset !== menuOffset;
  };
  /**
   * @param {object} params The parameters.
   * @param {FloatingMenu~size} params.menuSize The size of the menu.
   * @param {FloatingMenu~position} params.refPosition The position of the triggering element.
   * @param {FloatingMenu~offset} [params.offset={ left: 0, top: 0 }] The position offset of the menu.
   * @param {string} [params.direction=bottom] The menu direction.
   * @param {number} [params.scrollX=0] The scroll position of the viewport.
   * @param {number} [params.scrollY=0] The scroll position of the viewport.
   * @param {FloatingMenu~container} [params.container] The size and position type of target element.
   * @returns {FloatingMenu~offset} The position of the menu, relative to the top-left corner of the viewport.
   * @private
   */


  var getFloatingPosition = function getFloatingPosition(_ref) {
    var _DIRECTION_LEFT$DIREC;

    var menuSize = _ref.menuSize,
        _ref$refPosition = _ref.refPosition,
        refPosition = _ref$refPosition === void 0 ? {} : _ref$refPosition,
        _ref$offset = _ref.offset,
        offset = _ref$offset === void 0 ? {} : _ref$offset,
        _ref$direction = _ref.direction,
        direction = _ref$direction === void 0 ? DIRECTION_BOTTOM : _ref$direction,
        _ref$scrollX = _ref.scrollX,
        pageXOffset = _ref$scrollX === void 0 ? 0 : _ref$scrollX,
        _ref$scrollY = _ref.scrollY,
        pageYOffset = _ref$scrollY === void 0 ? 0 : _ref$scrollY,
        container = _ref.container;
    var _refPosition$left = refPosition.left,
        refLeft = _refPosition$left === void 0 ? 0 : _refPosition$left,
        _refPosition$top = refPosition.top,
        refTop = _refPosition$top === void 0 ? 0 : _refPosition$top,
        _refPosition$right = refPosition.right,
        refRight = _refPosition$right === void 0 ? 0 : _refPosition$right,
        _refPosition$bottom = refPosition.bottom,
        refBottom = _refPosition$bottom === void 0 ? 0 : _refPosition$bottom;
    var scrollX = container.position !== 'static' ? 0 : pageXOffset;
    var scrollY = container.position !== 'static' ? 0 : pageYOffset;
    var relativeDiff = {
      top: container.position !== 'static' ? container.rect.top : 0,
      left: container.position !== 'static' ? container.rect.left : 0
    };
    var width = menuSize.width,
        height = menuSize.height;
    var _offset$top = offset.top,
        top = _offset$top === void 0 ? 0 : _offset$top,
        _offset$left = offset.left,
        left = _offset$left === void 0 ? 0 : _offset$left;
    var refCenterHorizontal = (refLeft + refRight) / 2;
    var refCenterVertical = (refTop + refBottom) / 2;
    return (_DIRECTION_LEFT$DIREC = {}, _defineProperty$2(_DIRECTION_LEFT$DIREC, DIRECTION_LEFT, function () {
      return {
        left: refLeft - width + scrollX - left - relativeDiff.left,
        top: refCenterVertical - height / 2 + scrollY + top - 9 - relativeDiff.top
      };
    }), _defineProperty$2(_DIRECTION_LEFT$DIREC, DIRECTION_TOP, function () {
      return {
        left: refCenterHorizontal - width / 2 + scrollX + left - relativeDiff.left,
        top: refTop - height + scrollY - top - relativeDiff.top
      };
    }), _defineProperty$2(_DIRECTION_LEFT$DIREC, DIRECTION_RIGHT, function () {
      return {
        left: refRight + scrollX + left - relativeDiff.left,
        top: refCenterVertical - height / 2 + scrollY + top + 3 - relativeDiff.top
      };
    }), _defineProperty$2(_DIRECTION_LEFT$DIREC, DIRECTION_BOTTOM, function () {
      return {
        left: refCenterHorizontal - width / 2 + scrollX + left - relativeDiff.left,
        top: refBottom + scrollY + top - relativeDiff.top
      };
    }), _DIRECTION_LEFT$DIREC)[direction]();
  };
  /**
   * A menu that is detached from the triggering element.
   * Useful when the container of the triggering element cannot have `overflow:visible` style, etc.
   */


  var FloatingMenu = /*#__PURE__*/function (_React$Component) {
    _inherits(FloatingMenu, _React$Component);

    var _super = _createSuper(FloatingMenu);

    function FloatingMenu() {
      var _this;

      _classCallCheck$1(this, FloatingMenu);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty$2(_assertThisInitialized$1(_this), "_placeInProgress", false);

      _defineProperty$2(_assertThisInitialized$1(_this), "state", {
        /**
         * The position of the menu, relative to the top-left corner of the viewport.
         * @type {FloatingMenu~offset}
         */
        floatingPosition: undefined
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "_menuContainer", null);

      _defineProperty$2(_assertThisInitialized$1(_this), "_menuBody", null);

      _defineProperty$2(_assertThisInitialized$1(_this), "startSentinel", /*#__PURE__*/React__default["default"].createRef());

      _defineProperty$2(_assertThisInitialized$1(_this), "endSentinel", /*#__PURE__*/React__default["default"].createRef());

      _defineProperty$2(_assertThisInitialized$1(_this), "_updateMenuSize", function () {
        var prevProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var isAdjustment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var menuBody = _this._menuBody;
        warning(menuBody, 'The DOM node for menu body for calculating its position is not available. Skipping...') ;

        if (!menuBody) {
          return;
        }

        var _prevProps$menuOffset = prevProps.menuOffset,
            oldMenuOffset = _prevProps$menuOffset === void 0 ? {} : _prevProps$menuOffset,
            oldMenuDirection = prevProps.menuDirection;
        var _this$props = _this.props,
            _this$props$menuOffse = _this$props.menuOffset,
            menuOffset = _this$props$menuOffse === void 0 ? {} : _this$props$menuOffse,
            menuDirection = _this$props.menuDirection;

        if (hasChangeInOffset(oldMenuOffset, menuOffset) || oldMenuDirection !== menuDirection || isAdjustment) {
          var _this$props2 = _this.props,
              flipped = _this$props2.flipped,
              triggerRef = _this$props2.triggerRef,
              updateOrientation = _this$props2.updateOrientation;
          var triggerEl = triggerRef.current;
          var menuSize = menuBody.getBoundingClientRect();
          var refPosition = triggerEl && triggerEl.getBoundingClientRect();
          var offset = typeof menuOffset !== 'function' ? menuOffset : menuOffset(menuBody, menuDirection, triggerEl, flipped); // Optional function to allow parent component to check
          // if the orientation needs to be changed based on params

          if (updateOrientation) {
            updateOrientation({
              menuSize: menuSize,
              refPosition: refPosition,
              direction: menuDirection,
              offset: offset,
              scrollX: lib.pageXOffset,
              scrollY: lib.pageYOffset,
              container: {
                rect: _this.props.target().getBoundingClientRect(),
                position: getComputedStyle(_this.props.target()).position
              }
            });
          } // Skips if either in the following condition:
          // a) Menu body has `display:none`
          // b) `menuOffset` as a callback returns `undefined` (The callback saw that it couldn't calculate the value)


          if (menuSize.width > 0 && menuSize.height > 0 || !offset) {
            _this.setState({
              floatingPosition: getFloatingPosition({
                menuSize: menuSize,
                refPosition: refPosition,
                direction: menuDirection,
                offset: offset,
                scrollX: lib.pageXOffset,
                scrollY: lib.pageYOffset,
                container: {
                  rect: _this.props.target().getBoundingClientRect(),
                  position: getComputedStyle(_this.props.target()).position
                }
              })
            }, function () {
              if (!isAdjustment) {
                var newMenuSize = menuBody.getBoundingClientRect();

                if (newMenuSize !== menuSize) {
                  _this._updateMenuSize(_this.props, true);
                }
              }
            });
          }
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "_focusMenuContent", function (menuBody) {
        var primaryFocusNode = menuBody.querySelector(_this.props.selectorPrimaryFocus || null);
        var tabbableNode = menuBody.querySelector(selectorTabbable);
        var focusableNode = menuBody.querySelector(selectorFocusable);
        var focusTarget = primaryFocusNode || // User defined focusable node
        tabbableNode || // First sequentially focusable node
        focusableNode || // First programmatic focusable node
        menuBody;

        if (_this.props.focusTrap) {
          focusTarget.focus();
        }

        if (focusTarget === menuBody && "development" !== "production") {
          warning(focusableNode === null, 'Floating Menus must have at least a programmatically focusable child. ' + 'This can be accomplished by adding tabIndex="-1" to the content element.') ;
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "_menuRef", function (menuBody) {
        var menuRef = _this.props.menuRef;
        _this._placeInProgress = !!menuBody;
        menuRef && menuRef(_this._menuBody = menuBody);

        if (menuBody) {
          _this._updateMenuSize();
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "_getChildrenWithProps", function () {
        var _this$props3 = _this.props,
            styles = _this$props3.styles,
            children = _this$props3.children;
        var pos = _this.state.floatingPosition; // If no pos available, we need to hide the element (offscreen to the left)
        // This is done so we can measure the content before positioning it correctly.

        var positioningStyle = pos ? {
          left: "".concat(pos.left, "px"),
          top: "".concat(pos.top, "px"),
          right: 'auto'
        } : {
          visibility: 'hidden',
          top: '0px'
        };
        return /*#__PURE__*/React__default["default"].cloneElement(children, {
          ref: _this._menuRef,
          style: _objectSpread2$2(_objectSpread2$2(_objectSpread2$2({}, styles), positioningStyle), {}, {
            position: 'absolute',
            opacity: 1
          })
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleBlur", function (_ref2) {
        var oldActiveNode = _ref2.target,
            currentActiveNode = _ref2.relatedTarget;

        if (currentActiveNode && oldActiveNode) {
          var startSentinelNode = _this.startSentinel.current;
          var endSentinelNode = _this.endSentinel.current;
          wrapFocus({
            bodyNode: _this._menuBody,
            startSentinelNode: startSentinelNode,
            endSentinelNode: endSentinelNode,
            currentActiveNode: currentActiveNode,
            oldActiveNode: oldActiveNode
          });
        }
      });

      return _this;
    }

    _createClass$1(FloatingMenu, [{
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.hResize.release();
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;

        this.hResize = OptimizedResize$1.add(function () {
          _this2._updateMenuSize();
        });
      }
      /**
       * Set focus on floating menu content after menu placement.
       * @param {Element} menuBody The DOM element of the menu body.
       * @private
       */

    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        this._updateMenuSize(prevProps);

        var onPlace = this.props.onPlace;

        if (this._placeInProgress && this.state.floatingPosition) {
          if (this._menuBody && !this._menuBody.contains(document.activeElement)) {
            this._focusMenuContent(this._menuBody);
          }

          if (typeof onPlace === 'function') {
            onPlace(this._menuBody);
            this._placeInProgress = false;
          }
        }
      }
      /**
       * A callback for called when menu body is mounted or unmounted.
       * @param {Element} menuBody The menu body being mounted. `null` if the menu body is being unmounted.
       */

    }, {
      key: "render",
      value: function render() {
        var prefix = this.context;

        if (typeof document !== 'undefined') {
          var _this$props4 = this.props,
              focusTrap = _this$props4.focusTrap,
              target = _this$props4.target;
          return /*#__PURE__*/ReactDOM__default["default"].createPortal( /*#__PURE__*/React__default["default"].createElement("div", {
            onBlur: focusTrap ? this.handleBlur : null
          }, /*#__PURE__*/React__default["default"].createElement("span", {
            ref: this.startSentinel,
            tabIndex: "0",
            role: "link",
            className: "".concat(prefix, "--visually-hidden")
          }, "Focus sentinel"), this._getChildrenWithProps(), /*#__PURE__*/React__default["default"].createElement("span", {
            ref: this.endSentinel,
            tabIndex: "0",
            role: "link",
            className: "".concat(prefix, "--visually-hidden")
          }, "Focus sentinel")), !target ? document.body : target());
        }

        return null;
      }
    }]);

    return FloatingMenu;
  }(React__default["default"].Component);

  _defineProperty$2(FloatingMenu, "contextType", PrefixContext);

  _defineProperty$2(FloatingMenu, "propTypes", {
    /**
     * Contents to put into the floating menu.
     */
    children: PropTypes__default["default"].object,

    /**
     * `true` if the menu alignment should be flipped.
     */
    flipped: PropTypes__default["default"].bool,

    /**
     * Enable or disable focus trap behavior
     */
    focusTrap: PropTypes__default["default"].bool,

    /**
     * Where to put the tooltip, relative to the trigger button.
     */
    menuDirection: PropTypes__default["default"].oneOf([DIRECTION_LEFT, DIRECTION_TOP, DIRECTION_RIGHT, DIRECTION_BOTTOM]),

    /**
     * The adjustment of the floating menu position, considering the position of dropdown arrow, etc.
     */
    menuOffset: PropTypes__default["default"].oneOfType([PropTypes__default["default"].shape({
      top: PropTypes__default["default"].number,
      left: PropTypes__default["default"].number
    }), PropTypes__default["default"].func]),

    /**
     * The callback called when the menu body has been mounted to/will be unmounted from the DOM.
     */
    menuRef: PropTypes__default["default"].func,

    /**
     * The callback called when the menu body has been mounted and positioned.
     */
    onPlace: PropTypes__default["default"].func,

    /**
     * Specify a CSS selector that matches the DOM element that should
     * be focused when the Modal opens
     */
    selectorPrimaryFocus: PropTypes__default["default"].string,

    /**
     * The additional styles to put to the floating menu.
     */
    styles: PropTypes__default["default"].object,

    /**
     * The query selector indicating where the floating menu body should be placed.
     */
    target: PropTypes__default["default"].func,

    /**
     * The element ref of the tooltip's trigger button.
     */
    triggerRef: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].shape({
      current: PropTypes__default["default"].any
    })]),

    /**
     * Optional function to change orientation of tooltip based on parent
     */
    updateOrientation: PropTypes__default["default"].func
  });

  _defineProperty$2(FloatingMenu, "defaultProps", {
    menuOffset: {},
    menuDirection: DIRECTION_BOTTOM,
    updateOrientation: null
  });

  var _excluded$1_ = ["id", "ariaLabel", "children", "iconDescription", "direction", "flipped", "focusTrap", "menuOffset", "menuOffsetFlip", "iconClass", "onClick", "onOpen", "selectorPrimaryFocus", "renderIcon", "innerRef", "menuOptionsClass", "light", "size"];

  var _triggerButtonPositio, _triggerButtonPositio2;
  var getInstanceId$f = setupGetInstanceId$2();

  var on = function on(element) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    element.addEventListener.apply(element, args);
    return {
      release: function release() {
        element.removeEventListener.apply(element, args);
        return null;
      }
    };
  };
  /**
   * The CSS property names of the arrow keyed by the floating menu direction.
   * @type {object<string, string>}
   */


  var triggerButtonPositionProps = (_triggerButtonPositio = {}, _defineProperty$2(_triggerButtonPositio, DIRECTION_TOP, 'bottom'), _defineProperty$2(_triggerButtonPositio, DIRECTION_BOTTOM, 'top'), _triggerButtonPositio);
  /**
   * Determines how the position of arrow should affect the floating menu position.
   * @type {object<string, number>}
   */

  var triggerButtonPositionFactors = (_triggerButtonPositio2 = {}, _defineProperty$2(_triggerButtonPositio2, DIRECTION_TOP, -2), _defineProperty$2(_triggerButtonPositio2, DIRECTION_BOTTOM, -1), _triggerButtonPositio2);
  /**
   * @param {Element} menuBody The menu body with the menu arrow.
   * @param {string} direction The floating menu direction.
   * @returns {FloatingMenu~offset} The adjustment of the floating menu position, upon the position of the menu arrow.
   * @private
   */

  var getMenuOffset$1 = function getMenuOffset(menuBody, direction, trigger, flip) {
    var triggerButtonPositionProp = triggerButtonPositionProps[direction];
    var triggerButtonPositionFactor = triggerButtonPositionFactors[direction];

    {
      !(triggerButtonPositionProp && triggerButtonPositionFactor) ? invariant_1(false, '[OverflowMenu] wrong floating menu direction: `%s`', direction)  : void 0;
    }

    var menuWidth = menuBody.offsetWidth,
        menuHeight = menuBody.offsetHeight;

    switch (triggerButtonPositionProp) {
      case 'top':
      case 'bottom':
        {
          // TODO: Ensure `trigger` is there for `<OverflowMenu open>`
          var triggerWidth = !trigger ? 0 : trigger.offsetWidth;
          return {
            left: (!flip ? 1 : -1) * (menuWidth / 2 - triggerWidth / 2),
            top: 0
          };
        }

      case 'left':
      case 'right':
        {
          // TODO: Ensure `trigger` is there for `<OverflowMenu open>`
          var triggerHeight = !trigger ? 0 : trigger.offsetHeight;
          return {
            left: 0,
            top: (!flip ? 1 : -1) * (menuHeight / 2 - triggerHeight / 2)
          };
        }
    }
  };

  var OverflowMenu$1 = /*#__PURE__*/function (_Component) {
    _inherits(OverflowMenu, _Component);

    var _super = _createSuper(OverflowMenu);

    function OverflowMenu() {
      var _this;

      _classCallCheck$1(this, OverflowMenu);

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty$2(_assertThisInitialized$1(_this), "state", {});

      _defineProperty$2(_assertThisInitialized$1(_this), "instanceId", getInstanceId$f());

      _defineProperty$2(_assertThisInitialized$1(_this), "_hFocusIn", null);

      _defineProperty$2(_assertThisInitialized$1(_this), "_hBlurTimeout", void 0);

      _defineProperty$2(_assertThisInitialized$1(_this), "_triggerRef", /*#__PURE__*/React__default["default"].createRef());

      _defineProperty$2(_assertThisInitialized$1(_this), "handleClick", function (evt) {
        evt.stopPropagation();

        if (!_this._menuBody || !_this._menuBody.contains(evt.target)) {
          _this.setState({
            open: !_this.state.open
          });

          _this.props.onClick(evt);
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleKeyDown", function (evt) {
        if (matches(evt, [ArrowDown])) {
          _this.setState({
            open: !_this.state.open
          });

          _this.props.onClick(evt);
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleKeyPress", function (evt) {
        if (_this.state.open && matches(evt, [ArrowUp, ArrowRight, ArrowDown, ArrowLeft])) {
          evt.preventDefault();
        } // Close the overflow menu on escape


        if (matches(evt, [Escape])) {
          var wasOpen = _this.state.open;

          _this.closeMenu(function () {
            if (wasOpen) {
              _this.focusMenuEl();
            }
          }); // Stop the esc keypress from bubbling out and closing something it shouldn't


          evt.stopPropagation();
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleClickOutside", function (evt) {
        if (_this.state.open && (!_this._menuBody || !_this._menuBody.contains(evt.target))) {
          _this.closeMenu();
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "closeMenu", function (onCloseMenu) {
        _this.setState({
          open: false
        }, function () {
          // Optional callback to be executed after the state as been set to close
          if (onCloseMenu) {
            onCloseMenu();
          }

          _this.props.onClose();
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "focusMenuEl", function () {
        var triggerEl = _this._triggerRef.current;

        if (triggerEl) {
          triggerEl.focus();
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOverflowMenuItemFocus", function (_ref) {
        var _overflowMenuItem$cur;

        var currentIndex = _ref.currentIndex,
            direction = _ref.direction;
        var enabledIndices = React__default["default"].Children.toArray(_this.props.children).reduce(function (acc, curr, i) {
          if (!curr.props.disabled) {
            acc.push(i);
          }

          return acc;
        }, []);

        var nextValidIndex = function () {
          var nextIndex = enabledIndices.indexOf(currentIndex) + direction;

          switch (enabledIndices.indexOf(currentIndex) + direction) {
            case -1:
              return enabledIndices.length - 1;

            case enabledIndices.length:
              return 0;

            default:
              return nextIndex;
          }
        }();

        var overflowMenuItem = _this["overflowMenuItem".concat(enabledIndices[nextValidIndex])].overflowMenuItem;

        overflowMenuItem === null || overflowMenuItem === void 0 ? void 0 : (_overflowMenuItem$cur = overflowMenuItem.current) === null || _overflowMenuItem$cur === void 0 ? void 0 : _overflowMenuItem$cur.focus();
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "_bindMenuBody", function (menuBody) {
        if (!menuBody) {
          _this._menuBody = menuBody;
        }

        if (!menuBody && _this._hFocusIn) {
          _this._hFocusIn = _this._hFocusIn.release();
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "_handlePlace", function (menuBody) {
        if (menuBody) {
          _this._menuBody = menuBody;
          var hasFocusin = ('onfocusin' in window);
          var focusinEventName = hasFocusin ? 'focusin' : 'focus';
          _this._hFocusIn = on(menuBody.ownerDocument, focusinEventName, function (event) {
            var target = ClickListener.getEventTarget(event);
            var triggerEl = _this._triggerRef.current;

            if (typeof target.matches === 'function') {
              if (!menuBody.contains(target) && triggerEl && !target.matches(".".concat(_this.context, "--overflow-menu,.").concat(_this.context, "--overflow-menu-options"))) {
                _this.closeMenu();
              }
            }
          }, !hasFocusin);

          _this.props.onOpen();
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "_getTarget", function () {
        var triggerEl = _this._triggerRef.current;
        return triggerEl && triggerEl.closest('[data-floating-menu-container]') || document.body;
      });

      return _this;
    }

    _createClass$1(OverflowMenu, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate(_, prevState) {
        var onClose = this.props.onClose;

        if (!this.state.open && prevState.open) {
          onClose();
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (typeof this._hBlurTimeout === 'number') {
          clearTimeout(this._hBlurTimeout);
          this._hBlurTimeout = undefined;
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _classNames,
            _classNames2,
            _this2 = this;

        var prefix = this.context;

        var _this$props = this.props,
            id = _this$props.id,
            ariaLabel = _this$props.ariaLabel,
            children = _this$props.children,
            iconDescription = _this$props.iconDescription,
            direction = _this$props.direction,
            flipped = _this$props.flipped,
            focusTrap = _this$props.focusTrap,
            menuOffset = _this$props.menuOffset,
            menuOffsetFlip = _this$props.menuOffsetFlip,
            iconClass = _this$props.iconClass;
            _this$props.onClick;
            _this$props.onOpen;
            _this$props.selectorPrimaryFocus;
            var IconElement = _this$props.renderIcon,
            ref = _this$props.innerRef,
            menuOptionsClass = _this$props.menuOptionsClass,
            light = _this$props.light,
            _this$props$size = _this$props.size,
            size = _this$props$size === void 0 ? 'md' : _this$props$size,
            other = _objectWithoutProperties$2(_this$props, _excluded$1_);

        var open = this.state.open;
        var overflowMenuClasses = cx(this.props.className, "".concat(prefix, "--overflow-menu"), (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--overflow-menu--open"), open), _defineProperty$2(_classNames, "".concat(prefix, "--overflow-menu--light"), light), _defineProperty$2(_classNames, "".concat(prefix, "--overflow-menu--").concat(size), size), _classNames));
        var overflowMenuOptionsClasses = cx(menuOptionsClass, "".concat(prefix, "--overflow-menu-options"), (_classNames2 = {}, _defineProperty$2(_classNames2, "".concat(prefix, "--overflow-menu--flip"), this.props.flipped), _defineProperty$2(_classNames2, "".concat(prefix, "--overflow-menu-options--open"), open), _defineProperty$2(_classNames2, "".concat(prefix, "--overflow-menu-options--light"), light), _defineProperty$2(_classNames2, "".concat(prefix, "--overflow-menu-options--").concat(size), size), _classNames2));
        var overflowMenuIconClasses = cx("".concat(prefix, "--overflow-menu__icon"), iconClass);
        var childrenWithProps = React__default["default"].Children.toArray(children).map(function (child, index) {
          var _child$props;

          return /*#__PURE__*/React__default["default"].cloneElement(child, {
            closeMenu: (child === null || child === void 0 ? void 0 : (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.closeMenu) || _this2.closeMenu,
            handleOverflowMenuItemFocus: _this2.handleOverflowMenuItemFocus,
            ref: function ref(e) {
              _this2["overflowMenuItem".concat(index)] = e;
            },
            index: index
          });
        });
        var menuBodyId = "overflow-menu-".concat(this.instanceId, "__menu-body");
        var menuBody = /*#__PURE__*/React__default["default"].createElement("ul", {
          className: overflowMenuOptionsClasses,
          tabIndex: "-1",
          role: "menu",
          "aria-label": ariaLabel,
          id: menuBodyId
        }, childrenWithProps);
        var wrappedMenuBody = /*#__PURE__*/React__default["default"].createElement(FloatingMenu, {
          focusTrap: focusTrap,
          triggerRef: this._triggerRef,
          menuDirection: direction,
          menuOffset: flipped ? menuOffsetFlip : menuOffset,
          menuRef: this._bindMenuBody,
          flipped: this.props.flipped,
          target: this._getTarget,
          onPlace: this._handlePlace,
          selectorPrimaryFocus: this.props.selectorPrimaryFocus
        }, /*#__PURE__*/React__default["default"].cloneElement(menuBody, {
          'data-floating-menu-direction': direction
        }));
        var iconProps = {
          className: overflowMenuIconClasses,
          'aria-label': iconDescription
        };
        return /*#__PURE__*/React__default["default"].createElement(ClickListener, {
          onClickOutside: this.handleClickOutside
        }, /*#__PURE__*/React__default["default"].createElement("button", _extends$3({}, other, {
          type: "button",
          "aria-haspopup": true,
          "aria-expanded": this.state.open,
          className: overflowMenuClasses,
          onKeyDown: this.handleKeyPress,
          onClick: this.handleClick,
          "aria-label": ariaLabel,
          id: id,
          ref: mergeRefs$1(this._triggerRef, ref),
          "aria-controls": this.state.open ? menuBodyId : null
        }), /*#__PURE__*/React__default["default"].createElement(IconElement, iconProps, iconDescription && /*#__PURE__*/React__default["default"].createElement("title", null, iconDescription)), open && wrappedMenuBody));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref2, state) {
        var open = _ref2.open;
        var prevOpen = state.prevOpen;
        return prevOpen === open ? null : {
          open: open,
          prevOpen: open
        };
      }
    }]);

    return OverflowMenu;
  }(React.Component);

  _defineProperty$2(OverflowMenu$1, "propTypes", {
    /**
     * The ARIA label.
     */
    ariaLabel: enabled('enable-v11-release') ? PropTypes__default["default"].string.isRequired : PropTypes__default["default"].string,

    /**
     * The child nodes.
     */
    children: PropTypes__default["default"].node,

    /**
     * The CSS class names.
     */
    className: PropTypes__default["default"].string,

    /**
     * The menu direction.
     */
    direction: PropTypes__default["default"].oneOf([DIRECTION_TOP, DIRECTION_BOTTOM]),

    /**
     * `true` if the menu alignment should be flipped.
     */
    flipped: PropTypes__default["default"].bool,

    /**
     * Enable or disable focus trap behavior
     */
    focusTrap: PropTypes__default["default"].bool,

    /**
     * The CSS class for the icon.
     */
    iconClass: PropTypes__default["default"].string,

    /**
     * The icon description.
     */
    iconDescription: PropTypes__default["default"].string.isRequired,

    /**
     * The element ID.
     */
    id: PropTypes__default["default"].string,

    /**
     * `true` to use the light version. For use on $ui-01 backgrounds only.
     * Don't use this to make OverflowMenu background color same as container background color.
     */
    light: enabled('enable-v11-release') ? deprecate(PropTypes__default["default"].bool, 'The `light` prop for `OverflowMenu` is no longer needed and has been deprecated. It will be removed in the next major release. Use the Layer component instead.') : PropTypes__default["default"].bool,

    /**
     * The adjustment in position applied to the floating menu.
     */
    menuOffset: PropTypes__default["default"].oneOfType([PropTypes__default["default"].shape({
      top: PropTypes__default["default"].number,
      left: PropTypes__default["default"].number
    }), PropTypes__default["default"].func]),

    /**
     * The adjustment in position applied to the floating menu.
     */
    menuOffsetFlip: PropTypes__default["default"].oneOfType([PropTypes__default["default"].shape({
      top: PropTypes__default["default"].number,
      left: PropTypes__default["default"].number
    }), PropTypes__default["default"].func]),

    /**
     * The class to apply to the menu options
     */
    menuOptionsClass: PropTypes__default["default"].string,

    /**
     * The event handler for the `click` event.
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Function called when menu is closed
     */
    onClose: PropTypes__default["default"].func,

    /**
     * The event handler for the `focus` event.
     */
    onFocus: PropTypes__default["default"].func,

    /**
     * The event handler for the `keydown` event.
     */
    onKeyDown: PropTypes__default["default"].func,

    /**
     * Function called when menu is opened
     */
    onOpen: PropTypes__default["default"].func,

    /**
     * `true` if the menu should be open.
     */
    open: PropTypes__default["default"].bool,

    /**
     * Function called to override icon rendering.
     */
    renderIcon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),

    /**
     * Specify a CSS selector that matches the DOM element that should
     * be focused when the OverflowMenu opens
     */
    selectorPrimaryFocus: PropTypes__default["default"].string,

    /**
     * Specify the size of the OverflowMenu. Currently supports either `sm`, 'md' (default) or 'lg` as an option.
     */
    size: enabled('enable-v11-release') ? PropTypes__default["default"].oneOf(['sm', 'md', 'lg']) : PropTypes__default["default"].oneOf(['sm', 'md', 'lg', 'xl'])
  });

  _defineProperty$2(OverflowMenu$1, "contextType", PrefixContext);

  _defineProperty$2(OverflowMenu$1, "defaultProps", {
    ariaLabel: enabled('enable-v11-release') ? null : 'Open and close list of options',
    iconDescription: 'Open and close list of options',
    open: false,
    direction: DIRECTION_BOTTOM,
    flipped: false,
    focusTrap: true,
    renderIcon: OverflowMenuVertical16,
    onClick: function onClick() {},
    onKeyDown: function onKeyDown() {},
    onClose: function onClose() {},
    onOpen: function onOpen() {},
    menuOffset: getMenuOffset$1,
    menuOffsetFlip: getMenuOffset$1,
    light: false,
    selectorPrimaryFocus: '[data-overflow-menu-primary-focus]'
  });

  /**
   * Wrap a class component with a functional component. This prevents an end-user
   * from being able to pass `ref` and access the underlying class instance.
   *
   * @param {ReactNode} Component
   * @returns {ReactNode}
   */

  function createClassWrapper(Component) {
    function ClassWrapper(props) {
      return /*#__PURE__*/React__default["default"].createElement(Component, props);
    }

    {
      var name = Component.displayName || Component.name;
      ClassWrapper.displayName = "ClassWrapper(".concat(name, ")");
    }

    return ClassWrapper;
  }

  var OverflowMenu = enabled('enable-v11-release') ? createClassWrapper(OverflowMenu$1) : OverflowMenu$1;

  var _excluded$1Z = ["className", "renderIcon", "iconDescription", "children"];

  var TableToolbarMenu = function TableToolbarMenu(_ref) {
    var className = _ref.className,
        renderIcon = _ref.renderIcon,
        iconDescription = _ref.iconDescription,
        children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, _excluded$1Z);

    var prefix = usePrefix();
    var toolbarActionClasses = cx(className, "".concat(prefix, "--toolbar-action ").concat(prefix, "--overflow-menu"));
    return /*#__PURE__*/React__default["default"].createElement(OverflowMenu, _extends$3({
      ariaLabel: iconDescription,
      renderIcon: renderIcon,
      className: toolbarActionClasses,
      title: iconDescription,
      iconDescription: iconDescription,
      flipped: true
    }, rest), children);
  };

  TableToolbarMenu.defaultProps = {
    renderIcon: Settings16,
    iconDescription: 'Settings'
  };
  TableToolbarMenu.propTypes = {
    children: PropTypes__default["default"].node.isRequired,

    /**
     * Provide an optional class name for the toolbar menu
     */
    className: PropTypes__default["default"].string,

    /**
     * The description of the menu icon.
     */
    iconDescription: PropTypes__default["default"].string.isRequired,

    /**
     * Optional prop to allow overriding the default menu icon
     */
    renderIcon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object])
  };
  var TableToolbarMenu$1 = TableToolbarMenu;

  DataTable$1.Table = Table$1;
  DataTable$1.TableActionList = TableActionList$1;
  DataTable$1.TableBatchAction = TableBatchAction$1;
  DataTable$1.TableBatchActions = TableBatchActions$1;
  DataTable$1.TableBody = TableBody$1;
  DataTable$1.TableCell = TableCell$1;
  DataTable$1.TableContainer = TableContainer$1;
  DataTable$1.TableExpandHeader = TableExpandHeader$1;
  DataTable$1.TableExpandRow = TableExpandRow$1;
  DataTable$1.TableExpandedRow = TableExpandedRow$1;
  DataTable$1.TableHead = TableHead$1;
  DataTable$1.TableHeader = TableHeader$1;
  DataTable$1.TableRow = TableRow$1;
  DataTable$1.TableSelectAll = TableSelectAll$1;
  DataTable$1.TableSelectRow = TableSelectRow$1;
  DataTable$1.TableToolbar = TableToolbar$1;
  DataTable$1.TableToolbarAction = TableToolbarAction$1;
  DataTable$1.TableToolbarContent = TableToolbarContent$1;
  DataTable$1.TableToolbarSearch = TableToolbarSearch$1;
  DataTable$1.TableToolbarMenu = TableToolbarMenu$1;
  var DataTable = DataTable$1;

  const HOOKS = [
      "onChange",
      "onClose",
      "onDayCreate",
      "onDestroy",
      "onKeyDown",
      "onMonthChange",
      "onOpen",
      "onParseConfig",
      "onReady",
      "onValueUpdate",
      "onYearChange",
      "onPreCalendarPosition",
  ];
  const defaults = {
      _disable: [],
      allowInput: false,
      allowInvalidPreload: false,
      altFormat: "F j, Y",
      altInput: false,
      altInputClass: "form-control input",
      animate: typeof window === "object" &&
          window.navigator.userAgent.indexOf("MSIE") === -1,
      ariaDateFormat: "F j, Y",
      autoFillDefaultTime: true,
      clickOpens: true,
      closeOnSelect: true,
      conjunction: ", ",
      dateFormat: "Y-m-d",
      defaultHour: 12,
      defaultMinute: 0,
      defaultSeconds: 0,
      disable: [],
      disableMobile: false,
      enableSeconds: false,
      enableTime: false,
      errorHandler: (err) => typeof console !== "undefined" && console.warn(err),
      getWeek: (givenDate) => {
          const date = new Date(givenDate.getTime());
          date.setHours(0, 0, 0, 0);
          date.setDate(date.getDate() + 3 - ((date.getDay() + 6) % 7));
          var week1 = new Date(date.getFullYear(), 0, 4);
          return (1 +
              Math.round(((date.getTime() - week1.getTime()) / 86400000 -
                  3 +
                  ((week1.getDay() + 6) % 7)) /
                  7));
      },
      hourIncrement: 1,
      ignoredFocusElements: [],
      inline: false,
      locale: "default",
      minuteIncrement: 5,
      mode: "single",
      monthSelectorType: "dropdown",
      nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
      noCalendar: false,
      now: new Date(),
      onChange: [],
      onClose: [],
      onDayCreate: [],
      onDestroy: [],
      onKeyDown: [],
      onMonthChange: [],
      onOpen: [],
      onParseConfig: [],
      onReady: [],
      onValueUpdate: [],
      onYearChange: [],
      onPreCalendarPosition: [],
      plugins: [],
      position: "auto",
      positionElement: undefined,
      prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
      shorthandCurrentMonth: false,
      showMonths: 1,
      static: false,
      time_24hr: false,
      weekNumbers: false,
      wrap: false,
  };

  const english = {
      weekdays: {
          shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          longhand: [
              "Sunday",
              "Monday",
              "Tuesday",
              "Wednesday",
              "Thursday",
              "Friday",
              "Saturday",
          ],
      },
      months: {
          shorthand: [
              "Jan",
              "Feb",
              "Mar",
              "Apr",
              "May",
              "Jun",
              "Jul",
              "Aug",
              "Sep",
              "Oct",
              "Nov",
              "Dec",
          ],
          longhand: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December",
          ],
      },
      daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
      firstDayOfWeek: 0,
      ordinal: (nth) => {
          const s = nth % 100;
          if (s > 3 && s < 21)
              return "th";
          switch (s % 10) {
              case 1:
                  return "st";
              case 2:
                  return "nd";
              case 3:
                  return "rd";
              default:
                  return "th";
          }
      },
      rangeSeparator: " to ",
      weekAbbreviation: "Wk",
      scrollTitle: "Scroll to increment",
      toggleTitle: "Click to toggle",
      amPM: ["AM", "PM"],
      yearAriaLabel: "Year",
      monthAriaLabel: "Month",
      hourAriaLabel: "Hour",
      minuteAriaLabel: "Minute",
      time_24hr: false,
  };

  const pad = (number, length = 2) => `000${number}`.slice(length * -1);
  const int = (bool) => (bool === true ? 1 : 0);
  function debounce$1(fn, wait) {
      let t;
      return function () {
          clearTimeout(t);
          t = setTimeout(() => fn.apply(this, arguments), wait);
      };
  }
  const arrayify = (obj) => obj instanceof Array ? obj : [obj];

  function toggleClass(elem, className, bool) {
      if (bool === true)
          return elem.classList.add(className);
      elem.classList.remove(className);
  }
  function createElement(tag, className, content) {
      const e = window.document.createElement(tag);
      className = className || "";
      content = content || "";
      e.className = className;
      if (content !== undefined)
          e.textContent = content;
      return e;
  }
  function clearNode(node) {
      while (node.firstChild)
          node.removeChild(node.firstChild);
  }
  function findParent(node, condition) {
      if (condition(node))
          return node;
      else if (node.parentNode)
          return findParent(node.parentNode, condition);
      return undefined;
  }
  function createNumberInput(inputClassName, opts) {
      const wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
      if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
          numInput.type = "number";
      }
      else {
          numInput.type = "text";
          numInput.pattern = "\\d*";
      }
      if (opts !== undefined)
          for (const key in opts)
              numInput.setAttribute(key, opts[key]);
      wrapper.appendChild(numInput);
      wrapper.appendChild(arrowUp);
      wrapper.appendChild(arrowDown);
      return wrapper;
  }
  function getEventTarget(event) {
      try {
          if (typeof event.composedPath === "function") {
              const path = event.composedPath();
              return path[0];
          }
          return event.target;
      }
      catch (error) {
          return event.target;
      }
  }

  const doNothing = () => undefined;
  const monthToStr$2 = (monthNumber, shorthand, locale) => locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
  const revFormat = {
      D: doNothing,
      F: function (dateObj, monthName, locale) {
          dateObj.setMonth(locale.months.longhand.indexOf(monthName));
      },
      G: (dateObj, hour) => {
          dateObj.setHours(parseFloat(hour));
      },
      H: (dateObj, hour) => {
          dateObj.setHours(parseFloat(hour));
      },
      J: (dateObj, day) => {
          dateObj.setDate(parseFloat(day));
      },
      K: (dateObj, amPM, locale) => {
          dateObj.setHours((dateObj.getHours() % 12) +
              12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
      },
      M: function (dateObj, shortMonth, locale) {
          dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
      },
      S: (dateObj, seconds) => {
          dateObj.setSeconds(parseFloat(seconds));
      },
      U: (_, unixSeconds) => new Date(parseFloat(unixSeconds) * 1000),
      W: function (dateObj, weekNum, locale) {
          const weekNumber = parseInt(weekNum);
          const date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
          date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
          return date;
      },
      Y: (dateObj, year) => {
          dateObj.setFullYear(parseFloat(year));
      },
      Z: (_, ISODate) => new Date(ISODate),
      d: (dateObj, day) => {
          dateObj.setDate(parseFloat(day));
      },
      h: (dateObj, hour) => {
          dateObj.setHours(parseFloat(hour));
      },
      i: (dateObj, minutes) => {
          dateObj.setMinutes(parseFloat(minutes));
      },
      j: (dateObj, day) => {
          dateObj.setDate(parseFloat(day));
      },
      l: doNothing,
      m: (dateObj, month) => {
          dateObj.setMonth(parseFloat(month) - 1);
      },
      n: (dateObj, month) => {
          dateObj.setMonth(parseFloat(month) - 1);
      },
      s: (dateObj, seconds) => {
          dateObj.setSeconds(parseFloat(seconds));
      },
      u: (_, unixMillSeconds) => new Date(parseFloat(unixMillSeconds)),
      w: doNothing,
      y: (dateObj, year) => {
          dateObj.setFullYear(2000 + parseFloat(year));
      },
  };
  const tokenRegex = {
      D: "(\\w+)",
      F: "(\\w+)",
      G: "(\\d\\d|\\d)",
      H: "(\\d\\d|\\d)",
      J: "(\\d\\d|\\d)\\w+",
      K: "",
      M: "(\\w+)",
      S: "(\\d\\d|\\d)",
      U: "(.+)",
      W: "(\\d\\d|\\d)",
      Y: "(\\d{4})",
      Z: "(.+)",
      d: "(\\d\\d|\\d)",
      h: "(\\d\\d|\\d)",
      i: "(\\d\\d|\\d)",
      j: "(\\d\\d|\\d)",
      l: "(\\w+)",
      m: "(\\d\\d|\\d)",
      n: "(\\d\\d|\\d)",
      s: "(\\d\\d|\\d)",
      u: "(.+)",
      w: "(\\d\\d|\\d)",
      y: "(\\d{2})",
  };
  const formats = {
      Z: (date) => date.toISOString(),
      D: function (date, locale, options) {
          return locale.weekdays.shorthand[formats.w(date, locale, options)];
      },
      F: function (date, locale, options) {
          return monthToStr$2(formats.n(date, locale, options) - 1, false, locale);
      },
      G: function (date, locale, options) {
          return pad(formats.h(date, locale, options));
      },
      H: (date) => pad(date.getHours()),
      J: function (date, locale) {
          return locale.ordinal !== undefined
              ? date.getDate() + locale.ordinal(date.getDate())
              : date.getDate();
      },
      K: (date, locale) => locale.amPM[int(date.getHours() > 11)],
      M: function (date, locale) {
          return monthToStr$2(date.getMonth(), true, locale);
      },
      S: (date) => pad(date.getSeconds()),
      U: (date) => date.getTime() / 1000,
      W: function (date, _, options) {
          return options.getWeek(date);
      },
      Y: (date) => pad(date.getFullYear(), 4),
      d: (date) => pad(date.getDate()),
      h: (date) => (date.getHours() % 12 ? date.getHours() % 12 : 12),
      i: (date) => pad(date.getMinutes()),
      j: (date) => date.getDate(),
      l: function (date, locale) {
          return locale.weekdays.longhand[date.getDay()];
      },
      m: (date) => pad(date.getMonth() + 1),
      n: (date) => date.getMonth() + 1,
      s: (date) => date.getSeconds(),
      u: (date) => date.getTime(),
      w: (date) => date.getDay(),
      y: (date) => String(date.getFullYear()).substring(2),
  };

  const createDateFormatter = ({ config = defaults, l10n = english, isMobile = false, }) => (dateObj, frmt, overrideLocale) => {
      const locale = overrideLocale || l10n;
      if (config.formatDate !== undefined && !isMobile) {
          return config.formatDate(dateObj, frmt, locale);
      }
      return frmt
          .split("")
          .map((c, i, arr) => formats[c] && arr[i - 1] !== "\\"
          ? formats[c](dateObj, locale, config)
          : c !== "\\"
              ? c
              : "")
          .join("");
  };
  const createDateParser = ({ config = defaults, l10n = english }) => (date, givenFormat, timeless, customLocale) => {
      if (date !== 0 && !date)
          return undefined;
      const locale = customLocale || l10n;
      let parsedDate;
      const dateOrig = date;
      if (date instanceof Date)
          parsedDate = new Date(date.getTime());
      else if (typeof date !== "string" &&
          date.toFixed !== undefined)
          parsedDate = new Date(date);
      else if (typeof date === "string") {
          const format = givenFormat || (config || defaults).dateFormat;
          const datestr = String(date).trim();
          if (datestr === "today") {
              parsedDate = new Date();
              timeless = true;
          }
          else if (/Z$/.test(datestr) ||
              /GMT$/.test(datestr))
              parsedDate = new Date(date);
          else if (config && config.parseDate)
              parsedDate = config.parseDate(date, format);
          else {
              parsedDate =
                  !config || !config.noCalendar
                      ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0)
                      : new Date(new Date().setHours(0, 0, 0, 0));
              let matched, ops = [];
              for (let i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
                  const token = format[i];
                  const isBackSlash = token === "\\";
                  const escaped = format[i - 1] === "\\" || isBackSlash;
                  if (tokenRegex[token] && !escaped) {
                      regexStr += tokenRegex[token];
                      const match = new RegExp(regexStr).exec(date);
                      if (match && (matched = true)) {
                          ops[token !== "Y" ? "push" : "unshift"]({
                              fn: revFormat[token],
                              val: match[++matchIndex],
                          });
                      }
                  }
                  else if (!isBackSlash)
                      regexStr += ".";
                  ops.forEach(({ fn, val }) => (parsedDate = fn(parsedDate, val, locale) || parsedDate));
              }
              parsedDate = matched ? parsedDate : undefined;
          }
      }
      if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
          config.errorHandler(new Error(`Invalid date provided: ${dateOrig}`));
          return undefined;
      }
      if (timeless === true)
          parsedDate.setHours(0, 0, 0, 0);
      return parsedDate;
  };
  function compareDates(date1, date2, timeless = true) {
      if (timeless !== false) {
          return (new Date(date1.getTime()).setHours(0, 0, 0, 0) -
              new Date(date2.getTime()).setHours(0, 0, 0, 0));
      }
      return date1.getTime() - date2.getTime();
  }
  const isBetween = (ts, ts1, ts2) => {
      return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
  };
  const duration = {
      DAY: 86400000,
  };
  function getDefaultHours(config) {
      let hours = config.defaultHour;
      let minutes = config.defaultMinute;
      let seconds = config.defaultSeconds;
      if (config.minDate !== undefined) {
          const minHour = config.minDate.getHours();
          const minMinutes = config.minDate.getMinutes();
          const minSeconds = config.minDate.getSeconds();
          if (hours < minHour) {
              hours = minHour;
          }
          if (hours === minHour && minutes < minMinutes) {
              minutes = minMinutes;
          }
          if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
              seconds = config.minDate.getSeconds();
      }
      if (config.maxDate !== undefined) {
          const maxHr = config.maxDate.getHours();
          const maxMinutes = config.maxDate.getMinutes();
          hours = Math.min(hours, maxHr);
          if (hours === maxHr)
              minutes = Math.min(maxMinutes, minutes);
          if (hours === maxHr && minutes === maxMinutes)
              seconds = config.maxDate.getSeconds();
      }
      return { hours, minutes, seconds };
  }

  if (typeof Object.assign !== "function") {
      Object.assign = function (target, ...args) {
          if (!target) {
              throw TypeError("Cannot convert undefined or null to object");
          }
          for (const source of args) {
              if (source) {
                  Object.keys(source).forEach((key) => (target[key] = source[key]));
              }
          }
          return target;
      };
  }

  const DEBOUNCED_CHANGE_MS = 300;
  function FlatpickrInstance(element, instanceConfig) {
      const self = {
          config: Object.assign(Object.assign({}, defaults), flatpickr.defaultConfig),
          l10n: english,
      };
      self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
      self._handlers = [];
      self.pluginElements = [];
      self.loadedPlugins = [];
      self._bind = bind;
      self._setHoursFromDate = setHoursFromDate;
      self._positionCalendar = positionCalendar;
      self.changeMonth = changeMonth;
      self.changeYear = changeYear;
      self.clear = clear;
      self.close = close;
      self._createElement = createElement;
      self.destroy = destroy;
      self.isEnabled = isEnabled;
      self.jumpToDate = jumpToDate;
      self.open = open;
      self.redraw = redraw;
      self.set = set;
      self.setDate = setDate;
      self.toggle = toggle;
      function setupHelperFunctions() {
          self.utils = {
              getDaysInMonth(month = self.currentMonth, yr = self.currentYear) {
                  if (month === 1 && ((yr % 4 === 0 && yr % 100 !== 0) || yr % 400 === 0))
                      return 29;
                  return self.l10n.daysInMonth[month];
              },
          };
      }
      function init() {
          self.element = self.input = element;
          self.isOpen = false;
          parseConfig();
          setupLocale();
          setupInputs();
          setupDates();
          setupHelperFunctions();
          if (!self.isMobile)
              build();
          bindEvents();
          if (self.selectedDates.length || self.config.noCalendar) {
              if (self.config.enableTime) {
                  setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj : undefined);
              }
              updateValue(false);
          }
          setCalendarWidth();
          const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
          if (!self.isMobile && isSafari) {
              positionCalendar();
          }
          triggerEvent("onReady");
      }
      function bindToInstance(fn) {
          return fn.bind(self);
      }
      function setCalendarWidth() {
          const config = self.config;
          if (config.weekNumbers === false && config.showMonths === 1) {
              return;
          }
          else if (config.noCalendar !== true) {
              window.requestAnimationFrame(function () {
                  if (self.calendarContainer !== undefined) {
                      self.calendarContainer.style.visibility = "hidden";
                      self.calendarContainer.style.display = "block";
                  }
                  if (self.daysContainer !== undefined) {
                      const daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
                      self.daysContainer.style.width = daysWidth + "px";
                      self.calendarContainer.style.width =
                          daysWidth +
                              (self.weekWrapper !== undefined
                                  ? self.weekWrapper.offsetWidth
                                  : 0) +
                              "px";
                      self.calendarContainer.style.removeProperty("visibility");
                      self.calendarContainer.style.removeProperty("display");
                  }
              });
          }
      }
      function updateTime(e) {
          if (self.selectedDates.length === 0) {
              const defaultDate = self.config.minDate === undefined ||
                  compareDates(new Date(), self.config.minDate) >= 0
                  ? new Date()
                  : new Date(self.config.minDate.getTime());
              const defaults = getDefaultHours(self.config);
              defaultDate.setHours(defaults.hours, defaults.minutes, defaults.seconds, defaultDate.getMilliseconds());
              self.selectedDates = [defaultDate];
              self.latestSelectedDateObj = defaultDate;
          }
          if (e !== undefined && e.type !== "blur") {
              timeWrapper(e);
          }
          const prevValue = self._input.value;
          setHoursFromInputs();
          updateValue();
          if (self._input.value !== prevValue) {
              self._debouncedChange();
          }
      }
      function ampm2military(hour, amPM) {
          return (hour % 12) + 12 * int(amPM === self.l10n.amPM[1]);
      }
      function military2ampm(hour) {
          switch (hour % 24) {
              case 0:
              case 12:
                  return 12;
              default:
                  return hour % 12;
          }
      }
      function setHoursFromInputs() {
          if (self.hourElement === undefined || self.minuteElement === undefined)
              return;
          let hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60, seconds = self.secondElement !== undefined
              ? (parseInt(self.secondElement.value, 10) || 0) % 60
              : 0;
          if (self.amPM !== undefined) {
              hours = ampm2military(hours, self.amPM.textContent);
          }
          const limitMinHours = self.config.minTime !== undefined ||
              (self.config.minDate &&
                  self.minDateHasTime &&
                  self.latestSelectedDateObj &&
                  compareDates(self.latestSelectedDateObj, self.config.minDate, true) ===
                      0);
          const limitMaxHours = self.config.maxTime !== undefined ||
              (self.config.maxDate &&
                  self.maxDateHasTime &&
                  self.latestSelectedDateObj &&
                  compareDates(self.latestSelectedDateObj, self.config.maxDate, true) ===
                      0);
          if (limitMaxHours) {
              const maxTime = self.config.maxTime !== undefined
                  ? self.config.maxTime
                  : self.config.maxDate;
              hours = Math.min(hours, maxTime.getHours());
              if (hours === maxTime.getHours())
                  minutes = Math.min(minutes, maxTime.getMinutes());
              if (minutes === maxTime.getMinutes())
                  seconds = Math.min(seconds, maxTime.getSeconds());
          }
          if (limitMinHours) {
              const minTime = self.config.minTime !== undefined
                  ? self.config.minTime
                  : self.config.minDate;
              hours = Math.max(hours, minTime.getHours());
              if (hours === minTime.getHours() && minutes < minTime.getMinutes())
                  minutes = minTime.getMinutes();
              if (minutes === minTime.getMinutes())
                  seconds = Math.max(seconds, minTime.getSeconds());
          }
          setHours(hours, minutes, seconds);
      }
      function setHoursFromDate(dateObj) {
          const date = dateObj || self.latestSelectedDateObj;
          if (date) {
              setHours(date.getHours(), date.getMinutes(), date.getSeconds());
          }
      }
      function setHours(hours, minutes, seconds) {
          if (self.latestSelectedDateObj !== undefined) {
              self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
          }
          if (!self.hourElement || !self.minuteElement || self.isMobile)
              return;
          self.hourElement.value = pad(!self.config.time_24hr
              ? ((12 + hours) % 12) + 12 * int(hours % 12 === 0)
              : hours);
          self.minuteElement.value = pad(minutes);
          if (self.amPM !== undefined)
              self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];
          if (self.secondElement !== undefined)
              self.secondElement.value = pad(seconds);
      }
      function onYearInput(event) {
          const eventTarget = getEventTarget(event);
          const year = parseInt(eventTarget.value) + (event.delta || 0);
          if (year / 1000 > 1 ||
              (event.key === "Enter" && !/[^\d]/.test(year.toString()))) {
              changeYear(year);
          }
      }
      function bind(element, event, handler, options) {
          if (event instanceof Array)
              return event.forEach((ev) => bind(element, ev, handler, options));
          if (element instanceof Array)
              return element.forEach((el) => bind(el, event, handler, options));
          element.addEventListener(event, handler, options);
          self._handlers.push({
              remove: () => element.removeEventListener(event, handler),
          });
      }
      function triggerChange() {
          triggerEvent("onChange");
      }
      function bindEvents() {
          if (self.config.wrap) {
              ["open", "close", "toggle", "clear"].forEach((evt) => {
                  Array.prototype.forEach.call(self.element.querySelectorAll(`[data-${evt}]`), (el) => bind(el, "click", self[evt]));
              });
          }
          if (self.isMobile) {
              setupMobile();
              return;
          }
          const debouncedResize = debounce$1(onResize, 50);
          self._debouncedChange = debounce$1(triggerChange, DEBOUNCED_CHANGE_MS);
          if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
              bind(self.daysContainer, "mouseover", (e) => {
                  if (self.config.mode === "range")
                      onMouseOver(getEventTarget(e));
              });
          bind(window.document.body, "keydown", onKeyDown);
          if (!self.config.inline && !self.config.static)
              bind(window, "resize", debouncedResize);
          if (window.ontouchstart !== undefined)
              bind(window.document, "touchstart", documentClick);
          else
              bind(window.document, "mousedown", documentClick);
          bind(window.document, "focus", documentClick, { capture: true });
          if (self.config.clickOpens === true) {
              bind(self._input, "focus", self.open);
              bind(self._input, "click", self.open);
          }
          if (self.daysContainer !== undefined) {
              bind(self.monthNav, "click", onMonthNavClick);
              bind(self.monthNav, ["keyup", "increment"], onYearInput);
              bind(self.daysContainer, "click", selectDate);
          }
          if (self.timeContainer !== undefined &&
              self.minuteElement !== undefined &&
              self.hourElement !== undefined) {
              const selText = (e) => getEventTarget(e).select();
              bind(self.timeContainer, ["increment"], updateTime);
              bind(self.timeContainer, "blur", updateTime, { capture: true });
              bind(self.timeContainer, "click", timeIncrement);
              bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);
              if (self.secondElement !== undefined)
                  bind(self.secondElement, "focus", () => self.secondElement && self.secondElement.select());
              if (self.amPM !== undefined) {
                  bind(self.amPM, "click", (e) => {
                      updateTime(e);
                      triggerChange();
                  });
              }
          }
          if (self.config.allowInput) {
              bind(self._input, "blur", onBlur);
          }
      }
      function jumpToDate(jumpDate, triggerChange) {
          const jumpTo = jumpDate !== undefined
              ? self.parseDate(jumpDate)
              : self.latestSelectedDateObj ||
                  (self.config.minDate && self.config.minDate > self.now
                      ? self.config.minDate
                      : self.config.maxDate && self.config.maxDate < self.now
                          ? self.config.maxDate
                          : self.now);
          const oldYear = self.currentYear;
          const oldMonth = self.currentMonth;
          try {
              if (jumpTo !== undefined) {
                  self.currentYear = jumpTo.getFullYear();
                  self.currentMonth = jumpTo.getMonth();
              }
          }
          catch (e) {
              e.message = "Invalid date supplied: " + jumpTo;
              self.config.errorHandler(e);
          }
          if (triggerChange && self.currentYear !== oldYear) {
              triggerEvent("onYearChange");
              buildMonthSwitch();
          }
          if (triggerChange &&
              (self.currentYear !== oldYear || self.currentMonth !== oldMonth)) {
              triggerEvent("onMonthChange");
          }
          self.redraw();
      }
      function timeIncrement(e) {
          const eventTarget = getEventTarget(e);
          if (~eventTarget.className.indexOf("arrow"))
              incrementNumInput(e, eventTarget.classList.contains("arrowUp") ? 1 : -1);
      }
      function incrementNumInput(e, delta, inputElem) {
          const target = e && getEventTarget(e);
          const input = inputElem ||
              (target && target.parentNode && target.parentNode.firstChild);
          const event = createEvent("increment");
          event.delta = delta;
          input && input.dispatchEvent(event);
      }
      function build() {
          const fragment = window.document.createDocumentFragment();
          self.calendarContainer = createElement("div", "flatpickr-calendar");
          self.calendarContainer.tabIndex = -1;
          if (!self.config.noCalendar) {
              fragment.appendChild(buildMonthNav());
              self.innerContainer = createElement("div", "flatpickr-innerContainer");
              if (self.config.weekNumbers) {
                  const { weekWrapper, weekNumbers } = buildWeeks();
                  self.innerContainer.appendChild(weekWrapper);
                  self.weekNumbers = weekNumbers;
                  self.weekWrapper = weekWrapper;
              }
              self.rContainer = createElement("div", "flatpickr-rContainer");
              self.rContainer.appendChild(buildWeekdays());
              if (!self.daysContainer) {
                  self.daysContainer = createElement("div", "flatpickr-days");
                  self.daysContainer.tabIndex = -1;
              }
              buildDays();
              self.rContainer.appendChild(self.daysContainer);
              self.innerContainer.appendChild(self.rContainer);
              fragment.appendChild(self.innerContainer);
          }
          if (self.config.enableTime) {
              fragment.appendChild(buildTime());
          }
          toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
          toggleClass(self.calendarContainer, "animate", self.config.animate === true);
          toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
          self.calendarContainer.appendChild(fragment);
          const customAppend = self.config.appendTo !== undefined &&
              self.config.appendTo.nodeType !== undefined;
          if (self.config.inline || self.config.static) {
              self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");
              if (self.config.inline) {
                  if (!customAppend && self.element.parentNode)
                      self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);
                  else if (self.config.appendTo !== undefined)
                      self.config.appendTo.appendChild(self.calendarContainer);
              }
              if (self.config.static) {
                  const wrapper = createElement("div", "flatpickr-wrapper");
                  if (self.element.parentNode)
                      self.element.parentNode.insertBefore(wrapper, self.element);
                  wrapper.appendChild(self.element);
                  if (self.altInput)
                      wrapper.appendChild(self.altInput);
                  wrapper.appendChild(self.calendarContainer);
              }
          }
          if (!self.config.static && !self.config.inline)
              (self.config.appendTo !== undefined
                  ? self.config.appendTo
                  : window.document.body).appendChild(self.calendarContainer);
      }
      function createDay(className, date, dayNumber, i) {
          const dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", "flatpickr-day " + className, date.getDate().toString());
          dayElement.dateObj = date;
          dayElement.$i = i;
          dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));
          if (className.indexOf("hidden") === -1 &&
              compareDates(date, self.now) === 0) {
              self.todayDateElem = dayElement;
              dayElement.classList.add("today");
              dayElement.setAttribute("aria-current", "date");
          }
          if (dateIsEnabled) {
              dayElement.tabIndex = -1;
              if (isDateSelected(date)) {
                  dayElement.classList.add("selected");
                  self.selectedDateElem = dayElement;
                  if (self.config.mode === "range") {
                      toggleClass(dayElement, "startRange", self.selectedDates[0] &&
                          compareDates(date, self.selectedDates[0], true) === 0);
                      toggleClass(dayElement, "endRange", self.selectedDates[1] &&
                          compareDates(date, self.selectedDates[1], true) === 0);
                      if (className === "nextMonthDay")
                          dayElement.classList.add("inRange");
                  }
              }
          }
          else {
              dayElement.classList.add("flatpickr-disabled");
          }
          if (self.config.mode === "range") {
              if (isDateInRange(date) && !isDateSelected(date))
                  dayElement.classList.add("inRange");
          }
          if (self.weekNumbers &&
              self.config.showMonths === 1 &&
              className !== "prevMonthDay" &&
              dayNumber % 7 === 1) {
              self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
          }
          triggerEvent("onDayCreate", dayElement);
          return dayElement;
      }
      function focusOnDayElem(targetNode) {
          targetNode.focus();
          if (self.config.mode === "range")
              onMouseOver(targetNode);
      }
      function getFirstAvailableDay(delta) {
          const startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
          const endMonth = delta > 0 ? self.config.showMonths : -1;
          for (let m = startMonth; m != endMonth; m += delta) {
              const month = self.daysContainer.children[m];
              const startIndex = delta > 0 ? 0 : month.children.length - 1;
              const endIndex = delta > 0 ? month.children.length : -1;
              for (let i = startIndex; i != endIndex; i += delta) {
                  const c = month.children[i];
                  if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
                      return c;
              }
          }
          return undefined;
      }
      function getNextAvailableDay(current, delta) {
          const givenMonth = current.className.indexOf("Month") === -1
              ? current.dateObj.getMonth()
              : self.currentMonth;
          const endMonth = delta > 0 ? self.config.showMonths : -1;
          const loopDelta = delta > 0 ? 1 : -1;
          for (let m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
              const month = self.daysContainer.children[m];
              const startIndex = givenMonth - self.currentMonth === m
                  ? current.$i + delta
                  : delta < 0
                      ? month.children.length - 1
                      : 0;
              const numMonthDays = month.children.length;
              for (let i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
                  const c = month.children[i];
                  if (c.className.indexOf("hidden") === -1 &&
                      isEnabled(c.dateObj) &&
                      Math.abs(current.$i - i) >= Math.abs(delta))
                      return focusOnDayElem(c);
              }
          }
          self.changeMonth(loopDelta);
          focusOnDay(getFirstAvailableDay(loopDelta), 0);
          return undefined;
      }
      function focusOnDay(current, offset) {
          const dayFocused = isInView(document.activeElement || document.body);
          const startElem = current !== undefined
              ? current
              : dayFocused
                  ? document.activeElement
                  : self.selectedDateElem !== undefined && isInView(self.selectedDateElem)
                      ? self.selectedDateElem
                      : self.todayDateElem !== undefined && isInView(self.todayDateElem)
                          ? self.todayDateElem
                          : getFirstAvailableDay(offset > 0 ? 1 : -1);
          if (startElem === undefined) {
              self._input.focus();
          }
          else if (!dayFocused) {
              focusOnDayElem(startElem);
          }
          else {
              getNextAvailableDay(startElem, offset);
          }
      }
      function buildMonthDays(year, month) {
          const firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
          const prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12, year);
          const daysInMonth = self.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
          let dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
          for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
              days.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
          }
          for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
              days.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));
          }
          for (let dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth &&
              (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
              days.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
          }
          const dayContainer = createElement("div", "dayContainer");
          dayContainer.appendChild(days);
          return dayContainer;
      }
      function buildDays() {
          if (self.daysContainer === undefined) {
              return;
          }
          clearNode(self.daysContainer);
          if (self.weekNumbers)
              clearNode(self.weekNumbers);
          const frag = document.createDocumentFragment();
          for (let i = 0; i < self.config.showMonths; i++) {
              const d = new Date(self.currentYear, self.currentMonth, 1);
              d.setMonth(self.currentMonth + i);
              frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
          }
          self.daysContainer.appendChild(frag);
          self.days = self.daysContainer.firstChild;
          if (self.config.mode === "range" && self.selectedDates.length === 1) {
              onMouseOver();
          }
      }
      function buildMonthSwitch() {
          if (self.config.showMonths > 1 ||
              self.config.monthSelectorType !== "dropdown")
              return;
          const shouldBuildMonth = function (month) {
              if (self.config.minDate !== undefined &&
                  self.currentYear === self.config.minDate.getFullYear() &&
                  month < self.config.minDate.getMonth()) {
                  return false;
              }
              return !(self.config.maxDate !== undefined &&
                  self.currentYear === self.config.maxDate.getFullYear() &&
                  month > self.config.maxDate.getMonth());
          };
          self.monthsDropdownContainer.tabIndex = -1;
          self.monthsDropdownContainer.innerHTML = "";
          for (let i = 0; i < 12; i++) {
              if (!shouldBuildMonth(i))
                  continue;
              const month = createElement("option", "flatpickr-monthDropdown-month");
              month.value = new Date(self.currentYear, i).getMonth().toString();
              month.textContent = monthToStr$2(i, self.config.shorthandCurrentMonth, self.l10n);
              month.tabIndex = -1;
              if (self.currentMonth === i) {
                  month.selected = true;
              }
              self.monthsDropdownContainer.appendChild(month);
          }
      }
      function buildMonth() {
          const container = createElement("div", "flatpickr-month");
          const monthNavFragment = window.document.createDocumentFragment();
          let monthElement;
          if (self.config.showMonths > 1 ||
              self.config.monthSelectorType === "static") {
              monthElement = createElement("span", "cur-month");
          }
          else {
              self.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
              self.monthsDropdownContainer.setAttribute("aria-label", self.l10n.monthAriaLabel);
              bind(self.monthsDropdownContainer, "change", (e) => {
                  const target = getEventTarget(e);
                  const selectedMonth = parseInt(target.value, 10);
                  self.changeMonth(selectedMonth - self.currentMonth);
                  triggerEvent("onMonthChange");
              });
              buildMonthSwitch();
              monthElement = self.monthsDropdownContainer;
          }
          const yearInput = createNumberInput("cur-year", { tabindex: "-1" });
          const yearElement = yearInput.getElementsByTagName("input")[0];
          yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);
          if (self.config.minDate) {
              yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
          }
          if (self.config.maxDate) {
              yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
              yearElement.disabled =
                  !!self.config.minDate &&
                      self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
          }
          const currentMonth = createElement("div", "flatpickr-current-month");
          currentMonth.appendChild(monthElement);
          currentMonth.appendChild(yearInput);
          monthNavFragment.appendChild(currentMonth);
          container.appendChild(monthNavFragment);
          return {
              container,
              yearElement,
              monthElement,
          };
      }
      function buildMonths() {
          clearNode(self.monthNav);
          self.monthNav.appendChild(self.prevMonthNav);
          if (self.config.showMonths) {
              self.yearElements = [];
              self.monthElements = [];
          }
          for (let m = self.config.showMonths; m--;) {
              const month = buildMonth();
              self.yearElements.push(month.yearElement);
              self.monthElements.push(month.monthElement);
              self.monthNav.appendChild(month.container);
          }
          self.monthNav.appendChild(self.nextMonthNav);
      }
      function buildMonthNav() {
          self.monthNav = createElement("div", "flatpickr-months");
          self.yearElements = [];
          self.monthElements = [];
          self.prevMonthNav = createElement("span", "flatpickr-prev-month");
          self.prevMonthNav.innerHTML = self.config.prevArrow;
          self.nextMonthNav = createElement("span", "flatpickr-next-month");
          self.nextMonthNav.innerHTML = self.config.nextArrow;
          buildMonths();
          Object.defineProperty(self, "_hidePrevMonthArrow", {
              get: () => self.__hidePrevMonthArrow,
              set(bool) {
                  if (self.__hidePrevMonthArrow !== bool) {
                      toggleClass(self.prevMonthNav, "flatpickr-disabled", bool);
                      self.__hidePrevMonthArrow = bool;
                  }
              },
          });
          Object.defineProperty(self, "_hideNextMonthArrow", {
              get: () => self.__hideNextMonthArrow,
              set(bool) {
                  if (self.__hideNextMonthArrow !== bool) {
                      toggleClass(self.nextMonthNav, "flatpickr-disabled", bool);
                      self.__hideNextMonthArrow = bool;
                  }
              },
          });
          self.currentYearElement = self.yearElements[0];
          updateNavigationCurrentMonth();
          return self.monthNav;
      }
      function buildTime() {
          self.calendarContainer.classList.add("hasTime");
          if (self.config.noCalendar)
              self.calendarContainer.classList.add("noCalendar");
          const defaults = getDefaultHours(self.config);
          self.timeContainer = createElement("div", "flatpickr-time");
          self.timeContainer.tabIndex = -1;
          const separator = createElement("span", "flatpickr-time-separator", ":");
          const hourInput = createNumberInput("flatpickr-hour", {
              "aria-label": self.l10n.hourAriaLabel,
          });
          self.hourElement = hourInput.getElementsByTagName("input")[0];
          const minuteInput = createNumberInput("flatpickr-minute", {
              "aria-label": self.l10n.minuteAriaLabel,
          });
          self.minuteElement = minuteInput.getElementsByTagName("input")[0];
          self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
          self.hourElement.value = pad(self.latestSelectedDateObj
              ? self.latestSelectedDateObj.getHours()
              : self.config.time_24hr
                  ? defaults.hours
                  : military2ampm(defaults.hours));
          self.minuteElement.value = pad(self.latestSelectedDateObj
              ? self.latestSelectedDateObj.getMinutes()
              : defaults.minutes);
          self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
          self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
          self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
          self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
          self.hourElement.setAttribute("maxlength", "2");
          self.minuteElement.setAttribute("min", "0");
          self.minuteElement.setAttribute("max", "59");
          self.minuteElement.setAttribute("maxlength", "2");
          self.timeContainer.appendChild(hourInput);
          self.timeContainer.appendChild(separator);
          self.timeContainer.appendChild(minuteInput);
          if (self.config.time_24hr)
              self.timeContainer.classList.add("time24hr");
          if (self.config.enableSeconds) {
              self.timeContainer.classList.add("hasSeconds");
              const secondInput = createNumberInput("flatpickr-second");
              self.secondElement = secondInput.getElementsByTagName("input")[0];
              self.secondElement.value = pad(self.latestSelectedDateObj
                  ? self.latestSelectedDateObj.getSeconds()
                  : defaults.seconds);
              self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
              self.secondElement.setAttribute("min", "0");
              self.secondElement.setAttribute("max", "59");
              self.secondElement.setAttribute("maxlength", "2");
              self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
              self.timeContainer.appendChild(secondInput);
          }
          if (!self.config.time_24hr) {
              self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int((self.latestSelectedDateObj
                  ? self.hourElement.value
                  : self.config.defaultHour) > 11)]);
              self.amPM.title = self.l10n.toggleTitle;
              self.amPM.tabIndex = -1;
              self.timeContainer.appendChild(self.amPM);
          }
          return self.timeContainer;
      }
      function buildWeekdays() {
          if (!self.weekdayContainer)
              self.weekdayContainer = createElement("div", "flatpickr-weekdays");
          else
              clearNode(self.weekdayContainer);
          for (let i = self.config.showMonths; i--;) {
              const container = createElement("div", "flatpickr-weekdaycontainer");
              self.weekdayContainer.appendChild(container);
          }
          updateWeekdays();
          return self.weekdayContainer;
      }
      function updateWeekdays() {
          if (!self.weekdayContainer) {
              return;
          }
          const firstDayOfWeek = self.l10n.firstDayOfWeek;
          let weekdays = [...self.l10n.weekdays.shorthand];
          if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
              weekdays = [
                  ...weekdays.splice(firstDayOfWeek, weekdays.length),
                  ...weekdays.splice(0, firstDayOfWeek),
              ];
          }
          for (let i = self.config.showMonths; i--;) {
              self.weekdayContainer.children[i].innerHTML = `
      <span class='flatpickr-weekday'>
        ${weekdays.join("</span><span class='flatpickr-weekday'>")}
      </span>
      `;
          }
      }
      function buildWeeks() {
          self.calendarContainer.classList.add("hasWeeks");
          const weekWrapper = createElement("div", "flatpickr-weekwrapper");
          weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
          const weekNumbers = createElement("div", "flatpickr-weeks");
          weekWrapper.appendChild(weekNumbers);
          return {
              weekWrapper,
              weekNumbers,
          };
      }
      function changeMonth(value, isOffset = true) {
          const delta = isOffset ? value : value - self.currentMonth;
          if ((delta < 0 && self._hidePrevMonthArrow === true) ||
              (delta > 0 && self._hideNextMonthArrow === true))
              return;
          self.currentMonth += delta;
          if (self.currentMonth < 0 || self.currentMonth > 11) {
              self.currentYear += self.currentMonth > 11 ? 1 : -1;
              self.currentMonth = (self.currentMonth + 12) % 12;
              triggerEvent("onYearChange");
              buildMonthSwitch();
          }
          buildDays();
          triggerEvent("onMonthChange");
          updateNavigationCurrentMonth();
      }
      function clear(triggerChangeEvent = true, toInitial = true) {
          self.input.value = "";
          if (self.altInput !== undefined)
              self.altInput.value = "";
          if (self.mobileInput !== undefined)
              self.mobileInput.value = "";
          self.selectedDates = [];
          self.latestSelectedDateObj = undefined;
          if (toInitial === true) {
              self.currentYear = self._initialDate.getFullYear();
              self.currentMonth = self._initialDate.getMonth();
          }
          if (self.config.enableTime === true) {
              const { hours, minutes, seconds } = getDefaultHours(self.config);
              setHours(hours, minutes, seconds);
          }
          self.redraw();
          if (triggerChangeEvent)
              triggerEvent("onChange");
      }
      function close() {
          self.isOpen = false;
          if (!self.isMobile) {
              if (self.calendarContainer !== undefined) {
                  self.calendarContainer.classList.remove("open");
              }
              if (self._input !== undefined) {
                  self._input.classList.remove("active");
              }
          }
          triggerEvent("onClose");
      }
      function destroy() {
          if (self.config !== undefined)
              triggerEvent("onDestroy");
          for (let i = self._handlers.length; i--;) {
              self._handlers[i].remove();
          }
          self._handlers = [];
          if (self.mobileInput) {
              if (self.mobileInput.parentNode)
                  self.mobileInput.parentNode.removeChild(self.mobileInput);
              self.mobileInput = undefined;
          }
          else if (self.calendarContainer && self.calendarContainer.parentNode) {
              if (self.config.static && self.calendarContainer.parentNode) {
                  const wrapper = self.calendarContainer.parentNode;
                  wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
                  if (wrapper.parentNode) {
                      while (wrapper.firstChild)
                          wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
                      wrapper.parentNode.removeChild(wrapper);
                  }
              }
              else
                  self.calendarContainer.parentNode.removeChild(self.calendarContainer);
          }
          if (self.altInput) {
              self.input.type = "text";
              if (self.altInput.parentNode)
                  self.altInput.parentNode.removeChild(self.altInput);
              delete self.altInput;
          }
          if (self.input) {
              self.input.type = self.input._type;
              self.input.classList.remove("flatpickr-input");
              self.input.removeAttribute("readonly");
          }
          [
              "_showTimeInput",
              "latestSelectedDateObj",
              "_hideNextMonthArrow",
              "_hidePrevMonthArrow",
              "__hideNextMonthArrow",
              "__hidePrevMonthArrow",
              "isMobile",
              "isOpen",
              "selectedDateElem",
              "minDateHasTime",
              "maxDateHasTime",
              "days",
              "daysContainer",
              "_input",
              "_positionElement",
              "innerContainer",
              "rContainer",
              "monthNav",
              "todayDateElem",
              "calendarContainer",
              "weekdayContainer",
              "prevMonthNav",
              "nextMonthNav",
              "monthsDropdownContainer",
              "currentMonthElement",
              "currentYearElement",
              "navigationCurrentMonth",
              "selectedDateElem",
              "config",
          ].forEach((k) => {
              try {
                  delete self[k];
              }
              catch (_) { }
          });
      }
      function isCalendarElem(elem) {
          if (self.config.appendTo && self.config.appendTo.contains(elem))
              return true;
          return self.calendarContainer.contains(elem);
      }
      function documentClick(e) {
          if (self.isOpen && !self.config.inline) {
              const eventTarget = getEventTarget(e);
              const isCalendarElement = isCalendarElem(eventTarget);
              const isInput = eventTarget === self.input ||
                  eventTarget === self.altInput ||
                  self.element.contains(eventTarget) ||
                  (e.path &&
                      e.path.indexOf &&
                      (~e.path.indexOf(self.input) ||
                          ~e.path.indexOf(self.altInput)));
              const lostFocus = e.type === "blur"
                  ? isInput &&
                      e.relatedTarget &&
                      !isCalendarElem(e.relatedTarget)
                  : !isInput &&
                      !isCalendarElement &&
                      !isCalendarElem(e.relatedTarget);
              const isIgnored = !self.config.ignoredFocusElements.some((elem) => elem.contains(eventTarget));
              if (lostFocus && isIgnored) {
                  if (self.timeContainer !== undefined &&
                      self.minuteElement !== undefined &&
                      self.hourElement !== undefined &&
                      self.input.value !== "" &&
                      self.input.value !== undefined) {
                      updateTime();
                  }
                  self.close();
                  if (self.config &&
                      self.config.mode === "range" &&
                      self.selectedDates.length === 1) {
                      self.clear(false);
                      self.redraw();
                  }
              }
          }
      }
      function changeYear(newYear) {
          if (!newYear ||
              (self.config.minDate && newYear < self.config.minDate.getFullYear()) ||
              (self.config.maxDate && newYear > self.config.maxDate.getFullYear()))
              return;
          const newYearNum = newYear, isNewYear = self.currentYear !== newYearNum;
          self.currentYear = newYearNum || self.currentYear;
          if (self.config.maxDate &&
              self.currentYear === self.config.maxDate.getFullYear()) {
              self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
          }
          else if (self.config.minDate &&
              self.currentYear === self.config.minDate.getFullYear()) {
              self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
          }
          if (isNewYear) {
              self.redraw();
              triggerEvent("onYearChange");
              buildMonthSwitch();
          }
      }
      function isEnabled(date, timeless = true) {
          var _a;
          const dateToCheck = self.parseDate(date, undefined, timeless);
          if ((self.config.minDate &&
              dateToCheck &&
              compareDates(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0) ||
              (self.config.maxDate &&
                  dateToCheck &&
                  compareDates(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0))
              return false;
          if (!self.config.enable && self.config.disable.length === 0)
              return true;
          if (dateToCheck === undefined)
              return false;
          const bool = !!self.config.enable, array = (_a = self.config.enable) !== null && _a !== void 0 ? _a : self.config.disable;
          for (let i = 0, d; i < array.length; i++) {
              d = array[i];
              if (typeof d === "function" &&
                  d(dateToCheck))
                  return bool;
              else if (d instanceof Date &&
                  dateToCheck !== undefined &&
                  d.getTime() === dateToCheck.getTime())
                  return bool;
              else if (typeof d === "string") {
                  const parsed = self.parseDate(d, undefined, true);
                  return parsed && parsed.getTime() === dateToCheck.getTime()
                      ? bool
                      : !bool;
              }
              else if (typeof d === "object" &&
                  dateToCheck !== undefined &&
                  d.from &&
                  d.to &&
                  dateToCheck.getTime() >= d.from.getTime() &&
                  dateToCheck.getTime() <= d.to.getTime())
                  return bool;
          }
          return !bool;
      }
      function isInView(elem) {
          if (self.daysContainer !== undefined)
              return (elem.className.indexOf("hidden") === -1 &&
                  elem.className.indexOf("flatpickr-disabled") === -1 &&
                  self.daysContainer.contains(elem));
          return false;
      }
      function onBlur(e) {
          const isInput = e.target === self._input;
          if (isInput &&
              (self.selectedDates.length > 0 || self._input.value.length > 0) &&
              !(e.relatedTarget && isCalendarElem(e.relatedTarget))) {
              self.setDate(self._input.value, true, e.target === self.altInput
                  ? self.config.altFormat
                  : self.config.dateFormat);
          }
      }
      function onKeyDown(e) {
          const eventTarget = getEventTarget(e);
          const isInput = self.config.wrap
              ? element.contains(eventTarget)
              : eventTarget === self._input;
          const allowInput = self.config.allowInput;
          const allowKeydown = self.isOpen && (!allowInput || !isInput);
          const allowInlineKeydown = self.config.inline && isInput && !allowInput;
          if (e.keyCode === 13 && isInput) {
              if (allowInput) {
                  self.setDate(self._input.value, true, eventTarget === self.altInput
                      ? self.config.altFormat
                      : self.config.dateFormat);
                  return eventTarget.blur();
              }
              else {
                  self.open();
              }
          }
          else if (isCalendarElem(eventTarget) ||
              allowKeydown ||
              allowInlineKeydown) {
              const isTimeObj = !!self.timeContainer &&
                  self.timeContainer.contains(eventTarget);
              switch (e.keyCode) {
                  case 13:
                      if (isTimeObj) {
                          e.preventDefault();
                          updateTime();
                          focusAndClose();
                      }
                      else
                          selectDate(e);
                      break;
                  case 27:
                      e.preventDefault();
                      focusAndClose();
                      break;
                  case 8:
                  case 46:
                      if (isInput && !self.config.allowInput) {
                          e.preventDefault();
                          self.clear();
                      }
                      break;
                  case 37:
                  case 39:
                      if (!isTimeObj && !isInput) {
                          e.preventDefault();
                          if (self.daysContainer !== undefined &&
                              (allowInput === false ||
                                  (document.activeElement && isInView(document.activeElement)))) {
                              const delta = e.keyCode === 39 ? 1 : -1;
                              if (!e.ctrlKey)
                                  focusOnDay(undefined, delta);
                              else {
                                  e.stopPropagation();
                                  changeMonth(delta);
                                  focusOnDay(getFirstAvailableDay(1), 0);
                              }
                          }
                      }
                      else if (self.hourElement)
                          self.hourElement.focus();
                      break;
                  case 38:
                  case 40:
                      e.preventDefault();
                      const delta = e.keyCode === 40 ? 1 : -1;
                      if ((self.daysContainer &&
                          eventTarget.$i !== undefined) ||
                          eventTarget === self.input ||
                          eventTarget === self.altInput) {
                          if (e.ctrlKey) {
                              e.stopPropagation();
                              changeYear(self.currentYear - delta);
                              focusOnDay(getFirstAvailableDay(1), 0);
                          }
                          else if (!isTimeObj)
                              focusOnDay(undefined, delta * 7);
                      }
                      else if (eventTarget === self.currentYearElement) {
                          changeYear(self.currentYear - delta);
                      }
                      else if (self.config.enableTime) {
                          if (!isTimeObj && self.hourElement)
                              self.hourElement.focus();
                          updateTime(e);
                          self._debouncedChange();
                      }
                      break;
                  case 9:
                      if (isTimeObj) {
                          const elems = [
                              self.hourElement,
                              self.minuteElement,
                              self.secondElement,
                              self.amPM,
                          ]
                              .concat(self.pluginElements)
                              .filter((x) => x);
                          const i = elems.indexOf(eventTarget);
                          if (i !== -1) {
                              const target = elems[i + (e.shiftKey ? -1 : 1)];
                              e.preventDefault();
                              (target || self._input).focus();
                          }
                      }
                      else if (!self.config.noCalendar &&
                          self.daysContainer &&
                          self.daysContainer.contains(eventTarget) &&
                          e.shiftKey) {
                          e.preventDefault();
                          self._input.focus();
                      }
                      break;
              }
          }
          if (self.amPM !== undefined && eventTarget === self.amPM) {
              switch (e.key) {
                  case self.l10n.amPM[0].charAt(0):
                  case self.l10n.amPM[0].charAt(0).toLowerCase():
                      self.amPM.textContent = self.l10n.amPM[0];
                      setHoursFromInputs();
                      updateValue();
                      break;
                  case self.l10n.amPM[1].charAt(0):
                  case self.l10n.amPM[1].charAt(0).toLowerCase():
                      self.amPM.textContent = self.l10n.amPM[1];
                      setHoursFromInputs();
                      updateValue();
                      break;
              }
          }
          if (isInput || isCalendarElem(eventTarget)) {
              triggerEvent("onKeyDown", e);
          }
      }
      function onMouseOver(elem) {
          if (self.selectedDates.length !== 1 ||
              (elem &&
                  (!elem.classList.contains("flatpickr-day") ||
                      elem.classList.contains("flatpickr-disabled"))))
              return;
          const hoverDate = elem
              ? elem.dateObj.getTime()
              : self.days.firstElementChild.dateObj.getTime(), initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(), rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime());
          let containsDisabled = false;
          let minRange = 0, maxRange = 0;
          for (let t = rangeStartDate; t < rangeEndDate; t += duration.DAY) {
              if (!isEnabled(new Date(t), true)) {
                  containsDisabled =
                      containsDisabled || (t > rangeStartDate && t < rangeEndDate);
                  if (t < initialDate && (!minRange || t > minRange))
                      minRange = t;
                  else if (t > initialDate && (!maxRange || t < maxRange))
                      maxRange = t;
              }
          }
          for (let m = 0; m < self.config.showMonths; m++) {
              const month = self.daysContainer.children[m];
              for (let i = 0, l = month.children.length; i < l; i++) {
                  const dayElem = month.children[i], date = dayElem.dateObj;
                  const timestamp = date.getTime();
                  const outOfRange = (minRange > 0 && timestamp < minRange) ||
                      (maxRange > 0 && timestamp > maxRange);
                  if (outOfRange) {
                      dayElem.classList.add("notAllowed");
                      ["inRange", "startRange", "endRange"].forEach((c) => {
                          dayElem.classList.remove(c);
                      });
                      continue;
                  }
                  else if (containsDisabled && !outOfRange)
                      continue;
                  ["startRange", "inRange", "endRange", "notAllowed"].forEach((c) => {
                      dayElem.classList.remove(c);
                  });
                  if (elem !== undefined) {
                      elem.classList.add(hoverDate <= self.selectedDates[0].getTime()
                          ? "startRange"
                          : "endRange");
                      if (initialDate < hoverDate && timestamp === initialDate)
                          dayElem.classList.add("startRange");
                      else if (initialDate > hoverDate && timestamp === initialDate)
                          dayElem.classList.add("endRange");
                      if (timestamp >= minRange &&
                          (maxRange === 0 || timestamp <= maxRange) &&
                          isBetween(timestamp, initialDate, hoverDate))
                          dayElem.classList.add("inRange");
                  }
              }
          }
      }
      function onResize() {
          if (self.isOpen && !self.config.static && !self.config.inline)
              positionCalendar();
      }
      function open(e, positionElement = self._positionElement) {
          if (self.isMobile === true) {
              if (e) {
                  e.preventDefault();
                  const eventTarget = getEventTarget(e);
                  if (eventTarget) {
                      eventTarget.blur();
                  }
              }
              if (self.mobileInput !== undefined) {
                  self.mobileInput.focus();
                  self.mobileInput.click();
              }
              triggerEvent("onOpen");
              return;
          }
          else if (self._input.disabled || self.config.inline) {
              return;
          }
          const wasOpen = self.isOpen;
          self.isOpen = true;
          if (!wasOpen) {
              self.calendarContainer.classList.add("open");
              self._input.classList.add("active");
              triggerEvent("onOpen");
              positionCalendar(positionElement);
          }
          if (self.config.enableTime === true && self.config.noCalendar === true) {
              if (self.config.allowInput === false &&
                  (e === undefined ||
                      !self.timeContainer.contains(e.relatedTarget))) {
                  setTimeout(() => self.hourElement.select(), 50);
              }
          }
      }
      function minMaxDateSetter(type) {
          return (date) => {
              const dateObj = (self.config[`_${type}Date`] = self.parseDate(date, self.config.dateFormat));
              const inverseDateObj = self.config[`_${type === "min" ? "max" : "min"}Date`];
              if (dateObj !== undefined) {
                  self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] =
                      dateObj.getHours() > 0 ||
                          dateObj.getMinutes() > 0 ||
                          dateObj.getSeconds() > 0;
              }
              if (self.selectedDates) {
                  self.selectedDates = self.selectedDates.filter((d) => isEnabled(d));
                  if (!self.selectedDates.length && type === "min")
                      setHoursFromDate(dateObj);
                  updateValue();
              }
              if (self.daysContainer) {
                  redraw();
                  if (dateObj !== undefined)
                      self.currentYearElement[type] = dateObj.getFullYear().toString();
                  else
                      self.currentYearElement.removeAttribute(type);
                  self.currentYearElement.disabled =
                      !!inverseDateObj &&
                          dateObj !== undefined &&
                          inverseDateObj.getFullYear() === dateObj.getFullYear();
              }
          };
      }
      function parseConfig() {
          const boolOpts = [
              "wrap",
              "weekNumbers",
              "allowInput",
              "allowInvalidPreload",
              "clickOpens",
              "time_24hr",
              "enableTime",
              "noCalendar",
              "altInput",
              "shorthandCurrentMonth",
              "inline",
              "static",
              "enableSeconds",
              "disableMobile",
          ];
          const userConfig = Object.assign(Object.assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
          const formats = {};
          self.config.parseDate = userConfig.parseDate;
          self.config.formatDate = userConfig.formatDate;
          Object.defineProperty(self.config, "enable", {
              get: () => self.config._enable,
              set: (dates) => {
                  self.config._enable = parseDateRules(dates);
              },
          });
          Object.defineProperty(self.config, "disable", {
              get: () => self.config._disable,
              set: (dates) => {
                  self.config._disable = parseDateRules(dates);
              },
          });
          const timeMode = userConfig.mode === "time";
          if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
              const defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
              formats.dateFormat =
                  userConfig.noCalendar || timeMode
                      ? "H:i" + (userConfig.enableSeconds ? ":S" : "")
                      : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
          }
          if (userConfig.altInput &&
              (userConfig.enableTime || timeMode) &&
              !userConfig.altFormat) {
              const defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
              formats.altFormat =
                  userConfig.noCalendar || timeMode
                      ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K")
                      : defaultAltFormat + ` h:i${userConfig.enableSeconds ? ":S" : ""} K`;
          }
          Object.defineProperty(self.config, "minDate", {
              get: () => self.config._minDate,
              set: minMaxDateSetter("min"),
          });
          Object.defineProperty(self.config, "maxDate", {
              get: () => self.config._maxDate,
              set: minMaxDateSetter("max"),
          });
          const minMaxTimeSetter = (type) => (val) => {
              self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i:S");
          };
          Object.defineProperty(self.config, "minTime", {
              get: () => self.config._minTime,
              set: minMaxTimeSetter("min"),
          });
          Object.defineProperty(self.config, "maxTime", {
              get: () => self.config._maxTime,
              set: minMaxTimeSetter("max"),
          });
          if (userConfig.mode === "time") {
              self.config.noCalendar = true;
              self.config.enableTime = true;
          }
          Object.assign(self.config, formats, userConfig);
          for (let i = 0; i < boolOpts.length; i++)
              self.config[boolOpts[i]] =
                  self.config[boolOpts[i]] === true ||
                      self.config[boolOpts[i]] === "true";
          HOOKS.filter((hook) => self.config[hook] !== undefined).forEach((hook) => {
              self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
          });
          self.isMobile =
              !self.config.disableMobile &&
                  !self.config.inline &&
                  self.config.mode === "single" &&
                  !self.config.disable.length &&
                  !self.config.enable &&
                  !self.config.weekNumbers &&
                  /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
          for (let i = 0; i < self.config.plugins.length; i++) {
              const pluginConf = self.config.plugins[i](self) || {};
              for (const key in pluginConf) {
                  if (HOOKS.indexOf(key) > -1) {
                      self.config[key] = arrayify(pluginConf[key])
                          .map(bindToInstance)
                          .concat(self.config[key]);
                  }
                  else if (typeof userConfig[key] === "undefined")
                      self.config[key] = pluginConf[key];
              }
          }
          if (!userConfig.altInputClass) {
              self.config.altInputClass =
                  getInputElem().className + " " + self.config.altInputClass;
          }
          triggerEvent("onParseConfig");
      }
      function getInputElem() {
          return self.config.wrap
              ? element.querySelector("[data-input]")
              : element;
      }
      function setupLocale() {
          if (typeof self.config.locale !== "object" &&
              typeof flatpickr.l10ns[self.config.locale] === "undefined")
              self.config.errorHandler(new Error(`flatpickr: invalid locale ${self.config.locale}`));
          self.l10n = Object.assign(Object.assign({}, flatpickr.l10ns.default), (typeof self.config.locale === "object"
              ? self.config.locale
              : self.config.locale !== "default"
                  ? flatpickr.l10ns[self.config.locale]
                  : undefined));
          tokenRegex.K = `(${self.l10n.amPM[0]}|${self.l10n.amPM[1]}|${self.l10n.amPM[0].toLowerCase()}|${self.l10n.amPM[1].toLowerCase()})`;
          const userConfig = Object.assign(Object.assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
          if (userConfig.time_24hr === undefined &&
              flatpickr.defaultConfig.time_24hr === undefined) {
              self.config.time_24hr = self.l10n.time_24hr;
          }
          self.formatDate = createDateFormatter(self);
          self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
      }
      function positionCalendar(customPositionElement) {
          if (typeof self.config.position === "function") {
              return void self.config.position(self, customPositionElement);
          }
          if (self.calendarContainer === undefined)
              return;
          triggerEvent("onPreCalendarPosition");
          const positionElement = customPositionElement || self._positionElement;
          const calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, ((acc, child) => acc + child.offsetHeight), 0), calendarWidth = self.calendarContainer.offsetWidth, configPos = self.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" ||
              (configPosVertical !== "below" &&
                  distanceFromBottom < calendarHeight &&
                  inputBounds.top > calendarHeight);
          const top = window.pageYOffset +
              inputBounds.top +
              (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
          toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
          toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
          if (self.config.inline)
              return;
          let left = window.pageXOffset + inputBounds.left;
          let isCenter = false;
          let isRight = false;
          if (configPosHorizontal === "center") {
              left -= (calendarWidth - inputBounds.width) / 2;
              isCenter = true;
          }
          else if (configPosHorizontal === "right") {
              left -= calendarWidth - inputBounds.width;
              isRight = true;
          }
          toggleClass(self.calendarContainer, "arrowLeft", !isCenter && !isRight);
          toggleClass(self.calendarContainer, "arrowCenter", isCenter);
          toggleClass(self.calendarContainer, "arrowRight", isRight);
          const right = window.document.body.offsetWidth -
              (window.pageXOffset + inputBounds.right);
          const rightMost = left + calendarWidth > window.document.body.offsetWidth;
          const centerMost = right + calendarWidth > window.document.body.offsetWidth;
          toggleClass(self.calendarContainer, "rightMost", rightMost);
          if (self.config.static)
              return;
          self.calendarContainer.style.top = `${top}px`;
          if (!rightMost) {
              self.calendarContainer.style.left = `${left}px`;
              self.calendarContainer.style.right = "auto";
          }
          else if (!centerMost) {
              self.calendarContainer.style.left = "auto";
              self.calendarContainer.style.right = `${right}px`;
          }
          else {
              const doc = getDocumentStyleSheet();
              if (doc === undefined)
                  return;
              const bodyWidth = window.document.body.offsetWidth;
              const centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
              const centerBefore = ".flatpickr-calendar.centerMost:before";
              const centerAfter = ".flatpickr-calendar.centerMost:after";
              const centerIndex = doc.cssRules.length;
              const centerStyle = `{left:${inputBounds.left}px;right:auto;}`;
              toggleClass(self.calendarContainer, "rightMost", false);
              toggleClass(self.calendarContainer, "centerMost", true);
              doc.insertRule(`${centerBefore},${centerAfter}${centerStyle}`, centerIndex);
              self.calendarContainer.style.left = `${centerLeft}px`;
              self.calendarContainer.style.right = "auto";
          }
      }
      function getDocumentStyleSheet() {
          let editableSheet = null;
          for (let i = 0; i < document.styleSheets.length; i++) {
              const sheet = document.styleSheets[i];
              try {
                  sheet.cssRules;
              }
              catch (err) {
                  continue;
              }
              editableSheet = sheet;
              break;
          }
          return editableSheet != null ? editableSheet : createStyleSheet();
      }
      function createStyleSheet() {
          const style = document.createElement("style");
          document.head.appendChild(style);
          return style.sheet;
      }
      function redraw() {
          if (self.config.noCalendar || self.isMobile)
              return;
          buildMonthSwitch();
          updateNavigationCurrentMonth();
          buildDays();
      }
      function focusAndClose() {
          self._input.focus();
          if (window.navigator.userAgent.indexOf("MSIE") !== -1 ||
              navigator.msMaxTouchPoints !== undefined) {
              setTimeout(self.close, 0);
          }
          else {
              self.close();
          }
      }
      function selectDate(e) {
          e.preventDefault();
          e.stopPropagation();
          const isSelectable = (day) => day.classList &&
              day.classList.contains("flatpickr-day") &&
              !day.classList.contains("flatpickr-disabled") &&
              !day.classList.contains("notAllowed");
          const t = findParent(getEventTarget(e), isSelectable);
          if (t === undefined)
              return;
          const target = t;
          const selectedDate = (self.latestSelectedDateObj = new Date(target.dateObj.getTime()));
          const shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth ||
              selectedDate.getMonth() >
                  self.currentMonth + self.config.showMonths - 1) &&
              self.config.mode !== "range";
          self.selectedDateElem = target;
          if (self.config.mode === "single")
              self.selectedDates = [selectedDate];
          else if (self.config.mode === "multiple") {
              const selectedIndex = isDateSelected(selectedDate);
              if (selectedIndex)
                  self.selectedDates.splice(parseInt(selectedIndex), 1);
              else
                  self.selectedDates.push(selectedDate);
          }
          else if (self.config.mode === "range") {
              if (self.selectedDates.length === 2) {
                  self.clear(false, false);
              }
              self.latestSelectedDateObj = selectedDate;
              self.selectedDates.push(selectedDate);
              if (compareDates(selectedDate, self.selectedDates[0], true) !== 0)
                  self.selectedDates.sort((a, b) => a.getTime() - b.getTime());
          }
          setHoursFromInputs();
          if (shouldChangeMonth) {
              const isNewYear = self.currentYear !== selectedDate.getFullYear();
              self.currentYear = selectedDate.getFullYear();
              self.currentMonth = selectedDate.getMonth();
              if (isNewYear) {
                  triggerEvent("onYearChange");
                  buildMonthSwitch();
              }
              triggerEvent("onMonthChange");
          }
          updateNavigationCurrentMonth();
          buildDays();
          updateValue();
          if (!shouldChangeMonth &&
              self.config.mode !== "range" &&
              self.config.showMonths === 1)
              focusOnDayElem(target);
          else if (self.selectedDateElem !== undefined &&
              self.hourElement === undefined) {
              self.selectedDateElem && self.selectedDateElem.focus();
          }
          if (self.hourElement !== undefined)
              self.hourElement !== undefined && self.hourElement.focus();
          if (self.config.closeOnSelect) {
              const single = self.config.mode === "single" && !self.config.enableTime;
              const range = self.config.mode === "range" &&
                  self.selectedDates.length === 2 &&
                  !self.config.enableTime;
              if (single || range) {
                  focusAndClose();
              }
          }
          triggerChange();
      }
      const CALLBACKS = {
          locale: [setupLocale, updateWeekdays],
          showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
          minDate: [jumpToDate],
          maxDate: [jumpToDate],
          clickOpens: [
              () => {
                  if (self.config.clickOpens === true) {
                      bind(self._input, "focus", self.open);
                      bind(self._input, "click", self.open);
                  }
                  else {
                      self._input.removeEventListener("focus", self.open);
                      self._input.removeEventListener("click", self.open);
                  }
              },
          ],
      };
      function set(option, value) {
          if (option !== null && typeof option === "object") {
              Object.assign(self.config, option);
              for (const key in option) {
                  if (CALLBACKS[key] !== undefined)
                      CALLBACKS[key].forEach((x) => x());
              }
          }
          else {
              self.config[option] = value;
              if (CALLBACKS[option] !== undefined)
                  CALLBACKS[option].forEach((x) => x());
              else if (HOOKS.indexOf(option) > -1)
                  self.config[option] = arrayify(value);
          }
          self.redraw();
          updateValue(true);
      }
      function setSelectedDate(inputDate, format) {
          let dates = [];
          if (inputDate instanceof Array)
              dates = inputDate.map((d) => self.parseDate(d, format));
          else if (inputDate instanceof Date || typeof inputDate === "number")
              dates = [self.parseDate(inputDate, format)];
          else if (typeof inputDate === "string") {
              switch (self.config.mode) {
                  case "single":
                  case "time":
                      dates = [self.parseDate(inputDate, format)];
                      break;
                  case "multiple":
                      dates = inputDate
                          .split(self.config.conjunction)
                          .map((date) => self.parseDate(date, format));
                      break;
                  case "range":
                      dates = inputDate
                          .split(self.l10n.rangeSeparator)
                          .map((date) => self.parseDate(date, format));
                      break;
              }
          }
          else
              self.config.errorHandler(new Error(`Invalid date supplied: ${JSON.stringify(inputDate)}`));
          self.selectedDates = (self.config.allowInvalidPreload
              ? dates
              : dates.filter((d) => d instanceof Date && isEnabled(d, false)));
          if (self.config.mode === "range")
              self.selectedDates.sort((a, b) => a.getTime() - b.getTime());
      }
      function setDate(date, triggerChange = false, format = self.config.dateFormat) {
          if ((date !== 0 && !date) || (date instanceof Array && date.length === 0))
              return self.clear(triggerChange);
          setSelectedDate(date, format);
          self.latestSelectedDateObj =
              self.selectedDates[self.selectedDates.length - 1];
          self.redraw();
          jumpToDate(undefined, triggerChange);
          setHoursFromDate();
          if (self.selectedDates.length === 0) {
              self.clear(false);
          }
          updateValue(triggerChange);
          if (triggerChange)
              triggerEvent("onChange");
      }
      function parseDateRules(arr) {
          return arr
              .slice()
              .map((rule) => {
              if (typeof rule === "string" ||
                  typeof rule === "number" ||
                  rule instanceof Date) {
                  return self.parseDate(rule, undefined, true);
              }
              else if (rule &&
                  typeof rule === "object" &&
                  rule.from &&
                  rule.to)
                  return {
                      from: self.parseDate(rule.from, undefined),
                      to: self.parseDate(rule.to, undefined),
                  };
              return rule;
          })
              .filter((x) => x);
      }
      function setupDates() {
          self.selectedDates = [];
          self.now = self.parseDate(self.config.now) || new Date();
          const preloadedDate = self.config.defaultDate ||
              ((self.input.nodeName === "INPUT" ||
                  self.input.nodeName === "TEXTAREA") &&
                  self.input.placeholder &&
                  self.input.value === self.input.placeholder
                  ? null
                  : self.input.value);
          if (preloadedDate)
              setSelectedDate(preloadedDate, self.config.dateFormat);
          self._initialDate =
              self.selectedDates.length > 0
                  ? self.selectedDates[0]
                  : self.config.minDate &&
                      self.config.minDate.getTime() > self.now.getTime()
                      ? self.config.minDate
                      : self.config.maxDate &&
                          self.config.maxDate.getTime() < self.now.getTime()
                          ? self.config.maxDate
                          : self.now;
          self.currentYear = self._initialDate.getFullYear();
          self.currentMonth = self._initialDate.getMonth();
          if (self.selectedDates.length > 0)
              self.latestSelectedDateObj = self.selectedDates[0];
          if (self.config.minTime !== undefined)
              self.config.minTime = self.parseDate(self.config.minTime, "H:i");
          if (self.config.maxTime !== undefined)
              self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
          self.minDateHasTime =
              !!self.config.minDate &&
                  (self.config.minDate.getHours() > 0 ||
                      self.config.minDate.getMinutes() > 0 ||
                      self.config.minDate.getSeconds() > 0);
          self.maxDateHasTime =
              !!self.config.maxDate &&
                  (self.config.maxDate.getHours() > 0 ||
                      self.config.maxDate.getMinutes() > 0 ||
                      self.config.maxDate.getSeconds() > 0);
      }
      function setupInputs() {
          self.input = getInputElem();
          if (!self.input) {
              self.config.errorHandler(new Error("Invalid input element specified"));
              return;
          }
          self.input._type = self.input.type;
          self.input.type = "text";
          self.input.classList.add("flatpickr-input");
          self._input = self.input;
          if (self.config.altInput) {
              self.altInput = createElement(self.input.nodeName, self.config.altInputClass);
              self._input = self.altInput;
              self.altInput.placeholder = self.input.placeholder;
              self.altInput.disabled = self.input.disabled;
              self.altInput.required = self.input.required;
              self.altInput.tabIndex = self.input.tabIndex;
              self.altInput.type = "text";
              self.input.setAttribute("type", "hidden");
              if (!self.config.static && self.input.parentNode)
                  self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
          }
          if (!self.config.allowInput)
              self._input.setAttribute("readonly", "readonly");
          self._positionElement = self.config.positionElement || self._input;
      }
      function setupMobile() {
          const inputType = self.config.enableTime
              ? self.config.noCalendar
                  ? "time"
                  : "datetime-local"
              : "date";
          self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
          self.mobileInput.tabIndex = 1;
          self.mobileInput.type = inputType;
          self.mobileInput.disabled = self.input.disabled;
          self.mobileInput.required = self.input.required;
          self.mobileInput.placeholder = self.input.placeholder;
          self.mobileFormatStr =
              inputType === "datetime-local"
                  ? "Y-m-d\\TH:i:S"
                  : inputType === "date"
                      ? "Y-m-d"
                      : "H:i:S";
          if (self.selectedDates.length > 0) {
              self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
          }
          if (self.config.minDate)
              self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
          if (self.config.maxDate)
              self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
          if (self.input.getAttribute("step"))
              self.mobileInput.step = String(self.input.getAttribute("step"));
          self.input.type = "hidden";
          if (self.altInput !== undefined)
              self.altInput.type = "hidden";
          try {
              if (self.input.parentNode)
                  self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
          }
          catch (_a) { }
          bind(self.mobileInput, "change", (e) => {
              self.setDate(getEventTarget(e).value, false, self.mobileFormatStr);
              triggerEvent("onChange");
              triggerEvent("onClose");
          });
      }
      function toggle(e) {
          if (self.isOpen === true)
              return self.close();
          self.open(e);
      }
      function triggerEvent(event, data) {
          if (self.config === undefined)
              return;
          const hooks = self.config[event];
          if (hooks !== undefined && hooks.length > 0) {
              for (let i = 0; hooks[i] && i < hooks.length; i++)
                  hooks[i](self.selectedDates, self.input.value, self, data);
          }
          if (event === "onChange") {
              self.input.dispatchEvent(createEvent("change"));
              self.input.dispatchEvent(createEvent("input"));
          }
      }
      function createEvent(name) {
          const e = document.createEvent("Event");
          e.initEvent(name, true, true);
          return e;
      }
      function isDateSelected(date) {
          for (let i = 0; i < self.selectedDates.length; i++) {
              if (compareDates(self.selectedDates[i], date) === 0)
                  return "" + i;
          }
          return false;
      }
      function isDateInRange(date) {
          if (self.config.mode !== "range" || self.selectedDates.length < 2)
              return false;
          return (compareDates(date, self.selectedDates[0]) >= 0 &&
              compareDates(date, self.selectedDates[1]) <= 0);
      }
      function updateNavigationCurrentMonth() {
          if (self.config.noCalendar || self.isMobile || !self.monthNav)
              return;
          self.yearElements.forEach((yearElement, i) => {
              const d = new Date(self.currentYear, self.currentMonth, 1);
              d.setMonth(self.currentMonth + i);
              if (self.config.showMonths > 1 ||
                  self.config.monthSelectorType === "static") {
                  self.monthElements[i].textContent =
                      monthToStr$2(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " ";
              }
              else {
                  self.monthsDropdownContainer.value = d.getMonth().toString();
              }
              yearElement.value = d.getFullYear().toString();
          });
          self._hidePrevMonthArrow =
              self.config.minDate !== undefined &&
                  (self.currentYear === self.config.minDate.getFullYear()
                      ? self.currentMonth <= self.config.minDate.getMonth()
                      : self.currentYear < self.config.minDate.getFullYear());
          self._hideNextMonthArrow =
              self.config.maxDate !== undefined &&
                  (self.currentYear === self.config.maxDate.getFullYear()
                      ? self.currentMonth + 1 > self.config.maxDate.getMonth()
                      : self.currentYear > self.config.maxDate.getFullYear());
      }
      function getDateStr(format) {
          return self.selectedDates
              .map((dObj) => self.formatDate(dObj, format))
              .filter((d, i, arr) => self.config.mode !== "range" ||
              self.config.enableTime ||
              arr.indexOf(d) === i)
              .join(self.config.mode !== "range"
              ? self.config.conjunction
              : self.l10n.rangeSeparator);
      }
      function updateValue(triggerChange = true) {
          if (self.mobileInput !== undefined && self.mobileFormatStr) {
              self.mobileInput.value =
                  self.latestSelectedDateObj !== undefined
                      ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr)
                      : "";
          }
          self.input.value = getDateStr(self.config.dateFormat);
          if (self.altInput !== undefined) {
              self.altInput.value = getDateStr(self.config.altFormat);
          }
          if (triggerChange !== false)
              triggerEvent("onValueUpdate");
      }
      function onMonthNavClick(e) {
          const eventTarget = getEventTarget(e);
          const isPrevMonth = self.prevMonthNav.contains(eventTarget);
          const isNextMonth = self.nextMonthNav.contains(eventTarget);
          if (isPrevMonth || isNextMonth) {
              changeMonth(isPrevMonth ? -1 : 1);
          }
          else if (self.yearElements.indexOf(eventTarget) >= 0) {
              eventTarget.select();
          }
          else if (eventTarget.classList.contains("arrowUp")) {
              self.changeYear(self.currentYear + 1);
          }
          else if (eventTarget.classList.contains("arrowDown")) {
              self.changeYear(self.currentYear - 1);
          }
      }
      function timeWrapper(e) {
          e.preventDefault();
          const isKeyDown = e.type === "keydown", eventTarget = getEventTarget(e), input = eventTarget;
          if (self.amPM !== undefined && eventTarget === self.amPM) {
              self.amPM.textContent =
                  self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
          }
          const min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e.delta ||
              (isKeyDown ? (e.which === 38 ? 1 : -1) : 0);
          let newValue = curValue + step * delta;
          if (typeof input.value !== "undefined" && input.value.length === 2) {
              const isHourElem = input === self.hourElement, isMinuteElem = input === self.minuteElement;
              if (newValue < min) {
                  newValue =
                      max +
                          newValue +
                          int(!isHourElem) +
                          (int(isHourElem) && int(!self.amPM));
                  if (isMinuteElem)
                      incrementNumInput(undefined, -1, self.hourElement);
              }
              else if (newValue > max) {
                  newValue =
                      input === self.hourElement ? newValue - max - int(!self.amPM) : min;
                  if (isMinuteElem)
                      incrementNumInput(undefined, 1, self.hourElement);
              }
              if (self.amPM &&
                  isHourElem &&
                  (step === 1
                      ? newValue + curValue === 23
                      : Math.abs(newValue - curValue) > step)) {
                  self.amPM.textContent =
                      self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
              }
              input.value = pad(newValue);
          }
      }
      init();
      return self;
  }
  function _flatpickr(nodeList, config) {
      const nodes = Array.prototype.slice
          .call(nodeList)
          .filter((x) => x instanceof HTMLElement);
      const instances = [];
      for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          try {
              if (node.getAttribute("data-fp-omit") !== null)
                  continue;
              if (node._flatpickr !== undefined) {
                  node._flatpickr.destroy();
                  node._flatpickr = undefined;
              }
              node._flatpickr = FlatpickrInstance(node, config || {});
              instances.push(node._flatpickr);
          }
          catch (e) {
              console.error(e);
          }
      }
      return instances.length === 1 ? instances[0] : instances;
  }
  if (typeof HTMLElement !== "undefined" &&
      typeof HTMLCollection !== "undefined" &&
      typeof NodeList !== "undefined") {
      HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
          return _flatpickr(this, config);
      };
      HTMLElement.prototype.flatpickr = function (config) {
          return _flatpickr([this], config);
      };
  }
  var flatpickr = function (selector, config) {
      if (typeof selector === "string") {
          return _flatpickr(window.document.querySelectorAll(selector), config);
      }
      else if (selector instanceof Node) {
          return _flatpickr([selector], config);
      }
      else {
          return _flatpickr(selector, config);
      }
  };
  flatpickr.defaultConfig = {};
  flatpickr.l10ns = {
      en: Object.assign({}, english),
      default: Object.assign({}, english),
  };
  flatpickr.localize = (l10n) => {
      flatpickr.l10ns.default = Object.assign(Object.assign({}, flatpickr.l10ns.default), l10n);
  };
  flatpickr.setDefaults = (config) => {
      flatpickr.defaultConfig = Object.assign(Object.assign({}, flatpickr.defaultConfig), config);
  };
  flatpickr.parseDate = createDateParser({});
  flatpickr.formatDate = createDateFormatter({});
  flatpickr.compareDates = compareDates;
  if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
      jQuery.fn.flatpickr = function (config) {
          return _flatpickr(this, config);
      };
  }
  Date.prototype.fp_incr = function (days) {
      return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
  };
  if (typeof window !== "undefined") {
      window.flatpickr = flatpickr;
  }

  var l10n$1 = {exports: {}};

  (function (module, exports) {
  (function (global, factory) {
      factory(exports) ;
  }(commonjsGlobal, (function (exports) {
      /*! *****************************************************************************
      Copyright (c) Microsoft Corporation.

      Permission to use, copy, modify, and/or distribute this software for any
      purpose with or without fee is hereby granted.

      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.
      ***************************************************************************** */

      var __assign = function() {
          __assign = Object.assign || function __assign(t) {
              for (var s, i = 1, n = arguments.length; i < n; i++) {
                  s = arguments[i];
                  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
              }
              return t;
          };
          return __assign.apply(this, arguments);
      };

      var fp = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Arabic = {
          weekdays: {
              shorthand: ["أحد", "اثنين", "ثلاثاء", "أربعاء", "خميس", "جمعة", "سبت"],
              longhand: [
                  "الأحد",
                  "الاثنين",
                  "الثلاثاء",
                  "الأربعاء",
                  "الخميس",
                  "الجمعة",
                  "السبت",
              ],
          },
          months: {
              shorthand: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
              longhand: [
                  "يناير",
                  "فبراير",
                  "مارس",
                  "أبريل",
                  "مايو",
                  "يونيو",
                  "يوليو",
                  "أغسطس",
                  "سبتمبر",
                  "أكتوبر",
                  "نوفمبر",
                  "ديسمبر",
              ],
          },
          rangeSeparator: " - ",
      };
      fp.l10ns.ar = Arabic;
      fp.l10ns;

      var fp$1 = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Austria = {
          weekdays: {
              shorthand: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
              longhand: [
                  "Sonntag",
                  "Montag",
                  "Dienstag",
                  "Mittwoch",
                  "Donnerstag",
                  "Freitag",
                  "Samstag",
              ],
          },
          months: {
              shorthand: [
                  "Jän",
                  "Feb",
                  "Mär",
                  "Apr",
                  "Mai",
                  "Jun",
                  "Jul",
                  "Aug",
                  "Sep",
                  "Okt",
                  "Nov",
                  "Dez",
              ],
              longhand: [
                  "Jänner",
                  "Februar",
                  "März",
                  "April",
                  "Mai",
                  "Juni",
                  "Juli",
                  "August",
                  "September",
                  "Oktober",
                  "November",
                  "Dezember",
              ],
          },
          firstDayOfWeek: 1,
          weekAbbreviation: "KW",
          rangeSeparator: " bis ",
          scrollTitle: "Zum Ändern scrollen",
          toggleTitle: "Zum Umschalten klicken",
      };
      fp$1.l10ns.at = Austria;
      fp$1.l10ns;

      var fp$2 = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Azerbaijan = {
          weekdays: {
              shorthand: ["B.", "B.e.", "Ç.a.", "Ç.", "C.a.", "C.", "Ş."],
              longhand: [
                  "Bazar",
                  "Bazar ertəsi",
                  "Çərşənbə axşamı",
                  "Çərşənbə",
                  "Cümə axşamı",
                  "Cümə",
                  "Şənbə",
              ],
          },
          months: {
              shorthand: [
                  "Yan",
                  "Fev",
                  "Mar",
                  "Apr",
                  "May",
                  "İyn",
                  "İyl",
                  "Avq",
                  "Sen",
                  "Okt",
                  "Noy",
                  "Dek",
              ],
              longhand: [
                  "Yanvar",
                  "Fevral",
                  "Mart",
                  "Aprel",
                  "May",
                  "İyun",
                  "İyul",
                  "Avqust",
                  "Sentyabr",
                  "Oktyabr",
                  "Noyabr",
                  "Dekabr",
              ],
          },
          firstDayOfWeek: 1,
          ordinal: function () {
              return ".";
          },
          rangeSeparator: " - ",
          weekAbbreviation: "Hf",
          scrollTitle: "Artırmaq üçün sürüşdürün",
          toggleTitle: "Aç / Bağla",
          amPM: ["GƏ", "GS"],
          time_24hr: true,
      };
      fp$2.l10ns.az = Azerbaijan;
      fp$2.l10ns;

      var fp$3 = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Belarusian = {
          weekdays: {
              shorthand: ["Нд", "Пн", "Аў", "Ср", "Чц", "Пт", "Сб"],
              longhand: [
                  "Нядзеля",
                  "Панядзелак",
                  "Аўторак",
                  "Серада",
                  "Чацвер",
                  "Пятніца",
                  "Субота",
              ],
          },
          months: {
              shorthand: [
                  "Сту",
                  "Лют",
                  "Сак",
                  "Кра",
                  "Тра",
                  "Чэр",
                  "Ліп",
                  "Жні",
                  "Вер",
                  "Кас",
                  "Ліс",
                  "Сне",
              ],
              longhand: [
                  "Студзень",
                  "Люты",
                  "Сакавік",
                  "Красавік",
                  "Травень",
                  "Чэрвень",
                  "Ліпень",
                  "Жнівень",
                  "Верасень",
                  "Кастрычнік",
                  "Лістапад",
                  "Снежань",
              ],
          },
          firstDayOfWeek: 1,
          ordinal: function () {
              return "";
          },
          rangeSeparator: " — ",
          weekAbbreviation: "Тыд.",
          scrollTitle: "Пракруціце для павелічэння",
          toggleTitle: "Націсніце для пераключэння",
          amPM: ["ДП", "ПП"],
          yearAriaLabel: "Год",
          time_24hr: true,
      };
      fp$3.l10ns.be = Belarusian;
      fp$3.l10ns;

      var fp$4 = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Bosnian = {
          firstDayOfWeek: 1,
          weekdays: {
              shorthand: ["Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"],
              longhand: [
                  "Nedjelja",
                  "Ponedjeljak",
                  "Utorak",
                  "Srijeda",
                  "Četvrtak",
                  "Petak",
                  "Subota",
              ],
          },
          months: {
              shorthand: [
                  "Jan",
                  "Feb",
                  "Mar",
                  "Apr",
                  "Maj",
                  "Jun",
                  "Jul",
                  "Avg",
                  "Sep",
                  "Okt",
                  "Nov",
                  "Dec",
              ],
              longhand: [
                  "Januar",
                  "Februar",
                  "Mart",
                  "April",
                  "Maj",
                  "Juni",
                  "Juli",
                  "Avgust",
                  "Septembar",
                  "Oktobar",
                  "Novembar",
                  "Decembar",
              ],
          },
          time_24hr: true,
      };
      fp$4.l10ns.bs = Bosnian;
      fp$4.l10ns;

      var fp$5 = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Bulgarian = {
          weekdays: {
              shorthand: ["Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
              longhand: [
                  "Неделя",
                  "Понеделник",
                  "Вторник",
                  "Сряда",
                  "Четвъртък",
                  "Петък",
                  "Събота",
              ],
          },
          months: {
              shorthand: [
                  "Яну",
                  "Фев",
                  "Март",
                  "Апр",
                  "Май",
                  "Юни",
                  "Юли",
                  "Авг",
                  "Сеп",
                  "Окт",
                  "Ное",
                  "Дек",
              ],
              longhand: [
                  "Януари",
                  "Февруари",
                  "Март",
                  "Април",
                  "Май",
                  "Юни",
                  "Юли",
                  "Август",
                  "Септември",
                  "Октомври",
                  "Ноември",
                  "Декември",
              ],
          },
          time_24hr: true,
          firstDayOfWeek: 1,
      };
      fp$5.l10ns.bg = Bulgarian;
      fp$5.l10ns;

      var fp$6 = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Bangla = {
          weekdays: {
              shorthand: ["রবি", "সোম", "মঙ্গল", "বুধ", "বৃহস্পতি", "শুক্র", "শনি"],
              longhand: [
                  "রবিবার",
                  "সোমবার",
                  "মঙ্গলবার",
                  "বুধবার",
                  "বৃহস্পতিবার",
                  "শুক্রবার",
                  "শনিবার",
              ],
          },
          months: {
              shorthand: [
                  "জানু",
                  "ফেব্রু",
                  "মার্চ",
                  "এপ্রিল",
                  "মে",
                  "জুন",
                  "জুলাই",
                  "আগ",
                  "সেপ্টে",
                  "অক্টো",
                  "নভে",
                  "ডিসে",
              ],
              longhand: [
                  "জানুয়ারী",
                  "ফেব্রুয়ারী",
                  "মার্চ",
                  "এপ্রিল",
                  "মে",
                  "জুন",
                  "জুলাই",
                  "আগস্ট",
                  "সেপ্টেম্বর",
                  "অক্টোবর",
                  "নভেম্বর",
                  "ডিসেম্বর",
              ],
          },
      };
      fp$6.l10ns.bn = Bangla;
      fp$6.l10ns;

      var fp$7 = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Catalan = {
          weekdays: {
              shorthand: ["Dg", "Dl", "Dt", "Dc", "Dj", "Dv", "Ds"],
              longhand: [
                  "Diumenge",
                  "Dilluns",
                  "Dimarts",
                  "Dimecres",
                  "Dijous",
                  "Divendres",
                  "Dissabte",
              ],
          },
          months: {
              shorthand: [
                  "Gen",
                  "Febr",
                  "Març",
                  "Abr",
                  "Maig",
                  "Juny",
                  "Jul",
                  "Ag",
                  "Set",
                  "Oct",
                  "Nov",
                  "Des",
              ],
              longhand: [
                  "Gener",
                  "Febrer",
                  "Març",
                  "Abril",
                  "Maig",
                  "Juny",
                  "Juliol",
                  "Agost",
                  "Setembre",
                  "Octubre",
                  "Novembre",
                  "Desembre",
              ],
          },
          ordinal: function (nth) {
              var s = nth % 100;
              if (s > 3 && s < 21)
                  return "è";
              switch (s % 10) {
                  case 1:
                      return "r";
                  case 2:
                      return "n";
                  case 3:
                      return "r";
                  case 4:
                      return "t";
                  default:
                      return "è";
              }
          },
          firstDayOfWeek: 1,
          time_24hr: true,
      };
      fp$7.l10ns.cat = fp$7.l10ns.ca = Catalan;
      fp$7.l10ns;

      var fp$8 = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Czech = {
          weekdays: {
              shorthand: ["Ne", "Po", "Út", "St", "Čt", "Pá", "So"],
              longhand: [
                  "Neděle",
                  "Pondělí",
                  "Úterý",
                  "Středa",
                  "Čtvrtek",
                  "Pátek",
                  "Sobota",
              ],
          },
          months: {
              shorthand: [
                  "Led",
                  "Ún",
                  "Bře",
                  "Dub",
                  "Kvě",
                  "Čer",
                  "Čvc",
                  "Srp",
                  "Zář",
                  "Říj",
                  "Lis",
                  "Pro",
              ],
              longhand: [
                  "Leden",
                  "Únor",
                  "Březen",
                  "Duben",
                  "Květen",
                  "Červen",
                  "Červenec",
                  "Srpen",
                  "Září",
                  "Říjen",
                  "Listopad",
                  "Prosinec",
              ],
          },
          firstDayOfWeek: 1,
          ordinal: function () {
              return ".";
          },
          rangeSeparator: " do ",
          weekAbbreviation: "Týd.",
          scrollTitle: "Rolujte pro změnu",
          toggleTitle: "Přepnout dopoledne/odpoledne",
          amPM: ["dop.", "odp."],
          yearAriaLabel: "Rok",
          time_24hr: true,
      };
      fp$8.l10ns.cs = Czech;
      fp$8.l10ns;

      var fp$9 = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Welsh = {
          weekdays: {
              shorthand: ["Sul", "Llun", "Maw", "Mer", "Iau", "Gwe", "Sad"],
              longhand: [
                  "Dydd Sul",
                  "Dydd Llun",
                  "Dydd Mawrth",
                  "Dydd Mercher",
                  "Dydd Iau",
                  "Dydd Gwener",
                  "Dydd Sadwrn",
              ],
          },
          months: {
              shorthand: [
                  "Ion",
                  "Chwef",
                  "Maw",
                  "Ebr",
                  "Mai",
                  "Meh",
                  "Gorff",
                  "Awst",
                  "Medi",
                  "Hyd",
                  "Tach",
                  "Rhag",
              ],
              longhand: [
                  "Ionawr",
                  "Chwefror",
                  "Mawrth",
                  "Ebrill",
                  "Mai",
                  "Mehefin",
                  "Gorffennaf",
                  "Awst",
                  "Medi",
                  "Hydref",
                  "Tachwedd",
                  "Rhagfyr",
              ],
          },
          firstDayOfWeek: 1,
          ordinal: function (nth) {
              if (nth === 1)
                  return "af";
              if (nth === 2)
                  return "ail";
              if (nth === 3 || nth === 4)
                  return "ydd";
              if (nth === 5 || nth === 6)
                  return "ed";
              if ((nth >= 7 && nth <= 10) ||
                  nth == 12 ||
                  nth == 15 ||
                  nth == 18 ||
                  nth == 20)
                  return "fed";
              if (nth == 11 ||
                  nth == 13 ||
                  nth == 14 ||
                  nth == 16 ||
                  nth == 17 ||
                  nth == 19)
                  return "eg";
              if (nth >= 21 && nth <= 39)
                  return "ain";
              // Inconclusive.
              return "";
          },
          time_24hr: true,
      };
      fp$9.l10ns.cy = Welsh;
      fp$9.l10ns;

      var fp$a = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Danish = {
          weekdays: {
              shorthand: ["søn", "man", "tir", "ons", "tors", "fre", "lør"],
              longhand: [
                  "søndag",
                  "mandag",
                  "tirsdag",
                  "onsdag",
                  "torsdag",
                  "fredag",
                  "lørdag",
              ],
          },
          months: {
              shorthand: [
                  "jan",
                  "feb",
                  "mar",
                  "apr",
                  "maj",
                  "jun",
                  "jul",
                  "aug",
                  "sep",
                  "okt",
                  "nov",
                  "dec",
              ],
              longhand: [
                  "januar",
                  "februar",
                  "marts",
                  "april",
                  "maj",
                  "juni",
                  "juli",
                  "august",
                  "september",
                  "oktober",
                  "november",
                  "december",
              ],
          },
          ordinal: function () {
              return ".";
          },
          firstDayOfWeek: 1,
          rangeSeparator: " til ",
          weekAbbreviation: "uge",
          time_24hr: true,
      };
      fp$a.l10ns.da = Danish;
      fp$a.l10ns;

      var fp$b = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var German = {
          weekdays: {
              shorthand: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
              longhand: [
                  "Sonntag",
                  "Montag",
                  "Dienstag",
                  "Mittwoch",
                  "Donnerstag",
                  "Freitag",
                  "Samstag",
              ],
          },
          months: {
              shorthand: [
                  "Jan",
                  "Feb",
                  "Mär",
                  "Apr",
                  "Mai",
                  "Jun",
                  "Jul",
                  "Aug",
                  "Sep",
                  "Okt",
                  "Nov",
                  "Dez",
              ],
              longhand: [
                  "Januar",
                  "Februar",
                  "März",
                  "April",
                  "Mai",
                  "Juni",
                  "Juli",
                  "August",
                  "September",
                  "Oktober",
                  "November",
                  "Dezember",
              ],
          },
          firstDayOfWeek: 1,
          weekAbbreviation: "KW",
          rangeSeparator: " bis ",
          scrollTitle: "Zum Ändern scrollen",
          toggleTitle: "Zum Umschalten klicken",
          time_24hr: true,
      };
      fp$b.l10ns.de = German;
      fp$b.l10ns;

      var english = {
          weekdays: {
              shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
              longhand: [
                  "Sunday",
                  "Monday",
                  "Tuesday",
                  "Wednesday",
                  "Thursday",
                  "Friday",
                  "Saturday",
              ],
          },
          months: {
              shorthand: [
                  "Jan",
                  "Feb",
                  "Mar",
                  "Apr",
                  "May",
                  "Jun",
                  "Jul",
                  "Aug",
                  "Sep",
                  "Oct",
                  "Nov",
                  "Dec",
              ],
              longhand: [
                  "January",
                  "February",
                  "March",
                  "April",
                  "May",
                  "June",
                  "July",
                  "August",
                  "September",
                  "October",
                  "November",
                  "December",
              ],
          },
          daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
          firstDayOfWeek: 0,
          ordinal: function (nth) {
              var s = nth % 100;
              if (s > 3 && s < 21)
                  return "th";
              switch (s % 10) {
                  case 1:
                      return "st";
                  case 2:
                      return "nd";
                  case 3:
                      return "rd";
                  default:
                      return "th";
              }
          },
          rangeSeparator: " to ",
          weekAbbreviation: "Wk",
          scrollTitle: "Scroll to increment",
          toggleTitle: "Click to toggle",
          amPM: ["AM", "PM"],
          yearAriaLabel: "Year",
          monthAriaLabel: "Month",
          hourAriaLabel: "Hour",
          minuteAriaLabel: "Minute",
          time_24hr: false,
      };

      var fp$c = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Esperanto = {
          firstDayOfWeek: 1,
          rangeSeparator: " ĝis ",
          weekAbbreviation: "Sem",
          scrollTitle: "Rulumu por pligrandigi la valoron",
          toggleTitle: "Klaku por ŝalti",
          weekdays: {
              shorthand: ["Dim", "Lun", "Mar", "Mer", "Ĵaŭ", "Ven", "Sab"],
              longhand: [
                  "dimanĉo",
                  "lundo",
                  "mardo",
                  "merkredo",
                  "ĵaŭdo",
                  "vendredo",
                  "sabato",
              ],
          },
          months: {
              shorthand: [
                  "Jan",
                  "Feb",
                  "Mar",
                  "Apr",
                  "Maj",
                  "Jun",
                  "Jul",
                  "Aŭg",
                  "Sep",
                  "Okt",
                  "Nov",
                  "Dec",
              ],
              longhand: [
                  "januaro",
                  "februaro",
                  "marto",
                  "aprilo",
                  "majo",
                  "junio",
                  "julio",
                  "aŭgusto",
                  "septembro",
                  "oktobro",
                  "novembro",
                  "decembro",
              ],
          },
          ordinal: function () {
              return "-a";
          },
          time_24hr: true,
      };
      fp$c.l10ns.eo = Esperanto;
      fp$c.l10ns;

      var fp$d = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Spanish = {
          weekdays: {
              shorthand: ["Dom", "Lun", "Mar", "Mié", "Jue", "Vie", "Sáb"],
              longhand: [
                  "Domingo",
                  "Lunes",
                  "Martes",
                  "Miércoles",
                  "Jueves",
                  "Viernes",
                  "Sábado",
              ],
          },
          months: {
              shorthand: [
                  "Ene",
                  "Feb",
                  "Mar",
                  "Abr",
                  "May",
                  "Jun",
                  "Jul",
                  "Ago",
                  "Sep",
                  "Oct",
                  "Nov",
                  "Dic",
              ],
              longhand: [
                  "Enero",
                  "Febrero",
                  "Marzo",
                  "Abril",
                  "Mayo",
                  "Junio",
                  "Julio",
                  "Agosto",
                  "Septiembre",
                  "Octubre",
                  "Noviembre",
                  "Diciembre",
              ],
          },
          ordinal: function () {
              return "º";
          },
          firstDayOfWeek: 1,
          rangeSeparator: " a ",
          time_24hr: true,
      };
      fp$d.l10ns.es = Spanish;
      fp$d.l10ns;

      var fp$e = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Estonian = {
          weekdays: {
              shorthand: ["P", "E", "T", "K", "N", "R", "L"],
              longhand: [
                  "Pühapäev",
                  "Esmaspäev",
                  "Teisipäev",
                  "Kolmapäev",
                  "Neljapäev",
                  "Reede",
                  "Laupäev",
              ],
          },
          months: {
              shorthand: [
                  "Jaan",
                  "Veebr",
                  "Märts",
                  "Apr",
                  "Mai",
                  "Juuni",
                  "Juuli",
                  "Aug",
                  "Sept",
                  "Okt",
                  "Nov",
                  "Dets",
              ],
              longhand: [
                  "Jaanuar",
                  "Veebruar",
                  "Märts",
                  "Aprill",
                  "Mai",
                  "Juuni",
                  "Juuli",
                  "August",
                  "September",
                  "Oktoober",
                  "November",
                  "Detsember",
              ],
          },
          firstDayOfWeek: 1,
          ordinal: function () {
              return ".";
          },
          weekAbbreviation: "Näd",
          rangeSeparator: " kuni ",
          scrollTitle: "Keri, et suurendada",
          toggleTitle: "Klõpsa, et vahetada",
          time_24hr: true,
      };
      fp$e.l10ns.et = Estonian;
      fp$e.l10ns;

      var fp$f = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Persian = {
          weekdays: {
              shorthand: ["یک", "دو", "سه", "چهار", "پنج", "جمعه", "شنبه"],
              longhand: [
                  "یک‌شنبه",
                  "دوشنبه",
                  "سه‌شنبه",
                  "چهارشنبه",
                  "پنچ‌شنبه",
                  "جمعه",
                  "شنبه",
              ],
          },
          months: {
              shorthand: [
                  "ژانویه",
                  "فوریه",
                  "مارس",
                  "آوریل",
                  "مه",
                  "ژوئن",
                  "ژوئیه",
                  "اوت",
                  "سپتامبر",
                  "اکتبر",
                  "نوامبر",
                  "دسامبر",
              ],
              longhand: [
                  "ژانویه",
                  "فوریه",
                  "مارس",
                  "آوریل",
                  "مه",
                  "ژوئن",
                  "ژوئیه",
                  "اوت",
                  "سپتامبر",
                  "اکتبر",
                  "نوامبر",
                  "دسامبر",
              ],
          },
          firstDayOfWeek: 6,
          ordinal: function () {
              return "";
          },
      };
      fp$f.l10ns.fa = Persian;
      fp$f.l10ns;

      var fp$g = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Finnish = {
          firstDayOfWeek: 1,
          weekdays: {
              shorthand: ["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"],
              longhand: [
                  "Sunnuntai",
                  "Maanantai",
                  "Tiistai",
                  "Keskiviikko",
                  "Torstai",
                  "Perjantai",
                  "Lauantai",
              ],
          },
          months: {
              shorthand: [
                  "Tammi",
                  "Helmi",
                  "Maalis",
                  "Huhti",
                  "Touko",
                  "Kesä",
                  "Heinä",
                  "Elo",
                  "Syys",
                  "Loka",
                  "Marras",
                  "Joulu",
              ],
              longhand: [
                  "Tammikuu",
                  "Helmikuu",
                  "Maaliskuu",
                  "Huhtikuu",
                  "Toukokuu",
                  "Kesäkuu",
                  "Heinäkuu",
                  "Elokuu",
                  "Syyskuu",
                  "Lokakuu",
                  "Marraskuu",
                  "Joulukuu",
              ],
          },
          ordinal: function () {
              return ".";
          },
          time_24hr: true,
      };
      fp$g.l10ns.fi = Finnish;
      fp$g.l10ns;

      var fp$h = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Faroese = {
          weekdays: {
              shorthand: ["Sun", "Mán", "Týs", "Mik", "Hós", "Frí", "Ley"],
              longhand: [
                  "Sunnudagur",
                  "Mánadagur",
                  "Týsdagur",
                  "Mikudagur",
                  "Hósdagur",
                  "Fríggjadagur",
                  "Leygardagur",
              ],
          },
          months: {
              shorthand: [
                  "Jan",
                  "Feb",
                  "Mar",
                  "Apr",
                  "Mai",
                  "Jun",
                  "Jul",
                  "Aug",
                  "Sep",
                  "Okt",
                  "Nov",
                  "Des",
              ],
              longhand: [
                  "Januar",
                  "Februar",
                  "Mars",
                  "Apríl",
                  "Mai",
                  "Juni",
                  "Juli",
                  "August",
                  "Septembur",
                  "Oktobur",
                  "Novembur",
                  "Desembur",
              ],
          },
          ordinal: function () {
              return ".";
          },
          firstDayOfWeek: 1,
          rangeSeparator: " til ",
          weekAbbreviation: "vika",
          scrollTitle: "Rulla fyri at broyta",
          toggleTitle: "Trýst fyri at skifta",
          yearAriaLabel: "Ár",
          time_24hr: true,
      };
      fp$h.l10ns.fo = Faroese;
      fp$h.l10ns;

      var fp$i = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var French = {
          firstDayOfWeek: 1,
          weekdays: {
              shorthand: ["dim", "lun", "mar", "mer", "jeu", "ven", "sam"],
              longhand: [
                  "dimanche",
                  "lundi",
                  "mardi",
                  "mercredi",
                  "jeudi",
                  "vendredi",
                  "samedi",
              ],
          },
          months: {
              shorthand: [
                  "janv",
                  "févr",
                  "mars",
                  "avr",
                  "mai",
                  "juin",
                  "juil",
                  "août",
                  "sept",
                  "oct",
                  "nov",
                  "déc",
              ],
              longhand: [
                  "janvier",
                  "février",
                  "mars",
                  "avril",
                  "mai",
                  "juin",
                  "juillet",
                  "août",
                  "septembre",
                  "octobre",
                  "novembre",
                  "décembre",
              ],
          },
          ordinal: function (nth) {
              if (nth > 1)
                  return "";
              return "er";
          },
          rangeSeparator: " au ",
          weekAbbreviation: "Sem",
          scrollTitle: "Défiler pour augmenter la valeur",
          toggleTitle: "Cliquer pour basculer",
          time_24hr: true,
      };
      fp$i.l10ns.fr = French;
      fp$i.l10ns;

      var fp$j = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Greek = {
          weekdays: {
              shorthand: ["Κυ", "Δε", "Τρ", "Τε", "Πέ", "Πα", "Σά"],
              longhand: [
                  "Κυριακή",
                  "Δευτέρα",
                  "Τρίτη",
                  "Τετάρτη",
                  "Πέμπτη",
                  "Παρασκευή",
                  "Σάββατο",
              ],
          },
          months: {
              shorthand: [
                  "Ιαν",
                  "Φεβ",
                  "Μάρ",
                  "Απρ",
                  "Μάι",
                  "Ιού",
                  "Ιού",
                  "Αύγ",
                  "Σεπ",
                  "Οκτ",
                  "Νοέ",
                  "Δεκ",
              ],
              longhand: [
                  "Ιανουάριος",
                  "Φεβρουάριος",
                  "Μάρτιος",
                  "Απρίλιος",
                  "Μάιος",
                  "Ιούνιος",
                  "Ιούλιος",
                  "Αύγουστος",
                  "Σεπτέμβριος",
                  "Οκτώβριος",
                  "Νοέμβριος",
                  "Δεκέμβριος",
              ],
          },
          firstDayOfWeek: 1,
          ordinal: function () {
              return "";
          },
          weekAbbreviation: "Εβδ",
          rangeSeparator: " έως ",
          scrollTitle: "Μετακυλήστε για προσαύξηση",
          toggleTitle: "Κάντε κλικ για αλλαγή",
          amPM: ["ΠΜ", "ΜΜ"],
      };
      fp$j.l10ns.gr = Greek;
      fp$j.l10ns;

      var fp$k = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Hebrew = {
          weekdays: {
              shorthand: ["א", "ב", "ג", "ד", "ה", "ו", "ש"],
              longhand: ["ראשון", "שני", "שלישי", "רביעי", "חמישי", "שישי", "שבת"],
          },
          months: {
              shorthand: [
                  "ינו׳",
                  "פבר׳",
                  "מרץ",
                  "אפר׳",
                  "מאי",
                  "יוני",
                  "יולי",
                  "אוג׳",
                  "ספט׳",
                  "אוק׳",
                  "נוב׳",
                  "דצמ׳",
              ],
              longhand: [
                  "ינואר",
                  "פברואר",
                  "מרץ",
                  "אפריל",
                  "מאי",
                  "יוני",
                  "יולי",
                  "אוגוסט",
                  "ספטמבר",
                  "אוקטובר",
                  "נובמבר",
                  "דצמבר",
              ],
          },
          rangeSeparator: " אל ",
          time_24hr: true,
      };
      fp$k.l10ns.he = Hebrew;
      fp$k.l10ns;

      var fp$l = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Hindi = {
          weekdays: {
              shorthand: ["रवि", "सोम", "मंगल", "बुध", "गुरु", "शुक्र", "शनि"],
              longhand: [
                  "रविवार",
                  "सोमवार",
                  "मंगलवार",
                  "बुधवार",
                  "गुरुवार",
                  "शुक्रवार",
                  "शनिवार",
              ],
          },
          months: {
              shorthand: [
                  "जन",
                  "फर",
                  "मार्च",
                  "अप्रेल",
                  "मई",
                  "जून",
                  "जूलाई",
                  "अग",
                  "सित",
                  "अक्ट",
                  "नव",
                  "दि",
              ],
              longhand: [
                  "जनवरी ",
                  "फरवरी",
                  "मार्च",
                  "अप्रेल",
                  "मई",
                  "जून",
                  "जूलाई",
                  "अगस्त ",
                  "सितम्बर",
                  "अक्टूबर",
                  "नवम्बर",
                  "दिसम्बर",
              ],
          },
      };
      fp$l.l10ns.hi = Hindi;
      fp$l.l10ns;

      var fp$m = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Croatian = {
          firstDayOfWeek: 1,
          weekdays: {
              shorthand: ["Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"],
              longhand: [
                  "Nedjelja",
                  "Ponedjeljak",
                  "Utorak",
                  "Srijeda",
                  "Četvrtak",
                  "Petak",
                  "Subota",
              ],
          },
          months: {
              shorthand: [
                  "Sij",
                  "Velj",
                  "Ožu",
                  "Tra",
                  "Svi",
                  "Lip",
                  "Srp",
                  "Kol",
                  "Ruj",
                  "Lis",
                  "Stu",
                  "Pro",
              ],
              longhand: [
                  "Siječanj",
                  "Veljača",
                  "Ožujak",
                  "Travanj",
                  "Svibanj",
                  "Lipanj",
                  "Srpanj",
                  "Kolovoz",
                  "Rujan",
                  "Listopad",
                  "Studeni",
                  "Prosinac",
              ],
          },
          time_24hr: true,
      };
      fp$m.l10ns.hr = Croatian;
      fp$m.l10ns;

      var fp$n = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Hungarian = {
          firstDayOfWeek: 1,
          weekdays: {
              shorthand: ["V", "H", "K", "Sz", "Cs", "P", "Szo"],
              longhand: [
                  "Vasárnap",
                  "Hétfő",
                  "Kedd",
                  "Szerda",
                  "Csütörtök",
                  "Péntek",
                  "Szombat",
              ],
          },
          months: {
              shorthand: [
                  "Jan",
                  "Feb",
                  "Már",
                  "Ápr",
                  "Máj",
                  "Jún",
                  "Júl",
                  "Aug",
                  "Szep",
                  "Okt",
                  "Nov",
                  "Dec",
              ],
              longhand: [
                  "Január",
                  "Február",
                  "Március",
                  "Április",
                  "Május",
                  "Június",
                  "Július",
                  "Augusztus",
                  "Szeptember",
                  "Október",
                  "November",
                  "December",
              ],
          },
          ordinal: function () {
              return ".";
          },
          weekAbbreviation: "Hét",
          scrollTitle: "Görgessen",
          toggleTitle: "Kattintson a váltáshoz",
          rangeSeparator: " - ",
          time_24hr: true,
      };
      fp$n.l10ns.hu = Hungarian;
      fp$n.l10ns;

      var fp$o = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Indonesian = {
          weekdays: {
              shorthand: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"],
              longhand: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"],
          },
          months: {
              shorthand: [
                  "Jan",
                  "Feb",
                  "Mar",
                  "Apr",
                  "Mei",
                  "Jun",
                  "Jul",
                  "Agu",
                  "Sep",
                  "Okt",
                  "Nov",
                  "Des",
              ],
              longhand: [
                  "Januari",
                  "Februari",
                  "Maret",
                  "April",
                  "Mei",
                  "Juni",
                  "Juli",
                  "Agustus",
                  "September",
                  "Oktober",
                  "November",
                  "Desember",
              ],
          },
          firstDayOfWeek: 1,
          ordinal: function () {
              return "";
          },
          time_24hr: true,
          rangeSeparator: " - ",
      };
      fp$o.l10ns.id = Indonesian;
      fp$o.l10ns;

      var fp$p = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Icelandic = {
          weekdays: {
              shorthand: ["Sun", "Mán", "Þri", "Mið", "Fim", "Fös", "Lau"],
              longhand: [
                  "Sunnudagur",
                  "Mánudagur",
                  "Þriðjudagur",
                  "Miðvikudagur",
                  "Fimmtudagur",
                  "Föstudagur",
                  "Laugardagur",
              ],
          },
          months: {
              shorthand: [
                  "Jan",
                  "Feb",
                  "Mar",
                  "Apr",
                  "Maí",
                  "Jún",
                  "Júl",
                  "Ágú",
                  "Sep",
                  "Okt",
                  "Nóv",
                  "Des",
              ],
              longhand: [
                  "Janúar",
                  "Febrúar",
                  "Mars",
                  "Apríl",
                  "Maí",
                  "Júní",
                  "Júlí",
                  "Ágúst",
                  "September",
                  "Október",
                  "Nóvember",
                  "Desember",
              ],
          },
          ordinal: function () {
              return ".";
          },
          firstDayOfWeek: 1,
          rangeSeparator: " til ",
          weekAbbreviation: "vika",
          yearAriaLabel: "Ár",
          time_24hr: true,
      };
      fp$p.l10ns.is = Icelandic;
      fp$p.l10ns;

      var fp$q = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Italian = {
          weekdays: {
              shorthand: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
              longhand: [
                  "Domenica",
                  "Lunedì",
                  "Martedì",
                  "Mercoledì",
                  "Giovedì",
                  "Venerdì",
                  "Sabato",
              ],
          },
          months: {
              shorthand: [
                  "Gen",
                  "Feb",
                  "Mar",
                  "Apr",
                  "Mag",
                  "Giu",
                  "Lug",
                  "Ago",
                  "Set",
                  "Ott",
                  "Nov",
                  "Dic",
              ],
              longhand: [
                  "Gennaio",
                  "Febbraio",
                  "Marzo",
                  "Aprile",
                  "Maggio",
                  "Giugno",
                  "Luglio",
                  "Agosto",
                  "Settembre",
                  "Ottobre",
                  "Novembre",
                  "Dicembre",
              ],
          },
          firstDayOfWeek: 1,
          ordinal: function () { return "°"; },
          rangeSeparator: " al ",
          weekAbbreviation: "Se",
          scrollTitle: "Scrolla per aumentare",
          toggleTitle: "Clicca per cambiare",
          time_24hr: true,
      };
      fp$q.l10ns.it = Italian;
      fp$q.l10ns;

      var fp$r = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Japanese = {
          weekdays: {
              shorthand: ["日", "月", "火", "水", "木", "金", "土"],
              longhand: [
                  "日曜日",
                  "月曜日",
                  "火曜日",
                  "水曜日",
                  "木曜日",
                  "金曜日",
                  "土曜日",
              ],
          },
          months: {
              shorthand: [
                  "1月",
                  "2月",
                  "3月",
                  "4月",
                  "5月",
                  "6月",
                  "7月",
                  "8月",
                  "9月",
                  "10月",
                  "11月",
                  "12月",
              ],
              longhand: [
                  "1月",
                  "2月",
                  "3月",
                  "4月",
                  "5月",
                  "6月",
                  "7月",
                  "8月",
                  "9月",
                  "10月",
                  "11月",
                  "12月",
              ],
          },
          time_24hr: true,
          rangeSeparator: " から ",
          monthAriaLabel: "月",
          amPM: ["午前", "午後"],
          yearAriaLabel: "年",
          hourAriaLabel: "時間",
          minuteAriaLabel: "分",
      };
      fp$r.l10ns.ja = Japanese;
      fp$r.l10ns;

      var fp$s = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Georgian = {
          weekdays: {
              shorthand: ["კვ", "ორ", "სა", "ოთ", "ხუ", "პა", "შა"],
              longhand: [
                  "კვირა",
                  "ორშაბათი",
                  "სამშაბათი",
                  "ოთხშაბათი",
                  "ხუთშაბათი",
                  "პარასკევი",
                  "შაბათი",
              ],
          },
          months: {
              shorthand: [
                  "იან",
                  "თებ",
                  "მარ",
                  "აპრ",
                  "მაი",
                  "ივნ",
                  "ივლ",
                  "აგვ",
                  "სექ",
                  "ოქტ",
                  "ნოე",
                  "დეკ",
              ],
              longhand: [
                  "იანვარი",
                  "თებერვალი",
                  "მარტი",
                  "აპრილი",
                  "მაისი",
                  "ივნისი",
                  "ივლისი",
                  "აგვისტო",
                  "სექტემბერი",
                  "ოქტომბერი",
                  "ნოემბერი",
                  "დეკემბერი",
              ],
          },
          firstDayOfWeek: 1,
          ordinal: function () {
              return "";
          },
          rangeSeparator: " — ",
          weekAbbreviation: "კვ.",
          scrollTitle: "დასქროლეთ გასადიდებლად",
          toggleTitle: "დააკლიკეთ გადართვისთვის",
          amPM: ["AM", "PM"],
          yearAriaLabel: "წელი",
          time_24hr: true,
      };
      fp$s.l10ns.ka = Georgian;
      fp$s.l10ns;

      var fp$t = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Korean = {
          weekdays: {
              shorthand: ["일", "월", "화", "수", "목", "금", "토"],
              longhand: [
                  "일요일",
                  "월요일",
                  "화요일",
                  "수요일",
                  "목요일",
                  "금요일",
                  "토요일",
              ],
          },
          months: {
              shorthand: [
                  "1월",
                  "2월",
                  "3월",
                  "4월",
                  "5월",
                  "6월",
                  "7월",
                  "8월",
                  "9월",
                  "10월",
                  "11월",
                  "12월",
              ],
              longhand: [
                  "1월",
                  "2월",
                  "3월",
                  "4월",
                  "5월",
                  "6월",
                  "7월",
                  "8월",
                  "9월",
                  "10월",
                  "11월",
                  "12월",
              ],
          },
          ordinal: function () {
              return "일";
          },
          rangeSeparator: " ~ ",
      };
      fp$t.l10ns.ko = Korean;
      fp$t.l10ns;

      var fp$u = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Khmer = {
          weekdays: {
              shorthand: ["អាទិត្យ", "ចន្ទ", "អង្គារ", "ពុធ", "ព្រហស.", "សុក្រ", "សៅរ៍"],
              longhand: [
                  "អាទិត្យ",
                  "ចន្ទ",
                  "អង្គារ",
                  "ពុធ",
                  "ព្រហស្បតិ៍",
                  "សុក្រ",
                  "សៅរ៍",
              ],
          },
          months: {
              shorthand: [
                  "មករា",
                  "កុម្ភះ",
                  "មីនា",
                  "មេសា",
                  "ឧសភា",
                  "មិថុនា",
                  "កក្កដា",
                  "សីហា",
                  "កញ្ញា",
                  "តុលា",
                  "វិច្ឆិកា",
                  "ធ្នូ",
              ],
              longhand: [
                  "មករា",
                  "កុម្ភះ",
                  "មីនា",
                  "មេសា",
                  "ឧសភា",
                  "មិថុនា",
                  "កក្កដា",
                  "សីហា",
                  "កញ្ញា",
                  "តុលា",
                  "វិច្ឆិកា",
                  "ធ្នូ",
              ],
          },
          ordinal: function () {
              return "";
          },
          firstDayOfWeek: 1,
          rangeSeparator: " ដល់ ",
          weekAbbreviation: "សប្តាហ៍",
          scrollTitle: "រំកិលដើម្បីបង្កើន",
          toggleTitle: "ចុចដើម្បីផ្លាស់ប្ដូរ",
          yearAriaLabel: "ឆ្នាំ",
          time_24hr: true,
      };
      fp$u.l10ns.km = Khmer;
      fp$u.l10ns;

      var fp$v = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Kazakh = {
          weekdays: {
              shorthand: ["Жс", "Дс", "Сc", "Ср", "Бс", "Жм", "Сб"],
              longhand: [
                  "Жексенбi",
                  "Дүйсенбi",
                  "Сейсенбi",
                  "Сәрсенбi",
                  "Бейсенбi",
                  "Жұма",
                  "Сенбi",
              ],
          },
          months: {
              shorthand: [
                  "Қаң",
                  "Ақп",
                  "Нау",
                  "Сәу",
                  "Мам",
                  "Мау",
                  "Шiл",
                  "Там",
                  "Қыр",
                  "Қаз",
                  "Қар",
                  "Жел",
              ],
              longhand: [
                  "Қаңтар",
                  "Ақпан",
                  "Наурыз",
                  "Сәуiр",
                  "Мамыр",
                  "Маусым",
                  "Шiлде",
                  "Тамыз",
                  "Қыркүйек",
                  "Қазан",
                  "Қараша",
                  "Желтоқсан",
              ],
          },
          firstDayOfWeek: 1,
          ordinal: function () {
              return "";
          },
          rangeSeparator: " — ",
          weekAbbreviation: "Апта",
          scrollTitle: "Үлкейту үшін айналдырыңыз",
          toggleTitle: "Ауыстыру үшін басыңыз",
          amPM: ["ТД", "ТК"],
          yearAriaLabel: "Жыл",
      };
      fp$v.l10ns.kz = Kazakh;
      fp$v.l10ns;

      var fp$w = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Lithuanian = {
          weekdays: {
              shorthand: ["S", "Pr", "A", "T", "K", "Pn", "Š"],
              longhand: [
                  "Sekmadienis",
                  "Pirmadienis",
                  "Antradienis",
                  "Trečiadienis",
                  "Ketvirtadienis",
                  "Penktadienis",
                  "Šeštadienis",
              ],
          },
          months: {
              shorthand: [
                  "Sau",
                  "Vas",
                  "Kov",
                  "Bal",
                  "Geg",
                  "Bir",
                  "Lie",
                  "Rgp",
                  "Rgs",
                  "Spl",
                  "Lap",
                  "Grd",
              ],
              longhand: [
                  "Sausis",
                  "Vasaris",
                  "Kovas",
                  "Balandis",
                  "Gegužė",
                  "Birželis",
                  "Liepa",
                  "Rugpjūtis",
                  "Rugsėjis",
                  "Spalis",
                  "Lapkritis",
                  "Gruodis",
              ],
          },
          firstDayOfWeek: 1,
          ordinal: function () {
              return "-a";
          },
          rangeSeparator: " iki ",
          weekAbbreviation: "Sav",
          scrollTitle: "Keisti laiką pelės rateliu",
          toggleTitle: "Perjungti laiko formatą",
          time_24hr: true,
      };
      fp$w.l10ns.lt = Lithuanian;
      fp$w.l10ns;

      var fp$x = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Latvian = {
          firstDayOfWeek: 1,
          weekdays: {
              shorthand: ["Sv", "Pr", "Ot", "Tr", "Ce", "Pk", "Se"],
              longhand: [
                  "Svētdiena",
                  "Pirmdiena",
                  "Otrdiena",
                  "Trešdiena",
                  "Ceturtdiena",
                  "Piektdiena",
                  "Sestdiena",
              ],
          },
          months: {
              shorthand: [
                  "Jan",
                  "Feb",
                  "Mar",
                  "Apr",
                  "Mai",
                  "Jūn",
                  "Jūl",
                  "Aug",
                  "Sep",
                  "Okt",
                  "Nov",
                  "Dec",
              ],
              longhand: [
                  "Janvāris",
                  "Februāris",
                  "Marts",
                  "Aprīlis",
                  "Maijs",
                  "Jūnijs",
                  "Jūlijs",
                  "Augusts",
                  "Septembris",
                  "Oktobris",
                  "Novembris",
                  "Decembris",
              ],
          },
          rangeSeparator: " līdz ",
          time_24hr: true,
      };
      fp$x.l10ns.lv = Latvian;
      fp$x.l10ns;

      var fp$y = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Macedonian = {
          weekdays: {
              shorthand: ["Не", "По", "Вт", "Ср", "Че", "Пе", "Са"],
              longhand: [
                  "Недела",
                  "Понеделник",
                  "Вторник",
                  "Среда",
                  "Четврток",
                  "Петок",
                  "Сабота",
              ],
          },
          months: {
              shorthand: [
                  "Јан",
                  "Фев",
                  "Мар",
                  "Апр",
                  "Мај",
                  "Јун",
                  "Јул",
                  "Авг",
                  "Сеп",
                  "Окт",
                  "Ное",
                  "Дек",
              ],
              longhand: [
                  "Јануари",
                  "Февруари",
                  "Март",
                  "Април",
                  "Мај",
                  "Јуни",
                  "Јули",
                  "Август",
                  "Септември",
                  "Октомври",
                  "Ноември",
                  "Декември",
              ],
          },
          firstDayOfWeek: 1,
          weekAbbreviation: "Нед.",
          rangeSeparator: " до ",
          time_24hr: true,
      };
      fp$y.l10ns.mk = Macedonian;
      fp$y.l10ns;

      var fp$z = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Mongolian = {
          firstDayOfWeek: 1,
          weekdays: {
              shorthand: ["Да", "Мя", "Лх", "Пү", "Ба", "Бя", "Ня"],
              longhand: ["Даваа", "Мягмар", "Лхагва", "Пүрэв", "Баасан", "Бямба", "Ням"],
          },
          months: {
              shorthand: [
                  "1-р сар",
                  "2-р сар",
                  "3-р сар",
                  "4-р сар",
                  "5-р сар",
                  "6-р сар",
                  "7-р сар",
                  "8-р сар",
                  "9-р сар",
                  "10-р сар",
                  "11-р сар",
                  "12-р сар",
              ],
              longhand: [
                  "Нэгдүгээр сар",
                  "Хоёрдугаар сар",
                  "Гуравдугаар сар",
                  "Дөрөвдүгээр сар",
                  "Тавдугаар сар",
                  "Зургаадугаар сар",
                  "Долдугаар сар",
                  "Наймдугаар сар",
                  "Есдүгээр сар",
                  "Аравдугаар сар",
                  "Арваннэгдүгээр сар",
                  "Арванхоёрдугаар сар",
              ],
          },
          rangeSeparator: "-с ",
          time_24hr: true,
      };
      fp$z.l10ns.mn = Mongolian;
      fp$z.l10ns;

      var fp$A = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Malaysian = {
          weekdays: {
              shorthand: ["Min", "Isn", "Sel", "Rab", "Kha", "Jum", "Sab"],
              longhand: [
                  "Minggu",
                  "Isnin",
                  "Selasa",
                  "Rabu",
                  "Khamis",
                  "Jumaat",
                  "Sabtu",
              ],
          },
          months: {
              shorthand: [
                  "Jan",
                  "Feb",
                  "Mac",
                  "Apr",
                  "Mei",
                  "Jun",
                  "Jul",
                  "Ogo",
                  "Sep",
                  "Okt",
                  "Nov",
                  "Dis",
              ],
              longhand: [
                  "Januari",
                  "Februari",
                  "Mac",
                  "April",
                  "Mei",
                  "Jun",
                  "Julai",
                  "Ogos",
                  "September",
                  "Oktober",
                  "November",
                  "Disember",
              ],
          },
          firstDayOfWeek: 1,
          ordinal: function () {
              return "";
          },
      };
      fp$A.l10ns;

      var fp$B = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Burmese = {
          weekdays: {
              shorthand: ["နွေ", "လာ", "ဂါ", "ဟူး", "ကြာ", "သော", "နေ"],
              longhand: [
                  "တနင်္ဂနွေ",
                  "တနင်္လာ",
                  "အင်္ဂါ",
                  "ဗုဒ္ဓဟူး",
                  "ကြာသပတေး",
                  "သောကြာ",
                  "စနေ",
              ],
          },
          months: {
              shorthand: [
                  "ဇန်",
                  "ဖေ",
                  "မတ်",
                  "ပြီ",
                  "မေ",
                  "ဇွန်",
                  "လိုင်",
                  "သြ",
                  "စက်",
                  "အောက်",
                  "နို",
                  "ဒီ",
              ],
              longhand: [
                  "ဇန်နဝါရီ",
                  "ဖေဖော်ဝါရီ",
                  "မတ်",
                  "ဧပြီ",
                  "မေ",
                  "ဇွန်",
                  "ဇူလိုင်",
                  "သြဂုတ်",
                  "စက်တင်ဘာ",
                  "အောက်တိုဘာ",
                  "နိုဝင်ဘာ",
                  "ဒီဇင်ဘာ",
              ],
          },
          firstDayOfWeek: 1,
          ordinal: function () {
              return "";
          },
          time_24hr: true,
      };
      fp$B.l10ns.my = Burmese;
      fp$B.l10ns;

      var fp$C = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Dutch = {
          weekdays: {
              shorthand: ["zo", "ma", "di", "wo", "do", "vr", "za"],
              longhand: [
                  "zondag",
                  "maandag",
                  "dinsdag",
                  "woensdag",
                  "donderdag",
                  "vrijdag",
                  "zaterdag",
              ],
          },
          months: {
              shorthand: [
                  "jan",
                  "feb",
                  "mrt",
                  "apr",
                  "mei",
                  "jun",
                  "jul",
                  "aug",
                  "sept",
                  "okt",
                  "nov",
                  "dec",
              ],
              longhand: [
                  "januari",
                  "februari",
                  "maart",
                  "april",
                  "mei",
                  "juni",
                  "juli",
                  "augustus",
                  "september",
                  "oktober",
                  "november",
                  "december",
              ],
          },
          firstDayOfWeek: 1,
          weekAbbreviation: "wk",
          rangeSeparator: " t/m ",
          scrollTitle: "Scroll voor volgende / vorige",
          toggleTitle: "Klik om te wisselen",
          time_24hr: true,
          ordinal: function (nth) {
              if (nth === 1 || nth === 8 || nth >= 20)
                  return "ste";
              return "de";
          },
      };
      fp$C.l10ns.nl = Dutch;
      fp$C.l10ns;

      var fp$D = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Norwegian = {
          weekdays: {
              shorthand: ["Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"],
              longhand: [
                  "Søndag",
                  "Mandag",
                  "Tirsdag",
                  "Onsdag",
                  "Torsdag",
                  "Fredag",
                  "Lørdag",
              ],
          },
          months: {
              shorthand: [
                  "Jan",
                  "Feb",
                  "Mar",
                  "Apr",
                  "Mai",
                  "Jun",
                  "Jul",
                  "Aug",
                  "Sep",
                  "Okt",
                  "Nov",
                  "Des",
              ],
              longhand: [
                  "Januar",
                  "Februar",
                  "Mars",
                  "April",
                  "Mai",
                  "Juni",
                  "Juli",
                  "August",
                  "September",
                  "Oktober",
                  "November",
                  "Desember",
              ],
          },
          firstDayOfWeek: 1,
          rangeSeparator: " til ",
          weekAbbreviation: "Uke",
          scrollTitle: "Scroll for å endre",
          toggleTitle: "Klikk for å veksle",
          time_24hr: true,
          ordinal: function () {
              return ".";
          },
      };
      fp$D.l10ns.no = Norwegian;
      fp$D.l10ns;

      var fp$E = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Punjabi = {
          weekdays: {
              shorthand: ["ਐਤ", "ਸੋਮ", "ਮੰਗਲ", "ਬੁੱਧ", "ਵੀਰ", "ਸ਼ੁੱਕਰ", "ਸ਼ਨਿੱਚਰ"],
              longhand: [
                  "ਐਤਵਾਰ",
                  "ਸੋਮਵਾਰ",
                  "ਮੰਗਲਵਾਰ",
                  "ਬੁੱਧਵਾਰ",
                  "ਵੀਰਵਾਰ",
                  "ਸ਼ੁੱਕਰਵਾਰ",
                  "ਸ਼ਨਿੱਚਰਵਾਰ",
              ],
          },
          months: {
              shorthand: [
                  "ਜਨ",
                  "ਫ਼ਰ",
                  "ਮਾਰ",
                  "ਅਪ੍ਰੈ",
                  "ਮਈ",
                  "ਜੂਨ",
                  "ਜੁਲਾ",
                  "ਅਗ",
                  "ਸਤੰ",
                  "ਅਕ",
                  "ਨਵੰ",
                  "ਦਸੰ",
              ],
              longhand: [
                  "ਜਨਵਰੀ",
                  "ਫ਼ਰਵਰੀ",
                  "ਮਾਰਚ",
                  "ਅਪ੍ਰੈਲ",
                  "ਮਈ",
                  "ਜੂਨ",
                  "ਜੁਲਾਈ",
                  "ਅਗਸਤ",
                  "ਸਤੰਬਰ",
                  "ਅਕਤੂਬਰ",
                  "ਨਵੰਬਰ",
                  "ਦਸੰਬਰ",
              ],
          },
          time_24hr: true,
      };
      fp$E.l10ns.pa = Punjabi;
      fp$E.l10ns;

      var fp$F = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Polish = {
          weekdays: {
              shorthand: ["Nd", "Pn", "Wt", "Śr", "Cz", "Pt", "So"],
              longhand: [
                  "Niedziela",
                  "Poniedziałek",
                  "Wtorek",
                  "Środa",
                  "Czwartek",
                  "Piątek",
                  "Sobota",
              ],
          },
          months: {
              shorthand: [
                  "Sty",
                  "Lut",
                  "Mar",
                  "Kwi",
                  "Maj",
                  "Cze",
                  "Lip",
                  "Sie",
                  "Wrz",
                  "Paź",
                  "Lis",
                  "Gru",
              ],
              longhand: [
                  "Styczeń",
                  "Luty",
                  "Marzec",
                  "Kwiecień",
                  "Maj",
                  "Czerwiec",
                  "Lipiec",
                  "Sierpień",
                  "Wrzesień",
                  "Październik",
                  "Listopad",
                  "Grudzień",
              ],
          },
          rangeSeparator: " do ",
          weekAbbreviation: "tydz.",
          scrollTitle: "Przewiń, aby zwiększyć",
          toggleTitle: "Kliknij, aby przełączyć",
          firstDayOfWeek: 1,
          time_24hr: true,
          ordinal: function () {
              return ".";
          },
      };
      fp$F.l10ns.pl = Polish;
      fp$F.l10ns;

      var fp$G = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Portuguese = {
          weekdays: {
              shorthand: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"],
              longhand: [
                  "Domingo",
                  "Segunda-feira",
                  "Terça-feira",
                  "Quarta-feira",
                  "Quinta-feira",
                  "Sexta-feira",
                  "Sábado",
              ],
          },
          months: {
              shorthand: [
                  "Jan",
                  "Fev",
                  "Mar",
                  "Abr",
                  "Mai",
                  "Jun",
                  "Jul",
                  "Ago",
                  "Set",
                  "Out",
                  "Nov",
                  "Dez",
              ],
              longhand: [
                  "Janeiro",
                  "Fevereiro",
                  "Março",
                  "Abril",
                  "Maio",
                  "Junho",
                  "Julho",
                  "Agosto",
                  "Setembro",
                  "Outubro",
                  "Novembro",
                  "Dezembro",
              ],
          },
          rangeSeparator: " até ",
          time_24hr: true,
      };
      fp$G.l10ns.pt = Portuguese;
      fp$G.l10ns;

      var fp$H = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Romanian = {
          weekdays: {
              shorthand: ["Dum", "Lun", "Mar", "Mie", "Joi", "Vin", "Sâm"],
              longhand: [
                  "Duminică",
                  "Luni",
                  "Marți",
                  "Miercuri",
                  "Joi",
                  "Vineri",
                  "Sâmbătă",
              ],
          },
          months: {
              shorthand: [
                  "Ian",
                  "Feb",
                  "Mar",
                  "Apr",
                  "Mai",
                  "Iun",
                  "Iul",
                  "Aug",
                  "Sep",
                  "Oct",
                  "Noi",
                  "Dec",
              ],
              longhand: [
                  "Ianuarie",
                  "Februarie",
                  "Martie",
                  "Aprilie",
                  "Mai",
                  "Iunie",
                  "Iulie",
                  "August",
                  "Septembrie",
                  "Octombrie",
                  "Noiembrie",
                  "Decembrie",
              ],
          },
          firstDayOfWeek: 1,
          time_24hr: true,
          ordinal: function () {
              return "";
          },
      };
      fp$H.l10ns.ro = Romanian;
      fp$H.l10ns;

      var fp$I = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Russian = {
          weekdays: {
              shorthand: ["Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
              longhand: [
                  "Воскресенье",
                  "Понедельник",
                  "Вторник",
                  "Среда",
                  "Четверг",
                  "Пятница",
                  "Суббота",
              ],
          },
          months: {
              shorthand: [
                  "Янв",
                  "Фев",
                  "Март",
                  "Апр",
                  "Май",
                  "Июнь",
                  "Июль",
                  "Авг",
                  "Сен",
                  "Окт",
                  "Ноя",
                  "Дек",
              ],
              longhand: [
                  "Январь",
                  "Февраль",
                  "Март",
                  "Апрель",
                  "Май",
                  "Июнь",
                  "Июль",
                  "Август",
                  "Сентябрь",
                  "Октябрь",
                  "Ноябрь",
                  "Декабрь",
              ],
          },
          firstDayOfWeek: 1,
          ordinal: function () {
              return "";
          },
          rangeSeparator: " — ",
          weekAbbreviation: "Нед.",
          scrollTitle: "Прокрутите для увеличения",
          toggleTitle: "Нажмите для переключения",
          amPM: ["ДП", "ПП"],
          yearAriaLabel: "Год",
          time_24hr: true,
      };
      fp$I.l10ns.ru = Russian;
      fp$I.l10ns;

      var fp$J = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Sinhala = {
          weekdays: {
              shorthand: ["ඉ", "ස", "අ", "බ", "බ්‍ර", "සි", "සෙ"],
              longhand: [
                  "ඉරිදා",
                  "සඳුදා",
                  "අඟහරුවාදා",
                  "බදාදා",
                  "බ්‍රහස්පතින්දා",
                  "සිකුරාදා",
                  "සෙනසුරාදා",
              ],
          },
          months: {
              shorthand: [
                  "ජන",
                  "පෙබ",
                  "මාර්",
                  "අප්‍රේ",
                  "මැයි",
                  "ජුනි",
                  "ජූලි",
                  "අගෝ",
                  "සැප්",
                  "ඔක්",
                  "නොවැ",
                  "දෙසැ",
              ],
              longhand: [
                  "ජනවාරි",
                  "පෙබරවාරි",
                  "මාර්තු",
                  "අප්‍රේල්",
                  "මැයි",
                  "ජුනි",
                  "ජූලි",
                  "අගෝස්තු",
                  "සැප්තැම්බර්",
                  "ඔක්තෝබර්",
                  "නොවැම්බර්",
                  "දෙසැම්බර්",
              ],
          },
          time_24hr: true,
      };
      fp$J.l10ns.si = Sinhala;
      fp$J.l10ns;

      var fp$K = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Slovak = {
          weekdays: {
              shorthand: ["Ned", "Pon", "Ut", "Str", "Štv", "Pia", "Sob"],
              longhand: [
                  "Nedeľa",
                  "Pondelok",
                  "Utorok",
                  "Streda",
                  "Štvrtok",
                  "Piatok",
                  "Sobota",
              ],
          },
          months: {
              shorthand: [
                  "Jan",
                  "Feb",
                  "Mar",
                  "Apr",
                  "Máj",
                  "Jún",
                  "Júl",
                  "Aug",
                  "Sep",
                  "Okt",
                  "Nov",
                  "Dec",
              ],
              longhand: [
                  "Január",
                  "Február",
                  "Marec",
                  "Apríl",
                  "Máj",
                  "Jún",
                  "Júl",
                  "August",
                  "September",
                  "Október",
                  "November",
                  "December",
              ],
          },
          firstDayOfWeek: 1,
          rangeSeparator: " do ",
          time_24hr: true,
          ordinal: function () {
              return ".";
          },
      };
      fp$K.l10ns.sk = Slovak;
      fp$K.l10ns;

      var fp$L = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Slovenian = {
          weekdays: {
              shorthand: ["Ned", "Pon", "Tor", "Sre", "Čet", "Pet", "Sob"],
              longhand: [
                  "Nedelja",
                  "Ponedeljek",
                  "Torek",
                  "Sreda",
                  "Četrtek",
                  "Petek",
                  "Sobota",
              ],
          },
          months: {
              shorthand: [
                  "Jan",
                  "Feb",
                  "Mar",
                  "Apr",
                  "Maj",
                  "Jun",
                  "Jul",
                  "Avg",
                  "Sep",
                  "Okt",
                  "Nov",
                  "Dec",
              ],
              longhand: [
                  "Januar",
                  "Februar",
                  "Marec",
                  "April",
                  "Maj",
                  "Junij",
                  "Julij",
                  "Avgust",
                  "September",
                  "Oktober",
                  "November",
                  "December",
              ],
          },
          firstDayOfWeek: 1,
          rangeSeparator: " do ",
          time_24hr: true,
          ordinal: function () {
              return ".";
          },
      };
      fp$L.l10ns.sl = Slovenian;
      fp$L.l10ns;

      var fp$M = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Albanian = {
          weekdays: {
              shorthand: ["Di", "Hë", "Ma", "Më", "En", "Pr", "Sh"],
              longhand: [
                  "E Diel",
                  "E Hënë",
                  "E Martë",
                  "E Mërkurë",
                  "E Enjte",
                  "E Premte",
                  "E Shtunë",
              ],
          },
          months: {
              shorthand: [
                  "Jan",
                  "Shk",
                  "Mar",
                  "Pri",
                  "Maj",
                  "Qer",
                  "Kor",
                  "Gus",
                  "Sht",
                  "Tet",
                  "Nën",
                  "Dhj",
              ],
              longhand: [
                  "Janar",
                  "Shkurt",
                  "Mars",
                  "Prill",
                  "Maj",
                  "Qershor",
                  "Korrik",
                  "Gusht",
                  "Shtator",
                  "Tetor",
                  "Nëntor",
                  "Dhjetor",
              ],
          },
          time_24hr: true,
      };
      fp$M.l10ns.sq = Albanian;
      fp$M.l10ns;

      var fp$N = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Serbian = {
          weekdays: {
              shorthand: ["Ned", "Pon", "Uto", "Sre", "Čet", "Pet", "Sub"],
              longhand: [
                  "Nedelja",
                  "Ponedeljak",
                  "Utorak",
                  "Sreda",
                  "Četvrtak",
                  "Petak",
                  "Subota",
              ],
          },
          months: {
              shorthand: [
                  "Jan",
                  "Feb",
                  "Mar",
                  "Apr",
                  "Maj",
                  "Jun",
                  "Jul",
                  "Avg",
                  "Sep",
                  "Okt",
                  "Nov",
                  "Dec",
              ],
              longhand: [
                  "Januar",
                  "Februar",
                  "Mart",
                  "April",
                  "Maj",
                  "Jun",
                  "Jul",
                  "Avgust",
                  "Septembar",
                  "Oktobar",
                  "Novembar",
                  "Decembar",
              ],
          },
          firstDayOfWeek: 1,
          weekAbbreviation: "Ned.",
          rangeSeparator: " do ",
          time_24hr: true,
      };
      fp$N.l10ns.sr = Serbian;
      fp$N.l10ns;

      var fp$O = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Swedish = {
          firstDayOfWeek: 1,
          weekAbbreviation: "v",
          weekdays: {
              shorthand: ["Sön", "Mån", "Tis", "Ons", "Tor", "Fre", "Lör"],
              longhand: [
                  "Söndag",
                  "Måndag",
                  "Tisdag",
                  "Onsdag",
                  "Torsdag",
                  "Fredag",
                  "Lördag",
              ],
          },
          months: {
              shorthand: [
                  "Jan",
                  "Feb",
                  "Mar",
                  "Apr",
                  "Maj",
                  "Jun",
                  "Jul",
                  "Aug",
                  "Sep",
                  "Okt",
                  "Nov",
                  "Dec",
              ],
              longhand: [
                  "Januari",
                  "Februari",
                  "Mars",
                  "April",
                  "Maj",
                  "Juni",
                  "Juli",
                  "Augusti",
                  "September",
                  "Oktober",
                  "November",
                  "December",
              ],
          },
          time_24hr: true,
          ordinal: function () {
              return ".";
          },
      };
      fp$O.l10ns.sv = Swedish;
      fp$O.l10ns;

      var fp$P = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Thai = {
          weekdays: {
              shorthand: ["อา", "จ", "อ", "พ", "พฤ", "ศ", "ส"],
              longhand: [
                  "อาทิตย์",
                  "จันทร์",
                  "อังคาร",
                  "พุธ",
                  "พฤหัสบดี",
                  "ศุกร์",
                  "เสาร์",
              ],
          },
          months: {
              shorthand: [
                  "ม.ค.",
                  "ก.พ.",
                  "มี.ค.",
                  "เม.ย.",
                  "พ.ค.",
                  "มิ.ย.",
                  "ก.ค.",
                  "ส.ค.",
                  "ก.ย.",
                  "ต.ค.",
                  "พ.ย.",
                  "ธ.ค.",
              ],
              longhand: [
                  "มกราคม",
                  "กุมภาพันธ์",
                  "มีนาคม",
                  "เมษายน",
                  "พฤษภาคม",
                  "มิถุนายน",
                  "กรกฎาคม",
                  "สิงหาคม",
                  "กันยายน",
                  "ตุลาคม",
                  "พฤศจิกายน",
                  "ธันวาคม",
              ],
          },
          firstDayOfWeek: 1,
          rangeSeparator: " ถึง ",
          scrollTitle: "เลื่อนเพื่อเพิ่มหรือลด",
          toggleTitle: "คลิกเพื่อเปลี่ยน",
          time_24hr: true,
          ordinal: function () {
              return "";
          },
      };
      fp$P.l10ns.th = Thai;
      fp$P.l10ns;

      var fp$Q = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Turkish = {
          weekdays: {
              shorthand: ["Paz", "Pzt", "Sal", "Çar", "Per", "Cum", "Cmt"],
              longhand: [
                  "Pazar",
                  "Pazartesi",
                  "Salı",
                  "Çarşamba",
                  "Perşembe",
                  "Cuma",
                  "Cumartesi",
              ],
          },
          months: {
              shorthand: [
                  "Oca",
                  "Şub",
                  "Mar",
                  "Nis",
                  "May",
                  "Haz",
                  "Tem",
                  "Ağu",
                  "Eyl",
                  "Eki",
                  "Kas",
                  "Ara",
              ],
              longhand: [
                  "Ocak",
                  "Şubat",
                  "Mart",
                  "Nisan",
                  "Mayıs",
                  "Haziran",
                  "Temmuz",
                  "Ağustos",
                  "Eylül",
                  "Ekim",
                  "Kasım",
                  "Aralık",
              ],
          },
          firstDayOfWeek: 1,
          ordinal: function () {
              return ".";
          },
          rangeSeparator: " - ",
          weekAbbreviation: "Hf",
          scrollTitle: "Artırmak için kaydırın",
          toggleTitle: "Aç/Kapa",
          amPM: ["ÖÖ", "ÖS"],
          time_24hr: true,
      };
      fp$Q.l10ns.tr = Turkish;
      fp$Q.l10ns;

      var fp$R = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Ukrainian = {
          firstDayOfWeek: 1,
          weekdays: {
              shorthand: ["Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
              longhand: [
                  "Неділя",
                  "Понеділок",
                  "Вівторок",
                  "Середа",
                  "Четвер",
                  "П'ятниця",
                  "Субота",
              ],
          },
          months: {
              shorthand: [
                  "Січ",
                  "Лют",
                  "Бер",
                  "Кві",
                  "Тра",
                  "Чер",
                  "Лип",
                  "Сер",
                  "Вер",
                  "Жов",
                  "Лис",
                  "Гру",
              ],
              longhand: [
                  "Січень",
                  "Лютий",
                  "Березень",
                  "Квітень",
                  "Травень",
                  "Червень",
                  "Липень",
                  "Серпень",
                  "Вересень",
                  "Жовтень",
                  "Листопад",
                  "Грудень",
              ],
          },
          time_24hr: true,
      };
      fp$R.l10ns.uk = Ukrainian;
      fp$R.l10ns;

      var fp$S = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Uzbek = {
          weekdays: {
              shorthand: ["Якш", "Душ", "Сеш", "Чор", "Пай", "Жум", "Шан"],
              longhand: [
                  "Якшанба",
                  "Душанба",
                  "Сешанба",
                  "Чоршанба",
                  "Пайшанба",
                  "Жума",
                  "Шанба",
              ],
          },
          months: {
              shorthand: [
                  "Янв",
                  "Фев",
                  "Мар",
                  "Апр",
                  "Май",
                  "Июн",
                  "Июл",
                  "Авг",
                  "Сен",
                  "Окт",
                  "Ноя",
                  "Дек",
              ],
              longhand: [
                  "Январ",
                  "Феврал",
                  "Март",
                  "Апрел",
                  "Май",
                  "Июн",
                  "Июл",
                  "Август",
                  "Сентябр",
                  "Октябр",
                  "Ноябр",
                  "Декабр",
              ],
          },
          firstDayOfWeek: 1,
          ordinal: function () {
              return "";
          },
          rangeSeparator: " — ",
          weekAbbreviation: "Ҳафта",
          scrollTitle: "Катталаштириш учун айлантиринг",
          toggleTitle: "Ўтиш учун босинг",
          amPM: ["AM", "PM"],
          yearAriaLabel: "Йил",
          time_24hr: true,
      };
      fp$S.l10ns.uz = Uzbek;
      fp$S.l10ns;

      var fp$T = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var UzbekLatin = {
          weekdays: {
              shorthand: ["Ya", "Du", "Se", "Cho", "Pa", "Ju", "Sha"],
              longhand: [
                  "Yakshanba",
                  "Dushanba",
                  "Seshanba",
                  "Chorshanba",
                  "Payshanba",
                  "Juma",
                  "Shanba",
              ],
          },
          months: {
              shorthand: [
                  "Yan",
                  "Fev",
                  "Mar",
                  "Apr",
                  "May",
                  "Iyun",
                  "Iyul",
                  "Avg",
                  "Sen",
                  "Okt",
                  "Noy",
                  "Dek",
              ],
              longhand: [
                  "Yanvar",
                  "Fevral",
                  "Mart",
                  "Aprel",
                  "May",
                  "Iyun",
                  "Iyul",
                  "Avgust",
                  "Sentabr",
                  "Oktabr",
                  "Noyabr",
                  "Dekabr",
              ],
          },
          firstDayOfWeek: 1,
          ordinal: function () {
              return "";
          },
          rangeSeparator: " — ",
          weekAbbreviation: "Hafta",
          scrollTitle: "Kattalashtirish uchun aylantiring",
          toggleTitle: "O‘tish uchun bosing",
          amPM: ["AM", "PM"],
          yearAriaLabel: "Yil",
          time_24hr: true,
      };
      fp$T.l10ns["uz_latn"] = UzbekLatin;
      fp$T.l10ns;

      var fp$U = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Vietnamese = {
          weekdays: {
              shorthand: ["CN", "T2", "T3", "T4", "T5", "T6", "T7"],
              longhand: [
                  "Chủ nhật",
                  "Thứ hai",
                  "Thứ ba",
                  "Thứ tư",
                  "Thứ năm",
                  "Thứ sáu",
                  "Thứ bảy",
              ],
          },
          months: {
              shorthand: [
                  "Th1",
                  "Th2",
                  "Th3",
                  "Th4",
                  "Th5",
                  "Th6",
                  "Th7",
                  "Th8",
                  "Th9",
                  "Th10",
                  "Th11",
                  "Th12",
              ],
              longhand: [
                  "Tháng một",
                  "Tháng hai",
                  "Tháng ba",
                  "Tháng tư",
                  "Tháng năm",
                  "Tháng sáu",
                  "Tháng bảy",
                  "Tháng tám",
                  "Tháng chín",
                  "Tháng mười",
                  "Tháng mười một",
                  "Tháng mười hai",
              ],
          },
          firstDayOfWeek: 1,
          rangeSeparator: " đến ",
      };
      fp$U.l10ns.vn = Vietnamese;
      fp$U.l10ns;

      var fp$V = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var Mandarin = {
          weekdays: {
              shorthand: ["周日", "周一", "周二", "周三", "周四", "周五", "周六"],
              longhand: [
                  "星期日",
                  "星期一",
                  "星期二",
                  "星期三",
                  "星期四",
                  "星期五",
                  "星期六",
              ],
          },
          months: {
              shorthand: [
                  "一月",
                  "二月",
                  "三月",
                  "四月",
                  "五月",
                  "六月",
                  "七月",
                  "八月",
                  "九月",
                  "十月",
                  "十一月",
                  "十二月",
              ],
              longhand: [
                  "一月",
                  "二月",
                  "三月",
                  "四月",
                  "五月",
                  "六月",
                  "七月",
                  "八月",
                  "九月",
                  "十月",
                  "十一月",
                  "十二月",
              ],
          },
          rangeSeparator: " 至 ",
          weekAbbreviation: "周",
          scrollTitle: "滚动切换",
          toggleTitle: "点击切换 12/24 小时时制",
      };
      fp$V.l10ns.zh = Mandarin;
      fp$V.l10ns;

      var fp$W = typeof window !== "undefined" && window.flatpickr !== undefined
          ? window.flatpickr
          : {
              l10ns: {},
          };
      var MandarinTraditional = {
          weekdays: {
              shorthand: ["週日", "週一", "週二", "週三", "週四", "週五", "週六"],
              longhand: [
                  "星期日",
                  "星期一",
                  "星期二",
                  "星期三",
                  "星期四",
                  "星期五",
                  "星期六",
              ],
          },
          months: {
              shorthand: [
                  "一月",
                  "二月",
                  "三月",
                  "四月",
                  "五月",
                  "六月",
                  "七月",
                  "八月",
                  "九月",
                  "十月",
                  "十一月",
                  "十二月",
              ],
              longhand: [
                  "一月",
                  "二月",
                  "三月",
                  "四月",
                  "五月",
                  "六月",
                  "七月",
                  "八月",
                  "九月",
                  "十月",
                  "十一月",
                  "十二月",
              ],
          },
          rangeSeparator: " 至 ",
          weekAbbreviation: "週",
          scrollTitle: "滾動切換",
          toggleTitle: "點擊切換 12/24 小時時制",
      };
      fp$W.l10ns.zh_tw = MandarinTraditional;
      fp$W.l10ns;

      var l10n = {
          ar: Arabic,
          at: Austria,
          az: Azerbaijan,
          be: Belarusian,
          bg: Bulgarian,
          bn: Bangla,
          bs: Bosnian,
          ca: Catalan,
          cat: Catalan,
          cs: Czech,
          cy: Welsh,
          da: Danish,
          de: German,
          default: __assign({}, english),
          en: english,
          eo: Esperanto,
          es: Spanish,
          et: Estonian,
          fa: Persian,
          fi: Finnish,
          fo: Faroese,
          fr: French,
          gr: Greek,
          he: Hebrew,
          hi: Hindi,
          hr: Croatian,
          hu: Hungarian,
          id: Indonesian,
          is: Icelandic,
          it: Italian,
          ja: Japanese,
          ka: Georgian,
          ko: Korean,
          km: Khmer,
          kz: Kazakh,
          lt: Lithuanian,
          lv: Latvian,
          mk: Macedonian,
          mn: Mongolian,
          ms: Malaysian,
          my: Burmese,
          nl: Dutch,
          no: Norwegian,
          pa: Punjabi,
          pl: Polish,
          pt: Portuguese,
          ro: Romanian,
          ru: Russian,
          si: Sinhala,
          sk: Slovak,
          sl: Slovenian,
          sq: Albanian,
          sr: Serbian,
          sv: Swedish,
          th: Thai,
          tr: Turkish,
          uk: Ukrainian,
          vn: Vietnamese,
          zh: Mandarin,
          zh_tw: MandarinTraditional,
          uz: Uzbek,
          uz_latn: UzbekLatin,
      };

      exports.default = l10n;

      Object.defineProperty(exports, '__esModule', { value: true });

  })));
  }(l10n$1, l10n$1.exports));

  var l10n = /*@__PURE__*/getDefaultExportFromCjs(l10n$1.exports);

  var _excluded$1Y = ["datePickerType", "disabled", "helperText", "hideLabel", "id", "invalid", "invalidText", "labelText", "onClick", "onChange", "pattern", "placeholder", "size", "type", "warn", "warnText"],
      _excluded2$c = ["openCalendar", "iconDescription"],
      _excluded3$8 = ["datePickerType", "invalid", "warn"];
  var DatePickerInput$3 = /*#__PURE__*/React__default["default"].forwardRef(function DatePickerInput(props, ref) {
    var _cx, _cx2, _cx4;

    var datePickerType = props.datePickerType,
        _props$disabled = props.disabled,
        disabled = _props$disabled === void 0 ? false : _props$disabled,
        helperText = props.helperText,
        hideLabel = props.hideLabel,
        id = props.id,
        _props$invalid = props.invalid,
        invalid = _props$invalid === void 0 ? false : _props$invalid,
        invalidText = props.invalidText,
        labelText = props.labelText,
        _props$onClick = props.onClick,
        _onClick = _props$onClick === void 0 ? function () {} : _props$onClick,
        _props$onChange = props.onChange,
        _onChange = _props$onChange === void 0 ? function () {} : _props$onChange,
        _props$pattern = props.pattern,
        pattern = _props$pattern === void 0 ? '\\d{1,2}\\/\\d{1,2}\\/\\d{4}' : _props$pattern,
        placeholder = props.placeholder,
        _props$size = props.size,
        size = _props$size === void 0 ? 'md' : _props$size,
        _props$type = props.type,
        type = _props$type === void 0 ? 'text' : _props$type,
        warn = props.warn,
        warnText = props.warnText,
        rest = _objectWithoutProperties$2(props, _excluded$1Y);

    var prefix = usePrefix();
    var datePickerInputProps = {
      id: id,
      onChange: function onChange(event) {
        if (!disabled) {
          _onChange(event);
        }
      },
      onClick: function onClick(event) {
        if (!disabled) {
          _onClick(event);
        }
      },
      pattern: pattern,
      placeholder: placeholder,
      type: type
    };
    var wrapperClasses = cx("".concat(prefix, "--date-picker-input__wrapper"), (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--date-picker-input__wrapper--invalid"), invalid), _defineProperty$2(_cx, "".concat(prefix, "--date-picker-input__wrapper--warn"), warn), _cx));
    var labelClasses = cx("".concat(prefix, "--label"), (_cx2 = {}, _defineProperty$2(_cx2, "".concat(prefix, "--visually-hidden"), hideLabel), _defineProperty$2(_cx2, "".concat(prefix, "--label--disabled"), disabled), _cx2));
    var helperTextClasses = cx("".concat(prefix, "--form__helper-text"), _defineProperty$2({}, "".concat(prefix, "--form__helper-text--disabled"), disabled));
    var inputClasses = cx("".concat(prefix, "--date-picker__input"), (_cx4 = {}, _defineProperty$2(_cx4, "".concat(prefix, "--date-picker__input--").concat(size), size), _defineProperty$2(_cx4, "".concat(prefix, "--date-picker__input--invalid"), invalid), _cx4));
    var containerClasses = cx("".concat(prefix, "--date-picker-container"), _defineProperty$2({}, "".concat(prefix, "--date-picker--nolabel"), !labelText));

    var _rest = _objectSpread2$2({}, rest),
        openCalendar = _rest.openCalendar,
        iconDescription = _rest.iconDescription,
        other = _objectWithoutProperties$2(_rest, _excluded2$c);

    var input = invalid ? /*#__PURE__*/React__default["default"].createElement("input", _extends$3({}, other, datePickerInputProps, {
      disabled: disabled,
      ref: ref,
      "data-invalid": true,
      className: inputClasses
    })) : /*#__PURE__*/React__default["default"].createElement("input", _extends$3({}, other, datePickerInputProps, {
      disabled: disabled,
      className: inputClasses,
      ref: ref
    }));
    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: containerClasses
    }, labelText && /*#__PURE__*/React__default["default"].createElement("label", {
      htmlFor: id,
      className: labelClasses
    }, labelText), /*#__PURE__*/React__default["default"].createElement("div", {
      className: wrapperClasses
    }, input, /*#__PURE__*/React__default["default"].createElement(DatePickerIcon, {
      datePickerType: datePickerType,
      iconDescription: iconDescription,
      invalid: invalid,
      openCalendar: openCalendar,
      warn: warn
    })), invalid && /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--form-requirement")
    }, invalidText), warn && /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--form-requirement")
    }, warnText), helperText && /*#__PURE__*/React__default["default"].createElement("div", {
      className: helperTextClasses
    }, helperText));
  });
  DatePickerInput$3.propTypes = {
    /**
     * The type of the date picker:
     *
     * * `simple` - Without calendar dropdown.
     * * `single` - With calendar dropdown and single date.
     * * `range` - With calendar dropdown and a date range.
     */
    datePickerType: PropTypes__default["default"].oneOf(['simple', 'single', 'range']),

    /**
     * Specify whether or not the input should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Provide text that is used alongside the control label for additional help
     */
    helperText: PropTypes__default["default"].node,

    /**
     * Specify if the label should be hidden
     */
    hideLabel: PropTypes__default["default"].bool,

    /**
     * The description of the calendar icon.
     */
    iconDescription: deprecate(PropTypes__default["default"].string, "\nThe prop `iconDescriptionInput` for DatePickerInput has been deprecated and is no longer used"),

    /**
     * Specify an id that uniquely identifies the `<input>`
     */
    id: PropTypes__default["default"].string.isRequired,

    /**
     * Specify whether or not the input should be invalid
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * Specify the text to be rendered when the input is invalid
     */
    invalidText: PropTypes__default["default"].node,

    /**
     * Provide the text that will be read by a screen reader when visiting this
     * control
     */
    labelText: PropTypes__default["default"].node.isRequired,

    /**
     * Specify an `onChange` handler that is called whenever a change in the
     * input field has occurred
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Provide a function to be called when the input field is clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Provide a function to be called when the input field is clicked
     */
    openCalendar: deprecate(PropTypes__default["default"].func, "\nThe prop `openCalendar` for DatePickerInput has been deprecated and is no longer used"),

    /**
     * Provide a regular expression that the input value must match
     */
    pattern: function pattern(props, propName, componentName) {
      if (props[propName] === undefined) {
        return;
      }

      try {
        new RegExp(props[propName]);
      } catch (e) {
        return new Error("Invalid value of prop '".concat(propName, "' supplied to '").concat(componentName, "', it should be a valid regular expression"));
      }
    },

    /**
     * Specify the placeholder text
     */
    placeholder: PropTypes__default["default"].string,

    /**
     * Specify the size of the Date Picker Input. Currently supports either `sm`, `md`, or `lg` as an option.
     */
    size: PropTypes__default["default"].oneOf(['sm', 'md', 'lg']),

    /**
     * Specify the type of the `<input>`
     */
    type: PropTypes__default["default"].string,

    /**
     * Specify whether the control is currently in warning state
     */
    warn: PropTypes__default["default"].bool,

    /**
     * Provide the text that is displayed when the control is in warning state
     */
    warnText: PropTypes__default["default"].node
  };

  function DatePickerIcon(_ref) {
    var datePickerType = _ref.datePickerType,
        invalid = _ref.invalid,
        warn = _ref.warn,
        rest = _objectWithoutProperties$2(_ref, _excluded3$8);

    var prefix = usePrefix();

    if (datePickerType === 'simple' && !invalid && !warn) {
      return null;
    }

    if (invalid) {
      return /*#__PURE__*/React__default["default"].createElement(WarningFilled16, {
        className: "".concat(prefix, "--date-picker__icon ").concat(prefix, "--date-picker__icon--invalid")
      });
    }

    if (!invalid && warn) {
      return /*#__PURE__*/React__default["default"].createElement(WarningAltFilled16, {
        className: "".concat(prefix, "--date-picker__icon ").concat(prefix, "--date-picker__icon--warn")
      });
    }

    return /*#__PURE__*/React__default["default"].createElement(Calendar16, {
      className: "".concat(prefix, "--date-picker__icon"),
      "aria-label": rest.iconDescription,
      onClick: rest.openCalendar,
      role: "img",
      "aria-hidden": "true"
    }, rest.iconDescription && /*#__PURE__*/React__default["default"].createElement("title", null, rest.iconDescription));
  }

  DatePickerIcon.propTypes = {
    /**
     * The type of the date picker:
     *
     * * `simple` - Without calendar dropdown.
     * * `single` - With calendar dropdown and single date.
     * * `range` - With calendar dropdown and a date range.
     */
    datePickerType: PropTypes__default["default"].oneOf(['simple', 'single', 'range']),

    /**
     * Specify whether or not the input should be invalid
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * Specify whether the control is currently in warning state
     */
    warn: PropTypes__default["default"].bool
  };
  var DatePickerInputNext = DatePickerInput$3;

  var _excluded$1X = ["id", "labelText", "disabled", "invalid", "invalidText", "helperText", "hideLabel", "onChange", "onClick", "placeholder", "type", "datePickerType", "pattern", "iconDescription", "openCalendar", "size", "warn", "warnText"];

  var DatePickerInput$2 = /*#__PURE__*/function (_Component) {
    _inherits(DatePickerInput, _Component);

    var _super = _createSuper(DatePickerInput);

    function DatePickerInput() {
      _classCallCheck$1(this, DatePickerInput);

      return _super.apply(this, arguments);
    }

    _createClass$1(DatePickerInput, [{
      key: "render",
      value: function render() {
        var _this = this;

        var _this$props = this.props,
            id = _this$props.id,
            labelText = _this$props.labelText,
            disabled = _this$props.disabled,
            invalid = _this$props.invalid,
            invalidText = _this$props.invalidText,
            helperText = _this$props.helperText,
            hideLabel = _this$props.hideLabel,
            _onChange = _this$props.onChange,
            _onClick = _this$props.onClick,
            placeholder = _this$props.placeholder,
            type = _this$props.type,
            datePickerType = _this$props.datePickerType,
            pattern = _this$props.pattern,
            iconDescription = _this$props.iconDescription,
            openCalendar = _this$props.openCalendar,
            size = _this$props.size,
            warn = _this$props.warn,
            warnText = _this$props.warnText,
            other = _objectWithoutProperties$2(_this$props, _excluded$1X);

        var getInstanceId = setupGetInstanceId$2();
        var datePickerInputInstanceId = getInstanceId();
        var datePickerInputHelperId = !helperText ? undefined : "detepicker-input-helper-text-".concat(datePickerInputInstanceId);

        var datePickerInputProps = _defineProperty$2({
          id: id,
          onChange: function onChange(evt) {
            if (!disabled) {
              _onChange(evt);
            }
          },
          onClick: function onClick(evt) {
            if (!disabled) {
              _onClick(evt);
            }
          },
          placeholder: placeholder,
          type: type,
          pattern: pattern
        }, 'aria-describedby', helperText ? datePickerInputHelperId : undefined);

        return /*#__PURE__*/React__default["default"].createElement(PrefixContext.Consumer, null, function (prefix) {
          var _classNames, _classNames2, _classNames4;

          var wrapperClasses = cx("".concat(prefix, "--date-picker-input__wrapper"), (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--date-picker-input__wrapper--invalid"), invalid), _defineProperty$2(_classNames, "".concat(prefix, "--date-picker-input__wrapper--warn"), warn), _classNames));
          var labelClasses = cx("".concat(prefix, "--label"), (_classNames2 = {}, _defineProperty$2(_classNames2, "".concat(prefix, "--visually-hidden"), hideLabel), _defineProperty$2(_classNames2, "".concat(prefix, "--label--disabled"), disabled), _classNames2));
          var helperTextClasses = cx("".concat(prefix, "--form__helper-text"), _defineProperty$2({}, "".concat(prefix, "--form__helper-text--disabled"), disabled));
          var inputClasses = cx("".concat(prefix, "--date-picker__input"), (_classNames4 = {}, _defineProperty$2(_classNames4, "".concat(prefix, "--date-picker__input--").concat(size), size), _defineProperty$2(_classNames4, "".concat(prefix, "--date-picker__input--invalid"), invalid), _classNames4));

          var datePickerIcon = function () {
            if (datePickerType === 'simple' && !invalid && !warn) {
              return;
            }

            if (invalid) {
              return /*#__PURE__*/React__default["default"].createElement(WarningFilled16, {
                className: "".concat(prefix, "--date-picker__icon ").concat(prefix, "--date-picker__icon--invalid")
              });
            }

            if (!invalid && warn) {
              return /*#__PURE__*/React__default["default"].createElement(WarningAltFilled16, {
                className: "".concat(prefix, "--date-picker__icon ").concat(prefix, "--date-picker__icon--warn")
              });
            }

            return /*#__PURE__*/React__default["default"].createElement(Calendar16, {
              className: "".concat(prefix, "--date-picker__icon"),
              "aria-label": iconDescription,
              onClick: openCalendar,
              role: "img",
              "aria-hidden": "true"
            }, iconDescription && /*#__PURE__*/React__default["default"].createElement("title", null, iconDescription));
          }();

          var label = labelText ? /*#__PURE__*/React__default["default"].createElement("label", {
            htmlFor: id,
            className: labelClasses
          }, labelText) : null;
          var helper = helperText ? /*#__PURE__*/React__default["default"].createElement("div", {
            id: datePickerInputHelperId,
            className: helperTextClasses
          }, helperText) : null;
          var error = null;

          if (invalid) {
            error = /*#__PURE__*/React__default["default"].createElement("div", {
              className: "".concat(prefix, "--form-requirement")
            }, invalidText);
          } else if (warn) {
            error = /*#__PURE__*/React__default["default"].createElement("div", {
              className: "".concat(prefix, "--form-requirement")
            }, warnText);
          }

          var containerClasses = cx("".concat(prefix, "--date-picker-container"), _defineProperty$2({}, "".concat(prefix, "--date-picker--nolabel"), !label));
          var input = invalid ? /*#__PURE__*/React__default["default"].createElement("input", _extends$3({}, other, datePickerInputProps, {
            disabled: disabled,
            ref: function ref(input) {
              _this.input = input;
            },
            "data-invalid": true,
            className: inputClasses
          })) : /*#__PURE__*/React__default["default"].createElement("input", _extends$3({
            ref: function ref(input) {
              _this.input = input;
            }
          }, other, datePickerInputProps, {
            disabled: disabled,
            className: inputClasses
          }));
          return /*#__PURE__*/React__default["default"].createElement("div", {
            className: containerClasses
          }, label, /*#__PURE__*/React__default["default"].createElement("div", {
            className: wrapperClasses
          }, input, datePickerIcon), error, helper);
        });
      }
    }]);

    return DatePickerInput;
  }(React.Component);

  _defineProperty$2(DatePickerInput$2, "propTypes", {
    /**
     * The type of the date picker:
     *
     * * `simple` - Without calendar dropdown.
     * * `single` - With calendar dropdown and single date.
     * * `range` - With calendar dropdown and a date range.
     */
    datePickerType: PropTypes__default["default"].oneOf(['simple', 'single', 'range']),

    /**
     * Specify whether or not the input should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Provide text that is used alongside the control label for additional help
     */
    helperText: PropTypes__default["default"].node,

    /**
     * Specify if the label should be hidden
     */
    hideLabel: PropTypes__default["default"].bool,

    /**
     * The description of the calendar icon.
     */
    iconDescription: deprecate(PropTypes__default["default"].string, "\nThe prop `iconDescriptionInput` for DatePickerInput has been deprecated and is no longer used"),

    /**
     * Specify an id that uniquely identifies the `<input>`
     */
    id: PropTypes__default["default"].string.isRequired,

    /**
     * Specify whether or not the input should be invalid
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * Specify the text to be rendered when the input is invalid
     */
    invalidText: PropTypes__default["default"].node,

    /**
     * Provide the text that will be read by a screen reader when visiting this
     * control
     */
    labelText: PropTypes__default["default"].node.isRequired,

    /**
     * Specify an `onChange` handler that is called whenever a change in the
     * input field has occurred
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Provide a function to be called when the input field is clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Provide a function to be called when the input field is clicked
     */
    openCalendar: deprecate(PropTypes__default["default"].func, "\nThe prop `openCalendar` for DatePickerInput has been deprecated and is no longer used"),

    /**
     * Provide a regular expression that the input value must match
     */
    pattern: function pattern(props, propName, componentName) {
      if (props[propName] === undefined) {
        return;
      }

      try {
        new RegExp(props[propName]);
      } catch (e) {
        return new Error("Invalid value of prop '".concat(propName, "' supplied to '").concat(componentName, "', it should be a valid regular expression"));
      }
    },

    /**
     * Specify the placeholder text
     */
    placeholder: PropTypes__default["default"].string,

    /**
     * Specify the size of the Date Picker Input. Currently supports either `sm`, 'md' (default) or 'lg` as an option.
     * TODO V11: remove `xl` (replaced with lg)
     */
    size: PropTypes__default["default"].oneOf(['sm', 'md', 'lg', 'xl']),

    /**
     * Specify the type of the `<input>`
     */
    type: PropTypes__default["default"].string,

    /**
     * Specify whether the control is currently in warning state
     */
    warn: PropTypes__default["default"].bool,

    /**
     * Provide the text that is displayed when the control is in warning state
     */
    warnText: PropTypes__default["default"].node
  });

  _defineProperty$2(DatePickerInput$2, "defaultProps", {
    pattern: '\\d{1,2}\\/\\d{1,2}\\/\\d{4}',
    type: 'text',
    disabled: false,
    invalid: false,
    onClick: function onClick() {},
    onChange: function onChange() {}
  });

  var DatePickerInput = enabled('enable-v11-release') ? DatePickerInputNext : DatePickerInput$2;
  var DatePickerInput$1 = DatePickerInput;

  /**
   * @param {object} config Plugin configuration.
   * @returns {Plugin} A Flatpickr plugin to put adjust the position of calendar dropdown.
   */
  var carbonFlatpickrAppendToPlugin = (function (config) {
    return function (fp) {
      /**
       * Adjusts the floating menu position after Flatpicker sets it.
       */
      var handlePreCalendarPosition = function handlePreCalendarPosition() {
        Promise.resolve().then(function () {
          var calendarContainer = fp.calendarContainer,
              fpConfig = fp.config,
              positionElement = fp._positionElement;
          var appendTo = fpConfig.appendTo;

          var _appendTo$getBounding = appendTo.getBoundingClientRect(),
              containerLeft = _appendTo$getBounding.left,
              containerTop = _appendTo$getBounding.top;

          var _positionElement$getB = positionElement.getBoundingClientRect(),
              refLeft = _positionElement$getB.left,
              refBottom = _positionElement$getB.bottom;

          if ((appendTo !== appendTo.ownerDocument.body || containerLeft !== 0 || containerTop !== 0) && appendTo.ownerDocument.defaultView.getComputedStyle(appendTo).getPropertyValue('position') === 'static') {
            throw new Error('Floating menu container must not have `position:static`.');
          } // `2` for negative margin on calendar dropdown


          calendarContainer.style.top = "".concat(refBottom - containerTop + 2, "px");
          calendarContainer.style.left = "".concat(refLeft - containerLeft, "px");
        });
      };
      /**
       * Registers this Flatpickr plugin.
       */


      var register = function register() {
        fp.loadedPlugins.push('carbonFlatpickrAppendToPlugin');
      };

      return {
        appendTo: config.appendTo,
        onReady: register,
        onPreCalendarPosition: handlePreCalendarPosition
      };
    };
  });

  /**
   * @param {object} config Plugin configuration.
   * @returns {Plugin} A Flatpickr plugin to fix Flatpickr's behavior of certain events.
   */

  var carbonFlatpickrFixEventsPlugin = (function (config) {
    return function (fp) {
      /**
       * Handles `keydown` event.
       */
      var handleKeydown = function handleKeydown(event) {
        var inputFrom = config.inputFrom,
            inputTo = config.inputTo;
        var target = event.target;

        if (inputFrom === target || inputTo === target) {
          if (match(event, Enter)) {
            // Makes sure the hitting enter key picks up pending values of both `<input>`
            // Workaround for: https://github.com/flatpickr/flatpickr/issues/1942
            fp.setDate([inputFrom.value, inputTo && inputTo.value], true, fp.config.dateFormat);
            event.stopPropagation();
          } else if (match(event, ArrowLeft) || match(event, ArrowRight)) {
            // Prevents Flatpickr code from canceling the event if left/right arrow keys are hit on `<input>`,
            // so user can move the keyboard cursor for editing dates
            // Workaround for: https://github.com/flatpickr/flatpickr/issues/1943
            event.stopPropagation();
          } else if (match(event, ArrowDown)) {
            event.preventDefault();
            fp.open();
          }
        }
      };
      /**
       * Releases event listeners used in this Flatpickr plugin.
       */


      var release = function release() {
        var inputFrom = config.inputFrom,
            inputTo = config.inputTo;

        if (inputTo) {
          inputTo.removeEventListener('keydown', handleKeydown, true);
        }

        inputFrom.removeEventListener('keydown', handleKeydown, true);
      };
      /**
       * Sets up event listeners used for this Flatpickr plugin.
       */


      var init = function init() {
        release();
        var inputFrom = config.inputFrom,
            inputTo = config.inputTo;
        inputFrom.addEventListener('keydown', handleKeydown, true);

        if (inputTo) {
          inputTo.addEventListener('keydown', handleKeydown, true);
        }
      };
      /**
       * Registers this Flatpickr plugin.
       */


      var register = function register() {
        fp.loadedPlugins.push('carbonFlatpickrFixEventsPlugin');
      };

      return {
        onReady: [register, init],
        onDestroy: [release]
      };
    };
  });

  var rangePlugin$1 = {exports: {}};

  (function (module, exports) {
  (function (global, factory) {
      module.exports = factory() ;
  }(commonjsGlobal, (function () {
      /*! *****************************************************************************
      Copyright (c) Microsoft Corporation.

      Permission to use, copy, modify, and/or distribute this software for any
      purpose with or without fee is hereby granted.

      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.
      ***************************************************************************** */

      function __spreadArrays() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
              for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                  r[k] = a[j];
          return r;
      }

      function rangePlugin(config) {
          if (config === void 0) { config = {}; }
          return function (fp) {
              var dateFormat = "", secondInput, _secondInputFocused, _prevDates;
              var createSecondInput = function () {
                  if (config.input) {
                      secondInput =
                          config.input instanceof Element
                              ? config.input
                              : window.document.querySelector(config.input);
                      if (!secondInput) {
                          fp.config.errorHandler(new Error("Invalid input element specified"));
                          return;
                      }
                      if (fp.config.wrap) {
                          secondInput = secondInput.querySelector("[data-input]");
                      }
                  }
                  else {
                      secondInput = fp._input.cloneNode();
                      secondInput.removeAttribute("id");
                      secondInput._flatpickr = undefined;
                  }
                  if (secondInput.value) {
                      var parsedDate = fp.parseDate(secondInput.value);
                      if (parsedDate)
                          fp.selectedDates.push(parsedDate);
                  }
                  secondInput.setAttribute("data-fp-omit", "");
                  if (fp.config.clickOpens) {
                      fp._bind(secondInput, ["focus", "click"], function () {
                          if (fp.selectedDates[1]) {
                              fp.latestSelectedDateObj = fp.selectedDates[1];
                              fp._setHoursFromDate(fp.selectedDates[1]);
                              fp.jumpToDate(fp.selectedDates[1]);
                          }
                          _secondInputFocused = true;
                          fp.isOpen = false;
                          fp.open(undefined, config.position === "left" ? fp._input : secondInput);
                      });
                      fp._bind(fp._input, ["focus", "click"], function (e) {
                          e.preventDefault();
                          fp.isOpen = false;
                          fp.open();
                      });
                  }
                  if (fp.config.allowInput)
                      fp._bind(secondInput, "keydown", function (e) {
                          if (e.key === "Enter") {
                              fp.setDate([fp.selectedDates[0], secondInput.value], true, dateFormat);
                              secondInput.click();
                          }
                      });
                  if (!config.input)
                      fp._input.parentNode &&
                          fp._input.parentNode.insertBefore(secondInput, fp._input.nextSibling);
              };
              var plugin = {
                  onParseConfig: function () {
                      fp.config.mode = "range";
                      dateFormat = fp.config.altInput
                          ? fp.config.altFormat
                          : fp.config.dateFormat;
                  },
                  onReady: function () {
                      createSecondInput();
                      fp.config.ignoredFocusElements.push(secondInput);
                      if (fp.config.allowInput) {
                          fp._input.removeAttribute("readonly");
                          secondInput.removeAttribute("readonly");
                      }
                      else {
                          secondInput.setAttribute("readonly", "readonly");
                      }
                      fp._bind(fp._input, "focus", function () {
                          fp.latestSelectedDateObj = fp.selectedDates[0];
                          fp._setHoursFromDate(fp.selectedDates[0]);
                          _secondInputFocused = false;
                          fp.jumpToDate(fp.selectedDates[0]);
                      });
                      if (fp.config.allowInput)
                          fp._bind(fp._input, "keydown", function (e) {
                              if (e.key === "Enter")
                                  fp.setDate([fp._input.value, fp.selectedDates[1]], true, dateFormat);
                          });
                      fp.setDate(fp.selectedDates, false);
                      plugin.onValueUpdate(fp.selectedDates);
                      fp.loadedPlugins.push("range");
                  },
                  onPreCalendarPosition: function () {
                      if (_secondInputFocused) {
                          fp._positionElement = secondInput;
                          setTimeout(function () {
                              fp._positionElement = fp._input;
                          }, 0);
                      }
                  },
                  onChange: function () {
                      if (!fp.selectedDates.length) {
                          setTimeout(function () {
                              if (fp.selectedDates.length)
                                  return;
                              secondInput.value = "";
                              _prevDates = [];
                          }, 10);
                      }
                      if (_secondInputFocused) {
                          setTimeout(function () {
                              secondInput.focus();
                          }, 0);
                      }
                  },
                  onDestroy: function () {
                      if (!config.input)
                          secondInput.parentNode &&
                              secondInput.parentNode.removeChild(secondInput);
                  },
                  onValueUpdate: function (selDates) {
                      var _a, _b, _c;
                      if (!secondInput)
                          return;
                      _prevDates =
                          !_prevDates || selDates.length >= _prevDates.length
                              ? __spreadArrays(selDates) : _prevDates;
                      if (_prevDates.length > selDates.length) {
                          var newSelectedDate = selDates[0];
                          var newDates = _secondInputFocused
                              ? [_prevDates[0], newSelectedDate]
                              : [newSelectedDate, _prevDates[1]];
                          fp.setDate(newDates, false);
                          _prevDates = __spreadArrays(newDates);
                      }
                      _a = fp.selectedDates.map(function (d) { return fp.formatDate(d, dateFormat); }), _b = _a[0], fp._input.value = _b === void 0 ? "" : _b, _c = _a[1], secondInput.value = _c === void 0 ? "" : _c;
                  },
              };
              return plugin;
          };
      }

      return rangePlugin;

  })));
  }(rangePlugin$1));

  var rangePlugin = rangePlugin$1.exports;

  /**
   * @param {object} config Plugin configuration.
   * @returns {Plugin} An extension of Flatpickr `rangePlugin` that does the following:
   *   * Better ensures the calendar dropdown is always aligned to the `<input>` for the starting date.
   *     Workaround for: https://github.com/flatpickr/flatpickr/issues/1944
   *   * A logic to ensure `fp.setDate()` call won't end up with "startDate to endDate" set to the first `<input>`
   */

  var carbonFlatpickrRangePlugin = (function (config) {
    var factory = rangePlugin(Object.assign({
      position: 'left'
    }, config));
    return function (fp) {
      var origSetDate = fp.setDate;

      var init = function init() {
        fp.setDate = function setDate(dates, triggerChange, format) {
          origSetDate.call(this, dates, triggerChange, format); // If `triggerChange` is `true`, `onValueUpdate` Flatpickr event is fired
          // where Flatpickr's range plugin takes care of fixing the first `<input>`

          if (!triggerChange) {
            var inputFrom = fp._input;
            var inputTo = config.input;
            [inputFrom, inputTo].forEach(function (input, i) {
              if (input) {
                input.value = !dates[i] ? '' : fp.formatDate(new Date(dates[i]), fp.config.dateFormat);
              }
            });
          }
        };
      };

      var origRangePlugin = factory(fp);
      var origOnReady = origRangePlugin.onReady;
      return Object.assign(origRangePlugin, {
        onReady: [init, origOnReady],
        onPreCalendarPosition: function onPreCalendarPosition() {}
      });
    };
  });

  /**
   * Provide a stable reference for a callback that is passed as a prop to a
   * component. This is helpful when you want access to the latest version of a
   * callback prop but don't want it to be added to the dependency array of an
   * effect.
   *
   * @param {Function} callback
   * @returns {Function}
   */

  function useSavedCallback(callback) {
    var savedCallback = React.useRef(callback);
    React.useEffect(function () {
      savedCallback.current = callback;
    });
    return React.useCallback(function () {
      if (savedCallback.current) {
        return savedCallback.current();
      }
    }, []);
  }

  var _excluded$1W = ["allowInput", "appendTo", "children", "className", "dateFormat", "datePickerType", "disable", "enable", "inline", "light", "locale", "maxDate", "minDate", "onChange", "onClose", "onOpen", "short", "value"];

  l10n.en.weekdays.shorthand.forEach(function (_day, index) {
    var currentDay = l10n.en.weekdays.shorthand;

    if (currentDay[index] === 'Thu' || currentDay[index] === 'Th') {
      currentDay[index] = 'Th';
    } else {
      currentDay[index] = currentDay[index].charAt(0);
    }
  });
  var forEach$1 = Array.prototype.forEach;
  /**
   * @param {number} monthNumber The month number.
   * @param {boolean} shorthand `true` to use shorthand month.
   * @param {Locale} locale The Flatpickr locale data.
   * @returns {string} The month string.
   */

  var monthToStr$1 = function monthToStr(monthNumber, shorthand, locale) {
    return locale.months[shorthand ? 'shorthand' : 'longhand'][monthNumber];
  };
  /**
   * @param {object} config Plugin configuration.
   * @param {boolean} [config.shorthand] `true` to use shorthand month.
   * @param {string} config.selectorFlatpickrMonthYearContainer The CSS selector for the container of month/year selection UI.
   * @param {string} config.selectorFlatpickrYearContainer The CSS selector for the container of year selection UI.
   * @param {string} config.selectorFlatpickrCurrentMonth The CSS selector for the text-based month selection UI.
   * @param {string} config.classFlatpickrCurrentMonth The CSS class for the text-based month selection UI.
   * @returns {Plugin} A Flatpickr plugin to use text instead of `<select>` for month picker.
   */


  var carbonFlatpickrMonthSelectPlugin$1 = function carbonFlatpickrMonthSelectPlugin(config) {
    return function (fp) {
      var setupElements = function setupElements() {
        var _fp$monthElements;

        if (!fp.monthElements) {
          return;
        }

        fp.monthElements.forEach(function (elem) {
          if (!elem.parentNode) {
            return;
          }

          elem.parentNode.removeChild(elem);
        });

        (_fp$monthElements = fp.monthElements).splice.apply(_fp$monthElements, [0, fp.monthElements.length].concat(_toConsumableArray(fp.monthElements.map(function () {
          // eslint-disable-next-line no-underscore-dangle
          var monthElement = fp._createElement('span', config.classFlatpickrCurrentMonth);

          monthElement.textContent = monthToStr$1(fp.currentMonth, config.shorthand === true, fp.l10n);
          fp.yearElements[0].closest(config.selectorFlatpickrMonthYearContainer).insertBefore(monthElement, fp.yearElements[0].closest(config.selectorFlatpickrYearContainer));
          return monthElement;
        }))));
      };

      var updateCurrentMonth = function updateCurrentMonth() {
        var monthStr = monthToStr$1(fp.currentMonth, config.shorthand === true, fp.l10n);
        fp.yearElements.forEach(function (elem) {
          var currentMonthContainer = elem.closest(config.selectorFlatpickrMonthYearContainer);
          Array.prototype.forEach.call(currentMonthContainer.querySelectorAll('.cur-month'), function (monthElement) {
            monthElement.textContent = monthStr;
          });
        });
      };

      var register = function register() {
        fp.loadedPlugins.push('carbonFlatpickrMonthSelectPlugin');
      };

      return {
        onMonthChange: updateCurrentMonth,
        onValueUpdate: updateCurrentMonth,
        onOpen: updateCurrentMonth,
        onReady: [setupElements, updateCurrentMonth, register]
      };
    };
  };
  /**
   * Determine if every child in a list of children has no label specified
   * @param {Array<ReactElement>} children
   * @returns {boolean}
   */


  function isLabelTextEmpty(children) {
    return children.every(function (child) {
      return !child.props.labelText;
    });
  }

  var rightArrowHTML = "<svg width=\"16px\" height=\"16px\" viewBox=\"0 0 16 16\">\n  <polygon points=\"11,8 6,13 5.3,12.3 9.6,8 5.3,3.7 6,3 \"/>\n  <rect width=\"16\" height=\"16\" style=\"fill:none\" />\n</svg>";
  var leftArrowHTML = "<svg width=\"16px\" height=\"16px\" viewBox=\"0 0 16 16\">\n  <polygon points=\"5,8 10,3 10.7,3.7 6.4,8 10.7,12.3 10,13 \"/>\n  <rect width=\"16\" height=\"16\" style=\"fill:none\" />\n</svg>";

  function updateClassNames(calendar, prefix) {
    var calendarContainer = calendar.calendarContainer;
    var daysContainer = calendar.days;

    if (calendarContainer && daysContainer) {
      // calendarContainer and daysContainer are undefined if flatpickr detects a mobile device
      calendarContainer.classList.add("".concat(prefix, "--date-picker__calendar"));
      calendarContainer.querySelector('.flatpickr-month').classList.add("".concat(prefix, "--date-picker__month"));
      calendarContainer.querySelector('.flatpickr-weekdays').classList.add("".concat(prefix, "--date-picker__weekdays"));
      calendarContainer.querySelector('.flatpickr-days').classList.add("".concat(prefix, "--date-picker__days"));
      forEach$1.call(calendarContainer.querySelectorAll('.flatpickr-weekday'), function (item) {
        var currentItem = item;
        currentItem.innerHTML = currentItem.innerHTML.replace(/\s+/g, '');
        currentItem.classList.add("".concat(prefix, "--date-picker__weekday"));
      });
      forEach$1.call(daysContainer.querySelectorAll('.flatpickr-day'), function (item) {
        item.classList.add("".concat(prefix, "--date-picker__day"));

        if (item.classList.contains('today') && calendar.selectedDates.length > 0) {
          item.classList.add('no-border');
        } else if (item.classList.contains('today') && calendar.selectedDates.length === 0) {
          item.classList.remove('no-border');
        }
      });
    }
  }

  function DatePicker$3(_ref) {
    var _cx;

    var allowInput = _ref.allowInput,
        appendTo = _ref.appendTo,
        children = _ref.children,
        className = _ref.className,
        _ref$dateFormat = _ref.dateFormat,
        dateFormat = _ref$dateFormat === void 0 ? 'm/d/Y' : _ref$dateFormat,
        datePickerType = _ref.datePickerType,
        disable = _ref.disable,
        enable = _ref.enable,
        inline = _ref.inline,
        _ref$light = _ref.light,
        light = _ref$light === void 0 ? false : _ref$light,
        _ref$locale = _ref.locale,
        locale = _ref$locale === void 0 ? 'en' : _ref$locale,
        maxDate = _ref.maxDate,
        minDate = _ref.minDate,
        onChange = _ref.onChange,
        onClose = _ref.onClose,
        onOpen = _ref.onOpen,
        _ref$short = _ref.short,
        short = _ref$short === void 0 ? false : _ref$short,
        value = _ref.value,
        rest = _objectWithoutProperties$2(_ref, _excluded$1W);

    var prefix = usePrefix();
    var startInputField = React.useRef(null);
    var endInputField = React.useRef(null);
    var calendarRef = React.useRef(null);
    var savedOnChange = useSavedCallback(onChange);
    var savedOnClose = useSavedCallback(onClose);
    var savedOnOpen = useSavedCallback(onOpen);
    var datePickerClasses = cx("".concat(prefix, "--date-picker"), (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--date-picker--short"), short), _defineProperty$2(_cx, "".concat(prefix, "--date-picker--light"), light), _defineProperty$2(_cx, "".concat(prefix, "--date-picker--simple"), datePickerType === 'simple'), _defineProperty$2(_cx, "".concat(prefix, "--date-picker--single"), datePickerType === 'single'), _defineProperty$2(_cx, "".concat(prefix, "--date-picker--range"), datePickerType === 'range'), _defineProperty$2(_cx, "".concat(prefix, "--date-picker--nolabel"), datePickerType === 'range' && isLabelTextEmpty(children)), _cx));
    var wrapperClasses = cx("".concat(prefix, "--form-item"), _defineProperty$2({}, className, className));
    var childrenWithProps = React__default["default"].Children.toArray(children).map(function (child, index) {
      if (index === 0 && child.type === React__default["default"].createElement(DatePickerInput$1, child.props).type) {
        return /*#__PURE__*/React__default["default"].cloneElement(child, {
          datePickerType: datePickerType,
          ref: startInputField,
          openCalendar: function openCalendar() {
            if (calendarRef.current) {
              calendarRef.current.open();
            }
          }
        });
      }

      if (index === 1 && child.type === React__default["default"].createElement(DatePickerInput$1, child.props).type) {
        return /*#__PURE__*/React__default["default"].cloneElement(child, {
          datePickerType: datePickerType,
          ref: endInputField,
          openCalendar: function openCalendar() {
            if (calendarRef.current) {
              calendarRef.current.open();
            }
          }
        });
      }

      if (index === 0) {
        return /*#__PURE__*/React__default["default"].cloneElement(child, {
          ref: startInputField
        });
      }

      if (index === 1) {
        return /*#__PURE__*/React__default["default"].cloneElement(child, {
          ref: endInputField
        });
      }
    });
    React.useEffect(function () {
      var _flatpickr;

      if (datePickerType !== 'single' && datePickerType !== 'range') {
        return;
      }

      if (startInputField.current === null) {
        return;
      }

      var onHook = function onHook(_electedDates, _dateStr, instance, prefix) {
        updateClassNames(instance, prefix);
      }; // Logic to determine if `enable` or `disable` will be passed down. If neither
      // is provided, we return the default empty disabled array, allowing all dates.


      var enableOrDisable = enable ? 'enable' : 'disable';
      var enableOrDisableArr;

      if (!enable && !disable) {
        enableOrDisableArr = [];
      } else if (enable) {
        enableOrDisableArr = enable;
      } else {
        enableOrDisableArr = disable;
      }

      var localeData;

      if (_typeof(locale) === 'object') {
        var location = locale.locale ? locale.locale : 'en';
        localeData = _objectSpread2$2(_objectSpread2$2({}, l10n[location]), locale);
      } else {
        localeData = l10n[locale];
      }

      var start = startInputField.current;
      var end = endInputField.current;
      var calendar = new flatpickr(start, (_flatpickr = {
        inline: inline !== null && inline !== void 0 ? inline : false,
        disableMobile: true,
        defaultDate: value,
        mode: datePickerType,
        allowInput: allowInput !== null && allowInput !== void 0 ? allowInput : true,
        dateFormat: dateFormat,
        locale: localeData
      }, _defineProperty$2(_flatpickr, enableOrDisable, enableOrDisableArr), _defineProperty$2(_flatpickr, "minDate", minDate), _defineProperty$2(_flatpickr, "maxDate", maxDate), _defineProperty$2(_flatpickr, "plugins", [datePickerType === 'range' ? new carbonFlatpickrRangePlugin({
        input: endInputField.current
      }) : function () {}, appendTo ? carbonFlatpickrAppendToPlugin({
        appendTo: appendTo
      }) : function () {}, carbonFlatpickrMonthSelectPlugin$1({
        selectorFlatpickrMonthYearContainer: '.flatpickr-current-month',
        selectorFlatpickrYearContainer: '.numInputWrapper',
        selectorFlatpickrCurrentMonth: '.cur-month',
        classFlatpickrCurrentMonth: 'cur-month'
      }), carbonFlatpickrFixEventsPlugin({
        inputFrom: startInputField.current,
        inputTo: endInputField.current
      })]), _defineProperty$2(_flatpickr, "clickOpens", true), _defineProperty$2(_flatpickr, "nextArrow", rightArrowHTML), _defineProperty$2(_flatpickr, "prevArrow", leftArrowHTML), _defineProperty$2(_flatpickr, "onChange", savedOnChange), _defineProperty$2(_flatpickr, "onClose", savedOnClose), _defineProperty$2(_flatpickr, "onReady", onHook), _defineProperty$2(_flatpickr, "onMonthChange", onHook), _defineProperty$2(_flatpickr, "onYearChange", onHook), _defineProperty$2(_flatpickr, "onOpen", function onOpen() {
        onHook.apply(void 0, arguments);
        savedOnOpen.apply(void 0, arguments);
      }), _defineProperty$2(_flatpickr, "onValueUpdate", onHook), _flatpickr));
      calendarRef.current = calendar;

      function handleArrowDown(event) {
        if (match(event, ArrowDown)) {
          var calendarContainer = calendar.calendarContainer,
              fpSelectedDateElem = calendar.selectedDateElem,
              fptodayDateElem = calendar.todayDateElem;
          var selectedDateElem = calendarContainer.querySelector('.selected') && fpSelectedDateElem;
          var todayDateElem = calendarContainer.querySelector('.today') && fptodayDateElem;
          (selectedDateElem || todayDateElem || calendarContainer.querySelector('.flatpickr-day[tabindex]') || calendarContainer).focus();
        }
      }

      function handleOnChange() {
        if (start.value !== '') {
          return;
        }

        if (!calendar.selectedDates) {
          return;
        }

        if (calendar.selectedDates.length === 0) {
          return;
        }

        calendar.clear();
        calendar.input.focus();
      }

      if (start) {
        start.addEventListener('keydown', handleArrowDown);
        start.addEventListener('change', handleOnChange); // Flatpickr's calendar dialog is not rendered in a landmark causing an
        // error with IBM Equal Access Accessibility Checker so we add an aria
        // role to the container div.

        calendar.calendarContainer.setAttribute('role', 'region'); // IBM EAAC requires an aria-label on a role='region'

        calendar.calendarContainer.setAttribute('aria-label', 'calendar-container');
      }

      if (end) {
        end.addEventListener('keydown', handleArrowDown);
        end.addEventListener('change', handleOnChange);
      } //component did unmount equivalent


      return function () {
        // Note: if the `startInputField` ref is undefined then calendar will be
        // of type: Array and `destroy` will not be defined
        if (calendar && calendar.destroy) {
          calendar.destroy();
        }

        if (start) {
          start.removeEventListener('keydown', handleArrowDown);
          start.removeEventListener('change', handleOnChange);
        }

        if (end) {
          end.removeEventListener('keydown', handleArrowDown);
          end.removeEventListener('change', handleOnChange);
        }
      };
    }, [savedOnChange, savedOnClose, savedOnOpen]); //eslint-disable-line react-hooks/exhaustive-deps

    React.useEffect(function () {
      if (calendarRef.current) {
        calendarRef.current.set({
          dateFormat: dateFormat
        });
      }
    }, [dateFormat]);
    React.useEffect(function () {
      if (calendarRef.current && minDate) {
        calendarRef.current.set('minDate', minDate);
      }
    }, [minDate]);
    React.useEffect(function () {
      if (calendarRef.current && maxDate) {
        calendarRef.current.set('maxDate', maxDate);
      }
    }, [maxDate]);
    React.useEffect(function () {
      if (calendarRef.current && disable) {
        calendarRef.current.set('disbale', disable);
      }
    }, [disable]);
    React.useEffect(function () {
      if (calendarRef.current && enable) {
        calendarRef.current.set('enable', enable);
      }
    }, [enable]);
    React.useEffect(function () {
      if (calendarRef.current && inline) {
        calendarRef.current.set('inline', inline);
      }
    }, [inline]);
    React.useEffect(function () {
      if (calendarRef.current) {
        calendarRef.current.set({
          value: value
        });
        updateClassNames(calendarRef.current, prefix); //for simple date picker w/o calendar; initial mount may not have value
      } else if (!calendarRef.current && value) {
        startInputField.current.value = value;
      }
    }, [value, prefix]);
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: wrapperClasses
    }, rest), /*#__PURE__*/React__default["default"].createElement("div", {
      className: datePickerClasses
    }, childrenWithProps));
  }

  DatePicker$3.propTypes = {
    /**
     * flatpickr prop passthrough. Allows the user to enter a date directly
     * into the input field
     */
    allowInput: PropTypes__default["default"].bool,

    /**
     * The DOM element the Flatpicker should be inserted into. `<body>` by default.
     */
    appendTo: PropTypes__default["default"].object,

    /**
     * The child nodes.
     */
    children: PropTypes__default["default"].node,

    /**
     * The CSS class names.
     */
    className: PropTypes__default["default"].string,

    /**
     * The date format.
     */
    dateFormat: PropTypes__default["default"].string,

    /**
     * The type of the date picker:
     *
     * * `simple` - Without calendar dropdown.
     * * `single` - With calendar dropdown and single date.
     * * `range` - With calendar dropdown and a date range.
     */
    datePickerType: PropTypes__default["default"].oneOf(['simple', 'single', 'range']),

    /**
     * The flatpickr `disable` option that allows a user to disable certain dates.
     */
    disable: PropTypes__default["default"].array,

    /**
     * The flatpickr `enable` option that allows a user to enable certain dates.
     */
    enable: PropTypes__default["default"].array,

    /**
     * The flatpickr `inline` option.
     */
    inline: PropTypes__default["default"].bool,

    /**
     * `true` to use the light version.
     */
    light: PropTypes__default["default"].bool,

    /**
     *  The language locale used to format the days of the week, months, and numbers. The full list of supported locales can be found here https://github.com/flatpickr/flatpickr/tree/master/src/l10n
     */
    locale: PropTypes__default["default"].oneOfType([PropTypes__default["default"].object, PropTypes__default["default"].oneOf(['ar', // Arabic
    'at', // Austria
    'az', // Azerbaijan
    'be', // Belarusian
    'bg', // Bulgarian
    'bn', // Bangla
    'bs', // Bosnia
    'cat', // Catalan
    'cs', // Czech
    'cy', // Welsh
    'da', // Danish
    'de', // German
    'en', // English
    'eo', // Esperanto
    'es', // Spanish
    'et', // Estonian
    'fa', // Persian
    'fi', // Finnish
    'fo', // Faroese
    'fr', // French
    'ga', // Gaelic
    'gr', // Greek
    'he', // Hebrew
    'hi', // Hindi
    'hr', // Croatian
    'hu', // Hungarian
    'id', // Indonesian
    'is', // Icelandic
    'it', // Italian
    'ja', // Japanese
    'ka', // Georgian
    'km', // Khmer
    'ko', // Korean
    'kz', // Kazakh
    'lt', // Lithuanian
    'lv', // Latvian
    'mk', // Macedonian
    'mn', // Mongolian
    'ms', // Malaysian
    'my', // Burmese
    'nl', // Dutch
    'no', // Norwegian
    'pa', // Punjabi
    'pl', // Polish
    'pt', // Portuguese
    'ro', // Romanian
    'ru', // Russian
    'si', // Sinhala
    'sk', // Slovak
    'sl', // Slovenian
    'sq', // Albanian
    'sr', // Serbian
    'sv', // Swedish
    'th', // Thai
    'tr', // Turkish
    'uk', // Ukrainian
    'uz', // Uzbek
    'uz_latn', // Uzbek Latin
    'vn', // Vietnamese
    'zh_tw', // Mandarin Traditional
    'zh' // Mandarin
    ])]),

    /**
     * The maximum date that a user can pick to.
     */
    maxDate: PropTypes__default["default"].string,

    /**
     * The minimum date that a user can start picking from.
     */
    minDate: PropTypes__default["default"].string,

    /**
     * The `change` event handler.
     */
    onChange: PropTypes__default["default"].func,

    /**
     * The `close` event handler.
     */
    onClose: PropTypes__default["default"].func,

    /**
     * The `open` event handler.
     */
    onOpen: PropTypes__default["default"].func,

    /**
     * `true` to use the short version.
     */
    short: PropTypes__default["default"].bool,

    /**
     * The value of the date value provided to flatpickr, could
     * be a date, a date number, a date string, an array of dates.
     */
    value: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].arrayOf(PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number, PropTypes__default["default"].object])), PropTypes__default["default"].object, PropTypes__default["default"].number])
  };

  var _excluded$1V = ["allowInput", "appendTo", "datePickerType", "dateFormat", "locale", "minDate", "maxDate", "value", "onClose", "disable", "enable"],
      _excluded2$b = ["dateFormat", "minDate", "maxDate", "value", "disable", "enable"],
      _excluded3$7 = ["dateFormat", "minDate", "maxDate", "value", "disable", "enable"],
      _excluded4$7 = ["allowInput", "appendTo", "children", "className", "short", "light", "datePickerType", "minDate", "maxDate", "dateFormat", "onChange", "locale", "value", "onOpen"];

  l10n.en.weekdays.shorthand.forEach(function (day, index) {
    var currentDay = l10n.en.weekdays.shorthand;

    if (currentDay[index] === 'Thu' || currentDay[index] === 'Th') {
      currentDay[index] = 'Th';
    } else {
      currentDay[index] = currentDay[index].charAt(0);
    }
  });
  var forEach = Array.prototype.forEach;
  /**
   * @param {number} monthNumber The month number.
   * @param {boolean} shorthand `true` to use shorthand month.
   * @param {Locale} locale The Flatpickr locale data.
   * @returns {string} The month string.
   */

  var monthToStr = function monthToStr(monthNumber, shorthand, locale) {
    return locale.months[shorthand ? 'shorthand' : 'longhand'][monthNumber];
  };
  /**
   * @param {object} config Plugin configuration.
   * @param {boolean} [config.shorthand] `true` to use shorthand month.
   * @param {string} config.selectorFlatpickrMonthYearContainer The CSS selector for the container of month/year selection UI.
   * @param {string} config.selectorFlatpickrYearContainer The CSS selector for the container of year selection UI.
   * @param {string} config.selectorFlatpickrCurrentMonth The CSS selector for the text-based month selection UI.
   * @param {string} config.classFlatpickrCurrentMonth The CSS class for the text-based month selection UI.
   * @returns {Plugin} A Flatpickr plugin to use text instead of `<select>` for month picker.
   */


  var carbonFlatpickrMonthSelectPlugin = function carbonFlatpickrMonthSelectPlugin(config) {
    return function (fp) {
      var setupElements = function setupElements() {
        var _fp$monthElements;

        if (!fp.monthElements) {
          return;
        }

        fp.monthElements.forEach(function (elem) {
          if (!elem.parentNode) {
            return;
          }

          elem.parentNode.removeChild(elem);
        });

        (_fp$monthElements = fp.monthElements).splice.apply(_fp$monthElements, [0, fp.monthElements.length].concat(_toConsumableArray(fp.monthElements.map(function () {
          // eslint-disable-next-line no-underscore-dangle
          var monthElement = fp._createElement('span', config.classFlatpickrCurrentMonth);

          monthElement.textContent = monthToStr(fp.currentMonth, config.shorthand === true, fp.l10n);
          fp.yearElements[0].closest(config.selectorFlatpickrMonthYearContainer).insertBefore(monthElement, fp.yearElements[0].closest(config.selectorFlatpickrYearContainer));
          return monthElement;
        }))));
      };

      var updateCurrentMonth = function updateCurrentMonth() {
        var monthStr = monthToStr(fp.currentMonth, config.shorthand === true, fp.l10n);
        fp.yearElements.forEach(function (elem) {
          var currentMonthContainer = elem.closest(config.selectorFlatpickrMonthYearContainer);
          Array.prototype.forEach.call(currentMonthContainer.querySelectorAll('.cur-month'), function (monthElement) {
            monthElement.textContent = monthStr;
          });
        });
      };

      var register = function register() {
        fp.loadedPlugins.push('carbonFlatpickrMonthSelectPlugin');
      };

      return {
        onMonthChange: updateCurrentMonth,
        onValueUpdate: updateCurrentMonth,
        onOpen: updateCurrentMonth,
        onReady: [setupElements, updateCurrentMonth, register]
      };
    };
  };

  var DatePicker$2 = /*#__PURE__*/function (_Component) {
    _inherits(DatePicker, _Component);

    var _super = _createSuper(DatePicker);

    function DatePicker() {
      var _this;

      _classCallCheck$1(this, DatePicker);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty$2(_assertThisInitialized$1(_this), "onChange", function () {
        var _this$cal;

        if (_this.inputField.value === '' && (_this$cal = _this.cal) !== null && _this$cal !== void 0 && _this$cal.selectedDates.length) {
          _this.cal.clear();

          _this.cal.input.focus();
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "addRoleAttributeToDialog", function () {
        if (_this.inputField) {
          _this.cal.calendarContainer.setAttribute('role', 'application'); // IBM EAAC requires an aria-label on a role='region'


          _this.cal.calendarContainer.setAttribute('aria-label', 'calendar-container');
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "addKeyboardEvents", function (cal) {
        var initArrowDownListener = function initArrowDownListener(element) {
          if (element) {
            element.addEventListener('keydown', function (e) {
              if (match(e, ArrowDown)) {
                var calendarContainer = cal.calendarContainer,
                    fpSelectedDateElem = cal.selectedDateElem,
                    fptodayDateElem = cal.todayDateElem;
                var selectedDateElem = calendarContainer.querySelector('.selected') && fpSelectedDateElem;
                var todayDateElem = calendarContainer.querySelector('.today') && fptodayDateElem;
                (selectedDateElem || todayDateElem || calendarContainer.querySelector('.flatpickr-day[tabindex]') || calendarContainer).focus();
              }
            });
            element.addEventListener('change', _this.onChange);
          }
        };

        initArrowDownListener(_this.inputField);
        initArrowDownListener(_this.toInputField);
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "updateClassNames", function (calendar) {
        var calendarContainer = calendar.calendarContainer;
        var daysContainer = calendar.days;

        if (calendarContainer && daysContainer) {
          // calendarContainer and daysContainer are undefined if flatpickr detects a mobile device
          calendarContainer.classList.add("".concat(_this.context, "--date-picker__calendar"));
          calendarContainer.querySelector('.flatpickr-month').classList.add("".concat(_this.context, "--date-picker__month"));
          calendarContainer.querySelector('.flatpickr-weekdays').classList.add("".concat(_this.context, "--date-picker__weekdays"));
          calendarContainer.querySelector('.flatpickr-days').classList.add("".concat(_this.context, "--date-picker__days"));
          forEach.call(calendarContainer.querySelectorAll('.flatpickr-weekday'), function (item) {
            var currentItem = item;
            currentItem.innerHTML = currentItem.innerHTML.replace(/\s+/g, '');
            currentItem.classList.add("".concat(_this.context, "--date-picker__weekday"));
          });
          forEach.call(daysContainer.querySelectorAll('.flatpickr-day'), function (item) {
            item.classList.add("".concat(_this.context, "--date-picker__day"));

            if (item.classList.contains('today') && calendar.selectedDates.length > 0) {
              item.classList.add('no-border');
            } else if (item.classList.contains('today') && calendar.selectedDates.length === 0) {
              item.classList.remove('no-border');
            }
          });
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "assignInputFieldRef", function (node) {
        _this.inputField = !node ? null : // Child is a regular DOM node, seen in tests
        node.nodeType === Node.ELEMENT_NODE ? node.querySelector(".".concat(_this.context, "--date-picker__input")) : // Child is a React component
        node.input && node.input.nodeType === Node.ELEMENT_NODE ? node.input : null;
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "assignToInputFieldRef", function (node) {
        _this.toInputField = !node ? null : // Child is a regular DOM node, seen in tests
        node.nodeType === Node.ELEMENT_NODE ? node.querySelector(".".concat(_this.context, "--date-picker__input")) : // Child is a React component
        node.input && node.input.nodeType === Node.ELEMENT_NODE ? node.input : null;
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "isLabelTextEmpty", function (children) {
        return children.every(function (child) {
          return !child.props.labelText;
        });
      });

      return _this;
    }

    _createClass$1(DatePicker, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;

        var _this$props = this.props,
            allowInput = _this$props.allowInput,
            appendTo = _this$props.appendTo,
            datePickerType = _this$props.datePickerType,
            dateFormat = _this$props.dateFormat,
            locale = _this$props.locale,
            minDate = _this$props.minDate,
            maxDate = _this$props.maxDate,
            value = _this$props.value,
            onClose = _this$props.onClose,
            disable = _this$props.disable,
            enable = _this$props.enable,
            rest = _objectWithoutProperties$2(_this$props, _excluded$1V);

        if (datePickerType === 'single' || datePickerType === 'range') {
          var onHook = function onHook(electedDates, dateStr, instance) {
            _this2.updateClassNames(instance);
          }; // Logic to determine if `enable` or `disable` will be passed down. If neither
          // is provided, we return the default empty disabled array, allowing all dates.


          var enableOrDisable = enable ? 'enable' : 'disable';
          var enableOrDisableArr;

          if (!enable && !disable) {
            enableOrDisableArr = [];
          } else if (enable) {
            enableOrDisableArr = enable;
          } else {
            enableOrDisableArr = disable;
          }

          var localeData;

          if (_typeof(locale) === 'object') {
            var location = locale.locale ? locale.locale : 'en';
            localeData = _objectSpread2$2(_objectSpread2$2({}, l10n[location]), locale);
          } else {
            localeData = l10n[locale];
          } // inputField ref might not be set in enzyme tests


          if (this.inputField) {
            var _rest$inline, _flatpickr;

            this.cal = new flatpickr(this.inputField, (_flatpickr = {
              inline: (_rest$inline = rest.inline) !== null && _rest$inline !== void 0 ? _rest$inline : false,
              disableMobile: true,
              defaultDate: value,
              mode: datePickerType,
              allowInput: allowInput !== null && allowInput !== void 0 ? allowInput : true,
              dateFormat: dateFormat,
              locale: localeData
            }, _defineProperty$2(_flatpickr, enableOrDisable, enableOrDisableArr), _defineProperty$2(_flatpickr, "minDate", minDate), _defineProperty$2(_flatpickr, "maxDate", maxDate), _defineProperty$2(_flatpickr, "plugins", [datePickerType === 'range' ? new carbonFlatpickrRangePlugin({
              input: this.toInputField
            }) : function () {}, appendTo ? carbonFlatpickrAppendToPlugin({
              appendTo: appendTo
            }) : function () {}, carbonFlatpickrMonthSelectPlugin({
              selectorFlatpickrMonthYearContainer: '.flatpickr-current-month',
              selectorFlatpickrYearContainer: '.numInputWrapper',
              selectorFlatpickrCurrentMonth: '.cur-month',
              classFlatpickrCurrentMonth: 'cur-month'
            }), carbonFlatpickrFixEventsPlugin({
              inputFrom: this.inputField,
              inputTo: this.toInputField
            })]), _defineProperty$2(_flatpickr, "clickOpens", true), _defineProperty$2(_flatpickr, "nextArrow", this.rightArrowHTML()), _defineProperty$2(_flatpickr, "prevArrow", this.leftArrowHTML()), _defineProperty$2(_flatpickr, "onChange", function onChange() {
              var onChange = _this2.props.onChange;

              if (onChange) {
                onChange.apply(void 0, arguments);
              }
            }), _defineProperty$2(_flatpickr, "onClose", onClose), _defineProperty$2(_flatpickr, "onReady", onHook), _defineProperty$2(_flatpickr, "onMonthChange", onHook), _defineProperty$2(_flatpickr, "onYearChange", onHook), _defineProperty$2(_flatpickr, "onOpen", function onOpen() {
              var onOpen = _this2.props.onOpen;
              onHook.apply(void 0, arguments);

              if (onOpen) {
                onOpen.apply(void 0, arguments);
              }
            }), _defineProperty$2(_flatpickr, "onValueUpdate", onHook), _flatpickr));
            this.addKeyboardEvents(this.cal);
            this.addRoleAttributeToDialog();
          }
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(_ref) {
        var prevDateFormat = _ref.dateFormat,
            prevMinDate = _ref.minDate,
            prevMaxDate = _ref.maxDate,
            prevValue = _ref.value,
            prevDisable = _ref.disable,
            prevEnable = _ref.enable,
            prevRest = _objectWithoutProperties$2(_ref, _excluded2$b);

        var _this$props2 = this.props,
            dateFormat = _this$props2.dateFormat,
            minDate = _this$props2.minDate,
            maxDate = _this$props2.maxDate,
            value = _this$props2.value,
            disable = _this$props2.disable,
            enable = _this$props2.enable,
            rest = _objectWithoutProperties$2(_this$props2, _excluded3$7);

        if (this.cal) {
          if (prevDateFormat !== dateFormat) {
            this.cal.set({
              dateFormat: dateFormat
            });
          }

          if (prevMinDate !== minDate) {
            this.cal.set('minDate', minDate);
          }

          if (prevMaxDate !== maxDate) {
            this.cal.set('maxDate', maxDate);
          }

          if (disable !== prevDisable) {
            this.cal.set('disable', disable);
          }

          if (enable !== prevEnable) {
            this.cal.set('enable', enable);
          }

          if (rest.inline && rest.inline !== (prevRest === null || prevRest === void 0 ? void 0 : prevRest.inline)) {
            this.cal.set('inline', rest.inline);
          }
        } // Coordinate when the given `value` prop changes. When this happens, we
        // should update the calendar to the new value.


        if (prevValue !== value) {
          if (this.cal) {
            this.cal.setDate(this.props.value);
            this.updateClassNames(this.cal);
          } else if (this.inputField) {
            this.inputField.value = this.props.value;
          }
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this.cal) {
          this.cal.destroy();
        }

        if (this.inputField) {
          this.inputField.removeEventListener('change', this.onChange);
        }

        if (this.toInputField) {
          this.toInputField.removeEventListener('change', this.onChange);
        }
      }
    }, {
      key: "rightArrowHTML",
      value: function rightArrowHTML() {
        return "\n      <svg width=\"16px\" height=\"16px\" viewBox=\"0 0 16 16\">\n        <polygon points=\"11,8 6,13 5.3,12.3 9.6,8 5.3,3.7 6,3 \"/>\n        <rect width=\"16\" height=\"16\" style=\"fill:none\" />\n      </svg>";
      }
    }, {
      key: "leftArrowHTML",
      value: function leftArrowHTML() {
        return "\n      <svg width=\"16px\" height=\"16px\" viewBox=\"0 0 16 16\">\n        <polygon points=\"5,8 10,3 10.7,3.7 6.4,8 10.7,12.3 10,13 \"/>\n        <rect width=\"16\" height=\"16\" style=\"fill:none\" />\n      </svg>";
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        return /*#__PURE__*/React__default["default"].createElement(FeatureFlagContext.Consumer, null, function (scope) {
          var _classNames;

          var _this3$props = _this3.props;
              _this3$props.allowInput;
              _this3$props.appendTo;
              var children = _this3$props.children,
              className = _this3$props.className,
              short = _this3$props.short,
              light = _this3$props.light,
              datePickerType = _this3$props.datePickerType;
              _this3$props.minDate;
              _this3$props.maxDate;
              _this3$props.dateFormat;
              _this3$props.onChange;
              _this3$props.locale;
              _this3$props.value;
              _this3$props.onOpen;
              var other = _objectWithoutProperties$2(_this3$props, _excluded4$7);

          var enabled;

          if (scope.enabled) {
            enabled = scope.enabled('enable-v11-release');
          }

          var datePickerClasses = cx("".concat(_this3.context, "--date-picker"), [enabled ? null : className], (_classNames = {}, _defineProperty$2(_classNames, "".concat(_this3.context, "--date-picker--short"), short), _defineProperty$2(_classNames, "".concat(_this3.context, "--date-picker--light"), light), _defineProperty$2(_classNames, "".concat(_this3.context, "--date-picker--simple"), datePickerType === 'simple'), _defineProperty$2(_classNames, "".concat(_this3.context, "--date-picker--single"), datePickerType === 'single'), _defineProperty$2(_classNames, "".concat(_this3.context, "--date-picker--range"), datePickerType === 'range'), _defineProperty$2(_classNames, "".concat(_this3.context, "--date-picker--nolabel"), datePickerType === 'range' && _this3.isLabelTextEmpty(children)), _classNames));
          var wrapperClasses = cx("".concat(_this3.context, "--form-item"), [enabled ? className : null]);
          var childArray = React__default["default"].Children.toArray(children);
          var childrenWithProps = childArray.map(function (child, index) {
            if (index === 0 && child.type === React__default["default"].createElement(DatePickerInput$1, child.props).type) {
              return /*#__PURE__*/React__default["default"].cloneElement(child, {
                datePickerType: datePickerType,
                ref: _this3.assignInputFieldRef
              });
            }

            if (index === 1 && child.type === React__default["default"].createElement(DatePickerInput$1, child.props).type) {
              return /*#__PURE__*/React__default["default"].cloneElement(child, {
                datePickerType: datePickerType,
                ref: _this3.assignToInputFieldRef
              });
            }

            if (index === 0) {
              return /*#__PURE__*/React__default["default"].cloneElement(child, {
                ref: _this3.assignInputFieldRef
              });
            }

            if (index === 1) {
              return /*#__PURE__*/React__default["default"].cloneElement(child, {
                ref: _this3.assignToInputFieldRef
              });
            }
          });
          return /*#__PURE__*/React__default["default"].createElement("div", {
            className: wrapperClasses
          }, /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
            className: datePickerClasses
          }, other), childrenWithProps));
        });
      }
    }]);

    return DatePicker;
  }(React.Component);

  _defineProperty$2(DatePicker$2, "propTypes", {
    /**
     * flatpickr prop passthrough. Allows the user to enter a date directly
     * into the input field
     */
    allowInput: PropTypes__default["default"].bool,

    /**
     * The DOM element the Flatpicker should be inserted into. `<body>` by default.
     */
    appendTo: PropTypes__default["default"].object,

    /**
     * The child nodes.
     */
    children: PropTypes__default["default"].node,

    /**
     * The CSS class names.
     */
    className: PropTypes__default["default"].string,

    /**
     * The date format.
     */
    dateFormat: PropTypes__default["default"].string,

    /**
     * The type of the date picker:
     *
     * * `simple` - Without calendar dropdown.
     * * `single` - With calendar dropdown and single date.
     * * `range` - With calendar dropdown and a date range.
     */
    datePickerType: PropTypes__default["default"].oneOf(['simple', 'single', 'range']),

    /**
     * The flatpickr `disable` option that allows a user to disable certain dates.
     */
    disable: PropTypes__default["default"].array,

    /**
     * The flatpickr `enable` option that allows a user to enable certain dates.
     */
    enable: PropTypes__default["default"].array,

    /**
     * `true` to use the light version.
     */
    light: PropTypes__default["default"].bool,

    /**
     *  The language locale used to format the days of the week, months, and numbers. The full list of supported locales can be found here https://github.com/flatpickr/flatpickr/tree/master/src/l10n
     */
    locale: PropTypes__default["default"].oneOfType([PropTypes__default["default"].object, PropTypes__default["default"].oneOf(['ar', // Arabic
    'at', // Austria
    'az', // Azerbaijan
    'be', // Belarusian
    'bg', // Bulgarian
    'bn', // Bangla
    'bs', // Bosnia
    'cat', // Catalan
    'cs', // Czech
    'cy', // Welsh
    'da', // Danish
    'de', // German
    'en', // English
    'eo', // Esperanto
    'es', // Spanish
    'et', // Estonian
    'fa', // Persian
    'fi', // Finnish
    'fo', // Faroese
    'fr', // French
    'ga', // Gaelic
    'gr', // Greek
    'he', // Hebrew
    'hi', // Hindi
    'hr', // Croatian
    'hu', // Hungarian
    'id', // Indonesian
    'is', // Icelandic
    'it', // Italian
    'ja', // Japanese
    'ka', // Georgian
    'km', // Khmer
    'ko', // Korean
    'kz', // Kazakh
    'lt', // Lithuanian
    'lv', // Latvian
    'mk', // Macedonian
    'mn', // Mongolian
    'ms', // Malaysian
    'my', // Burmese
    'nl', // Dutch
    'no', // Norwegian
    'pa', // Punjabi
    'pl', // Polish
    'pt', // Portuguese
    'ro', // Romanian
    'ru', // Russian
    'si', // Sinhala
    'sk', // Slovak
    'sl', // Slovenian
    'sq', // Albanian
    'sr', // Serbian
    'sv', // Swedish
    'th', // Thai
    'tr', // Turkish
    'uk', // Ukrainian
    'uz', // Uzbek
    'uz_latn', // Uzbek Latin
    'vn', // Vietnamese
    'zh_tw', // Mandarin Traditional
    'zh' // Mandarin
    ])]),

    /**
     * The maximum date that a user can pick to.
     */
    maxDate: PropTypes__default["default"].string,

    /**
     * The minimum date that a user can start picking from.
     */
    minDate: PropTypes__default["default"].string,

    /**
     * The `change` event handler.
     */
    onChange: PropTypes__default["default"].func,

    /**
     * The `close` event handler.
     */
    onClose: PropTypes__default["default"].func,

    /**
     * The `open` event handler.
     */
    onOpen: PropTypes__default["default"].func,

    /**
     * `true` to use the short version.
     */
    short: PropTypes__default["default"].bool,

    /**
     * The value of the date value provided to flatpickr, could
     * be a date, a date number, a date string, an array of dates.
     */
    value: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].arrayOf(PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number, PropTypes__default["default"].object])), PropTypes__default["default"].object, PropTypes__default["default"].number])
  });

  _defineProperty$2(DatePicker$2, "defaultProps", {
    short: false,
    light: false,
    dateFormat: 'm/d/Y',
    locale: 'en'
  });

  _defineProperty$2(DatePicker$2, "contextType", PrefixContext);

  var _excluded$1U = ["range", "id", "className"];

  var DatePickerSkeleton = function DatePickerSkeleton(_ref) {
    var range = _ref.range,
        id = _ref.id,
        className = _ref.className,
        rest = _objectWithoutProperties$2(_ref, _excluded$1U);

    var prefix = usePrefix();
    var dateInput = /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--date-picker-container")
    },
    /*#__PURE__*/

    /* eslint-disable jsx-a11y/label-has-for,jsx-a11y/label-has-associated-control */
    React__default["default"].createElement("label", {
      className: "".concat(prefix, "--label"),
      htmlFor: id
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--date-picker__input ").concat(prefix, "--skeleton")
    }));

    if (range) {
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: "".concat(prefix, "--form-item")
      }, /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
        className: cx("".concat(prefix, "--date-picker"), "".concat(prefix, "--date-picker--range"), "".concat(prefix, "--skeleton"), className)
      }, rest), dateInput, dateInput));
    }

    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--form-item")
    }, /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: cx("".concat(prefix, "--date-picker"), "".concat(prefix, "--date-picker--short"), "".concat(prefix, "--date-picker--simple"), "".concat(prefix, "--skeleton"), className)
    }, rest), dateInput));
  };

  DatePickerSkeleton.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the id to add.
     */
    id: PropTypes__default["default"].string,

    /**
     * Specify whether the skeleton should be of range date picker.
     */
    range: PropTypes__default["default"].bool
  };
  var DatePickerSkeleton$1 = DatePickerSkeleton;

  var DatePicker = enabled('enable-v11-release') ? DatePicker$3 : DatePicker$2;
  var DatePicker$1 = DatePicker;

  var _excluded$1T = ["className", "size", "inline"];

  var DropdownSkeleton = function DropdownSkeleton(_ref) {
    var _cx;

    var className = _ref.className,
        size = _ref.size;
        _ref.inline;
        var rest = _objectWithoutProperties$2(_ref, _excluded$1T);

    var prefix = usePrefix();
    var wrapperClasses = cx(className, (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--skeleton"), true), _defineProperty$2(_cx, "".concat(prefix, "--dropdown-v2"), true), _defineProperty$2(_cx, "".concat(prefix, "--list-box"), true), _defineProperty$2(_cx, "".concat(prefix, "--form-item"), true), _defineProperty$2(_cx, "".concat(prefix, "--list-box--").concat(size), size), _cx));
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: wrapperClasses
    }, rest), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--list-box__field")
    }, /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--list-box__label")
    })));
  };

  DropdownSkeleton.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether you want the inline version of this control
     */
    inline: deprecate(PropTypes__default["default"].bool, "The `inline` prop has been deprecated and will\n    be removed in the next major release. To specify the inline variant of Dropdown, please use the `type` prop."),

    /**
     * Specify the size of the ListBox.
     */
    size: ListBoxSize
  };
  var DropdownSkeleton$1 = DropdownSkeleton;

  var _excluded$1S = ["className", "disabled", "direction", "items", "label", "ariaLabel", "itemToString", "itemToElement", "renderSelectedItem", "type", "size", "onChange", "id", "titleText", "hideLabel", "helperText", "translateWithId", "light", "invalid", "invalidText", "warn", "warnText", "initialSelectedItem", "selectedItem", "downshiftProps"];
  var getInstanceId$e = setupGetInstanceId$2();

  var defaultItemToString$1 = function defaultItemToString(item) {
    if (typeof item === 'string') {
      return item;
    }

    return item ? item.label : '';
  };

  var Dropdown = /*#__PURE__*/React__default["default"].forwardRef(function Dropdown(_ref, ref) {
    var _cx, _cx2, _cx4;

    var containerClassName = _ref.className,
        disabled = _ref.disabled,
        direction = _ref.direction,
        items = _ref.items,
        label = _ref.label,
        ariaLabel = _ref.ariaLabel,
        itemToString = _ref.itemToString,
        itemToElement = _ref.itemToElement,
        renderSelectedItem = _ref.renderSelectedItem,
        type = _ref.type,
        size = _ref.size,
        onChange = _ref.onChange,
        id = _ref.id,
        titleText = _ref.titleText,
        hideLabel = _ref.hideLabel,
        helperText = _ref.helperText,
        translateWithId = _ref.translateWithId,
        light = _ref.light,
        invalid = _ref.invalid,
        invalidText = _ref.invalidText,
        warn = _ref.warn,
        warnText = _ref.warnText,
        initialSelectedItem = _ref.initialSelectedItem,
        controlledSelectedItem = _ref.selectedItem,
        downshiftProps = _ref.downshiftProps,
        other = _objectWithoutProperties$2(_ref, _excluded$1S);

    var prefix = usePrefix();
    var selectProps = mapDownshiftProps(_objectSpread2$2(_objectSpread2$2({}, downshiftProps), {}, {
      items: items,
      itemToString: itemToString,
      initialSelectedItem: initialSelectedItem,
      onSelectedItemChange: onSelectedItemChange
    }));

    var _useRef = React.useRef(getInstanceId$e()),
        dropdownInstanceId = _useRef.current;

    var helperId = !helperText ? undefined : "dropdown-helper-text-".concat(dropdownInstanceId); // only set selectedItem if the prop is defined. Setting if it is undefined
    // will overwrite default selected items from useSelect

    if (controlledSelectedItem !== undefined) {
      selectProps.selectedItem = controlledSelectedItem;
    }

    var _useSelect = useSelect(selectProps),
        isOpen = _useSelect.isOpen,
        getToggleButtonProps = _useSelect.getToggleButtonProps,
        getLabelProps = _useSelect.getLabelProps,
        getMenuProps = _useSelect.getMenuProps,
        getItemProps = _useSelect.getItemProps,
        highlightedIndex = _useSelect.highlightedIndex,
        selectedItem = _useSelect.selectedItem;

    var inline = type === 'inline';
    var showWarning = !invalid && warn;
    var enabled = useFeatureFlag('enable-v11-release');
    var className = cx("".concat(prefix, "--dropdown"), [enabled ? null : containerClassName], (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--dropdown--invalid"), invalid), _defineProperty$2(_cx, "".concat(prefix, "--dropdown--warning"), showWarning), _defineProperty$2(_cx, "".concat(prefix, "--dropdown--open"), isOpen), _defineProperty$2(_cx, "".concat(prefix, "--dropdown--inline"), inline), _defineProperty$2(_cx, "".concat(prefix, "--dropdown--disabled"), disabled), _defineProperty$2(_cx, "".concat(prefix, "--dropdown--light"), light), _defineProperty$2(_cx, "".concat(prefix, "--dropdown--").concat(size), size), _defineProperty$2(_cx, "".concat(prefix, "--list-box--up"), direction === 'top'), _cx));
    var titleClasses = cx("".concat(prefix, "--label"), (_cx2 = {}, _defineProperty$2(_cx2, "".concat(prefix, "--label--disabled"), disabled), _defineProperty$2(_cx2, "".concat(prefix, "--visually-hidden"), hideLabel), _cx2));
    var helperClasses = cx("".concat(prefix, "--form__helper-text"), _defineProperty$2({}, "".concat(prefix, "--form__helper-text--disabled"), disabled));
    var wrapperClasses = cx("".concat(prefix, "--dropdown__wrapper"), "".concat(prefix, "--list-box__wrapper"), [enabled ? containerClassName : null], (_cx4 = {}, _defineProperty$2(_cx4, "".concat(prefix, "--dropdown__wrapper--inline"), inline), _defineProperty$2(_cx4, "".concat(prefix, "--list-box__wrapper--inline"), inline), _defineProperty$2(_cx4, "".concat(prefix, "--dropdown__wrapper--inline--invalid"), inline && invalid), _defineProperty$2(_cx4, "".concat(prefix, "--list-box__wrapper--inline--invalid"), inline && invalid), _cx4)); // needs to be Capitalized for react to render it correctly

    var ItemToElement = itemToElement;
    var toggleButtonProps = getToggleButtonProps();
    var helper = helperText ? /*#__PURE__*/React__default["default"].createElement("div", {
      id: helperId,
      className: helperClasses
    }, helperText) : null;

    function onSelectedItemChange(_ref2) {
      var selectedItem = _ref2.selectedItem;

      if (onChange) {
        onChange({
          selectedItem: selectedItem
        });
      }
    }

    var menuItemOptionRefs = React.useRef(items.map(function (_) {
      return /*#__PURE__*/React__default["default"].createRef();
    }));
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: wrapperClasses
    }, other), titleText && /*#__PURE__*/React__default["default"].createElement("label", _extends$3({
      className: titleClasses
    }, getLabelProps()), titleText), /*#__PURE__*/React__default["default"].createElement(ListBox$1, {
      "aria-label": ariaLabel,
      size: size,
      className: className,
      invalid: invalid,
      invalidText: invalidText,
      warn: warn,
      warnText: warnText,
      light: light,
      isOpen: isOpen,
      id: id
    }, invalid && /*#__PURE__*/React__default["default"].createElement(WarningFilled16, {
      className: "".concat(prefix, "--list-box__invalid-icon")
    }), showWarning && /*#__PURE__*/React__default["default"].createElement(WarningAltFilled16, {
      className: "".concat(prefix, "--list-box__invalid-icon ").concat(prefix, "--list-box__invalid-icon--warning")
    }), /*#__PURE__*/React__default["default"].createElement("button", _extends$3({
      type: "button" // aria-expanded is already being passed through {...toggleButtonProps}
      ,
      role: "combobox" // eslint-disable-line jsx-a11y/role-has-required-aria-props
      ,
      "aria-controls": getMenuProps().id,
      className: "".concat(prefix, "--list-box__field"),
      disabled: disabled,
      "aria-disabled": disabled,
      "aria-describedby": !inline && !invalid && !warn && helper ? helperId : undefined,
      title: selectedItem ? itemToString(selectedItem) : label
    }, toggleButtonProps, {
      ref: mergeRefs$1(toggleButtonProps.ref, ref)
    }), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--list-box__label")
    }, selectedItem ? renderSelectedItem ? renderSelectedItem(selectedItem) : itemToString(selectedItem) : label), /*#__PURE__*/React__default["default"].createElement(ListBox$1.MenuIcon, {
      isOpen: isOpen,
      translateWithId: translateWithId
    })), /*#__PURE__*/React__default["default"].createElement(ListBox$1.Menu, getMenuProps(), isOpen && items.map(function (item, index) {
      var _menuItemOptionRefs$c;

      var itemProps = getItemProps({
        item: item,
        index: index,
        disabled: item.disabled
      });
      var title = itemToElement ? item.text : itemToString(item);

      var _ref3 = (menuItemOptionRefs === null || menuItemOptionRefs === void 0 ? void 0 : (_menuItemOptionRefs$c = menuItemOptionRefs.current[index]) === null || _menuItemOptionRefs$c === void 0 ? void 0 : _menuItemOptionRefs$c.current) || {},
          offsetWidth = _ref3.offsetWidth,
          scrollWidth = _ref3.scrollWidth;

      return /*#__PURE__*/React__default["default"].createElement(ListBox$1.MenuItem, _extends$3({
        key: itemProps.id,
        isActive: selectedItem === item,
        isHighlighted: highlightedIndex === index || selectedItem === item,
        title: offsetWidth < scrollWidth && title || undefined,
        ref: {
          menuItemOptionRef: menuItemOptionRefs.current[index]
        }
      }, itemProps), itemToElement ? /*#__PURE__*/React__default["default"].createElement(ItemToElement, _extends$3({
        key: itemProps.id
      }, item)) : itemToString(item), selectedItem === item && /*#__PURE__*/React__default["default"].createElement(Checkmark16, {
        className: "".concat(prefix, "--list-box__menu-item__selected-icon")
      }));
    }))), !inline && !invalid && !warn && helper);
  });
  Dropdown.displayName = 'Dropdown';
  Dropdown.propTypes = {
    /**
     * 'aria-label' of the ListBox component.
     */
    ariaLabel: PropTypes__default["default"].string,

    /**
     * Provide a custom className to be applied on the bx--dropdown node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the direction of the dropdown. Can be either top or bottom.
     */
    direction: PropTypes__default["default"].oneOf(['top', 'bottom']),

    /**
     * Disable the control
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Additional props passed to Downshift
     */
    downshiftProps: PropTypes__default["default"].object,

    /**
     * Provide helper text that is used alongside the control label for
     * additional help
     */
    helperText: PropTypes__default["default"].node,

    /**
     * Specify whether the title text should be hidden or not
     */
    hideLabel: PropTypes__default["default"].bool,

    /**
     * Specify a custom `id`
     */
    id: PropTypes__default["default"].string.isRequired,

    /**
     * Allow users to pass in an arbitrary item or a string (in case their items are an array of strings)
     * from their collection that are pre-selected
     */
    initialSelectedItem: PropTypes__default["default"].oneOfType([PropTypes__default["default"].object, PropTypes__default["default"].string, PropTypes__default["default"].number]),

    /**
     * Specify whether you want the inline version of this control
     */
    inline: deprecate(PropTypes__default["default"].bool, "The `inline` prop has been deprecated and will\n    be removed in the next major release. To specify the inline variant of Dropdown, please use the `type` prop."),

    /**
     * Specify if the currently selected value is invalid.
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * Message which is displayed if the value is invalid.
     */
    invalidText: PropTypes__default["default"].node,

    /**
     * Function to render items as custom components instead of strings.
     * Defaults to null and is overridden by a getter
     */
    itemToElement: PropTypes__default["default"].func,

    /**
     * Helper function passed to downshift that allows the library to render a
     * given item to a string label. By default, it extracts the `label` field
     * from a given item to serve as the item label in the list.
     */
    itemToString: PropTypes__default["default"].func,

    /**
     * We try to stay as generic as possible here to allow individuals to pass
     * in a collection of whatever kind of data structure they prefer
     */
    items: PropTypes__default["default"].array.isRequired,

    /**
     * Generic `label` that will be used as the textual representation of what
     * this field is for
     */
    label: PropTypes__default["default"].node.isRequired,

    /**
     * `true` to use the light version.
     */
    light: PropTypes__default["default"].bool,

    /**
     * `onChange` is a utility for this controlled component to communicate to a
     * consuming component what kind of internal state changes are occurring.
     */
    onChange: PropTypes__default["default"].func,

    /**
     * An optional callback to render the currently selected item as a react element instead of only
     * as a string.
     */
    renderSelectedItem: PropTypes__default["default"].func,

    /**
     * In the case you want to control the dropdown selection entirely.
     */
    selectedItem: PropTypes__default["default"].oneOfType([PropTypes__default["default"].object, PropTypes__default["default"].string, PropTypes__default["default"].number]),

    /**
     * Specify the size of the ListBox. Currently supports either `sm`, `md` or `lg` as an option.
     */
    size: ListBoxSize,

    /**
     * Provide the title text that will be read by a screen reader when
     * visiting this control
     */
    titleText: PropTypes__default["default"].node,

    /**
     * Callback function for translating ListBoxMenuIcon SVG title
     */
    translateWithId: PropTypes__default["default"].func,

    /**
     * The dropdown type, `default` or `inline`
     */
    type: ListBoxType,

    /**
     * Specify whether the control is currently in warning state
     */
    warn: PropTypes__default["default"].bool,

    /**
     * Provide the text that is displayed when the control is in warning state
     */
    warnText: PropTypes__default["default"].node
  };
  Dropdown.defaultProps = {
    disabled: false,
    type: 'default',
    itemToString: defaultItemToString$1,
    itemToElement: null,
    light: false,
    titleText: '',
    helperText: '',
    direction: 'bottom'
  };
  var Dropdown$1 = Dropdown;

  var ErrorBoundaryContext = /*#__PURE__*/React.createContext({
    log: function log(error, info) {
      console.log(info.componentStack);
    }
  });

  /**
   * React introduced additional lifecycle methods in v16 for capturing errors
   * that occur in a specific sub-tree of components. This component helps to
   * consolidate some of the duplication that occurs when using these lifecycle
   * methods across a codebase. In addition, it allows you to specify the fallback
   * UI to display when an error occurs in the sub-tree through the `fallback`
   * prop.
   *
   * This component roughly follows the React.js docs example code for these
   * methods. In addition, it takes advantage of an `ErrorBoundaryContext` so that
   * consumers can specify their own logic for logging errors. For example,
   * reporting an error in the UI to an external service for every `ErrorBoundary`
   * used.
   *
   * Reference:
   * https://reactjs.org/docs/error-boundaries.html#introducing-error-boundaries
   */

  var ErrorBoundary = /*#__PURE__*/function (_React$Component) {
    _inherits(ErrorBoundary, _React$Component);

    var _super = _createSuper(ErrorBoundary);

    function ErrorBoundary() {
      var _this;

      _classCallCheck$1(this, ErrorBoundary);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty$2(_assertThisInitialized$1(_this), "state", {
        hasError: false
      });

      return _this;
    }

    _createClass$1(ErrorBoundary, [{
      key: "componentDidCatch",
      value: function componentDidCatch(error, info) {
        this.context.log(error, info);
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        if (prevProps.children !== this.props.children) {
          this.setState({
            hasError: false
          });
        }
      }
    }, {
      key: "render",
      value: function render() {
        if (this.state.hasError) {
          return this.props.fallback;
        }

        return this.props.children;
      }
    }], [{
      key: "getDerivedStateFromError",
      value: function getDerivedStateFromError() {
        return {
          hasError: true
        };
      }
    }]);

    return ErrorBoundary;
  }(React__default["default"].Component);

  _defineProperty$2(ErrorBoundary, "propTypes", {
    children: PropTypes__default["default"].node,
    fallback: PropTypes__default["default"].node
  });

  _defineProperty$2(ErrorBoundary, "contextType", ErrorBoundaryContext);

  var _excluded$1R = ["id", "active", "className", "withOverlay", "small", "description"];
  var getInstanceId$d = setupGetInstanceId$2();

  function Loading(_ref) {
    var _cx, _cx2;

    var id = _ref.id,
        active = _ref.active,
        customClassName = _ref.className,
        withOverlay = _ref.withOverlay,
        small = _ref.small,
        description = _ref.description,
        rest = _objectWithoutProperties$2(_ref, _excluded$1R);

    var prefix = usePrefix();

    var _useRef = React.useRef(getInstanceId$d()),
        instanceId = _useRef.current;

    var loadingClassName = cx(customClassName, (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--loading"), true), _defineProperty$2(_cx, "".concat(prefix, "--loading--small"), small), _defineProperty$2(_cx, "".concat(prefix, "--loading--stop"), !active), _cx));
    var overlayClassName = cx((_cx2 = {}, _defineProperty$2(_cx2, "".concat(prefix, "--loading-overlay"), true), _defineProperty$2(_cx2, "".concat(prefix, "--loading-overlay--stop"), !active), _cx2));
    var loadingId = id || "loading-id-".concat(instanceId);
    var loading = /*#__PURE__*/React__default["default"].createElement("div", _extends$3({}, rest, {
      "aria-atomic": "true",
      "aria-live": active ? 'assertive' : 'off',
      className: loadingClassName
    }), /*#__PURE__*/React__default["default"].createElement("label", {
      id: loadingId,
      className: "".concat(prefix, "--visually-hidden")
    }, description), /*#__PURE__*/React__default["default"].createElement("svg", {
      className: "".concat(prefix, "--loading__svg"),
      viewBox: "0 0 100 100"
    }, /*#__PURE__*/React__default["default"].createElement("title", null, description), small ? /*#__PURE__*/React__default["default"].createElement("circle", {
      className: "".concat(prefix, "--loading__background"),
      cx: "50%",
      cy: "50%",
      r: "44"
    }) : null, /*#__PURE__*/React__default["default"].createElement("circle", {
      className: "".concat(prefix, "--loading__stroke"),
      cx: "50%",
      cy: "50%",
      r: "44"
    })));
    return withOverlay ? /*#__PURE__*/React__default["default"].createElement("div", {
      className: overlayClassName
    }, loading) : loading;
  }

  Loading.propTypes = {
    /**
     * Specify whether you want the loading indicator to be spinning or not
     */
    active: PropTypes__default["default"].bool,

    /**
     * Provide an optional className to be applied to the containing node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify a description that would be used to best describe the loading state
     */
    description: PropTypes__default["default"].string,

    /**
     * Provide an `id` to uniquely identify the label
     */
    id: PropTypes__default["default"].string,

    /**
     * Specify whether you would like the small variant of <Loading>
     */
    small: PropTypes__default["default"].bool,

    /**
     * Specify whether you want the loader to be applied with an overlay
     */
    withOverlay: PropTypes__default["default"].bool
  };
  Loading.defaultProps = {
    active: true,
    withOverlay: true,
    small: false,
    description: 'Active loading indicator'
  };

  var _excluded$1Q = ["iconDescription", "status", "invalid", "name"];

  function Filename(_ref) {
    var iconDescription = _ref.iconDescription,
        status = _ref.status,
        invalid = _ref.invalid,
        name = _ref.name,
        rest = _objectWithoutProperties$2(_ref, _excluded$1Q);

    var prefix = usePrefix();

    switch (status) {
      case 'uploading':
        return /*#__PURE__*/React__default["default"].createElement(Loading, {
          description: iconDescription,
          small: true,
          withOverlay: false
        });

      case 'edit':
        return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, invalid && /*#__PURE__*/React__default["default"].createElement(WarningFilled16, {
          className: "".concat(prefix, "--file-invalid")
        }), /*#__PURE__*/React__default["default"].createElement("button", _extends$3({
          "aria-label": "".concat(iconDescription, " - ").concat(name),
          className: "".concat(prefix, "--file-close"),
          type: "button"
        }, rest), /*#__PURE__*/React__default["default"].createElement(Close16, null)));

      case 'complete':
        return /*#__PURE__*/React__default["default"].createElement(CheckmarkFilled16, _extends$3({
          "aria-label": iconDescription,
          className: "".concat(prefix, "--file-complete")
        }, rest, {
          tabIndex: null
        }), iconDescription && /*#__PURE__*/React__default["default"].createElement("title", null, iconDescription));

      default:
        return null;
    }
  }

  Filename.propTypes = {
    /**
     * Provide a description of the SVG icon to denote file upload status
     */
    iconDescription: PropTypes__default["default"].string,

    /**
     * Specify if the file is invalid
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * Name of the uploaded file
     */
    name: PropTypes__default["default"].string,

    /**
     * Status of the file upload
     */
    status: PropTypes__default["default"].oneOf(['edit', 'complete', 'uploading']),

    /**
     * Provide a custom tabIndex value for the <Filename>
     */
    tabIndex: PropTypes__default["default"].string
  };
  Filename.defaultProps = {
    iconDescription: 'Uploading file',
    status: 'uploading',
    tabIndex: '0'
  };

  var _excluded$1P = ["accept", "buttonKind", "className", "disabled", "disableLabelChanges", "id", "labelText", "multiple", "onChange", "name", "size", "tabIndex"];

  function noop$1() {}

  function FileUploaderButton(_ref) {
    var _cx;

    var accept = _ref.accept,
        _ref$buttonKind = _ref.buttonKind,
        buttonKind = _ref$buttonKind === void 0 ? 'primary' : _ref$buttonKind,
        className = _ref.className,
        _ref$disabled = _ref.disabled,
        disabled = _ref$disabled === void 0 ? false : _ref$disabled,
        _ref$disableLabelChan = _ref.disableLabelChanges,
        disableLabelChanges = _ref$disableLabelChan === void 0 ? false : _ref$disableLabelChan,
        id = _ref.id,
        _ref$labelText = _ref.labelText,
        ownerLabelText = _ref$labelText === void 0 ? 'Add file' : _ref$labelText,
        _ref$multiple = _ref.multiple,
        multiple = _ref$multiple === void 0 ? false : _ref$multiple,
        _ref$onChange = _ref.onChange,
        onChange = _ref$onChange === void 0 ? noop$1 : _ref$onChange,
        name = _ref.name,
        _ref$size = _ref.size,
        size = _ref$size === void 0 ? 'md' : _ref$size,
        _ref$tabIndex = _ref.tabIndex,
        tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex,
        other = _objectWithoutProperties$2(_ref, _excluded$1P);

    var prefix = usePrefix();

    var _useState = React.useState(ownerLabelText),
        _useState2 = _slicedToArray$1(_useState, 2),
        labelText = _useState2[0],
        setLabelText = _useState2[1];

    var _useState3 = React.useState(ownerLabelText),
        _useState4 = _slicedToArray$1(_useState3, 2),
        prevOwnerLabelText = _useState4[0],
        setPrevOwnerLabelText = _useState4[1];

    var _useRef = React.useRef(id || uniqueId()),
        inputId = _useRef.current;

    var inputNode = React.useRef(null);
    var classes = cx("".concat(prefix, "--btn"), className, (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--btn--").concat(buttonKind), buttonKind), _defineProperty$2(_cx, "".concat(prefix, "--btn--disabled"), disabled), _defineProperty$2(_cx, "".concat(prefix, "--btn--md"), size === 'field' || size === 'md'), _defineProperty$2(_cx, "".concat(prefix, "--btn--sm"), size === 'small' || size === 'sm'), _cx)); // Adjust label text state based on changes to the labelText prop

    if (ownerLabelText !== prevOwnerLabelText) {
      setLabelText(ownerLabelText);
      setPrevOwnerLabelText(ownerLabelText);
    }

    function onClick(event) {
      event.target.value = null;

      if (inputNode.current) {
        inputNode.current.value = '';
        inputNode.current.click();
      }
    }

    function onKeyDown(event) {
      event.preventDefault();

      if (matches(event, [Enter, Space]) && inputNode.current) {
        inputNode.current.value = '';
        inputNode.current.click();
      }
    }

    function handleOnChange(event) {
      var files = event.target.files;
      var length = event.target.files.length;

      if (files && !disableLabelChanges) {
        if (length > 1) {
          setLabelText("".concat(length, " files"));
        } else if (length === 1) {
          setLabelText(files[0].name);
        }
      }

      onChange(event);
    }

    return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("button", _extends$3({
      type: "button",
      disabled: disabled,
      className: classes,
      onClick: onClick,
      onKeyDown: onKeyDown,
      tabIndex: tabIndex ? tabIndex : undefined
    }, other), labelText), /*#__PURE__*/React__default["default"].createElement("label", {
      className: "".concat(prefix, "--visually-hidden"),
      htmlFor: inputId
    }, /*#__PURE__*/React__default["default"].createElement("span", null, labelText)), /*#__PURE__*/React__default["default"].createElement("input", {
      className: "".concat(prefix, "--visually-hidden"),
      ref: inputNode,
      id: inputId,
      disabled: disabled,
      type: "file",
      tabIndex: -1,
      multiple: multiple,
      accept: accept,
      name: name,
      onChange: handleOnChange
    }));
  }

  FileUploaderButton.propTypes = {
    /**
     * Specify the types of files that this input should be able to receive
     */
    accept: PropTypes__default["default"].arrayOf(PropTypes__default["default"].string),

    /**
     * Specify the type of underlying button
     */
    buttonKind: PropTypes__default["default"].oneOf(ButtonKinds),

    /**
     * Provide a custom className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether you want to disable any updates to the FileUploaderButton
     * label
     */
    disableLabelChanges: PropTypes__default["default"].bool,

    /**
     * Specify whether file input is disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Provide a unique id for the underlying <input> node
     */
    id: PropTypes__default["default"].string,

    /**
     * Provide the label text to be read by screen readers when interacting with
     * this control
     */
    labelText: PropTypes__default["default"].node,

    /**
     * Specify if the component should accept multiple files to upload
     */
    multiple: PropTypes__default["default"].bool,

    /**
     * Provide a name for the underlying <input> node
     */
    name: PropTypes__default["default"].string,

    /**
     * Provide an optional `onChange` hook that is called each time the <input>
     * value changes
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Provide an optional `onClick` hook that is called each time the button is
     * clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Provide an accessibility role for the <FileUploaderButton>
     */
    role: PropTypes__default["default"].string,

    /**
     * Specify the size of the FileUploaderButton, from a list of available
     * sizes.
     */
    size: enabled('enable-v11-release') ? PropTypes__default["default"].oneOf(['sm', 'md', 'lg']) : PropTypes__default["default"].oneOf(['default', 'field', 'small', 'sm', 'md', 'lg']),

    /**
     * Provide a custom tabIndex value for the <FileUploaderButton>
     */
    tabIndex: PropTypes__default["default"].number
  };

  var _excluded$1O = ["iconDescription", "buttonLabel", "buttonKind", "disabled", "filenameStatus", "labelDescription", "labelTitle", "className", "multiple", "accept", "name", "size", "onDelete"];

  var FileUploader = /*#__PURE__*/function (_React$Component) {
    _inherits(FileUploader, _React$Component);

    var _super = _createSuper(FileUploader);

    function FileUploader() {
      var _this;

      _classCallCheck$1(this, FileUploader);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty$2(_assertThisInitialized$1(_this), "state", {
        filenames: []
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "nodes", []);

      _defineProperty$2(_assertThisInitialized$1(_this), "handleChange", function (evt) {
        evt.stopPropagation();
        var filenames = Array.prototype.map.call(evt.target.files, function (file) {
          return file.name;
        });

        _this.setState({
          filenames: _this.props.multiple ? _this.state.filenames.concat(filenames) : filenames
        });

        if (_this.props.onChange) {
          _this.props.onChange(evt);
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleClick", function (evt, _ref) {
        var index = _ref.index,
            filenameStatus = _ref.filenameStatus;

        if (filenameStatus === 'edit') {
          evt.stopPropagation();

          var filteredArray = _this.state.filenames.filter(function (filename) {
            return filename !== _this.nodes[index].innerText.trim();
          });

          _this.setState({
            filenames: filteredArray
          });

          if (_this.props.onDelete) {
            _this.props.onDelete(evt);
          }

          _this.props.onClick(evt);
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "clearFiles", function () {
        // A clearFiles function that resets filenames and can be referenced using a ref by the parent.
        _this.setState({
          filenames: []
        });
      });

      return _this;
    }

    _createClass$1(FileUploader, [{
      key: "render",
      value: function render() {
        var _classNames,
            _classNames3,
            _this2 = this;

        var _this$props = this.props,
            iconDescription = _this$props.iconDescription,
            buttonLabel = _this$props.buttonLabel,
            buttonKind = _this$props.buttonKind,
            disabled = _this$props.disabled,
            filenameStatus = _this$props.filenameStatus,
            labelDescription = _this$props.labelDescription,
            labelTitle = _this$props.labelTitle,
            className = _this$props.className,
            multiple = _this$props.multiple,
            accept = _this$props.accept,
            name = _this$props.name,
            _this$props$size = _this$props.size,
            size = _this$props$size === void 0 ? 'md' : _this$props$size;
            _this$props.onDelete;
            var other = _objectWithoutProperties$2(_this$props, _excluded$1O);

        var prefix = this.context;
        var classes = cx((_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--form-item"), true), _defineProperty$2(_classNames, className, className), _classNames));

        var getHelperLabelClasses = function getHelperLabelClasses(baseClass) {
          return cx(baseClass, _defineProperty$2({}, "".concat(prefix, "--label-description--disabled"), disabled));
        };

        var selectedFileClasses = cx("".concat(prefix, "--file__selected-file"), (_classNames3 = {}, _defineProperty$2(_classNames3, "".concat(prefix, "--file__selected-file--md"), size === 'field' || size === 'md'), _defineProperty$2(_classNames3, "".concat(prefix, "--file__selected-file--sm"), size === 'small' || size === 'sm'), _classNames3));
        return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
          className: classes
        }, other), enabled('enable-v11-release') && !labelTitle ? null : /*#__PURE__*/React__default["default"].createElement("p", {
          className: getHelperLabelClasses("".concat(prefix, "--file--label"))
        }, labelTitle), /*#__PURE__*/React__default["default"].createElement("p", {
          className: getHelperLabelClasses("".concat(prefix, "--label-description"))
        }, labelDescription), /*#__PURE__*/React__default["default"].createElement(FileUploaderButton, {
          disabled: disabled,
          labelText: buttonLabel,
          multiple: multiple,
          buttonKind: buttonKind,
          onChange: this.handleChange,
          disableLabelChanges: true,
          accept: accept,
          name: name,
          size: size
        }), /*#__PURE__*/React__default["default"].createElement("div", {
          className: "".concat(prefix, "--file-container")
        }, this.state.filenames.length === 0 ? null : this.state.filenames.map(function (name, index) {
          return /*#__PURE__*/React__default["default"].createElement("span", _extends$3({
            key: index,
            className: selectedFileClasses,
            ref: function ref(node) {
              return _this2.nodes[index] = node;
            }
          }, other), /*#__PURE__*/React__default["default"].createElement("p", {
            className: "".concat(prefix, "--file-filename")
          }, name), /*#__PURE__*/React__default["default"].createElement("span", {
            className: "".concat(prefix, "--file__state-container")
          }, /*#__PURE__*/React__default["default"].createElement(Filename, {
            name: name,
            iconDescription: iconDescription,
            status: filenameStatus,
            onKeyDown: function onKeyDown(evt) {
              if (matches(evt, [Enter, Space])) {
                _this2.handleClick(evt, {
                  index: index,
                  filenameStatus: filenameStatus
                });
              }
            },
            onClick: function onClick(evt) {
              return _this2.handleClick(evt, {
                index: index,
                filenameStatus: filenameStatus
              });
            }
          })));
        })));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref2, state) {
        var filenameStatus = _ref2.filenameStatus;
        var prevFilenameStatus = state.prevFilenameStatus;
        return prevFilenameStatus === filenameStatus ? null : {
          filenameStatus: filenameStatus,
          prevFilenameStatus: filenameStatus
        };
      }
    }]);

    return FileUploader;
  }(React__default["default"].Component);

  _defineProperty$2(FileUploader, "propTypes", {
    /**
     * Specify the types of files that this input should be able to receive
     */
    accept: PropTypes__default["default"].arrayOf(PropTypes__default["default"].string),

    /**
     * Specify the type of the <FileUploaderButton>
     */
    buttonKind: PropTypes__default["default"].oneOf(ButtonKinds),

    /**
     * Provide the label text to be read by screen readers when interacting with
     * the <FileUploaderButton>
     */
    buttonLabel: PropTypes__default["default"].string,

    /**
     * Provide a custom className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether file input is disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Specify the status of the File Upload
     */
    filenameStatus: PropTypes__default["default"].oneOf(['edit', 'complete', 'uploading']).isRequired,

    /**
     * Provide a description for the complete/close icon that can be read by screen readers
     */
    iconDescription: enabled('enable-v11-release') ? PropTypes__default["default"].string.isRequired : PropTypes__default["default"].string,

    /**
     * Specify the description text of this <FileUploader>
     */
    labelDescription: PropTypes__default["default"].string,

    /**
     * Specify the title text of this <FileUploader>
     */
    labelTitle: PropTypes__default["default"].string,

    /**
     * Specify if the component should accept multiple files to upload
     */
    multiple: PropTypes__default["default"].bool,

    /**
     * Provide a name for the underlying `<input>` node
     */
    name: PropTypes__default["default"].string,

    /**
     * Provide an optional `onChange` hook that is called each time the input is
     * changed
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Provide an optional `onClick` hook that is called each time the
     * FileUploader is clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Provide an optional `onDelete` hook that is called when an uploaded item
     * is removed
     */
    onDelete: PropTypes__default["default"].func,

    /**
     * Specify the size of the FileUploaderButton, from a list of available
     * sizes.
     */
    size: enabled('enable-v11-release') ? PropTypes__default["default"].oneOf(['sm', 'md', 'lg']) : PropTypes__default["default"].oneOf(['default', 'field', 'small', 'sm', 'md', 'lg'])
  });

  _defineProperty$2(FileUploader, "contextType", PrefixContext);

  _defineProperty$2(FileUploader, "defaultProps", {
    disabled: false,
    iconDescription: enabled('enable-v11-release') ? undefined : 'Provide icon description',
    filenameStatus: 'uploading',
    buttonLabel: '',
    buttonKind: 'primary',
    multiple: false,
    onClick: function onClick() {},
    accept: []
  });

  var _excluded$1N = ["className"];

  function FileUploaderSkeleton(_ref) {
    var className = _ref.className,
        rest = _objectWithoutProperties$2(_ref, _excluded$1N);

    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: cx("".concat(prefix, "--form-item"), className)
    }, rest), /*#__PURE__*/React__default["default"].createElement(SkeletonText$1, {
      heading: true,
      width: "100px"
    }), /*#__PURE__*/React__default["default"].createElement(SkeletonText$1, {
      width: "225px",
      className: "".concat(prefix, "--label-description")
    }), /*#__PURE__*/React__default["default"].createElement(ButtonSkeleton$1, null));
  }

  FileUploaderSkeleton.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes__default["default"].string
  };

  var _excluded$1M = ["accept", "className", "id", "disabled", "labelText", "multiple", "name", "onAddFiles", "onClick", "pattern"];

  function FileUploaderDropContainer(_ref) {
    var _classNames;

    var accept = _ref.accept,
        className = _ref.className,
        id = _ref.id,
        disabled = _ref.disabled,
        labelText = _ref.labelText,
        multiple = _ref.multiple,
        name = _ref.name,
        onAddFiles = _ref.onAddFiles,
        onClick = _ref.onClick,
        pattern = _ref.pattern,
        rest = _objectWithoutProperties$2(_ref, _excluded$1M);

    var prefix = usePrefix();
    var inputRef = React.useRef(null);

    var _useRef = React.useRef(id || uniqueId()),
        uid = _useRef.current;

    var _useState = React.useState(false),
        _useState2 = _slicedToArray$1(_useState, 2),
        isActive = _useState2[0],
        setActive = _useState2[1];

    var dropareaClasses = cx("".concat(prefix, "--file__drop-container"), "".concat(prefix, "--file-browse-btn"), (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--file__drop-container--drag-over"), isActive), _defineProperty$2(_classNames, "".concat(prefix, "--file-browse-btn--disabled"), disabled), _defineProperty$2(_classNames, className, className), _classNames));
    /**
     * Filters the array of added files based on file type restrictions
     * @param {Event} event - Event object, used to get the list of files added
     */

    function validateFiles(event) {
      var transferredFiles = event.type === 'drop' ? _toConsumableArray(event.dataTransfer.files) : _toConsumableArray(event.target.files);

      if (!accept.length) {
        return transferredFiles;
      }

      var acceptedTypes = new Set(accept);
      return transferredFiles.reduce(function (acc, curr) {
        var name = curr.name,
            _curr$type = curr.type,
            mimeType = _curr$type === void 0 ? '' : _curr$type;
        var fileExtensionRegExp = new RegExp(pattern, 'i');
        var hasFileExtension = fileExtensionRegExp.test(name);

        if (!hasFileExtension) {
          return acc;
        }

        var _name$match = name.match(fileExtensionRegExp),
            _name$match2 = _slicedToArray$1(_name$match, 1),
            fileExtension = _name$match2[0];

        if (acceptedTypes.has(mimeType) || acceptedTypes.has(fileExtension)) {
          return acc.concat([curr]);
        }

        curr.invalidFileType = true;
        return acc.concat([curr]);
      }, []);
    }

    function handleChange(event) {
      var addedFiles = validateFiles(event);
      return onAddFiles(event, {
        addedFiles: addedFiles
      });
    }

    var handleClick = function handleClick() {
      if (!disabled) {
        inputRef.current.click();
      }
    };

    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--file"),
      onDragOver: function onDragOver(evt) {
        evt.stopPropagation();
        evt.preventDefault();

        if (disabled) {
          return;
        }

        setActive(true);
        evt.dataTransfer.dropEffect = 'copy';
      },
      onDragLeave: function onDragLeave(evt) {
        evt.stopPropagation();
        evt.preventDefault();

        if (disabled) {
          return;
        }

        setActive(false);
        evt.dataTransfer.dropEffect = 'move';
      },
      onDrop: function onDrop(evt) {
        evt.stopPropagation();
        evt.preventDefault();

        if (disabled) {
          return;
        }

        setActive(false);
        handleChange(evt);
      }
    }, /*#__PURE__*/React__default["default"].createElement("button", _extends$3({
      type: "button",
      className: dropareaClasses,
      onKeyDown: function onKeyDown(evt) {
        if (matches(evt, [Enter, Space])) {
          evt.preventDefault();
          inputRef.current.click();
        }
      },
      onClick: composeEventHandlers([onClick, handleClick])
    }, rest), labelText), /*#__PURE__*/React__default["default"].createElement("label", {
      htmlFor: uid,
      className: "".concat(prefix, "--visually-hidden")
    }, labelText), /*#__PURE__*/React__default["default"].createElement("input", {
      type: "file",
      id: uid,
      className: "".concat(prefix, "--file-input"),
      ref: inputRef,
      tabIndex: "-1",
      disabled: disabled,
      accept: accept,
      name: name,
      multiple: multiple,
      onChange: handleChange,
      onClick: function onClick(evt) {
        evt.target.value = null;
      }
    }));
  }

  FileUploaderDropContainer.propTypes = {
    /**
     * Specify the types of files that this input should be able to receive
     */
    accept: PropTypes__default["default"].arrayOf(PropTypes__default["default"].string),

    /**
     * Provide a custom className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether file input is disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Provide a unique id for the underlying `<input>` node
     */
    id: PropTypes__default["default"].string,

    /**
     * Provide the label text to be read by screen readers when interacting with
     * this control
     */
    labelText: PropTypes__default["default"].string.isRequired,

    /**
     * Specify if the component should accept multiple files to upload
     */
    multiple: PropTypes__default["default"].bool,

    /**
     * Provide a name for the underlying `<input>` node
     */
    name: PropTypes__default["default"].string,

    /**
     * Event handler that is called after files are added to the uploader
     * The event handler signature looks like `onAddFiles(evt, { addedFiles })`
     */
    onAddFiles: PropTypes__default["default"].func,

    /**
     * Provide an optional function to be called when the button element
     * is clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Provide a custom regex pattern for the acceptedTypes
     */
    pattern: PropTypes__default["default"].string,

    /**
     * Provide an accessibility role for the <FileUploaderButton>
     */
    role: deprecate(PropTypes__default["default"].number, 'The `role` prop for `FileUploaderButton` has ' + 'been deprecated since it now renders a button element by default, and has an implicit role of button.'),

    /**
     * Provide a custom tabIndex value for the <FileUploaderButton>
     */
    tabIndex: deprecate(PropTypes__default["default"].number, 'The `tabIndex` prop for `FileUploaderButton` has ' + 'been deprecated since it now renders a button element by default.')
  };
  FileUploaderDropContainer.defaultProps = {
    labelText: 'Add file',
    multiple: false,
    onAddFiles: function onAddFiles() {},
    accept: [],
    pattern: '.[0-9a-z]+$'
  };

  var _excluded$1L = ["uuid", "name", "status", "iconDescription", "onDelete", "invalid", "errorSubject", "errorBody", "size"];

  function FileUploaderItem(_ref) {
    var _cx;

    var uuid = _ref.uuid,
        name = _ref.name,
        status = _ref.status,
        iconDescription = _ref.iconDescription,
        onDelete = _ref.onDelete,
        invalid = _ref.invalid,
        errorSubject = _ref.errorSubject,
        errorBody = _ref.errorBody,
        size = _ref.size,
        other = _objectWithoutProperties$2(_ref, _excluded$1L);

    var prefix = usePrefix();

    var _useRef = React.useRef(uuid || uniqueId()),
        id = _useRef.current;

    var classes = cx("".concat(prefix, "--file__selected-file"), (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--file__selected-file--invalid"), invalid), _defineProperty$2(_cx, "".concat(prefix, "--file__selected-file--md"), size === 'field' || size === 'md'), _defineProperty$2(_cx, "".concat(prefix, "--file__selected-file--sm"), size === 'small' || size === 'sm'), _cx));
    return /*#__PURE__*/React__default["default"].createElement("span", _extends$3({
      className: classes
    }, other), /*#__PURE__*/React__default["default"].createElement("p", {
      className: "".concat(prefix, "--file-filename"),
      title: name
    }, name), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--file__state-container")
    }, /*#__PURE__*/React__default["default"].createElement(Filename, {
      name: name,
      iconDescription: iconDescription,
      status: status,
      invalid: invalid,
      onKeyDown: function onKeyDown(evt) {
        if (matches(evt, [Enter, Space])) {
          if (status === 'edit') {
            evt.preventDefault();
            onDelete(evt, {
              uuid: id
            });
          }
        }
      },
      onClick: function onClick(evt) {
        if (status === 'edit') {
          onDelete(evt, {
            uuid: id
          });
        }
      }
    })), invalid && errorSubject && /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--form-requirement")
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--form-requirement__title")
    }, errorSubject), errorBody && /*#__PURE__*/React__default["default"].createElement("p", {
      className: "".concat(prefix, "--form-requirement__supplement")
    }, errorBody)));
  }

  FileUploaderItem.propTypes = {
    /**
     * Error message body for an invalid file upload
     */
    errorBody: PropTypes__default["default"].string,

    /**
     * Error message subject for an invalid file upload
     */
    errorSubject: PropTypes__default["default"].string,

    /**
     * Description of status icon (displayed in native tooltip)
     */
    iconDescription: PropTypes__default["default"].string,

    /**
     * Specify if the currently uploaded file is invalid
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * Name of the uploaded file
     */
    name: PropTypes__default["default"].string,

    /**
     * Event handler that is called after removing a file from the file uploader
     * The event handler signature looks like `onDelete(evt, { uuid })`
     */
    onDelete: PropTypes__default["default"].func,

    /**
     * Specify the size of the FileUploaderButton, from a list of available
     * sizes.
     */
    size: enabled('enable-v11-release') ? PropTypes__default["default"].oneOf(['sm', 'md', 'lg']) : PropTypes__default["default"].oneOf(['default', 'field', 'small', 'sm', 'md', 'lg']),

    /**
     * Status of the file upload
     */
    status: PropTypes__default["default"].oneOf(['uploading', 'edit', 'complete']),

    /**
     * Unique identifier for the file object
     */
    uuid: PropTypes__default["default"].string
  };
  FileUploaderItem.defaultProps = {
    status: 'uploading',
    onDelete: function onDelete() {}
  };

  var index$2 = enabled('enable-v11-release') ? createClassWrapper(FileUploader) : FileUploader;

  var didWarnAboutDeprecation$6 = {};

  function deprecateFieldOnObject(object, field, Component, message) {
    Object.defineProperty(object, field, {
      enumerable: true,
      get: function get() {
        if (!didWarnAboutDeprecation$6[field]) {
          warning(false, message || "The ".concat(field, " field has been deprecated on the ").concat(object.displayName, " object. ") + "Please import and use ".concat(Component.displayName || Component.name || 'the field', " directly.")) ;
          didWarnAboutDeprecation$6[field] = true;
        }

        return Component;
      }
    });
  }

  var sortingPropTypes = {
    /**
     * Provide a compare function that is used to determine the ordering of
     * options. `compareItems` has the following function signature:
     *
     * compareFunction :
     *  (itemA: string, itemB: string, { locale: string }) => number
     */
    compareItems: PropTypes__default["default"].func.isRequired,

    /**
     * Provide a method that sorts all options in the control. Overriding this
     * prop means that you also have to handle the sort logic for selected versus
     * un-selected items. If you just want to control ordering, consider the
     * `compareItems` prop instead.
     *
     * `sortItems` has the following signature:
     *
     * sortItems :
     *   (items: Array<Item>, {
     *     selectedItems: Array<Item>,
     *     itemToString: Item => string,
     *     compareItems: (itemA: string, itemB: string, {
     *       locale: string
     *     }) => number,
     *     locale: string,
     *   }) => Array<Item>
     */
    sortItems: PropTypes__default["default"].func.isRequired
  };

  var itemToString = function itemToString(item) {
    !(typeof item.label === 'string') ? invariant_1(false, '[MultiSelect] the default `itemToString` method expected to receive ' + 'an item with a `label` field of type `string`. Instead received: `%s`', _typeof(item.label))  : void 0;
    return item.label || '';
  };

  var defaultItemToString = function defaultItemToString(item) {
    if (Array.isArray(item)) {
      return item.map(itemToString);
    }

    return itemToString(item);
  };

  /**
   * Use the local `localCompare` with the `numeric` option to sort two,
   * potentially alpha-numeric, strings in a list of items.
   *
   * @param {string} itemA
   * @param {string} itemB
   * @param {object} options
   * @param {string} options.locale
   * @returns {number}
   */
  var defaultCompareItems = function defaultCompareItems(itemA, itemB, _ref) {
    var locale = _ref.locale;
    return itemA.localeCompare(itemB, locale, {
      numeric: true
    });
  };
  /**
   * Default sorting algorithm for options in a selection control
   */

  var defaultSortItems = function defaultSortItems(items, _ref2) {
    var _ref2$selectedItems = _ref2.selectedItems,
        selectedItems = _ref2$selectedItems === void 0 ? [] : _ref2$selectedItems,
        itemToString = _ref2.itemToString,
        compareItems = _ref2.compareItems,
        _ref2$locale = _ref2.locale,
        locale = _ref2$locale === void 0 ? 'en' : _ref2$locale;
    return items.sort(function (itemA, itemB) {
      var hasItemA = selectedItems.includes(itemA);
      var hasItemB = selectedItems.includes(itemB); // Prefer whichever item is in the `selectedItems` array first

      if (hasItemA && !hasItemB) {
        return -1;
      }

      if (hasItemB && !hasItemA) {
        return 1;
      }

      return compareItems(itemToString(itemA), itemToString(itemB), {
        locale: locale
      });
    });
  };

  function callOnChangeHandler(_ref) {
    var isControlled = _ref.isControlled,
        isMounted = _ref.isMounted,
        onChangeHandlerControlled = _ref.onChangeHandlerControlled,
        onChangeHandlerUncontrolled = _ref.onChangeHandlerUncontrolled,
        selectedItems = _ref.selectedItems;

    if (isControlled) {
      if (isMounted && onChangeHandlerControlled) {
        onChangeHandlerControlled({
          selectedItems: selectedItems
        });
      }
    } else {
      onChangeHandlerUncontrolled(selectedItems);
    }
  }

  function useSelection(_ref2) {
    var disabled = _ref2.disabled,
        onChange = _ref2.onChange,
        _ref2$initialSelected = _ref2.initialSelectedItems,
        initialSelectedItems = _ref2$initialSelected === void 0 ? [] : _ref2$initialSelected,
        controlledItems = _ref2.selectedItems;
    var isMounted = React.useRef(false);
    var savedOnChange = React.useRef(onChange);

    var _useState = React.useState(initialSelectedItems),
        _useState2 = _slicedToArray$1(_useState, 2),
        uncontrolledItems = _useState2[0],
        setUncontrolledItems = _useState2[1];

    var isControlled = !!controlledItems;
    var selectedItems = isControlled ? controlledItems : uncontrolledItems;
    var onItemChange = React.useCallback(function (item) {
      if (disabled) {
        return;
      }

      var selectedIndex;
      selectedItems.forEach(function (selectedItem, index) {
        if (isEqual(selectedItem, item)) {
          selectedIndex = index;
        }
      });
      var newSelectedItems;

      if (selectedIndex === undefined) {
        newSelectedItems = selectedItems.concat(item);
        callOnChangeHandler({
          isControlled: isControlled,
          isMounted: isMounted.current,
          onChangeHandlerControlled: savedOnChange.current,
          onChangeHandlerUncontrolled: setUncontrolledItems,
          selectedItems: newSelectedItems
        });
        return;
      }

      newSelectedItems = removeAtIndex(selectedItems, selectedIndex);
      callOnChangeHandler({
        isControlled: isControlled,
        isMounted: isMounted.current,
        onChangeHandlerControlled: savedOnChange.current,
        onChangeHandlerUncontrolled: setUncontrolledItems,
        selectedItems: newSelectedItems
      });
    }, [disabled, isControlled, selectedItems]);
    var clearSelection = React.useCallback(function () {
      if (disabled) {
        return;
      }

      callOnChangeHandler({
        isControlled: isControlled,
        isMounted: isMounted.current,
        onChangeHandlerControlled: savedOnChange.current,
        onChangeHandlerUncontrolled: setUncontrolledItems,
        selectedItems: []
      });
    }, [disabled, isControlled]);
    React.useEffect(function () {
      savedOnChange.current = onChange;
    }, [onChange]);
    React.useEffect(function () {
      if (isMounted.current && savedOnChange.current && !isControlled) {
        savedOnChange.current({
          selectedItems: selectedItems
        });
      }
    }, [isControlled, selectedItems]);
    React.useEffect(function () {
      isMounted.current = true;
      return function () {
        isMounted.current = false;
      };
    }, []);
    return {
      selectedItems: selectedItems,
      onItemChange: onItemChange,
      clearSelection: clearSelection
    };
  }

  var Selection = /*#__PURE__*/function (_React$Component) {
    _inherits(Selection, _React$Component);

    var _super = _createSuper(Selection);

    function Selection(props) {
      var _this;

      _classCallCheck$1(this, Selection);

      _this = _super.call(this, props);

      _defineProperty$2(_assertThisInitialized$1(_this), "internalSetState", function (stateToSet, callback) {
        return _this.setState(stateToSet, function () {
          if (callback) {
            callback();
          }

          if (_this.props.onChange) {
            _this.props.onChange(_this.state);
          }
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleClearSelection", function () {
        if (_this.props.disabled) {
          return;
        }

        _this.internalSetState({
          selectedItems: []
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleSelectItem", function (item) {
        _this.internalSetState(function (state) {
          return {
            selectedItems: state.selectedItems.concat(item)
          };
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleRemoveItem", function (index) {
        _this.internalSetState(function (state) {
          return {
            selectedItems: removeAtIndex(state.selectedItems, index)
          };
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOnItemChange", function (item) {
        if (_this.props.disabled) {
          return;
        }

        var selectedItems = _this.state.selectedItems;
        var selectedIndex;
        selectedItems.forEach(function (selectedItem, index) {
          if (isEqual(selectedItem, item)) {
            selectedIndex = index;
          }
        });

        if (selectedIndex === undefined) {
          _this.handleSelectItem(item);

          return;
        }

        _this.handleRemoveItem(selectedIndex);
      });

      _this.state = {
        selectedItems: props.initialSelectedItems
      };
      return _this;
    }

    _createClass$1(Selection, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            children = _this$props.children,
            render = _this$props.render;
        var selectedItems = this.state.selectedItems;
        var renderProps = {
          selectedItems: selectedItems,
          onItemChange: this.handleOnItemChange,
          clearSelection: this.handleClearSelection
        };

        if (render !== undefined) {
          return render(renderProps);
        }

        if (children !== undefined) {
          return children(renderProps);
        }

        return null;
      }
    }]);

    return Selection;
  }(React__default["default"].Component); // Generic utility for safely removing an element at a given index from an
  // array.


  _defineProperty$2(Selection, "propTypes", {
    children: PropTypes__default["default"].func,
    disabled: PropTypes__default["default"].bool,
    initialSelectedItems: PropTypes__default["default"].array.isRequired,
    onChange: PropTypes__default["default"].func,
    render: PropTypes__default["default"].func
  });

  _defineProperty$2(Selection, "defaultProps", {
    initialSelectedItems: []
  });

  var removeAtIndex = function removeAtIndex(array, index) {
    var result = array.slice();
    result.splice(index, 1);
    return result;
  };

  var noop = function noop() {};

  var getInstanceId$c = setupGetInstanceId$2();
  var _useSelect$stateChang = useSelect.stateChangeTypes,
      ItemClick = _useSelect$stateChang.ItemClick,
      MenuBlur = _useSelect$stateChang.MenuBlur,
      MenuKeyDownArrowDown = _useSelect$stateChang.MenuKeyDownArrowDown,
      MenuKeyDownArrowUp = _useSelect$stateChang.MenuKeyDownArrowUp,
      MenuKeyDownEnter = _useSelect$stateChang.MenuKeyDownEnter,
      MenuKeyDownEscape = _useSelect$stateChang.MenuKeyDownEscape,
      MenuKeyDownSpaceButton = _useSelect$stateChang.MenuKeyDownSpaceButton,
      ToggleButtonClick = _useSelect$stateChang.ToggleButtonClick;
  var MultiSelect = /*#__PURE__*/React__default["default"].forwardRef(function MultiSelect(_ref, ref) {
    var _cx, _cx2, _cx4;

    var containerClassName = _ref.className,
        id = _ref.id,
        items = _ref.items,
        itemToElement = _ref.itemToElement,
        _itemToString = _ref.itemToString,
        titleText = _ref.titleText,
        hideLabel = _ref.hideLabel,
        helperText = _ref.helperText,
        label = _ref.label,
        type = _ref.type,
        size = _ref.size,
        disabled = _ref.disabled,
        initialSelectedItems = _ref.initialSelectedItems,
        sortItems = _ref.sortItems,
        compareItems = _ref.compareItems,
        clearSelectionText = _ref.clearSelectionText,
        clearSelectionDescription = _ref.clearSelectionDescription,
        light = _ref.light,
        invalid = _ref.invalid,
        invalidText = _ref.invalidText,
        warn = _ref.warn,
        warnText = _ref.warnText,
        useTitleInItem = _ref.useTitleInItem,
        translateWithId = _ref.translateWithId,
        downshiftProps = _ref.downshiftProps,
        open = _ref.open,
        selectionFeedback = _ref.selectionFeedback,
        onChange = _ref.onChange,
        onMenuChange = _ref.onMenuChange,
        direction = _ref.direction,
        selected = _ref.selectedItems;
    var prefix = usePrefix();

    var _useRef = React.useRef(getInstanceId$c()),
        multiSelectInstanceId = _useRef.current;

    var _useState = React.useState(null),
        _useState2 = _slicedToArray$1(_useState, 2),
        highlightedIndex = _useState2[0],
        setHighlightedIndex = _useState2[1];

    var _useState3 = React.useState(false),
        _useState4 = _slicedToArray$1(_useState3, 2),
        inputFocused = _useState4[0],
        setInputFocused = _useState4[1];

    var _useState5 = React.useState(open || false),
        _useState6 = _slicedToArray$1(_useState5, 2),
        isOpen = _useState6[0],
        setIsOpen = _useState6[1];

    var _useState7 = React.useState(open),
        _useState8 = _slicedToArray$1(_useState7, 2),
        prevOpenProp = _useState8[0],
        setPrevOpenProp = _useState8[1];

    var _useState9 = React.useState([]),
        _useState10 = _slicedToArray$1(_useState9, 2),
        topItems = _useState10[0],
        setTopItems = _useState10[1];

    var _useSelection = useSelection({
      disabled: disabled,
      initialSelectedItems: initialSelectedItems,
      onChange: onChange,
      selectedItems: selected
    }),
        controlledSelectedItems = _useSelection.selectedItems,
        onItemChange = _useSelection.onItemChange,
        clearSelection = _useSelection.clearSelection;

    var _useSelect = useSelect(mapDownshiftProps(_objectSpread2$2(_objectSpread2$2({}, downshiftProps), {}, {
      highlightedIndex: highlightedIndex,
      isOpen: isOpen,
      itemToString: function itemToString(items) {
        return items.map(function (item) {
          return _itemToString(item);
        }).join(', ');
      },
      onStateChange: onStateChange,
      selectedItem: controlledSelectedItems,
      items: items
    }))),
        getToggleButtonProps = _useSelect.getToggleButtonProps,
        getLabelProps = _useSelect.getLabelProps,
        getMenuProps = _useSelect.getMenuProps,
        getItemProps = _useSelect.getItemProps,
        selectedItems = _useSelect.selectedItem;
    /**
     * wrapper function to forward changes to consumer
     */


    var setIsOpenWrapper = function setIsOpenWrapper(open) {
      setIsOpen(open);

      if (onMenuChange) {
        onMenuChange(open);
      }
    };
    /**
     * programmatically control this `open` prop
     */


    if (prevOpenProp !== open) {
      setIsOpenWrapper(open);
      setPrevOpenProp(open);
    }

    var inline = type === 'inline';
    var showWarning = !invalid && warn;
    var enabled = useFeatureFlag('enable-v11-release');
    var wrapperClasses = cx("".concat(prefix, "--multi-select__wrapper"), "".concat(prefix, "--list-box__wrapper"), [enabled ? containerClassName : null], (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--multi-select__wrapper--inline"), inline), _defineProperty$2(_cx, "".concat(prefix, "--list-box__wrapper--inline"), inline), _defineProperty$2(_cx, "".concat(prefix, "--multi-select__wrapper--inline--invalid"), inline && invalid), _defineProperty$2(_cx, "".concat(prefix, "--list-box__wrapper--inline--invalid"), inline && invalid), _cx));
    var titleClasses = cx("".concat(prefix, "--label"), (_cx2 = {}, _defineProperty$2(_cx2, "".concat(prefix, "--label--disabled"), disabled), _defineProperty$2(_cx2, "".concat(prefix, "--visually-hidden"), hideLabel), _cx2));
    var helperId = !helperText ? undefined : "multiselect-helper-text-".concat(multiSelectInstanceId);
    var fieldLabelId = "multiselect-field-label-".concat(multiSelectInstanceId);
    var helperClasses = cx("".concat(prefix, "--form__helper-text"), _defineProperty$2({}, "".concat(prefix, "--form__helper-text--disabled"), disabled));
    var className = cx("".concat(prefix, "--multi-select"), [enabled ? null : containerClassName], (_cx4 = {}, _defineProperty$2(_cx4, "".concat(prefix, "--multi-select--invalid"), invalid), _defineProperty$2(_cx4, "".concat(prefix, "--multi-select--invalid--focused"), invalid && inputFocused), _defineProperty$2(_cx4, "".concat(prefix, "--multi-select--warning"), showWarning), _defineProperty$2(_cx4, "".concat(prefix, "--multi-select--inline"), inline), _defineProperty$2(_cx4, "".concat(prefix, "--multi-select--selected"), selectedItems && selectedItems.length > 0), _defineProperty$2(_cx4, "".concat(prefix, "--list-box--up"), direction === 'top'), _cx4)); // needs to be capitalized for react to render it correctly

    var ItemToElement = itemToElement;
    var sortOptions = {
      selectedItems: controlledSelectedItems,
      itemToString: _itemToString,
      compareItems: compareItems,
      locale: 'en'
    };

    if (selectionFeedback === 'fixed') {
      sortOptions.selectedItems = [];
    } else if (selectionFeedback === 'top-after-reopen') {
      sortOptions.selectedItems = topItems;
    }

    function onStateChange(changes) {
      if (changes.isOpen && !isOpen) {
        setTopItems(controlledSelectedItems);
      }

      var type = changes.type;

      switch (type) {
        case ItemClick:
        case MenuKeyDownSpaceButton:
        case MenuKeyDownEnter:
          if (changes.selectedItem === undefined) {
            break;
          }

          onItemChange(changes.selectedItem);
          break;

        case MenuKeyDownArrowDown:
        case MenuKeyDownArrowUp:
          setHighlightedIndex(changes.highlightedIndex);
          break;

        case MenuBlur:
        case MenuKeyDownEscape:
          setIsOpenWrapper(false);
          setHighlightedIndex(changes.highlightedIndex);
          break;

        case ToggleButtonClick:
          setIsOpenWrapper(changes.isOpen || false);
          setHighlightedIndex(changes.highlightedIndex);
          break;
      }
    }

    var onKeyDown = function onKeyDown(e) {
      if (!disabled) {
        if (match(e, Delete) || match(e, Escape)) {
          clearSelection();
          e.stopPropagation();
        }
      }
    };

    var multiSelectFieldWrapperClasses = cx("".concat(prefix, "--list-box__field--wrapper"), _defineProperty$2({}, "".concat(prefix, "--list-box__field--wrapper--input-focused"), inputFocused));
    var toggleButtonProps = getToggleButtonProps({
      onFocus: function onFocus() {
        setInputFocused(true);
      },
      onBlur: function onBlur() {
        setInputFocused(false);
      }
    });
    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: wrapperClasses
    }, /*#__PURE__*/React__default["default"].createElement("label", _extends$3({
      className: titleClasses
    }, getLabelProps()), titleText && titleText, selectedItems.length > 0 && /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--visually-hidden")
    }, clearSelectionDescription, " ", selectedItems.length, ",", clearSelectionText)), /*#__PURE__*/React__default["default"].createElement(ListBox$1, {
      type: type,
      size: size,
      className: className,
      disabled: disabled,
      light: light,
      invalid: invalid,
      invalidText: invalidText,
      warn: warn,
      warnText: warnText,
      isOpen: isOpen,
      id: id
    }, invalid && /*#__PURE__*/React__default["default"].createElement(WarningFilled16, {
      className: "".concat(prefix, "--list-box__invalid-icon")
    }), showWarning && /*#__PURE__*/React__default["default"].createElement(WarningAltFilled16, {
      className: "".concat(prefix, "--list-box__invalid-icon ").concat(prefix, "--list-box__invalid-icon--warning")
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      className: multiSelectFieldWrapperClasses
    }, selectedItems.length > 0 && /*#__PURE__*/React__default["default"].createElement(ListBox$1.Selection, {
      clearSelection: !disabled ? clearSelection : noop,
      selectionCount: selectedItems.length,
      translateWithId: translateWithId,
      disabled: disabled
    }), /*#__PURE__*/React__default["default"].createElement("button", _extends$3({
      type: "button",
      className: "".concat(prefix, "--list-box__field"),
      disabled: disabled,
      "aria-disabled": disabled,
      "aria-describedby": !inline && !invalid && !warn && helperText ? helperId : undefined
    }, toggleButtonProps, {
      ref: mergeRefs$1(toggleButtonProps.ref, ref),
      onKeyDown: onKeyDown
    }), /*#__PURE__*/React__default["default"].createElement("span", {
      id: fieldLabelId,
      className: "".concat(prefix, "--list-box__label")
    }, label), /*#__PURE__*/React__default["default"].createElement(ListBox$1.MenuIcon, {
      isOpen: isOpen,
      translateWithId: translateWithId
    }))), /*#__PURE__*/React__default["default"].createElement(ListBox$1.Menu, _extends$3({
      "aria-multiselectable": "true"
    }, getMenuProps()), isOpen && sortItems(items, sortOptions).map(function (item, index) {
      var _getItemProps;

      var itemProps = getItemProps((_getItemProps = {
        item: item
      }, _defineProperty$2(_getItemProps, 'aria-selected', isChecked ? true : null), _defineProperty$2(_getItemProps, "disabled", item.disabled), _getItemProps));

      var itemText = _itemToString(item);

      var isChecked = selectedItems.filter(function (selected) {
        return isEqual(selected, item);
      }).length > 0;
      return /*#__PURE__*/React__default["default"].createElement(ListBox$1.MenuItem, _extends$3({
        key: itemProps.id,
        isActive: isChecked,
        "aria-label": itemText,
        isHighlighted: highlightedIndex === index,
        title: itemText
      }, itemProps), /*#__PURE__*/React__default["default"].createElement("div", {
        className: "".concat(prefix, "--checkbox-wrapper")
      }, /*#__PURE__*/React__default["default"].createElement("span", {
        title: useTitleInItem ? itemText : null,
        className: "".concat(prefix, "--checkbox-label"),
        "data-contained-checkbox-state": isChecked,
        id: "".concat(itemProps.id, "__checkbox")
      }, itemToElement ? /*#__PURE__*/React__default["default"].createElement(ItemToElement, _extends$3({
        key: itemProps.id
      }, item)) : itemText)));
    }))), !inline && !invalid && !warn && helperText && /*#__PURE__*/React__default["default"].createElement("div", {
      id: helperId,
      className: helperClasses
    }, helperText));
  });
  MultiSelect.displayName = 'MultiSelect';
  MultiSelect.propTypes = _objectSpread2$2(_objectSpread2$2({}, sortingPropTypes), {}, {
    /**
     * Specify the text that should be read for screen readers that describes total items selected
     */
    clearSelectionDescription: PropTypes__default["default"].string,

    /**
     * Specify the text that should be read for screen readers to clear selection.
     */
    clearSelectionText: PropTypes__default["default"].string,

    /**
     * Specify the direction of the multiselect dropdown. Can be either top or bottom.
     */
    direction: PropTypes__default["default"].oneOf(['top', 'bottom']),

    /**
     * Disable the control
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Additional props passed to Downshift
     */
    downshiftProps: PropTypes__default["default"].shape(Downshift$1.propTypes),

    /**
     * Specify whether the title text should be hidden or not
     */
    hideLabel: PropTypes__default["default"].bool,

    /**
     * Specify a custom `id`
     */
    id: PropTypes__default["default"].string.isRequired,

    /**
     * Allow users to pass in arbitrary items from their collection that are
     * pre-selected
     */
    initialSelectedItems: PropTypes__default["default"].array,

    /**
     * Is the current selection invalid?
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * If invalid, what is the error?
     */
    invalidText: PropTypes__default["default"].node,

    /**
     * Function to render items as custom components instead of strings.
     * Defaults to null and is overridden by a getter
     */
    itemToElement: PropTypes__default["default"].func,

    /**
     * Helper function passed to downshift that allows the library to render a
     * given item to a string label. By default, it extracts the `label` field
     * from a given item to serve as the item label in the list.
     */
    itemToString: PropTypes__default["default"].func,

    /**
     * We try to stay as generic as possible here to allow individuals to pass
     * in a collection of whatever kind of data structure they prefer
     */
    items: PropTypes__default["default"].array.isRequired,

    /**
     * Generic `label` that will be used as the textual representation of what
     * this field is for
     */
    label: PropTypes__default["default"].node.isRequired,

    /**
     * `true` to use the light version.
     */
    light: PropTypes__default["default"].bool,

    /**
     * Specify the locale of the control. Used for the default `compareItems`
     * used for sorting the list of items in the control.
     */
    locale: PropTypes__default["default"].string,

    /**
     * `onChange` is a utility for this controlled component to communicate to a
     * consuming component what kind of internal state changes are occurring.
     */
    onChange: PropTypes__default["default"].func,

    /**
     * `onMenuChange` is a utility for this controlled component to communicate to a
     * consuming component that the menu was open(`true`)/closed(`false`).
     */
    onMenuChange: PropTypes__default["default"].func,

    /**
     * Initialize the component with an open(`true`)/closed(`false`) menu.
     */
    open: PropTypes__default["default"].bool,

    /**
     * For full control of the selected items
     */
    selectedItems: PropTypes__default["default"].array,

    /**
     * Specify feedback (mode) of the selection.
     * `top`: selected item jumps to top
     * `fixed`: selected item stays at it's position
     * `top-after-reopen`: selected item jump to top after reopen dropdown
     */
    selectionFeedback: PropTypes__default["default"].oneOf(['top', 'fixed', 'top-after-reopen']),

    /**
     * Specify the size of the ListBox. Currently supports either `sm`, `md` or `lg` as an option.
     */
    size: ListBoxSize,

    /**
     * Provide text to be used in a `<label>` element that is tied to the
     * multiselect via ARIA attributes.
     */
    titleText: PropTypes__default["default"].node,

    /**
     * Callback function for translating ListBoxMenuIcon SVG title
     */
    translateWithId: PropTypes__default["default"].func,

    /**
     * Specify 'inline' to create an inline multi-select.
     */
    type: PropTypes__default["default"].oneOf(['default', 'inline']),

    /**
     * Specify title to show title on hover
     */
    useTitleInItem: PropTypes__default["default"].bool,

    /**
     * Specify whether the control is currently in warning state
     */
    warn: PropTypes__default["default"].bool,

    /**
     * Provide the text that is displayed when the control is in warning state
     */
    warnText: PropTypes__default["default"].node
  });
  MultiSelect.defaultProps = {
    compareItems: defaultCompareItems,
    disabled: false,
    locale: 'en',
    itemToString: defaultItemToString,
    initialSelectedItems: [],
    sortItems: defaultSortItems,
    type: 'default',
    light: false,
    title: false,
    open: false,
    selectionFeedback: 'top-after-reopen',
    direction: 'bottom',
    clearSelectionText: 'To clear selection, press Delete or Backspace,',
    clearSelectionDescription: 'Total items selected: ',
    selectedItems: null
  };
  var MultiSelect$1 = MultiSelect;

  var defaultFilterItems = function defaultFilterItems(items, _ref) {
    var itemToString = _ref.itemToString,
        inputValue = _ref.inputValue;
    return items.filter(function (item) {
      if (!inputValue) {
        return true;
      }

      return itemToString(item).toLowerCase().includes(inputValue.toLowerCase());
    });
  };

  var getInstanceId$b = setupGetInstanceId$2();

  var FilterableMultiSelect$2 = /*#__PURE__*/function (_React$Component) {
    _inherits(FilterableMultiSelect, _React$Component);

    var _super = _createSuper(FilterableMultiSelect);

    function FilterableMultiSelect(props) {
      var _this;

      _classCallCheck$1(this, FilterableMultiSelect);

      _this = _super.call(this, props);

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOnChange", function (changes) {
        if (_this.props.onChange) {
          _this.props.onChange(changes);
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOnMenuChange", function (isOpen) {
        _this.setState(function (state) {
          return {
            isOpen: isOpen !== null && isOpen !== void 0 ? isOpen : !state.isOpen
          };
        });

        if (_this.props.onMenuChange) {
          _this.props.onMenuChange(isOpen);
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOnOuterClick", function () {
        _this.handleOnMenuChange(false);
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOnStateChange", function (changes, downshift) {
        if (changes.isOpen && !_this.state.isOpen) {
          _this.setState({
            topItems: downshift.selectedItem
          });
        }

        var type = changes.type;
        var stateChangeTypes = Downshift$1.stateChangeTypes;

        switch (type) {
          case stateChangeTypes.keyDownArrowDown:
          case stateChangeTypes.keyDownArrowUp:
          case stateChangeTypes.keyDownHome:
          case stateChangeTypes.keyDownEnd:
            _this.setState({
              highlightedIndex: changes.highlightedIndex !== undefined ? changes.highlightedIndex : null
            });

            if (stateChangeTypes.keyDownArrowDown === type && !_this.state.isOpen) {
              _this.handleOnMenuChange(true);
            }

            break;

          case stateChangeTypes.keyDownEscape:
            _this.handleOnMenuChange(false);

            break;
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOnInputKeyDown", function (event) {
        event.stopPropagation();
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOnInputValueChange", function (inputValue, _ref) {
        var type = _ref.type;

        if (_this.props.onInputValueChange) {
          _this.props.onInputValueChange(inputValue);
        }

        if (type !== Downshift$1.stateChangeTypes.changeInput) {
          return;
        }

        _this.setState(function () {
          if (Array.isArray(inputValue)) {
            return {
              inputValue: ''
            };
          }

          return {
            inputValue: inputValue || ''
          };
        });

        if (inputValue && !_this.state.isOpen) {
          _this.handleOnMenuChange(true);
        } else if (!inputValue && _this.state.isOpen) {
          _this.handleOnMenuChange(false);
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "clearInputValue", function () {
        _this.setState({
          inputValue: ''
        }, function () {
          if (_this.textInput.current) {
            _this.textInput.current.focus();
          }
        });
      });

      _this.filterableMultiSelectInstanceId = getInstanceId$b();
      _this.state = {
        isOpen: props.open,
        inputValue: '',
        topItems: [],
        inputFocused: false,
        highlightedIndex: null
      };
      _this.textInput = /*#__PURE__*/React__default["default"].createRef();
      return _this;
    }

    _createClass$1(FilterableMultiSelect, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$state = this.state,
            highlightedIndex = _this$state.highlightedIndex,
            isOpen = _this$state.isOpen,
            inputValue = _this$state.inputValue;
        var _this$props = this.props,
            ariaLabel = _this$props.ariaLabel,
            containerClassName = _this$props.className,
            direction = _this$props.direction,
            disabled = _this$props.disabled,
            filterItems = _this$props.filterItems,
            items = _this$props.items,
            itemToElement = _this$props.itemToElement,
            itemToString = _this$props.itemToString,
            titleText = _this$props.titleText,
            hideLabel = _this$props.hideLabel,
            helperText = _this$props.helperText,
            type = _this$props.type,
            initialSelectedItems = _this$props.initialSelectedItems,
            id = _this$props.id,
            locale = _this$props.locale,
            size = _this$props.size,
            placeholder = _this$props.placeholder,
            sortItems = _this$props.sortItems,
            compareItems = _this$props.compareItems,
            light = _this$props.light,
            invalid = _this$props.invalid,
            invalidText = _this$props.invalidText,
            warn = _this$props.warn,
            warnText = _this$props.warnText,
            useTitleInItem = _this$props.useTitleInItem,
            translateWithId = _this$props.translateWithId,
            downshiftProps = _this$props.downshiftProps;
        var inline = type === 'inline';
        var showWarning = !invalid && warn; // needs to be capitalized for react to render it correctly

        var ItemToElement = itemToElement;
        var scope = this.context;
        var enabled;

        if (scope.enabled) {
          enabled = scope.enabled('enable-v11-release');
        }

        return /*#__PURE__*/React__default["default"].createElement(PrefixContext.Consumer, null, function (prefix) {
          var _cx, _cx2, _cx3, _cx4;

          var wrapperClasses = cx("".concat(prefix, "--multi-select__wrapper"), "".concat(prefix, "--multi-select--filterable__wrapper"), "".concat(prefix, "--list-box__wrapper"), [enabled ? containerClassName : null], (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--multi-select__wrapper--inline"), inline), _defineProperty$2(_cx, "".concat(prefix, "--list-box__wrapper--inline"), inline), _defineProperty$2(_cx, "".concat(prefix, "--multi-select__wrapper--inline--invalid"), inline && invalid), _defineProperty$2(_cx, "".concat(prefix, "--list-box__wrapper--inline--invalid"), inline && invalid), _defineProperty$2(_cx, "".concat(prefix, "--list-box--up"), direction === 'top'), _cx));
          var helperId = !helperText ? undefined : "filterablemultiselect-helper-text-".concat(_this2.filterableMultiSelectInstanceId);
          var labelId = "".concat(id, "-label");
          var titleClasses = cx((_cx2 = {}, _defineProperty$2(_cx2, "".concat(prefix, "--label"), true), _defineProperty$2(_cx2, "".concat(prefix, "--label--disabled"), disabled), _defineProperty$2(_cx2, "".concat(prefix, "--visually-hidden"), hideLabel), _cx2));
          var helperClasses = cx((_cx3 = {}, _defineProperty$2(_cx3, "".concat(prefix, "--form__helper-text"), true), _defineProperty$2(_cx3, "".concat(prefix, "--form__helper-text--disabled"), disabled), _cx3));
          var inputClasses = cx((_cx4 = {}, _defineProperty$2(_cx4, "".concat(prefix, "--text-input"), true), _defineProperty$2(_cx4, "".concat(prefix, "--text-input--empty"), !_this2.state.inputValue), _defineProperty$2(_cx4, "".concat(prefix, "--text-input--light"), light), _cx4));
          var helper = helperText ? /*#__PURE__*/React__default["default"].createElement("div", {
            id: helperId,
            className: helperClasses
          }, helperText) : null;
          var menuId = "".concat(id, "__menu");
          var inputId = "".concat(id, "-input");
          return /*#__PURE__*/React__default["default"].createElement(Selection, {
            disabled: disabled,
            onChange: _this2.handleOnChange,
            initialSelectedItems: initialSelectedItems,
            render: function render(_ref2) {
              var selectedItems = _ref2.selectedItems,
                  onItemChange = _ref2.onItemChange,
                  _clearSelection = _ref2.clearSelection;
              return /*#__PURE__*/React__default["default"].createElement(Downshift$1, _extends$3({}, mapDownshiftProps(downshiftProps), {
                highlightedIndex: highlightedIndex,
                id: id,
                isOpen: isOpen,
                inputValue: inputValue,
                onInputValueChange: _this2.handleOnInputValueChange,
                onChange: function onChange(selectedItem) {
                  if (selectedItem !== null) {
                    onItemChange(selectedItem);
                  }
                },
                itemToString: itemToString,
                onStateChange: _this2.handleOnStateChange,
                onOuterClick: _this2.handleOnOuterClick,
                selectedItem: selectedItems,
                labelId: labelId,
                menuId: menuId,
                inputId: inputId
              }), function (_ref3) {
                var _cx5;

                var getInputProps = _ref3.getInputProps,
                    getItemProps = _ref3.getItemProps,
                    getLabelProps = _ref3.getLabelProps,
                    getMenuProps = _ref3.getMenuProps,
                    getRootProps = _ref3.getRootProps,
                    getToggleButtonProps = _ref3.getToggleButtonProps,
                    isOpen = _ref3.isOpen,
                    inputValue = _ref3.inputValue,
                    selectedItem = _ref3.selectedItem;
                var className = cx("".concat(prefix, "--multi-select"), "".concat(prefix, "--combo-box"), "".concat(prefix, "--multi-select--filterable"), [enabled ? null : containerClassName], (_cx5 = {}, _defineProperty$2(_cx5, "".concat(prefix, "--multi-select--invalid"), invalid), _defineProperty$2(_cx5, "".concat(prefix, "--multi-select--invalid--focused"), invalid && _this2.state.inputFocused), _defineProperty$2(_cx5, "".concat(prefix, "--multi-select--open"), isOpen), _defineProperty$2(_cx5, "".concat(prefix, "--multi-select--inline"), inline), _defineProperty$2(_cx5, "".concat(prefix, "--multi-select--selected"), selectedItem.length > 0), _defineProperty$2(_cx5, "".concat(prefix, "--multi-select--filterable--input-focused"), _this2.state.inputFocused), _cx5));
                var rootProps = getRootProps({}, {
                  suppressRefError: true
                });
                var labelProps = getLabelProps();
                var buttonProps = getToggleButtonProps({
                  disabled: disabled,
                  onClick: function onClick() {
                    _this2.handleOnMenuChange(!_this2.state.isOpen);

                    if (_this2.textInput.current) {
                      _this2.textInput.current.focus();
                    }
                  },
                  // When we moved the "root node" of Downshift to the <input> for
                  // ARIA 1.2 compliance, we unfortunately hit this branch for the
                  // "mouseup" event that downshift listens to:
                  // https://github.com/downshift-js/downshift/blob/v5.2.1/src/downshift.js#L1051-L1065
                  //
                  // As a result, it will reset the state of the component and so we
                  // stop the event from propagating to prevent this. This allows the
                  // toggleMenu behavior for the toggleButton to correctly open and
                  // close the menu.
                  onMouseUp: function onMouseUp(event) {
                    if (isOpen) {
                      event.stopPropagation();
                    }
                  }
                });
                var inputProps = getInputProps({
                  'aria-controls': isOpen ? menuId : null,
                  'aria-describedby': helperText ? helperId : null,
                  // Remove excess aria `aria-labelledby`. HTML <label for>
                  // provides this aria information.
                  'aria-labelledby': null,
                  disabled: disabled,
                  placeholder: placeholder,
                  onClick: function onClick() {
                    _this2.handleOnMenuChange(true);
                  },
                  onKeyDown: function onKeyDown(event) {
                    if (match(event, Space)) {
                      event.stopPropagation();
                    }

                    if (!disabled) {
                      if (match(event, Delete) || match(event, Escape)) {
                        if (isOpen) {
                          _this2.handleOnMenuChange(true);

                          _this2.clearInputValue();

                          event.stopPropagation();
                        } else if (!isOpen) {
                          _this2.clearInputValue();

                          _clearSelection();

                          event.stopPropagation();
                        }
                      }
                    }
                  },
                  onFocus: function onFocus() {
                    _this2.setState({
                      inputFocused: true
                    });
                  },
                  onBlur: function onBlur() {
                    _this2.setState({
                      inputFocused: false,
                      inputValue: ''
                    });

                    _this2.handleOnMenuChange(false);
                  }
                });
                var menuProps = getMenuProps({
                  'aria-label': ariaLabel
                }, {
                  suppressRefError: true
                });
                return /*#__PURE__*/React__default["default"].createElement("div", {
                  className: wrapperClasses
                }, titleText ? /*#__PURE__*/React__default["default"].createElement("label", _extends$3({
                  className: titleClasses
                }, labelProps), titleText) : null, /*#__PURE__*/React__default["default"].createElement(ListBox$1, {
                  className: className,
                  disabled: disabled,
                  light: light,
                  invalid: invalid,
                  invalidText: invalidText,
                  warn: warn,
                  warnText: warnText,
                  isOpen: isOpen,
                  size: size
                }, /*#__PURE__*/React__default["default"].createElement("div", {
                  className: "".concat(prefix, "--list-box__field")
                }, selectedItem.length > 0 && /*#__PURE__*/React__default["default"].createElement(ListBoxSelection, {
                  clearSelection: function clearSelection() {
                    _clearSelection();

                    if (_this2.textInput.current) {
                      _this2.textInput.current.focus();
                    }
                  },
                  selectionCount: selectedItem.length,
                  translateWithId: translateWithId,
                  disabled: disabled
                }), /*#__PURE__*/React__default["default"].createElement("input", _extends$3({
                  className: inputClasses
                }, rootProps, inputProps, {
                  ref: mergeRefs$1(_this2.textInput, rootProps.ref)
                })), invalid && /*#__PURE__*/React__default["default"].createElement(WarningFilled16, {
                  className: "".concat(prefix, "--list-box__invalid-icon")
                }), showWarning && /*#__PURE__*/React__default["default"].createElement(WarningAltFilled16, {
                  className: "".concat(prefix, "--list-box__invalid-icon ").concat(prefix, "--list-box__invalid-icon--warning")
                }), inputValue && /*#__PURE__*/React__default["default"].createElement(ListBoxSelection, {
                  clearSelection: _this2.clearInputValue,
                  disabled: disabled,
                  translateWithId: translateWithId,
                  onMouseUp: function onMouseUp(event) {
                    // If we do not stop this event from propagating,
                    // it seems like Downshift takes our event and
                    // prevents us from getting `onClick` /
                    // `clearSelection` from the underlying <button> in
                    // ListBoxSelection
                    event.stopPropagation();
                  }
                }), /*#__PURE__*/React__default["default"].createElement(ListBoxTrigger$1, _extends$3({}, buttonProps, {
                  isOpen: isOpen,
                  translateWithId: translateWithId
                }))), isOpen ? /*#__PURE__*/React__default["default"].createElement(ListBox$1.Menu, menuProps, sortItems(filterItems(items, {
                  itemToString: itemToString,
                  inputValue: inputValue
                }), {
                  selectedItems: {
                    top: selectedItems,
                    fixed: [],
                    'top-after-reopen': _this2.state.topItems
                  }[_this2.props.selectionFeedback],
                  itemToString: itemToString,
                  compareItems: compareItems,
                  locale: locale
                }).map(function (item, index) {
                  var itemProps = getItemProps({
                    item: item,
                    disabled: item.disabled
                  });
                  var itemText = itemToString(item);
                  var isChecked = selectedItem.filter(function (selected) {
                    return isEqual(selected, item);
                  }).length > 0;
                  return /*#__PURE__*/React__default["default"].createElement(ListBox$1.MenuItem, _extends$3({
                    key: itemProps.id,
                    "aria-label": itemText,
                    isActive: isChecked,
                    isHighlighted: highlightedIndex === index,
                    title: itemText
                  }, itemProps), /*#__PURE__*/React__default["default"].createElement("div", {
                    className: "".concat(prefix, "--checkbox-wrapper")
                  }, /*#__PURE__*/React__default["default"].createElement("span", {
                    title: useTitleInItem ? itemText : null,
                    className: "".concat(prefix, "--checkbox-label"),
                    "data-contained-checkbox-state": isChecked,
                    id: "".concat(itemProps.id, "-item")
                  }, itemToElement ? /*#__PURE__*/React__default["default"].createElement(ItemToElement, _extends$3({
                    key: itemProps.id
                  }, item)) : itemText)));
                })) : null), !inline && !invalid && !warn ? helper : null);
              });
            }
          });
        });
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref4, state) {
        var open = _ref4.open;

        /**
         * programmatically control this `open` prop
         */
        var prevOpen = state.prevOpen;
        return prevOpen === open ? null : {
          isOpen: open,
          prevOpen: open
        };
      }
    }]);

    return FilterableMultiSelect;
  }(React__default["default"].Component);

  _defineProperty$2(FilterableMultiSelect$2, "propTypes", _objectSpread2$2(_objectSpread2$2({
    /**
     * 'aria-label' of the ListBox component.
     */
    ariaLabel: PropTypes__default["default"].string,

    /**
     * Specify the direction of the multiselect dropdown. Can be either top or bottom.
     */
    direction: PropTypes__default["default"].oneOf(['top', 'bottom']),

    /**
     * Disable the control
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Additional props passed to Downshift
     */
    downshiftProps: PropTypes__default["default"].shape(Downshift$1.propTypes),

    /**
     * Specify whether the title text should be hidden or not
     */
    hideLabel: PropTypes__default["default"].bool,

    /**
     * Specify a custom `id`
     */
    id: PropTypes__default["default"].string.isRequired,

    /**
     * Allow users to pass in arbitrary items from their collection that are
     * pre-selected
     */
    initialSelectedItems: PropTypes__default["default"].array,

    /**
     * Is the current selection invalid?
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * If invalid, what is the error?
     */
    invalidText: PropTypes__default["default"].node,

    /**
     * Function to render items as custom components instead of strings.
     * Defaults to null and is overridden by a getter
     */
    itemToElement: PropTypes__default["default"].func,

    /**
     * Helper function passed to downshift that allows the library to render a
     * given item to a string label. By default, it extracts the `label` field
     * from a given item to serve as the item label in the list.
     */
    itemToString: PropTypes__default["default"].func,

    /**
     * We try to stay as generic as possible here to allow individuals to pass
     * in a collection of whatever kind of data structure they prefer
     */
    items: PropTypes__default["default"].array.isRequired,

    /**
     * `true` to use the light version.
     */
    light: PropTypes__default["default"].bool,

    /**
     * Specify the locale of the control. Used for the default `compareItems`
     * used for sorting the list of items in the control.
     */
    locale: PropTypes__default["default"].string,

    /**
     * `onChange` is a utility for this controlled component to communicate to a
     * consuming component what kind of internal state changes are occurring.
     */
    onChange: PropTypes__default["default"].func,

    /**
     * `onInputValueChange` is a utility for this controlled component to communicate to
     * the currently typed input.
     */
    onInputValueChange: PropTypes__default["default"].func,

    /**
     * `onMenuChange` is a utility for this controlled component to communicate to a
     * consuming component that the menu was opened(`true`)/closed(`false`).
     */
    onMenuChange: PropTypes__default["default"].func,

    /**
     * Initialize the component with an open(`true`)/closed(`false`) menu.
     */
    open: PropTypes__default["default"].bool,

    /**
     * Generic `placeholder` that will be used as the textual representation of
     * what this field is for
     */
    placeholder: PropTypes__default["default"].string.isRequired,

    /**
     * Specify feedback (mode) of the selection.
     * `top`: selected item jumps to top
     * `fixed`: selected item stays at it's position
     * `top-after-reopen`: selected item jump to top after reopen dropdown
     */
    selectionFeedback: PropTypes__default["default"].oneOf(['top', 'fixed', 'top-after-reopen']),

    /**
     * Specify the size of the ListBox. Currently supports either `sm`, `md` or `lg` as an option.
     */
    size: ListBoxSize
  }, sortingPropTypes), {}, {
    /**
     * Callback function for translating ListBoxMenuIcon SVG title
     */
    translateWithId: PropTypes__default["default"].func,

    /**
     * Specify title to show title on hover
     */
    useTitleInItem: PropTypes__default["default"].bool,

    /**
     * Specify whether the control is currently in warning state
     */
    warn: PropTypes__default["default"].bool,

    /**
     * Provide the text that is displayed when the control is in warning state
     */
    warnText: PropTypes__default["default"].node
  }));

  _defineProperty$2(FilterableMultiSelect$2, "contextType", FeatureFlagContext);

  _defineProperty$2(FilterableMultiSelect$2, "defaultProps", {
    ariaLabel: 'Choose an item',
    compareItems: defaultCompareItems,
    direction: 'bottom',
    disabled: false,
    filterItems: defaultFilterItems,
    initialSelectedItems: [],
    itemToString: defaultItemToString,
    locale: 'en',
    sortItems: defaultSortItems,
    light: false,
    open: false,
    selectionFeedback: 'top-after-reopen'
  });

  var FilterableMultiSelect$1 = /*#__PURE__*/React__default["default"].forwardRef(function FilterableMultiSelect(_ref, ref) {
    var _cx, _cx2, _cx3, _cx4;

    var ariaLabel = _ref.ariaLabel,
        containerClassName = _ref.className,
        compareItems = _ref.compareItems,
        direction = _ref.direction,
        disabled = _ref.disabled,
        downshiftProps = _ref.downshiftProps,
        filterItems = _ref.filterItems,
        helperText = _ref.helperText,
        hideLabel = _ref.hideLabel,
        id = _ref.id,
        initialSelectedItems = _ref.initialSelectedItems,
        invalid = _ref.invalid,
        invalidText = _ref.invalidText,
        items = _ref.items,
        ItemToElement = _ref.itemToElement,
        itemToString = _ref.itemToString,
        light = _ref.light,
        locale = _ref.locale,
        onInputValueChange = _ref.onInputValueChange,
        open = _ref.open,
        onChange = _ref.onChange,
        onMenuChange = _ref.onMenuChange,
        placeholder = _ref.placeholder,
        titleText = _ref.titleText,
        type = _ref.type,
        selectionFeedback = _ref.selectionFeedback,
        size = _ref.size,
        sortItems = _ref.sortItems,
        translateWithId = _ref.translateWithId,
        useTitleInItem = _ref.useTitleInItem,
        warn = _ref.warn,
        warnText = _ref.warnText;

    var _useState = React.useState(open),
        _useState2 = _slicedToArray$1(_useState, 2),
        isOpen = _useState2[0],
        setIsOpen = _useState2[1];

    var _useState3 = React.useState(open),
        _useState4 = _slicedToArray$1(_useState3, 2),
        prevOpen = _useState4[0],
        setPrevOpen = _useState4[1];

    var _useState5 = React.useState(''),
        _useState6 = _slicedToArray$1(_useState5, 2),
        inputValue = _useState6[0],
        setInputValue = _useState6[1];

    var _useState7 = React.useState([]),
        _useState8 = _slicedToArray$1(_useState7, 2),
        topItems = _useState8[0],
        setTopItems = _useState8[1];

    var _useState9 = React.useState(false),
        _useState10 = _slicedToArray$1(_useState9, 2),
        inputFocused = _useState10[0],
        setInputFocused = _useState10[1];

    var _useState11 = React.useState(null),
        _useState12 = _slicedToArray$1(_useState11, 2),
        highlightedIndex = _useState12[0],
        setHighlightedIndex = _useState12[1];

    var textInput = React.useRef();
    var filterableMultiSelectInstanceId = useId();
    var enabled = useFeatureFlag('enable-v11-release');
    var prefix = usePrefix();

    if (prevOpen !== open) {
      setIsOpen(open);
      setPrevOpen(open);
    }

    var inline = type === 'inline';
    var showWarning = !invalid && warn;
    var wrapperClasses = cx("".concat(prefix, "--multi-select__wrapper"), "".concat(prefix, "--multi-select--filterable__wrapper"), "".concat(prefix, "--list-box__wrapper"), [enabled ? containerClassName : null], (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--multi-select__wrapper--inline"), inline), _defineProperty$2(_cx, "".concat(prefix, "--list-box__wrapper--inline"), inline), _defineProperty$2(_cx, "".concat(prefix, "--multi-select__wrapper--inline--invalid"), inline && invalid), _defineProperty$2(_cx, "".concat(prefix, "--list-box__wrapper--inline--invalid"), inline && invalid), _defineProperty$2(_cx, "".concat(prefix, "--list-box--up"), direction === 'top'), _cx));
    var helperId = !helperText ? undefined : "filterablemultiselect-helper-text-".concat(filterableMultiSelectInstanceId);
    var labelId = "".concat(id, "-label");
    var titleClasses = cx((_cx2 = {}, _defineProperty$2(_cx2, "".concat(prefix, "--label"), true), _defineProperty$2(_cx2, "".concat(prefix, "--label--disabled"), disabled), _defineProperty$2(_cx2, "".concat(prefix, "--visually-hidden"), hideLabel), _cx2));
    var helperClasses = cx((_cx3 = {}, _defineProperty$2(_cx3, "".concat(prefix, "--form__helper-text"), true), _defineProperty$2(_cx3, "".concat(prefix, "--form__helper-text--disabled"), disabled), _cx3));
    var inputClasses = cx((_cx4 = {}, _defineProperty$2(_cx4, "".concat(prefix, "--text-input"), true), _defineProperty$2(_cx4, "".concat(prefix, "--text-input--empty"), !inputValue), _defineProperty$2(_cx4, "".concat(prefix, "--text-input--light"), light), _cx4));
    var helper = helperText ? /*#__PURE__*/React__default["default"].createElement("div", {
      id: helperId,
      className: helperClasses
    }, helperText) : null;
    var menuId = "".concat(id, "__menu");
    var inputId = "".concat(id, "-input");

    function handleOnChange(changes) {
      if (onChange) {
        onChange(changes);
      }
    }

    function handleOnMenuChange(forceIsOpen) {
      var nextIsOpen = forceIsOpen !== null && forceIsOpen !== void 0 ? forceIsOpen : !isOpen;
      setIsOpen(nextIsOpen);

      if (onMenuChange) {
        onMenuChange(nextIsOpen);
      }
    }

    function handleOnOuterClick() {
      handleOnMenuChange(false);
    }

    function handleOnStateChange(changes, downshift) {
      if (changes.isOpen && !isOpen) {
        setTopItems(downshift.selectedItem);
      }

      var type = changes.type;
      var stateChangeTypes = Downshift$1.stateChangeTypes;

      switch (type) {
        case stateChangeTypes.keyDownArrowDown:
        case stateChangeTypes.keyDownArrowUp:
        case stateChangeTypes.keyDownHome:
        case stateChangeTypes.keyDownEnd:
          setHighlightedIndex(changes.highlightedIndex !== undefined ? changes.highlightedIndex : null);

          if (stateChangeTypes.keyDownArrowDown === type && !isOpen) {
            handleOnMenuChange(true);
          }

          break;

        case stateChangeTypes.keyDownEscape:
          handleOnMenuChange(false);
          break;
      }
    }

    function handleOnInputValueChange(inputValue, _ref2) {
      var type = _ref2.type;

      if (onInputValueChange) {
        onInputValueChange(inputValue);
      }

      if (type !== Downshift$1.stateChangeTypes.changeInput) {
        return;
      }

      if (Array.isArray(inputValue)) {
        clearInputValue();
      } else {
        setInputValue(inputValue);
      }

      if (inputValue && !isOpen) {
        handleOnMenuChange(true);
      } else if (!inputValue && isOpen) {
        handleOnMenuChange(false);
      }
    }

    function clearInputValue() {
      setInputValue('');

      if (textInput.current) {
        textInput.current.focus();
      }
    }

    return /*#__PURE__*/React__default["default"].createElement(Selection, {
      disabled: disabled,
      onChange: handleOnChange,
      initialSelectedItems: initialSelectedItems,
      render: function render(_ref3) {
        var selectedItems = _ref3.selectedItems,
            onItemChange = _ref3.onItemChange,
            _clearSelection = _ref3.clearSelection;
        return /*#__PURE__*/React__default["default"].createElement(Downshift$1, _extends$3({}, mapDownshiftProps(downshiftProps), {
          highlightedIndex: highlightedIndex,
          id: id,
          isOpen: isOpen,
          inputValue: inputValue,
          onInputValueChange: handleOnInputValueChange,
          onChange: function onChange(selectedItem) {
            if (selectedItem !== null) {
              onItemChange(selectedItem);
            }
          },
          itemToString: itemToString,
          onStateChange: handleOnStateChange,
          onOuterClick: handleOnOuterClick,
          selectedItem: selectedItems,
          labelId: labelId,
          menuId: menuId,
          inputId: inputId
        }), function (_ref4) {
          var _cx5;

          var getInputProps = _ref4.getInputProps,
              getItemProps = _ref4.getItemProps,
              getLabelProps = _ref4.getLabelProps,
              getMenuProps = _ref4.getMenuProps,
              getRootProps = _ref4.getRootProps,
              getToggleButtonProps = _ref4.getToggleButtonProps,
              isOpen = _ref4.isOpen,
              inputValue = _ref4.inputValue,
              selectedItem = _ref4.selectedItem;
          var className = cx("".concat(prefix, "--multi-select"), "".concat(prefix, "--combo-box"), "".concat(prefix, "--multi-select--filterable"), [enabled ? null : containerClassName], (_cx5 = {}, _defineProperty$2(_cx5, "".concat(prefix, "--multi-select--invalid"), invalid), _defineProperty$2(_cx5, "".concat(prefix, "--multi-select--invalid--focused"), invalid && inputFocused), _defineProperty$2(_cx5, "".concat(prefix, "--multi-select--open"), isOpen), _defineProperty$2(_cx5, "".concat(prefix, "--multi-select--inline"), inline), _defineProperty$2(_cx5, "".concat(prefix, "--multi-select--selected"), selectedItem.length > 0), _defineProperty$2(_cx5, "".concat(prefix, "--multi-select--filterable--input-focused"), inputFocused), _cx5));
          var rootProps = getRootProps({}, {
            suppressRefError: true
          });
          var labelProps = getLabelProps();
          var buttonProps = getToggleButtonProps({
            disabled: disabled,
            onClick: function onClick() {
              handleOnMenuChange(!isOpen);

              if (textInput.current) {
                textInput.current.focus();
              }
            },
            // When we moved the "root node" of Downshift to the <input> for
            // ARIA 1.2 compliance, we unfortunately hit this branch for the
            // "mouseup" event that downshift listens to:
            // https://github.com/downshift-js/downshift/blob/v5.2.1/src/downshift.js#L1051-L1065
            //
            // As a result, it will reset the state of the component and so we
            // stop the event from propagating to prevent this. This allows the
            // toggleMenu behavior for the toggleButton to correctly open and
            // close the menu.
            onMouseUp: function onMouseUp(event) {
              event.stopPropagation();
            }
          });
          var inputProps = getInputProps({
            'aria-controls': isOpen ? menuId : null,
            'aria-describedby': helperText ? helperId : null,
            // Remove excess aria `aria-labelledby`. HTML <label for>
            // provides this aria information.
            'aria-labelledby': null,
            disabled: disabled,
            placeholder: placeholder,
            onClick: function onClick() {
              handleOnMenuChange(true);
            },
            onKeyDown: function onKeyDown(event) {
              if (match(event, Space)) {
                event.stopPropagation();
              }

              if (!disabled) {
                if (match(event, Delete) || match(event, Escape)) {
                  if (isOpen) {
                    handleOnMenuChange(true);
                    clearInputValue();
                    event.stopPropagation();
                  } else if (!isOpen) {
                    clearInputValue();

                    _clearSelection();

                    event.stopPropagation();
                  }
                }
              }
            },
            onFocus: function onFocus() {
              setInputFocused(true);
            },
            onBlur: function onBlur() {
              setInputFocused(false);
              setInputValue('');
            }
          });
          var menuProps = getMenuProps({
            'aria-label': ariaLabel
          }, {
            suppressRefError: true
          });
          return /*#__PURE__*/React__default["default"].createElement("div", {
            className: wrapperClasses
          }, titleText ? /*#__PURE__*/React__default["default"].createElement("label", _extends$3({
            className: titleClasses
          }, labelProps), titleText) : null, /*#__PURE__*/React__default["default"].createElement(ListBox$1, {
            className: className,
            disabled: disabled,
            light: light,
            ref: ref,
            invalid: invalid,
            invalidText: invalidText,
            warn: warn,
            warnText: warnText,
            isOpen: isOpen,
            size: size
          }, /*#__PURE__*/React__default["default"].createElement("div", {
            className: "".concat(prefix, "--list-box__field")
          }, selectedItem.length > 0 && /*#__PURE__*/React__default["default"].createElement(ListBoxSelection, {
            clearSelection: function clearSelection() {
              _clearSelection();

              if (textInput.current) {
                textInput.current.focus();
              }
            },
            selectionCount: selectedItem.length,
            translateWithId: translateWithId,
            disabled: disabled
          }), /*#__PURE__*/React__default["default"].createElement("input", _extends$3({
            className: inputClasses
          }, rootProps, inputProps, {
            ref: mergeRefs$1(textInput, rootProps.ref)
          })), invalid && /*#__PURE__*/React__default["default"].createElement(WarningFilled16, {
            className: "".concat(prefix, "--list-box__invalid-icon")
          }), showWarning && /*#__PURE__*/React__default["default"].createElement(WarningAltFilled16, {
            className: "".concat(prefix, "--list-box__invalid-icon ").concat(prefix, "--list-box__invalid-icon--warning")
          }), inputValue && /*#__PURE__*/React__default["default"].createElement(ListBoxSelection, {
            clearSelection: clearInputValue,
            disabled: disabled,
            translateWithId: translateWithId,
            onMouseUp: function onMouseUp(event) {
              // If we do not stop this event from propagating,
              // it seems like Downshift takes our event and
              // prevents us from getting `onClick` /
              // `clearSelection` from the underlying <button> in
              // ListBoxSelection
              event.stopPropagation();
            }
          }), /*#__PURE__*/React__default["default"].createElement(ListBoxTrigger$1, _extends$3({}, buttonProps, {
            isOpen: isOpen,
            translateWithId: translateWithId
          }))), isOpen ? /*#__PURE__*/React__default["default"].createElement(ListBox$1.Menu, menuProps, sortItems(filterItems(items, {
            itemToString: itemToString,
            inputValue: inputValue
          }), {
            selectedItems: {
              top: selectedItems,
              fixed: [],
              'top-after-reopen': topItems
            }[selectionFeedback],
            itemToString: itemToString,
            compareItems: compareItems,
            locale: locale
          }).map(function (item, index) {
            var itemProps = getItemProps({
              item: item,
              disabled: item.disabled
            });
            var itemText = itemToString(item);
            var isChecked = selectedItem.filter(function (selected) {
              return isEqual(selected, item);
            }).length > 0;
            return /*#__PURE__*/React__default["default"].createElement(ListBox$1.MenuItem, _extends$3({
              key: itemProps.id,
              "aria-label": itemText,
              isActive: isChecked,
              isHighlighted: highlightedIndex === index,
              title: itemText
            }, itemProps), /*#__PURE__*/React__default["default"].createElement("div", {
              className: "".concat(prefix, "--checkbox-wrapper")
            }, /*#__PURE__*/React__default["default"].createElement("span", {
              title: useTitleInItem ? itemText : null,
              className: "".concat(prefix, "--checkbox-label"),
              "data-contained-checkbox-state": isChecked,
              id: "".concat(itemProps.id, "-item")
            }, ItemToElement ? /*#__PURE__*/React__default["default"].createElement(ItemToElement, _extends$3({
              key: itemProps.id
            }, item)) : itemText)));
          })) : null), !inline && !invalid && !warn ? helper : null);
        });
      }
    });
  });
  FilterableMultiSelect$1.propTypes = _objectSpread2$2(_objectSpread2$2({
    /**
     * 'aria-label' of the ListBox component.
     */
    ariaLabel: PropTypes__default["default"].string,

    /**
     * Specify the direction of the multiselect dropdown. Can be either top or bottom.
     */
    direction: PropTypes__default["default"].oneOf(['top', 'bottom']),

    /**
     * Disable the control
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Additional props passed to Downshift
     */
    downshiftProps: PropTypes__default["default"].shape(Downshift$1.propTypes),

    /**
     * Specify whether the title text should be hidden or not
     */
    hideLabel: PropTypes__default["default"].bool,

    /**
     * Specify a custom `id`
     */
    id: PropTypes__default["default"].string.isRequired,

    /**
     * Allow users to pass in arbitrary items from their collection that are
     * pre-selected
     */
    initialSelectedItems: PropTypes__default["default"].array,

    /**
     * Is the current selection invalid?
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * If invalid, what is the error?
     */
    invalidText: PropTypes__default["default"].node,

    /**
     * Function to render items as custom components instead of strings.
     * Defaults to null and is overridden by a getter
     */
    itemToElement: PropTypes__default["default"].func,

    /**
     * Helper function passed to downshift that allows the library to render a
     * given item to a string label. By default, it extracts the `label` field
     * from a given item to serve as the item label in the list.
     */
    itemToString: PropTypes__default["default"].func,

    /**
     * We try to stay as generic as possible here to allow individuals to pass
     * in a collection of whatever kind of data structure they prefer
     */
    items: PropTypes__default["default"].array.isRequired,

    /**
     * `true` to use the light version.
     */
    light: PropTypes__default["default"].bool,

    /**
     * Specify the locale of the control. Used for the default `compareItems`
     * used for sorting the list of items in the control.
     */
    locale: PropTypes__default["default"].string,

    /**
     * `onChange` is a utility for this controlled component to communicate to a
     * consuming component what kind of internal state changes are occurring.
     */
    onChange: PropTypes__default["default"].func,

    /**
     * `onInputValueChange` is a utility for this controlled component to communicate to
     * the currently typed input.
     */
    onInputValueChange: PropTypes__default["default"].func,

    /**
     * `onMenuChange` is a utility for this controlled component to communicate to a
     * consuming component that the menu was opened(`true`)/closed(`false`).
     */
    onMenuChange: PropTypes__default["default"].func,

    /**
     * Initialize the component with an open(`true`)/closed(`false`) menu.
     */
    open: PropTypes__default["default"].bool,

    /**
     * Generic `placeholder` that will be used as the textual representation of
     * what this field is for
     */
    placeholder: PropTypes__default["default"].string,

    /**
     * Specify feedback (mode) of the selection.
     * `top`: selected item jumps to top
     * `fixed`: selected item stays at it's position
     * `top-after-reopen`: selected item jump to top after reopen dropdown
     */
    selectionFeedback: PropTypes__default["default"].oneOf(['top', 'fixed', 'top-after-reopen']),

    /**
     * Specify the size of the ListBox. Currently supports either `sm`, `md` or `lg` as an option.
     */
    size: ListBoxSize
  }, sortingPropTypes), {}, {
    /**
     * Callback function for translating ListBoxMenuIcon SVG title
     */
    translateWithId: PropTypes__default["default"].func,

    /**
     * Specify title to show title on hover
     */
    useTitleInItem: PropTypes__default["default"].bool,

    /**
     * Specify whether the control is currently in warning state
     */
    warn: PropTypes__default["default"].bool,

    /**
     * Provide the text that is displayed when the control is in warning state
     */
    warnText: PropTypes__default["default"].node
  });
  FilterableMultiSelect$1.defaultProps = {
    ariaLabel: 'Choose an item',
    compareItems: defaultCompareItems,
    direction: 'bottom',
    disabled: false,
    filterItems: defaultFilterItems,
    initialSelectedItems: [],
    itemToString: defaultItemToString,
    locale: 'en',
    sortItems: defaultSortItems,
    light: false,
    open: false,
    selectionFeedback: 'top-after-reopen'
  };
  var FilterableMultiSelectNext = FilterableMultiSelect$1;

  FilterableMultiSelectNext.displayName = 'MultiSelect.Filterable';
  MultiSelect$1.Filterable = FilterableMultiSelect$2;
  var FilterableMultiSelect = enabled('enable-v11-release') ? FilterableMultiSelectNext : FilterableMultiSelect$2;

  {
    deprecateFieldOnObject(MultiSelect$1, 'Filterable', FilterableMultiSelect);
  }

  var _excluded$1K = ["className", "children"];

  var Form = function Form(_ref) {
    var className = _ref.className,
        children = _ref.children,
        other = _objectWithoutProperties$2(_ref, _excluded$1K);

    var prefix = usePrefix();
    var classNames = cx("".concat(prefix, "--form"), className);
    return /*#__PURE__*/React__default["default"].createElement("form", _extends$3({
      className: classNames
    }, other), ' ', children, ' ');
  };

  Form.propTypes = {
    /**
     * Provide children to be rendered inside of the <form> element
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide a custom className to be applied on the containing <form> node
     */
    className: PropTypes__default["default"].string
  };
  var Form$1 = Form;

  var FormContext = /*#__PURE__*/React.createContext({
    isFluid: false
  });

  var _excluded$1J = ["className", "children"];

  function FluidForm(_ref) {
    var className = _ref.className,
        children = _ref.children,
        other = _objectWithoutProperties$2(_ref, _excluded$1J);

    var prefix = usePrefix();
    var classNames = cx("".concat(prefix, "--form--fluid"), className);
    return /*#__PURE__*/React__default["default"].createElement(FormContext.Provider, {
      value: {
        isFluid: true
      }
    }, /*#__PURE__*/React__default["default"].createElement(Form$1, _extends$3({
      className: classNames
    }, other), children));
  }

  FluidForm.propTypes = {
    /**
     * Provide children to be rendered inside of the <form> element
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide a custom className to be applied on the containing <form> node
     */
    className: PropTypes__default["default"].string
  };

  var _excluded$1I = ["legendId", "legendText", "invalid", "children", "className", "message", "messageText", "hasMargin"];

  var FormGroup = function FormGroup(_ref) {
    var legendId = _ref.legendId,
        legendText = _ref.legendText,
        invalid = _ref.invalid,
        children = _ref.children,
        className = _ref.className,
        message = _ref.message,
        messageText = _ref.messageText,
        hasMargin = _ref.hasMargin,
        other = _objectWithoutProperties$2(_ref, _excluded$1I);

    var prefix = usePrefix();
    var enabled = useFeatureFlag('enable-v11-release');
    var classNamesLegend = cx("".concat(prefix, "--label"), [enabled ? null : className]); // TODO - remove `fieldset--no-margin` in v11

    var classNamesFieldset = cx("".concat(prefix, "--fieldset"), className, _defineProperty$2({}, "".concat(prefix, "--fieldset--no-margin"), !hasMargin));
    return /*#__PURE__*/React__default["default"].createElement("fieldset", _extends$3({}, invalid && {
      'data-invalid': ''
    }, {
      className: classNamesFieldset
    }, other, {
      "aria-labelledby": other['aria-labelledby'] || legendId
    }), /*#__PURE__*/React__default["default"].createElement("legend", {
      className: classNamesLegend,
      id: legendId || other['aria-labelledby']
    }, legendText), children, message ? /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--form__requirements")
    }, messageText) : null);
  };

  FormGroup.propTypes = {
    /**
     * Provide the children form elements to be rendered inside of the <fieldset>
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide a custom className to be applied to the containing <fieldset> node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether or not the FormGroup should provide bottom margin
     */
    hasMargin: PropTypes__default["default"].bool,

    /**
     * Specify whether the <FormGroup> is invalid
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * Provide id for the fieldset <legend> which corresponds to the fieldset
     * `aria-labelledby`
     */
    legendId: PropTypes__default["default"].node,

    /**
     * Provide the text to be rendered inside of the fieldset <legend>
     */
    legendText: PropTypes__default["default"].node.isRequired,

    /**
     * Specify whether the message should be displayed in the <FormGroup>
     */
    message: PropTypes__default["default"].bool,

    /**
     * Provide the text for the message in the <FormGroup>
     */
    messageText: PropTypes__default["default"].string
  };
  FormGroup.defaultProps = {
    invalid: false,
    message: false,
    messageText: '',
    hasMargin: true
  };
  var FormGroup$1 = FormGroup;

  var _excluded$1H = ["className", "children"];

  var FormItem = function FormItem(_ref) {
    var className = _ref.className,
        children = _ref.children,
        other = _objectWithoutProperties$2(_ref, _excluded$1H);

    var prefix = usePrefix();
    var classNames = cx("".concat(prefix, "--form-item"), className);
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: classNames
    }, other), children);
  };

  FormItem.propTypes = {
    /**
     * Provide content to be rendered in the form item
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide a custom className to be applied to the containing node
     */
    className: PropTypes__default["default"].string
  };
  var FormItem$1 = FormItem;

  var _excluded$1G = ["className", "children", "id"];

  function FormLabel(_ref) {
    var customClassName = _ref.className,
        children = _ref.children,
        id = _ref.id,
        rest = _objectWithoutProperties$2(_ref, _excluded$1G);

    var prefix = usePrefix();
    var className = cx("".concat(prefix, "--label"), _defineProperty$2({}, "".concat(prefix, "--label--no-margin"), enabled('enable-v11-release')), customClassName);
    return /*#__PURE__*/React__default["default"].createElement("label", _extends$3({
      htmlFor: id,
      className: className
    }, rest), children);
  }

  FormLabel.propTypes = {
    /**
     * Specify the content of the form label
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide a custom className to be applied to the containing <label> node
     */
    className: PropTypes__default["default"].string,

    /**
     * Provide a unique id for the given <FormLabel>
     */
    id: PropTypes__default["default"].string
  };

  /**
   * Provides a grid context for communication the grid "mode" (flexbox or
   * css-grid) along with subgrid information.
   */

  var GridSettingsContext = /*#__PURE__*/React__namespace.createContext({
    mode: 'flexbox',
    subgrid: false
  });
  function GridSettings(_ref) {
    var children = _ref.children,
        mode = _ref.mode,
        _ref$subgrid = _ref.subgrid,
        subgrid = _ref$subgrid === void 0 ? false : _ref$subgrid;
    var value = React__namespace.useMemo(function () {
      return {
        mode: mode,
        subgrid: subgrid
      };
    }, [mode, subgrid]);
    return /*#__PURE__*/React__namespace.createElement(GridSettingsContext.Provider, {
      value: value
    }, children);
  }
  GridSettings.propTypes = {
    /**
     * Pass in components which will be rendered within the `GridSettings`
     * component
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify the grid mode for the GridContext
     */
    mode: PropTypes__default["default"].oneOf(['flexbox', 'css-grid']).isRequired,

    /**
     * Specify whether subgrid should be enabled
     */
    subgrid: PropTypes__default["default"].bool
  };
  /**
   * Helper function for accessing the GridContext value
   */

  function useGridSettings() {
    return React__namespace.useContext(GridSettingsContext);
  }

  var _excluded$1F = ["as", "condensed", "narrow", "fullWidth", "className", "children"];

  function FlexGrid(_ref) {
    var _cx;

    var _ref$as = _ref.as,
        BaseComponent = _ref$as === void 0 ? 'div' : _ref$as,
        _ref$condensed = _ref.condensed,
        condensed = _ref$condensed === void 0 ? false : _ref$condensed,
        _ref$narrow = _ref.narrow,
        narrow = _ref$narrow === void 0 ? false : _ref$narrow,
        _ref$fullWidth = _ref.fullWidth,
        fullWidth = _ref$fullWidth === void 0 ? false : _ref$fullWidth,
        containerClassName = _ref.className,
        children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, _excluded$1F);

    var prefix = usePrefix();
    var className = cx(containerClassName, (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--grid"), true), _defineProperty$2(_cx, "".concat(prefix, "--grid--condensed"), condensed), _defineProperty$2(_cx, "".concat(prefix, "--grid--narrow"), narrow), _defineProperty$2(_cx, "".concat(prefix, "--grid--full-width"), fullWidth), _cx));
    return /*#__PURE__*/React__default["default"].createElement(GridSettings, {
      mode: "flexbox",
      subgrid: false
    }, /*#__PURE__*/React__default["default"].createElement(BaseComponent, _extends$3({
      className: className
    }, rest), children));
  }

  FlexGrid.propTypes = {
    /**
     * Provide a custom element to render instead of the default <div>
     */
    as: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].elementType]),

    /**
     * Pass in content that will be rendered within the `FlexGrid`
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify a custom className to be applied to the `FlexGrid`
     */
    className: PropTypes__default["default"].string,

    /**
     * Collapse the gutter to 1px. Useful for fluid layouts.
     * Rows have 1px of margin between them to match gutter.
     */
    condensed: PropTypes__default["default"].bool,

    /**
     * Remove the default max width that the grid has set
     */
    fullWidth: PropTypes__default["default"].bool,

    /**
     * Container hangs 16px into the gutter. Useful for
     * typographic alignment with and without containers.
     */
    narrow: PropTypes__default["default"].bool
  };

  var _excluded$1E = ["as", "children", "className", "condensed", "fullWidth", "narrow"],
      _excluded2$a = ["as", "className", "children", "mode"];

  function CSSGrid(_ref) {
    var _cx;

    var _ref$as = _ref.as,
        BaseComponent = _ref$as === void 0 ? 'div' : _ref$as,
        children = _ref.children,
        customClassName = _ref.className,
        _ref$condensed = _ref.condensed,
        condensed = _ref$condensed === void 0 ? false : _ref$condensed,
        _ref$fullWidth = _ref.fullWidth,
        fullWidth = _ref$fullWidth === void 0 ? false : _ref$fullWidth,
        _ref$narrow = _ref.narrow,
        narrow = _ref$narrow === void 0 ? false : _ref$narrow,
        rest = _objectWithoutProperties$2(_ref, _excluded$1E);

    var prefix = usePrefix();

    var _useGridSettings = useGridSettings(),
        subgrid = _useGridSettings.subgrid;

    var mode = 'wide';

    if (narrow) {
      mode = 'narrow';
    } else if (condensed) {
      mode = 'condensed';
    }

    if (subgrid) {
      return /*#__PURE__*/React__default["default"].createElement(GridSettings, {
        mode: "css-grid",
        subgrid: true
      }, /*#__PURE__*/React__default["default"].createElement(Subgrid, _extends$3({
        as: BaseComponent,
        className: customClassName,
        mode: mode
      }, rest), children));
    }

    var className = cx(customClassName, (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--css-grid"), true), _defineProperty$2(_cx, "".concat(prefix, "--css-grid--condensed"), mode === 'condensed'), _defineProperty$2(_cx, "".concat(prefix, "--css-grid--narrow"), mode === 'narrow'), _defineProperty$2(_cx, "".concat(prefix, "--css-grid--full-width"), fullWidth), _cx));
    return /*#__PURE__*/React__default["default"].createElement(GridSettings, {
      mode: "css-grid",
      subgrid: true
    }, /*#__PURE__*/React__default["default"].createElement(BaseComponent, _extends$3({
      className: className
    }, rest), children));
  }

  CSSGrid.propTypes = {
    /**
     * Provide a custom element to render instead of the default <div>
     */
    as: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].elementType]),

    /**
     * Pass in content that will be rendered within the `Grid`
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify a custom className to be applied to the `Grid`
     */
    className: PropTypes__default["default"].string,

    /**
     * Collapse the gutter to 1px. Useful for fluid layouts.
     * Rows have 1px of margin between them to match gutter.
     */
    condensed: PropTypes__default["default"].bool,

    /**
     * Remove the default max width that the grid has set
     */
    fullWidth: PropTypes__default["default"].bool,

    /**
     * Container hangs 16px into the gutter. Useful for
     * typographic alignment with and without containers.
     */
    narrow: PropTypes__default["default"].bool
  };

  function Subgrid(_ref2) {
    var _cx2;

    var _ref2$as = _ref2.as,
        BaseComponent = _ref2$as === void 0 ? 'div' : _ref2$as,
        customClassName = _ref2.className,
        children = _ref2.children,
        mode = _ref2.mode,
        rest = _objectWithoutProperties$2(_ref2, _excluded2$a);

    var prefix = usePrefix();
    var className = cx(customClassName, (_cx2 = {}, _defineProperty$2(_cx2, "".concat(prefix, "--subgrid"), true), _defineProperty$2(_cx2, "".concat(prefix, "--subgrid--condensed"), mode === 'condensed'), _defineProperty$2(_cx2, "".concat(prefix, "--subgrid--narrow"), mode === 'narrow'), _defineProperty$2(_cx2, "".concat(prefix, "--subgrid--wide"), mode === 'wide'), _cx2));
    return /*#__PURE__*/React__default["default"].createElement(BaseComponent, _extends$3({}, rest, {
      className: className
    }), children);
  }

  Subgrid.propTypes = {
    /**
     * Provide a custom element to render instead of the default <div>
     */
    as: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].elementType]),

    /**
     * Pass in content that will be rendered within the `Subgrid`
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify a custom className to be applied to the `Subgrid`
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the grid mode for the subgrid
     */
    mode: PropTypes__default["default"].oneOf(['wide', 'narrow', 'condensed'])
  };

  function Grid(props) {
    var enableCSSGrid = useFeatureFlag('enable-css-grid');

    if (enableCSSGrid) {
      return /*#__PURE__*/React__default["default"].createElement(CSSGrid, props);
    }

    return /*#__PURE__*/React__default["default"].createElement(FlexGrid, props);
  }

  Grid.propTypes = {
    /**
     * Provide a custom element to render instead of the default <div>
     */
    as: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].elementType]),

    /**
     * Pass in content that will be rendered within the `Grid`
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify a custom className to be applied to the `Grid`
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify how many columns wide the Grid should span
     */
    columns: PropTypes__default["default"].number,

    /**
     * Collapse the gutter to 1px. Useful for fluid layouts.
     * Rows have 1px of margin between them to match gutter.
     */
    condensed: PropTypes__default["default"].bool,

    /**
     * Remove the default max width that the grid has set
     */
    fullWidth: PropTypes__default["default"].bool,

    /**
     * Container hangs 16px into the gutter. Useful for
     * typographic alignment with and without containers.
     */
    narrow: PropTypes__default["default"].bool
  };

  var _excluded$1D = ["as", "condensed", "narrow", "className", "children"];

  function Row(_ref) {
    var _cx;

    var _ref$as = _ref.as,
        BaseComponent = _ref$as === void 0 ? 'div' : _ref$as,
        _ref$condensed = _ref.condensed,
        condensed = _ref$condensed === void 0 ? false : _ref$condensed,
        _ref$narrow = _ref.narrow,
        narrow = _ref$narrow === void 0 ? false : _ref$narrow,
        containerClassName = _ref.className,
        children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, _excluded$1D);

    var prefix = usePrefix();
    var className = cx(containerClassName, (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--row"), true), _defineProperty$2(_cx, "".concat(prefix, "--row--condensed"), condensed), _defineProperty$2(_cx, "".concat(prefix, "--row--narrow"), narrow), _cx));
    return /*#__PURE__*/React__default["default"].createElement(BaseComponent, _extends$3({
      className: className
    }, rest), children);
  }

  Row.propTypes = {
    /**
     * Provide a custom element to render instead of the default <div>
     */
    as: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].elementType]),

    /**
     * Pass in content that will be rendered within the `Row`
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify a custom className to be applied to the `Row`
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify a single row as condensed.Rows that are adjacent
     * and are condensed will have 2px of margin between them to match gutter.
     */
    condensed: PropTypes__default["default"].bool,

    /**
     * Specify a single row as narrow. The container will hang
     * 16px into the gutter.
     */
    narrow: PropTypes__default["default"].bool
  };

  var _excluded$1C = ["as", "children", "className", "sm", "md", "lg", "xlg", "max"],
      _excluded2$9 = ["as", "children", "className", "sm", "md", "lg", "xlg", "max", "span"];

  function Column(_ref) {
    var _ref$as = _ref.as,
        BaseComponent = _ref$as === void 0 ? 'div' : _ref$as,
        children = _ref.children,
        customClassName = _ref.className,
        sm = _ref.sm,
        md = _ref.md,
        lg = _ref.lg,
        xlg = _ref.xlg,
        max = _ref.max,
        rest = _objectWithoutProperties$2(_ref, _excluded$1C);

    var _useGridSettings = useGridSettings(),
        mode = _useGridSettings.mode;

    var prefix = usePrefix();

    if (mode === 'css-grid') {
      return /*#__PURE__*/React__default["default"].createElement(CSSGridColumn, _extends$3({
        as: BaseComponent,
        className: customClassName,
        sm: sm,
        md: md,
        lg: lg,
        xlg: xlg,
        max: max
      }, rest), children);
    }

    var columnClassName = getClassNameForFlexGridBreakpoints([sm, md, lg, xlg, max], prefix);
    var className = cx(customClassName, columnClassName, _defineProperty$2({}, "".concat(prefix, "--col"), columnClassName.length === 0));
    return /*#__PURE__*/React__default["default"].createElement(BaseComponent, _extends$3({
      className: className
    }, rest), children);
  }

  var percentSpanType = PropTypes__default["default"].oneOf(['25%', '50%', '75%', '100%']);
  var spanPropType = enabled('enable-css-grid') ? PropTypes__default["default"].oneOfType([PropTypes__default["default"].bool, PropTypes__default["default"].number, PropTypes__default["default"].shape({
    span: PropTypes__default["default"].oneOfType([PropTypes__default["default"].number, percentSpanType]),
    offset: PropTypes__default["default"].number,
    start: PropTypes__default["default"].number,
    end: PropTypes__default["default"].number
  }), percentSpanType]) : PropTypes__default["default"].oneOfType([PropTypes__default["default"].bool, PropTypes__default["default"].number, PropTypes__default["default"].shape({
    span: PropTypes__default["default"].number,
    offset: PropTypes__default["default"].number
  })]);
  Column.propTypes = {
    /**
     * Provide a custom element to render instead of the default <div>
     */
    as: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].elementType]),

    /**
     * Pass in content that will be rendered within the `Column`
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify a custom className to be applied to the `Column`
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify column span for the `lg` breakpoint (Default breakpoint up to 1312px)
     * This breakpoint supports 16 columns by default.
     *
     * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
     */
    lg: spanPropType,

    /**
     * Specify column span for the `max` breakpoint. This breakpoint supports 16
     * columns by default.
     *
     * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
     */
    max: spanPropType,

    /**
     * Specify column span for the `md` breakpoint (Default breakpoint up to 1056px)
     * This breakpoint supports 8 columns by default.
     *
     * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
     */
    md: spanPropType,

    /**
     * Specify column span for the `sm` breakpoint (Default breakpoint up to 672px)
     * This breakpoint supports 4 columns by default.
     *
     * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
     */
    sm: spanPropType,

    /**
     * Specify column span for the `xlg` breakpoint (Default breakpoint up to
     * 1584px) This breakpoint supports 16 columns by default.
     *
     * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
     */
    xlg: spanPropType
  };

  function CSSGridColumn(_ref2) {
    var _ref2$as = _ref2.as,
        BaseComponent = _ref2$as === void 0 ? 'div' : _ref2$as,
        children = _ref2.children,
        containerClassName = _ref2.className,
        sm = _ref2.sm,
        md = _ref2.md,
        lg = _ref2.lg,
        xlg = _ref2.xlg,
        max = _ref2.max,
        span = _ref2.span,
        rest = _objectWithoutProperties$2(_ref2, _excluded2$9);

    var prefix = usePrefix();
    var breakpointClassName = getClassNameForBreakpoints([sm, md, lg, xlg, max], prefix);
    var spanClassName = getClassNameForSpan(span, prefix);
    var className = cx(containerClassName, breakpointClassName, spanClassName, _defineProperty$2({}, "".concat(prefix, "--css-grid-column"), true));
    return /*#__PURE__*/React__default["default"].createElement(BaseComponent, _extends$3({
      className: className
    }, rest), children);
  }

  CSSGridColumn.propTypes = {
    /**
     * Provide a custom element to render instead of the default <div>
     */
    as: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].elementType]),

    /**
     * Pass in content that will be rendered within the `Column`
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify a custom className to be applied to the `Column`
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify column span for the `lg` breakpoint (Default breakpoint up to 1312px)
     * This breakpoint supports 16 columns by default.
     *
     * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
     */
    lg: spanPropType,

    /**
     * Specify column span for the `max` breakpoint. This breakpoint supports 16
     * columns by default.
     *
     * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
     */
    max: spanPropType,

    /**
     * Specify column span for the `md` breakpoint (Default breakpoint up to 1056px)
     * This breakpoint supports 8 columns by default.
     *
     * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
     */
    md: spanPropType,

    /**
     * Specify column span for the `sm` breakpoint (Default breakpoint up to 672px)
     * This breakpoint supports 4 columns by default.
     *
     * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
     */
    sm: spanPropType,

    /**
     * Specify constant column span, start,  or end values that will not change
     * based on breakpoint
     */
    span: PropTypes__default["default"].oneOfType([PropTypes__default["default"].number, percentSpanType, PropTypes__default["default"].shape({
      span: PropTypes__default["default"].oneOfType([PropTypes__default["default"].number, percentSpanType]),
      start: PropTypes__default["default"].number,
      end: PropTypes__default["default"].number
    })]),

    /**
     * Specify column span for the `xlg` breakpoint (Default breakpoint up to
     * 1584px) This breakpoint supports 16 columns by default.
     *
     * @see https://www.carbondesignsystem.com/guidelines/layout#breakpoints
     */
    xlg: spanPropType
  };
  var breakpointNames = ['sm', 'md', 'lg', 'xlg', 'max'];
  /**
   * @typedef {object} Breakpoint
   * @property {boolean|number} [span]
   * @property {number} [offset]
   */

  /**
   * Build the appropriate className for the given set of breakpoints.
   * @param {Array<boolean|number|Breakpoint>} breakpoints
   * @returns {string}
   */

  function getClassNameForBreakpoints(breakpoints, prefix) {
    var classNames = [];

    for (var i = 0; i < breakpoints.length; i++) {
      var breakpoint = breakpoints[i];

      if (breakpoint === undefined || breakpoint === null) {
        continue;
      }

      var name = breakpointNames[i]; // If our breakpoint is a boolean, the user has specified that the column
      // should be "auto" at this size

      if (breakpoint === true) {
        classNames.push("".concat(prefix, "--").concat(name, ":col-span-auto"));
        continue;
      } // If our breakpoint is a string, the user has specified a percent
      // they'd like this column to span.


      if (typeof breakpoint === 'string') {
        classNames.push("".concat(prefix, "--").concat(name, ":col-span-").concat(breakpoint.slice(0, -1)));
        continue;
      } // If our breakpoint is a number, the user has specified the number of
      // columns they'd like this column to span


      if (typeof breakpoint === 'number') {
        classNames.push("".concat(prefix, "--").concat(name, ":col-span-").concat(breakpoint));
        continue;
      }

      var span = breakpoint.span,
          offset = breakpoint.offset,
          start = breakpoint.start,
          end = breakpoint.end;

      if (typeof offset === 'number' && offset > 0) {
        classNames.push("".concat(prefix, "--").concat(name, ":col-start-").concat(offset + 1));
      }

      if (typeof start === 'number') {
        classNames.push("".concat(prefix, "--").concat(name, ":col-start-").concat(start));
      }

      if (typeof end === 'number') {
        classNames.push("".concat(prefix, "--").concat(name, ":col-end-").concat(end));
      }

      if (typeof span === 'number') {
        classNames.push("".concat(prefix, "--").concat(name, ":col-span-").concat(span));
      } else if (typeof span === 'string') {
        classNames.push("".concat(prefix, "--").concat(name, ":col-span-").concat(span.slice(0, -1)));
        continue;
      }
    }

    return classNames.join(' ');
  }
  /**
   * Build the appropriate className for the given set of breakpoints.
   * @param {Array<boolean|number|Breakpoint>} breakpoints
   * @returns {string}
   */


  function getClassNameForFlexGridBreakpoints(breakpoints, prefix) {
    var classNames = [];

    for (var i = 0; i < breakpoints.length; i++) {
      var breakpoint = breakpoints[i];

      if (breakpoint === undefined || breakpoint === null) {
        continue;
      }

      var name = breakpointNames[i]; // If our breakpoint is a boolean, the user has specified that the column
      // should be "auto" at this size

      if (breakpoint === true) {
        classNames.push("".concat(prefix, "--col-").concat(name));
        continue;
      } // If our breakpoint is a number, the user has specified the number of
      // columns they'd like this column to span


      if (typeof breakpoint === 'number') {
        classNames.push("".concat(prefix, "--col-").concat(name, "-").concat(breakpoint));
        continue;
      }

      var span = breakpoint.span,
          offset = breakpoint.offset;

      if (typeof span === 'number') {
        classNames.push("".concat(prefix, "--col-").concat(name, "-").concat(span));
      }

      if (span === true) {
        classNames.push("".concat(prefix, "--col-").concat(name));
      }

      if (typeof offset === 'number') {
        classNames.push("".concat(prefix, "--offset-").concat(name, "-").concat(offset));
      }
    }

    return classNames.join(' ');
  }
  /**
   * Build the appropriate className for a span value
   */


  function getClassNameForSpan(value, prefix) {
    var classNames = [];

    if (typeof value === 'number' || typeof value === 'string') {
      classNames.push("".concat(prefix, "--col-span-").concat(value));
    } else if (_typeof(value) === 'object') {
      var span = value.span,
          start = value.start,
          end = value.end;

      if (span !== undefined && span !== null) {
        classNames.push("".concat(prefix, "--col-span-").concat(span));
      }

      if (start !== undefined && start !== null) {
        classNames.push("".concat(prefix, "--col-start-").concat(start));
      }

      if (end !== undefined && end !== null) {
        classNames.push("".concat(prefix, "--col-end-").concat(end));
      }
    }

    return classNames.join('');
  }

  var _excluded$1B = ["as", "className", "children"];
  /**
   * Helper component for rendering content that hangs on the column. Useful when
   * trying to align content across different grid modes
   */

  function ColumnHang(_ref) {
    var _ref$as = _ref.as,
        BaseComponent = _ref$as === void 0 ? 'div' : _ref$as,
        customClassName = _ref.className,
        children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, _excluded$1B);

    var prefix = usePrefix();
    var className = cx(customClassName, "".concat(prefix, "--grid-column-hang"));
    return /*#__PURE__*/React__default["default"].createElement(BaseComponent, _extends$3({}, rest, {
      className: className
    }), children);
  }

  ColumnHang.propTypes = {
    /**
     * Provide a custom element to render instead of the default <div>
     */
    as: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].elementType]),

    /**
     * Pass in content that will be rendered within the `Grid`
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify a custom className to be applied to the `Grid`
     */
    className: PropTypes__default["default"].string
  };

  var _excluded$1A = ["className", "iconTitle", "description", "fill", "fillRule", "height", "name", "icon", "role", "style", "width", "iconRef"];
  /**
   * @param {object} svgData - JSON Object for an SVG icon
   * @returns {ReactElement} Elements/Nodes for SVG
   * @example
   * // Returns SVG elements
   * const svgData = getSvgData('copy-code');
   * svgShapes(svgData);
   */

  function svgShapes(svgData) {
    var svgElements = Object.keys(svgData).filter(function (key) {
      return svgData[key];
    }).map(function (svgProp) {
      var data = svgData[svgProp];

      if (svgProp === 'circles') {
        return data.map(function (circle, index) {
          var circleProps = {
            cx: circle.cx,
            cy: circle.cy,
            r: circle.r,
            key: "circle".concat(index)
          };
          return /*#__PURE__*/React__default["default"].createElement("circle", _extends$3({
            key: index
          }, circleProps));
        });
      } else if (svgProp === 'paths') {
        return data.map(function (path, index) {
          return /*#__PURE__*/React__default["default"].createElement("path", {
            d: path.d,
            key: "key".concat(index)
          });
        });
      } else if (svgProp === 'polygons') {
        return data.map(function (polygon, index) {
          return /*#__PURE__*/React__default["default"].createElement("polygon", {
            points: polygon.points,
            key: "key".concat(index)
          });
        });
      }

      return '';
    });
    return svgElements;
  }
  function isPrefixed(name) {
    {
      !(typeof name === 'string') ? invariant_1(false, '[Icon] icon name is missing. You likely forgot to specify the icon, ' + 'or are using older (pre-`7.x`) version of `carbon-icons` library. ' + 'To specify the icon, use either `icon` (data) or `name` (icon name) properties.')  : void 0;
    }

    return name && name.split('--')[0] === 'icon';
  }

  var Icon = function Icon(_ref) {
    var className = _ref.className,
        iconTitle = _ref.iconTitle,
        description = _ref.description,
        fill = _ref.fill,
        fillRule = _ref.fillRule,
        height = _ref.height,
        name = _ref.name,
        icon = _ref.icon,
        role = _ref.role,
        style = _ref.style,
        width = _ref.width,
        iconRef = _ref.iconRef,
        other = _objectWithoutProperties$2(_ref, _excluded$1A);

    var props = _objectSpread2$2({
      className: className,
      fill: fill,
      fillRule: fillRule,
      height: height || icon.height,
      name: isPrefixed ? name : "icon--".concat(name),
      role: role,
      style: style,
      viewBox: icon.viewBox,
      width: width || icon.width,
      ref: iconRef
    }, other);

    var svgContent = icon ? svgShapes(icon.svgData) : '';
    return /*#__PURE__*/React__default["default"].createElement("svg", _extends$3({}, props, {
      "aria-label": description
    }), /*#__PURE__*/React__default["default"].createElement("title", null, typeof iconTitle === 'undefined' ? description : iconTitle), svgContent);
  };

  Icon.propTypes = {
    /**
     * The CSS class name.
     */
    className: PropTypes__default["default"].string,

    /**
     * The icon description.
     */
    description: PropTypes__default["default"].string.isRequired,

    /**
     * The `<svg>` `fill` attribute.
     */
    fill: PropTypes__default["default"].string,

    /**
     * The `<svg>` `fillRule` attribute.
     */
    fillRule: PropTypes__default["default"].string,

    /**
     * The `<svg>` `height` attribute.
     */
    height: PropTypes__default["default"].string,

    /**
     * The icon data.
     */
    icon: PropTypes__default["default"].shape({
      width: PropTypes__default["default"].string,
      height: PropTypes__default["default"].string,
      viewBox: PropTypes__default["default"].string.isRequired,
      svgData: PropTypes__default["default"].object.isRequired
    }),

    /**
     * The `ref` callback for the icon.
     */
    iconRef: PropTypes__default["default"].func,

    /**
     * The icon title.
     */
    iconTitle: PropTypes__default["default"].string,

    /**
     * The name of the icon.
     */
    name: PropTypes__default["default"].string,

    /**
     * The `role` attribute.
     */
    role: PropTypes__default["default"].string,

    /**
     * The CSS styles.
     */
    style: PropTypes__default["default"].object,

    /**
     * The `<svg>` `viewbox` attribute.
     */
    viewBox: PropTypes__default["default"].string,

    /**
     * The `<svg>` `width` attribute.
     */
    width: PropTypes__default["default"].string
  };
  Icon.defaultProps = {
    fillRule: 'evenodd',
    role: 'img'
  };
  var Icon$1 = Icon;

  var _excluded$1z = ["style", "className"];

  var IconSkeleton = function IconSkeleton(_ref) {
    var style = _ref.style,
        className = _ref.className,
        rest = _objectWithoutProperties$2(_ref, _excluded$1z);

    var prefix = usePrefix();

    var props = _objectSpread2$2({
      style: style
    }, rest);

    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: cx("".concat(prefix, "--icon--skeleton"), className)
    }, props));
  };

  IconSkeleton.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes__default["default"].string,

    /**
     * The CSS styles.
     */
    style: PropTypes__default["default"].object
  };
  var IconSkeleton$1 = IconSkeleton;

  var _excluded$1y = ["className", "success", "status", "iconDescription", "description", "onSuccess", "successDelay"];
  function InlineLoading(_ref) {
    var className = _ref.className,
        success = _ref.success,
        _ref$status = _ref.status,
        status = _ref$status === void 0 ? success ? 'finished' : 'active' : _ref$status,
        iconDescription = _ref.iconDescription,
        description = _ref.description,
        onSuccess = _ref.onSuccess,
        successDelay = _ref.successDelay,
        other = _objectWithoutProperties$2(_ref, _excluded$1y);

    var prefix = usePrefix();
    var loadingClasses = cx("".concat(prefix, "--inline-loading"), className);

    var getLoading = function getLoading() {
      if (status === 'error') {
        return /*#__PURE__*/React__default["default"].createElement(ErrorFilled16, {
          className: "".concat(prefix, "--inline-loading--error")
        }, /*#__PURE__*/React__default["default"].createElement("title", null, iconDescription));
      }

      if (status === 'finished') {
        setTimeout(function () {
          if (onSuccess) {
            onSuccess();
          }
        }, successDelay);
        return /*#__PURE__*/React__default["default"].createElement(CheckmarkFilled16, {
          className: "".concat(prefix, "--inline-loading__checkmark-container")
        }, /*#__PURE__*/React__default["default"].createElement("title", null, iconDescription));
      }

      if (status === 'inactive' || status === 'active') {
        return /*#__PURE__*/React__default["default"].createElement(Loading, {
          small: true,
          description: iconDescription,
          withOverlay: false,
          active: status === 'active'
        });
      }

      return undefined;
    };

    var loadingText = /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--inline-loading__text")
    }, description);
    var loading = getLoading();
    var loadingAnimation = loading && /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--inline-loading__animation")
    }, loading);
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: loadingClasses
    }, other, {
      "aria-live": 'assertive' 
    }), loadingAnimation, description && loadingText);
  }
  InlineLoading.propTypes = {
    /**
     * Specify a custom className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the description for the inline loading text
     */
    description: PropTypes__default["default"].node,

    /**
     * Specify the description for the inline loading text
     */
    iconDescription: PropTypes__default["default"].string,

    /**
     * Provide an optional handler to be invoked when <InlineLoading> is
     * successful
     */
    onSuccess: PropTypes__default["default"].func,

    /**
     * Specify the loading status
     */
    status: PropTypes__default["default"].oneOf(['inactive', 'active', 'finished', 'error']),

    /**
     * Specify whether the load was successful
     */
    success: deprecate(PropTypes__default["default"].bool, "\nThe prop `success` for InlineLoading has been deprecated in favor of `status`. Please use `status=\"finished\"` instead."),

    /**
     * Provide a delay for the `setTimeout` for success
     */
    successDelay: PropTypes__default["default"].number
  };
  InlineLoading.defaultProps = {
    successDelay: 1500
  };

  var _excluded$1x = ["children", "className"];

  var ListItem = function ListItem(_ref) {
    var children = _ref.children,
        className = _ref.className,
        other = _objectWithoutProperties$2(_ref, _excluded$1x);

    var prefix = usePrefix();
    var classNames = cx("".concat(prefix, "--list__item"), className);
    return /*#__PURE__*/React__default["default"].createElement("li", _extends$3({
      className: classNames
    }, other), children);
  };

  ListItem.propTypes = {
    /**
     * Specify the content for the ListItem
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to apply to the underlying `<li>` node
     */
    className: PropTypes__default["default"].string
  };
  var ListItem$1 = ListItem;

  var _Modal$propTypes;

  var _excluded$1w = ["children", "className", "modalHeading", "modalLabel", "modalAriaLabel", "passiveModal", "hasForm", "secondaryButtonText", "primaryButtonText", "open", "onRequestClose", "onRequestSubmit", "onSecondarySubmit", "iconDescription", "primaryButtonDisabled", "danger", "alert", "secondaryButtons", "selectorPrimaryFocus", "selectorsFloatingMenus", "shouldSubmitOnEnter", "size", "hasScrollingContent", "closeButtonLabel", "preventCloseOnClickOutside"];
  var getInstanceId$a = setupGetInstanceId$2();
  var Modal$3 = /*#__PURE__*/React__default["default"].forwardRef(function Modal(_ref, ref) {
    var _classNames, _classNames3;

    var children = _ref.children,
        className = _ref.className,
        modalHeading = _ref.modalHeading,
        modalLabel = _ref.modalLabel,
        modalAriaLabel = _ref.modalAriaLabel,
        passiveModal = _ref.passiveModal,
        hasForm = _ref.hasForm,
        secondaryButtonText = _ref.secondaryButtonText,
        primaryButtonText = _ref.primaryButtonText,
        open = _ref.open,
        onRequestClose = _ref.onRequestClose,
        onRequestSubmit = _ref.onRequestSubmit,
        onSecondarySubmit = _ref.onSecondarySubmit,
        iconDescription = _ref.iconDescription,
        primaryButtonDisabled = _ref.primaryButtonDisabled,
        danger = _ref.danger,
        alert = _ref.alert,
        secondaryButtons = _ref.secondaryButtons,
        selectorPrimaryFocus = _ref.selectorPrimaryFocus,
        selectorsFloatingMenus = _ref.selectorsFloatingMenus,
        shouldSubmitOnEnter = _ref.shouldSubmitOnEnter,
        size = _ref.size,
        hasScrollingContent = _ref.hasScrollingContent,
        closeButtonLabel = _ref.closeButtonLabel,
        preventCloseOnClickOutside = _ref.preventCloseOnClickOutside,
        rest = _objectWithoutProperties$2(_ref, _excluded$1w);

    var prefix = usePrefix();
    var button = React.useRef();
    var secondaryButton = React.useRef();
    var innerModal = React.useRef();
    var startTrap = React.useRef();
    var endTrap = React.useRef();
    var modalInstanceId = "modal-".concat(getInstanceId$a());
    var modalLabelId = "".concat(prefix, "--modal-header__label--").concat(modalInstanceId);
    var modalHeadingId = "".concat(prefix, "--modal-header__heading--").concat(modalInstanceId);
    var modalBodyId = "".concat(prefix, "--modal-body--").concat(modalInstanceId);
    var modalCloseButtonClass = "".concat(prefix, "--modal-close");

    function isCloseButton(element) {
      return !onSecondarySubmit && element === secondaryButton.current || element.classList.contains(modalCloseButtonClass);
    }

    function handleKeyDown(evt) {
      if (open) {
        if (evt.which === 27) {
          onRequestClose(evt);
        }

        if (evt.which === 13 && shouldSubmitOnEnter && !isCloseButton(evt.target)) {
          onRequestSubmit(evt);
        }
      }
    }

    function handleMousedown(evt) {
      if (innerModal.current && !innerModal.current.contains(evt.target) && !elementOrParentIsFloatingMenu(evt.target, selectorsFloatingMenus) && !preventCloseOnClickOutside) {
        onRequestClose(evt);
      }
    }

    function handleBlur(_ref2) {
      var oldActiveNode = _ref2.target,
          currentActiveNode = _ref2.relatedTarget;

      if (open && currentActiveNode && oldActiveNode) {
        var bodyNode = innerModal.current;
        var startTrapNode = startTrap.current;
        var endTrapNode = endTrap.current;
        wrapFocus({
          bodyNode: bodyNode,
          startTrapNode: startTrapNode,
          endTrapNode: endTrapNode,
          currentActiveNode: currentActiveNode,
          oldActiveNode: oldActiveNode,
          selectorsFloatingMenus: selectorsFloatingMenus
        });
      }
    }

    var onSecondaryButtonClick = onSecondarySubmit ? onSecondarySubmit : onRequestClose;
    var modalClasses = cx("".concat(prefix, "--modal"), (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--modal-tall"), !passiveModal), _defineProperty$2(_classNames, 'is-visible', open), _defineProperty$2(_classNames, "".concat(prefix, "--modal--danger"), danger), _defineProperty$2(_classNames, className, className), _classNames));
    var containerClasses = cx("".concat(prefix, "--modal-container"), _defineProperty$2({}, "".concat(prefix, "--modal-container--").concat(size), size));
    var contentClasses = cx("".concat(prefix, "--modal-content"), (_classNames3 = {}, _defineProperty$2(_classNames3, "".concat(prefix, "--modal-content--with-form"), hasForm), _defineProperty$2(_classNames3, "".concat(prefix, "--modal-scroll-content"), hasScrollingContent), _classNames3));
    var footerClasses = cx("".concat(prefix, "--modal-footer"), _defineProperty$2({}, "".concat(prefix, "--modal-footer--three-button"), Array.isArray(secondaryButtons) && secondaryButtons.length === 2));
    var modalButton = /*#__PURE__*/React__default["default"].createElement("button", {
      className: modalCloseButtonClass,
      type: "button",
      onClick: onRequestClose,
      title: ariaLabel ? ariaLabel : iconDescription,
      "aria-label": closeButtonLabel ? closeButtonLabel : 'close',
      ref: button
    }, /*#__PURE__*/React__default["default"].createElement(Close20, {
      "aria-hidden": "true",
      tabIndex: "-1",
      className: "".concat(modalCloseButtonClass, "__icon")
    }));
    var ariaLabel = modalLabel || ['aria-label'] || modalAriaLabel || modalHeading;
    var getAriaLabelledBy = modalLabel ? modalLabelId : modalHeadingId;
    var hasScrollingContentProps = hasScrollingContent ? {
      tabIndex: 0,
      role: 'region',
      'aria-label': ariaLabel,
      'aria-labelledby': getAriaLabelledBy
    } : {};
    var alertDialogProps = {};

    if (alert && passiveModal) {
      alertDialogProps.role = 'alert';
    }

    if (alert && !passiveModal) {
      alertDialogProps.role = 'alertdialog';
      alertDialogProps['aria-describedby'] = modalBodyId;
    }

    React.useEffect(function () {
      return function () {
        toggleClass$1(document.body, "".concat(prefix, "--body--with-modal-open"), false);
      };
    }, [prefix]);
    React.useEffect(function () {
      toggleClass$1(document.body, "".concat(prefix, "--body--with-modal-open"), open);
    }, [open, prefix]);
    React.useEffect(function () {
      var initialFocus = function initialFocus(focusContainerElement) {
        var containerElement = focusContainerElement || innerModal.current;
        var primaryFocusElement = containerElement ? containerElement.querySelector(selectorPrimaryFocus) : null;

        if (primaryFocusElement) {
          return primaryFocusElement;
        }

        return button && button.current;
      };

      var focusButton = function focusButton(focusContainerElement) {
        var target = initialFocus(focusContainerElement);

        if (target) {
          target.focus();
        }
      };

      if (open) {
        focusButton(innerModal.current);
      }
    }, [open, selectorPrimaryFocus]);
    var modalBody = /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      ref: innerModal,
      role: "dialog"
    }, alertDialogProps, {
      className: containerClasses,
      "aria-label": ariaLabel,
      "aria-modal": "true",
      tabIndex: "-1"
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--modal-header")
    }, passiveModal && modalButton, modalLabel && /*#__PURE__*/React__default["default"].createElement("h2", {
      id: modalLabelId,
      className: "".concat(prefix, "--modal-header__label")
    }, modalLabel), /*#__PURE__*/React__default["default"].createElement("h3", {
      id: modalHeadingId,
      className: "".concat(prefix, "--modal-header__heading")
    }, modalHeading), !passiveModal && modalButton), /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      id: modalBodyId,
      className: contentClasses
    }, hasScrollingContentProps), children), hasScrollingContent && /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--modal-content--overflow-indicator")
    }), !passiveModal && /*#__PURE__*/React__default["default"].createElement(ButtonSet$1, {
      className: footerClasses
    }, Array.isArray(secondaryButtons) && secondaryButtons.length <= 2 ? secondaryButtons.map(function (_ref3, i) {
      var buttonText = _ref3.buttonText,
          onButtonClick = _ref3.onClick;
      return /*#__PURE__*/React__default["default"].createElement(Button$1, {
        key: "".concat(buttonText, "-").concat(i),
        kind: "secondary",
        onClick: onButtonClick
      }, buttonText);
    }) : secondaryButtonText && /*#__PURE__*/React__default["default"].createElement(Button$1, {
      kind: "secondary",
      onClick: onSecondaryButtonClick,
      ref: secondaryButton
    }, secondaryButtonText), /*#__PURE__*/React__default["default"].createElement(Button$1, {
      kind: danger ? 'danger' : 'primary',
      disabled: primaryButtonDisabled,
      onClick: onRequestSubmit,
      ref: button
    }, primaryButtonText)));
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({}, rest, {
      onKeyDown: handleKeyDown,
      onMouseDown: handleMousedown,
      onBlur: handleBlur,
      className: modalClasses,
      role: "presentation",
      ref: ref
    }), /*#__PURE__*/React__default["default"].createElement("span", {
      ref: startTrap,
      tabIndex: "0",
      role: "link",
      className: "".concat(prefix, "--visually-hidden")
    }, "Focus sentinel"), modalBody, /*#__PURE__*/React__default["default"].createElement("span", {
      ref: endTrap,
      tabIndex: "0",
      role: "link",
      className: "".concat(prefix, "--visually-hidden")
    }, "Focus sentinel"));
  });
  Modal$3.propTypes = (_Modal$propTypes = {
    /**
     * Specify whether the Modal is displaying an alert, error or warning
     * Should go hand in hand with the danger prop.
     */
    alert: PropTypes__default["default"].bool
  }, _defineProperty$2(_Modal$propTypes, 'aria-label', requiredIfGivenPropIsTruthy('hasScrollingContent', PropTypes__default["default"].string)), _defineProperty$2(_Modal$propTypes, "children", PropTypes__default["default"].node), _defineProperty$2(_Modal$propTypes, "className", PropTypes__default["default"].string), _defineProperty$2(_Modal$propTypes, "closeButtonLabel", PropTypes__default["default"].string), _defineProperty$2(_Modal$propTypes, "danger", PropTypes__default["default"].bool), _defineProperty$2(_Modal$propTypes, "focusTrap", deprecate(PropTypes__default["default"].bool, "\nThe prop `focusTrap` for Modal has been deprecated, as the feature of `focusTrap` runs by default.")), _defineProperty$2(_Modal$propTypes, "hasForm", deprecate(PropTypes__default["default"].bool, "\nThe prop `hasForm` for Modal has been deprecated, as the feature of `hasForm` runs by default.")), _defineProperty$2(_Modal$propTypes, "hasScrollingContent", PropTypes__default["default"].bool), _defineProperty$2(_Modal$propTypes, "iconDescription", deprecate(PropTypes__default["default"].string, 'The iconDescription prop is no longer needed and can be safely removed. This prop will be removed in the next major release of Carbon.')), _defineProperty$2(_Modal$propTypes, "id", PropTypes__default["default"].string), _defineProperty$2(_Modal$propTypes, "modalAriaLabel", PropTypes__default["default"].string), _defineProperty$2(_Modal$propTypes, "modalHeading", PropTypes__default["default"].node), _defineProperty$2(_Modal$propTypes, "modalLabel", PropTypes__default["default"].node), _defineProperty$2(_Modal$propTypes, "onKeyDown", PropTypes__default["default"].func), _defineProperty$2(_Modal$propTypes, "onRequestClose", PropTypes__default["default"].func), _defineProperty$2(_Modal$propTypes, "onRequestSubmit", PropTypes__default["default"].func), _defineProperty$2(_Modal$propTypes, "onSecondarySubmit", PropTypes__default["default"].func), _defineProperty$2(_Modal$propTypes, "open", PropTypes__default["default"].bool), _defineProperty$2(_Modal$propTypes, "passiveModal", PropTypes__default["default"].bool), _defineProperty$2(_Modal$propTypes, "preventCloseOnClickOutside", PropTypes__default["default"].bool), _defineProperty$2(_Modal$propTypes, "primaryButtonDisabled", PropTypes__default["default"].bool), _defineProperty$2(_Modal$propTypes, "primaryButtonText", PropTypes__default["default"].node), _defineProperty$2(_Modal$propTypes, "secondaryButtonText", PropTypes__default["default"].node), _defineProperty$2(_Modal$propTypes, "secondaryButtons", function secondaryButtons(props, propName, componentName) {
    if (props.secondaryButtons) {
      if (!Array.isArray(props.secondaryButtons) || props.secondaryButtons.length !== 2) {
        return new Error("".concat(propName, " needs to be an array of two button config objects"));
      }

      var shape = {
        buttonText: PropTypes__default["default"].node,
        onClick: PropTypes__default["default"].func
      };
      props[propName].forEach(function (secondaryButton) {
        PropTypes__default["default"].checkPropTypes(shape, secondaryButton, propName, componentName);
      });
    }

    return null;
  }), _defineProperty$2(_Modal$propTypes, "selectorPrimaryFocus", PropTypes__default["default"].string), _defineProperty$2(_Modal$propTypes, "selectorsFloatingMenus", PropTypes__default["default"].arrayOf(PropTypes__default["default"].string)), _defineProperty$2(_Modal$propTypes, "shouldSubmitOnEnter", PropTypes__default["default"].bool), _defineProperty$2(_Modal$propTypes, "size", PropTypes__default["default"].oneOf(['xs', 'sm', 'md', 'lg'])), _Modal$propTypes);
  Modal$3.defaultProps = {
    onRequestClose: function onRequestClose() {},
    onRequestSubmit: function onRequestSubmit() {},
    primaryButtonDisabled: false,
    onKeyDown: function onKeyDown() {},
    passiveModal: false,
    modalHeading: '',
    modalLabel: '',
    preventCloseOnClickOutside: false,
    selectorPrimaryFocus: '[data-modal-primary-focus]',
    hasScrollingContent: false
  };
  var ModalNext = Modal$3;

  var _defineProperty2$4;

  var _excluded$1v = ["modalHeading", "modalLabel", "modalAriaLabel", "passiveModal", "hasForm", "secondaryButtonText", "primaryButtonText", "open", "onRequestClose", "onRequestSubmit", "onSecondarySubmit", "iconDescription", "primaryButtonDisabled", "danger", "alert", "secondaryButtons", "selectorPrimaryFocus", "selectorsFloatingMenus", "shouldSubmitOnEnter", "size", "hasScrollingContent", "closeButtonLabel", "preventCloseOnClickOutside"];
  var getInstanceId$9 = setupGetInstanceId$2();

  var Modal$2 = /*#__PURE__*/function (_Component) {
    _inherits(Modal, _Component);

    var _super = _createSuper(Modal);

    function Modal() {
      var _this;

      _classCallCheck$1(this, Modal);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty$2(_assertThisInitialized$1(_this), "button", /*#__PURE__*/React__default["default"].createRef());

      _defineProperty$2(_assertThisInitialized$1(_this), "secondaryButton", /*#__PURE__*/React__default["default"].createRef());

      _defineProperty$2(_assertThisInitialized$1(_this), "outerModal", /*#__PURE__*/React__default["default"].createRef());

      _defineProperty$2(_assertThisInitialized$1(_this), "innerModal", /*#__PURE__*/React__default["default"].createRef());

      _defineProperty$2(_assertThisInitialized$1(_this), "startTrap", /*#__PURE__*/React__default["default"].createRef());

      _defineProperty$2(_assertThisInitialized$1(_this), "endTrap", /*#__PURE__*/React__default["default"].createRef());

      _defineProperty$2(_assertThisInitialized$1(_this), "modalInstanceId", "modal-".concat(getInstanceId$9()));

      _defineProperty$2(_assertThisInitialized$1(_this), "modalLabelId", "".concat(_this.context, "--modal-header__label--").concat(_this.modalInstanceId));

      _defineProperty$2(_assertThisInitialized$1(_this), "modalHeadingId", "".concat(_this.context, "--modal-header__heading--").concat(_this.modalInstanceId));

      _defineProperty$2(_assertThisInitialized$1(_this), "modalBodyId", "".concat(_this.context, "--modal-body--").concat(_this.modalInstanceId));

      _defineProperty$2(_assertThisInitialized$1(_this), "modalCloseButtonClass", "".concat(_this.context, "--modal-close"));

      _defineProperty$2(_assertThisInitialized$1(_this), "isCloseButton", function (element) {
        return !_this.props.onSecondarySubmit && element === _this.secondaryButton.current || element.classList.contains(_this.modalCloseButtonClass);
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleKeyDown", function (evt) {
        if (_this.props.open) {
          if (evt.which === 27) {
            _this.props.onRequestClose(evt);
          }

          if (evt.which === 13 && _this.props.shouldSubmitOnEnter && !_this.isCloseButton(evt.target)) {
            _this.props.onRequestSubmit(evt);
          }
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleMousedown", function (evt) {
        if (_this.innerModal.current && !_this.innerModal.current.contains(evt.target) && !elementOrParentIsFloatingMenu(evt.target, _this.props.selectorsFloatingMenus) && !_this.props.preventCloseOnClickOutside) {
          _this.props.onRequestClose(evt);
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleBlur", function (_ref) {
        var oldActiveNode = _ref.target,
            currentActiveNode = _ref.relatedTarget;
        var _this$props = _this.props,
            open = _this$props.open,
            selectorsFloatingMenus = _this$props.selectorsFloatingMenus;

        if (open && currentActiveNode && oldActiveNode) {
          var bodyNode = _this.innerModal.current;
          var startTrapNode = _this.startTrap.current;
          var endTrapNode = _this.endTrap.current;
          wrapFocus({
            bodyNode: bodyNode,
            startTrapNode: startTrapNode,
            endTrapNode: endTrapNode,
            currentActiveNode: currentActiveNode,
            oldActiveNode: oldActiveNode,
            selectorsFloatingMenus: selectorsFloatingMenus
          });
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "initialFocus", function (focusContainerElement) {
        var containerElement = focusContainerElement || _this.innerModal.current;
        var primaryFocusElement = containerElement ? containerElement.querySelector(_this.props.selectorPrimaryFocus) : null;

        if (primaryFocusElement) {
          return primaryFocusElement;
        }

        return _this.button && _this.button.current;
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "focusButton", function (focusContainerElement) {
        var target = _this.initialFocus(focusContainerElement);

        if (target) {
          target.focus();
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleTransitionEnd", function (evt) {
        if (evt.target === evt.currentTarget && // Not to handle `onTransitionEnd` on child DOM nodes
        _this.outerModal.current && _this.outerModal.current.offsetWidth && _this.outerModal.current.offsetHeight && _this.beingOpen) {
          _this.focusButton(evt.currentTarget);

          _this.beingOpen = false;
        }
      });

      return _this;
    }

    _createClass$1(Modal, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        if (!prevProps.open && this.props.open) {
          this.beingOpen = true;
        } else if (prevProps.open && !this.props.open) {
          this.beingOpen = false;
        }

        toggleClass$1(document.body, "".concat(this.context, "--body--with-modal-open"), this.props.open);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        toggleClass$1(document.body, "".concat(this.context, "--body--with-modal-open"), false);
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        toggleClass$1(document.body, "".concat(this.context, "--body--with-modal-open"), this.props.open);

        if (!this.props.open) {
          return;
        }

        this.focusButton(this.innerModal.current);
      }
    }, {
      key: "render",
      value: function render() {
        var _classNames, _classNames3;

        var _this$props2 = this.props,
            modalHeading = _this$props2.modalHeading,
            modalLabel = _this$props2.modalLabel,
            modalAriaLabel = _this$props2.modalAriaLabel,
            passiveModal = _this$props2.passiveModal,
            hasForm = _this$props2.hasForm,
            secondaryButtonText = _this$props2.secondaryButtonText,
            primaryButtonText = _this$props2.primaryButtonText,
            open = _this$props2.open,
            onRequestClose = _this$props2.onRequestClose,
            onRequestSubmit = _this$props2.onRequestSubmit,
            onSecondarySubmit = _this$props2.onSecondarySubmit,
            iconDescription = _this$props2.iconDescription,
            primaryButtonDisabled = _this$props2.primaryButtonDisabled,
            danger = _this$props2.danger,
            alert = _this$props2.alert,
            secondaryButtons = _this$props2.secondaryButtons;
            _this$props2.selectorPrimaryFocus;
            _this$props2.selectorsFloatingMenus;
            _this$props2.shouldSubmitOnEnter;
            var size = _this$props2.size,
            hasScrollingContent = _this$props2.hasScrollingContent,
            closeButtonLabel = _this$props2.closeButtonLabel;
            _this$props2.preventCloseOnClickOutside;
            var other = _objectWithoutProperties$2(_this$props2, _excluded$1v);

        var prefix = this.context;
        var onSecondaryButtonClick = onSecondarySubmit ? onSecondarySubmit : onRequestClose;
        var modalClasses = cx((_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--modal"), true), _defineProperty$2(_classNames, "".concat(prefix, "--modal-tall"), !passiveModal), _defineProperty$2(_classNames, 'is-visible', open), _defineProperty$2(_classNames, "".concat(prefix, "--modal--danger"), this.props.danger), _defineProperty$2(_classNames, this.props.className, this.props.className), _classNames));
        var containerClasses = cx("".concat(prefix, "--modal-container"), _defineProperty$2({}, "".concat(prefix, "--modal-container--").concat(size), size));
        var contentClasses = cx("".concat(prefix, "--modal-content"), (_classNames3 = {}, _defineProperty$2(_classNames3, "".concat(prefix, "--modal-content--with-form"), hasForm), _defineProperty$2(_classNames3, "".concat(prefix, "--modal-scroll-content"), hasScrollingContent), _classNames3));
        var footerClasses = cx("".concat(prefix, "--modal-footer"), _defineProperty$2({}, "".concat(prefix, "--modal-footer--three-button"), Array.isArray(secondaryButtons) && secondaryButtons.length === 2));
        var modalButton = /*#__PURE__*/React__default["default"].createElement("button", {
          className: this.modalCloseButtonClass,
          type: "button",
          onClick: onRequestClose,
          title: ariaLabel ? ariaLabel : iconDescription,
          "aria-label": closeButtonLabel ? closeButtonLabel : 'close',
          ref: this.button
        }, /*#__PURE__*/React__default["default"].createElement(Close20, {
          "aria-hidden": "true",
          tabIndex: "-1",
          className: "".concat(this.modalCloseButtonClass, "__icon")
        }));
        var ariaLabel = modalLabel || this.props['aria-label'] || modalAriaLabel || modalHeading;
        var getAriaLabelledBy = modalLabel ? this.modalLabelId : this.modalHeadingId;
        var hasScrollingContentProps = hasScrollingContent ? {
          tabIndex: 0,
          role: 'region',
          'aria-label': ariaLabel,
          'aria-labelledby': getAriaLabelledBy
        } : {};
        var alertDialogProps = {};

        if (alert && passiveModal) {
          alertDialogProps.role = 'alert';
        }

        if (alert && !passiveModal) {
          alertDialogProps.role = 'alertdialog';
          alertDialogProps['aria-describedby'] = this.modalBodyId;
        }

        var modalBody = /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
          ref: this.innerModal,
          role: "dialog"
        }, alertDialogProps, {
          className: containerClasses,
          "aria-label": ariaLabel,
          "aria-modal": "true",
          tabIndex: "-1"
        }), /*#__PURE__*/React__default["default"].createElement("div", {
          className: "".concat(prefix, "--modal-header")
        }, passiveModal && modalButton, modalLabel && /*#__PURE__*/React__default["default"].createElement("h2", {
          id: this.modalLabelId,
          className: "".concat(prefix, "--modal-header__label")
        }, modalLabel), /*#__PURE__*/React__default["default"].createElement("h3", {
          id: this.modalHeadingId,
          className: "".concat(prefix, "--modal-header__heading")
        }, modalHeading), !passiveModal && modalButton), /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
          id: this.modalBodyId,
          className: contentClasses
        }, hasScrollingContentProps), this.props.children), hasScrollingContent && /*#__PURE__*/React__default["default"].createElement("div", {
          className: "".concat(prefix, "--modal-content--overflow-indicator")
        }), !passiveModal && /*#__PURE__*/React__default["default"].createElement(ButtonSet$1, {
          className: footerClasses
        }, Array.isArray(secondaryButtons) && secondaryButtons.length <= 2 ? secondaryButtons.map(function (_ref2, i) {
          var buttonText = _ref2.buttonText,
              onButtonClick = _ref2.onClick;
          return /*#__PURE__*/React__default["default"].createElement(Button$1, {
            key: "".concat(buttonText, "-").concat(i),
            kind: "secondary",
            onClick: onButtonClick
          }, buttonText);
        }) : secondaryButtonText && /*#__PURE__*/React__default["default"].createElement(Button$1, {
          kind: "secondary",
          onClick: onSecondaryButtonClick,
          ref: this.secondaryButton
        }, secondaryButtonText), /*#__PURE__*/React__default["default"].createElement(Button$1, {
          kind: danger ? 'danger' : 'primary',
          disabled: primaryButtonDisabled,
          onClick: onRequestSubmit,
          ref: this.button
        }, primaryButtonText)));
        return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({}, other, {
          onKeyDown: this.handleKeyDown,
          onMouseDown: this.handleMousedown,
          onBlur: this.handleBlur,
          className: modalClasses,
          role: "presentation",
          onTransitionEnd: this.props.open ? this.handleTransitionEnd : undefined,
          ref: this.outerModal
        }), /*#__PURE__*/React__default["default"].createElement("span", {
          ref: this.startTrap,
          tabIndex: "0",
          role: "link",
          className: "".concat(prefix, "--visually-hidden")
        }, "Focus sentinel"), modalBody, /*#__PURE__*/React__default["default"].createElement("span", {
          ref: this.endTrap,
          tabIndex: "0",
          role: "link",
          className: "".concat(prefix, "--visually-hidden")
        }, "Focus sentinel"));
      }
    }]);

    return Modal;
  }(React.Component);

  _defineProperty$2(Modal$2, "contextType", PrefixContext);

  _defineProperty$2(Modal$2, "propTypes", (_defineProperty2$4 = {
    /**
     * Specify whether the Modal is displaying an alert, error or warning
     * Should go hand in hand with the danger prop.
     */
    alert: PropTypes__default["default"].bool
  }, _defineProperty$2(_defineProperty2$4, 'aria-label', requiredIfGivenPropIsTruthy('hasScrollingContent', PropTypes__default["default"].string)), _defineProperty$2(_defineProperty2$4, "children", PropTypes__default["default"].node), _defineProperty$2(_defineProperty2$4, "className", PropTypes__default["default"].string), _defineProperty$2(_defineProperty2$4, "closeButtonLabel", PropTypes__default["default"].string), _defineProperty$2(_defineProperty2$4, "danger", PropTypes__default["default"].bool), _defineProperty$2(_defineProperty2$4, "focusTrap", deprecate(PropTypes__default["default"].bool, "\nThe prop `focusTrap` for Modal has been deprecated, as the feature of `focusTrap` runs by default.")), _defineProperty$2(_defineProperty2$4, "hasForm", deprecate(PropTypes__default["default"].bool, "\nThe prop `hasForm` for Modal has been deprecated, as the feature of `hasForm` runs by default.")), _defineProperty$2(_defineProperty2$4, "hasScrollingContent", PropTypes__default["default"].bool), _defineProperty$2(_defineProperty2$4, "iconDescription", deprecate(PropTypes__default["default"].string, 'The iconDescription prop is no longer needed and can be safely removed. This prop will be removed in the next major release of Carbon.')), _defineProperty$2(_defineProperty2$4, "id", PropTypes__default["default"].string), _defineProperty$2(_defineProperty2$4, "modalAriaLabel", PropTypes__default["default"].string), _defineProperty$2(_defineProperty2$4, "modalHeading", PropTypes__default["default"].node), _defineProperty$2(_defineProperty2$4, "modalLabel", PropTypes__default["default"].node), _defineProperty$2(_defineProperty2$4, "onKeyDown", PropTypes__default["default"].func), _defineProperty$2(_defineProperty2$4, "onRequestClose", PropTypes__default["default"].func), _defineProperty$2(_defineProperty2$4, "onRequestSubmit", PropTypes__default["default"].func), _defineProperty$2(_defineProperty2$4, "onSecondarySubmit", PropTypes__default["default"].func), _defineProperty$2(_defineProperty2$4, "open", PropTypes__default["default"].bool), _defineProperty$2(_defineProperty2$4, "passiveModal", PropTypes__default["default"].bool), _defineProperty$2(_defineProperty2$4, "preventCloseOnClickOutside", PropTypes__default["default"].bool), _defineProperty$2(_defineProperty2$4, "primaryButtonDisabled", PropTypes__default["default"].bool), _defineProperty$2(_defineProperty2$4, "primaryButtonText", PropTypes__default["default"].node), _defineProperty$2(_defineProperty2$4, "secondaryButtonText", PropTypes__default["default"].node), _defineProperty$2(_defineProperty2$4, "secondaryButtons", function secondaryButtons(props, propName, componentName) {
    if (props.secondaryButtons) {
      if (!Array.isArray(props.secondaryButtons) || props.secondaryButtons.length !== 2) {
        return new Error("".concat(propName, " needs to be an array of two button config objects"));
      }

      var shape = {
        buttonText: PropTypes__default["default"].node,
        onClick: PropTypes__default["default"].func
      };
      props[propName].forEach(function (secondaryButton) {
        PropTypes__default["default"].checkPropTypes(shape, secondaryButton, propName, componentName);
      });
    }

    return null;
  }), _defineProperty$2(_defineProperty2$4, "selectorPrimaryFocus", PropTypes__default["default"].string), _defineProperty$2(_defineProperty2$4, "selectorsFloatingMenus", PropTypes__default["default"].arrayOf(PropTypes__default["default"].string)), _defineProperty$2(_defineProperty2$4, "shouldSubmitOnEnter", PropTypes__default["default"].bool), _defineProperty$2(_defineProperty2$4, "size", PropTypes__default["default"].oneOf(['xs', 'sm', 'md', 'lg'])), _defineProperty2$4));

  _defineProperty$2(Modal$2, "defaultProps", {
    onRequestClose: function onRequestClose() {},
    onRequestSubmit: function onRequestSubmit() {},
    primaryButtonDisabled: false,
    onKeyDown: function onKeyDown() {},
    passiveModal: false,
    modalHeading: '',
    modalLabel: '',
    preventCloseOnClickOutside: false,
    selectorPrimaryFocus: '[data-modal-primary-focus]',
    hasScrollingContent: false
  });

  var Modal = enabled('enable-v11-release') ? ModalNext : Modal$2;
  var Modal$1 = Modal;

  var _excluded$1u = ["children", "onKeyDown", "buttonTriggerText", "buttonTriggerClassName", "renderTriggerButtonIcon", "triggerButtonIconDescription", "triggerButtonKind", "disabled", "handleSubmit", "shouldCloseAfterSubmit", "selectorPrimaryFocus", "preventCloseOnClickOutside"];

  var ModalWrapper = /*#__PURE__*/function (_React$Component) {
    _inherits(ModalWrapper, _React$Component);

    var _super = _createSuper(ModalWrapper);

    function ModalWrapper() {
      var _this;

      _classCallCheck$1(this, ModalWrapper);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty$2(_assertThisInitialized$1(_this), "triggerButton", /*#__PURE__*/React__default["default"].createRef());

      _defineProperty$2(_assertThisInitialized$1(_this), "modal", /*#__PURE__*/React__default["default"].createRef());

      _defineProperty$2(_assertThisInitialized$1(_this), "state", {
        isOpen: false
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOpen", function () {
        _this.setState({
          isOpen: true
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleClose", function (evt) {
        if (evt && !_this.modal.current.innerModal.current.contains(evt.target) && _this.props.preventCloseOnClickOutside) {
          return;
        } else {
          _this.setState({
            isOpen: false
          }, function () {
            return _this.triggerButton.current.focus();
          });
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOnRequestSubmit", function () {
        var _this$props = _this.props,
            handleSubmit = _this$props.handleSubmit,
            shouldCloseAfterSubmit = _this$props.shouldCloseAfterSubmit;

        if (handleSubmit()) {
          if (shouldCloseAfterSubmit) {
            _this.handleClose();
          }
        }
      });

      return _this;
    }

    _createClass$1(ModalWrapper, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props2 = this.props,
            children = _this$props2.children,
            _onKeyDown = _this$props2.onKeyDown,
            buttonTriggerText = _this$props2.buttonTriggerText,
            buttonTriggerClassName = _this$props2.buttonTriggerClassName,
            renderTriggerButtonIcon = _this$props2.renderTriggerButtonIcon,
            triggerButtonIconDescription = _this$props2.triggerButtonIconDescription,
            triggerButtonKind = _this$props2.triggerButtonKind,
            disabled = _this$props2.disabled;
            _this$props2.handleSubmit;
            _this$props2.shouldCloseAfterSubmit;
            var selectorPrimaryFocus = _this$props2.selectorPrimaryFocus;
            _this$props2.preventCloseOnClickOutside;
            var other = _objectWithoutProperties$2(_this$props2, _excluded$1u);

        var props = _objectSpread2$2(_objectSpread2$2({}, other), {}, {
          selectorPrimaryFocus: selectorPrimaryFocus,
          open: this.state.isOpen,
          onRequestClose: this.handleClose,
          onRequestSubmit: this.handleOnRequestSubmit
        });

        return /*#__PURE__*/React__default["default"].createElement("div", {
          role: "presentation",
          onKeyDown: function onKeyDown(evt) {
            if (evt.which === 27) {
              _this2.handleClose();

              _onKeyDown(evt);
            }
          }
        }, /*#__PURE__*/React__default["default"].createElement(Button$1, {
          className: buttonTriggerClassName,
          disabled: disabled,
          kind: triggerButtonKind,
          renderIcon: renderTriggerButtonIcon,
          iconDescription: triggerButtonIconDescription,
          onClick: this.handleOpen,
          ref: this.triggerButton
        }, buttonTriggerText), /*#__PURE__*/React__default["default"].createElement(Modal$1, _extends$3({
          ref: this.modal
        }, props), children));
      }
    }]);

    return ModalWrapper;
  }(React__default["default"].Component);

  _defineProperty$2(ModalWrapper, "propTypes", {
    buttonTriggerClassName: PropTypes__default["default"].string,
    buttonTriggerText: PropTypes__default["default"].node,
    children: PropTypes__default["default"].node,
    disabled: PropTypes__default["default"].bool,
    handleOpen: PropTypes__default["default"].func,
    handleSubmit: PropTypes__default["default"].func,
    id: PropTypes__default["default"].string,
    modalBeforeContent: PropTypes__default["default"].bool,
    modalHeading: PropTypes__default["default"].string,
    modalLabel: PropTypes__default["default"].string,
    modalText: PropTypes__default["default"].string,
    onKeyDown: PropTypes__default["default"].func,
    passiveModal: PropTypes__default["default"].bool,
    preventCloseOnClickOutside: PropTypes__default["default"].bool,
    primaryButtonText: PropTypes__default["default"].string,
    renderTriggerButtonIcon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),
    secondaryButtonText: PropTypes__default["default"].string,
    selectorPrimaryFocus: PropTypes__default["default"].string,
    shouldCloseAfterSubmit: PropTypes__default["default"].bool,
    status: PropTypes__default["default"].string,
    triggerButtonIconDescription: PropTypes__default["default"].string,
    triggerButtonKind: PropTypes__default["default"].oneOf(ButtonKinds),
    withHeader: PropTypes__default["default"].bool
  });

  _defineProperty$2(ModalWrapper, "defaultProps", {
    primaryButtonText: 'Save',
    secondaryButtonText: 'Cancel',
    triggerButtonIconDescription: 'Provide icon description if icon is used',
    triggerButtonKind: 'primary',
    disabled: false,
    preventCloseOnClickOutside: false,
    selectorPrimaryFocus: '[data-modal-primary-focus]',
    onKeyDown: function onKeyDown() {}
  });

  var useIsomorphicEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;
  var useIsomorphicEffect$1 = useIsomorphicEffect;

  function useNoInteractiveChildren(ref) {
    var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'component should have no interactive child nodes';

    {
      // eslint-disable-next-line react-hooks/rules-of-hooks
      React.useEffect(function () {
        var node = ref.current ? getInteractiveContent(ref.current) : false;

        if (node) {
          throw new Error("Error: ".concat(message, ".\n\nInstead found: ").concat(node.outerHTML));
        }
      });
    }
  }
  /**
   * Determines if a given DOM node has interactive content, or is itself
   * interactive. It returns the interactive node if one is found
   *
   * @param {HTMLElement} node
   * @returns {HTMLElement}
   */

  function getInteractiveContent(node) {
    if (isFocusable(node)) {
      return node;
    }

    var _iterator = _createForOfIteratorHelper$1(node.childNodes),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var childNode = _step.value;
        var interactiveNode = getInteractiveContent(childNode);

        if (interactiveNode) {
          return interactiveNode;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return null;
  }
  /**
   * Determines if the given element is focusable, or not
   *
   * @param {HTMLElement} element
   * @returns {boolean}
   * @see https://github.com/w3c/aria-practices/blob/0553bb51588ffa517506e2a1b2ca1422ed438c5f/examples/js/utils.js#L68
   */

  function isFocusable(element) {
    if (element.tabIndex < 0) {
      return false;
    }

    if (element.disabled) {
      return false;
    }

    switch (element.nodeName) {
      case 'A':
        return !!element.href && element.rel !== 'ignore';

      case 'INPUT':
        return element.type !== 'hidden';

      case 'BUTTON':
      case 'SELECT':
      case 'TEXTAREA':
        return true;

      default:
        return false;
    }
  }

  var _iconTypes$1;

  var _excluded$1t = ["children", "className", "onClick", "inline"],
      _excluded2$8 = ["ariaLabel", "className", "iconDescription", "type", "renderIcon", "name", "notificationType"],
      _excluded3$6 = ["role", "onClose", "onCloseButtonClick", "iconDescription", "statusIconDescription", "className", "children", "kind", "lowContrast", "hideCloseButton", "timeout", "closeOnEscape"],
      _excluded4$6 = ["children", "role", "onClose", "onCloseButtonClick", "iconDescription", "statusIconDescription", "className", "kind", "lowContrast", "hideCloseButton", "closeOnEscape"],
      _excluded5$3 = ["actionButtonLabel", "children", "role", "onActionButtonClick", "onClose", "onCloseButtonClick", "iconDescription", "statusIconDescription", "className", "inline", "kind", "lowContrast", "hideCloseButton", "hasFocus", "closeOnEscape"];
  /**
   * Conditionally call a callback when the escape key is pressed
   * @param {node} ref - ref of the container element to scope the functionality to
   * @param {func} callback - function to be called
   * @param {bool} override - escape hatch to conditionally call the callback
   */

  function useEscapeToClose(ref, callback) {
    var override = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    var handleKeyDown = function handleKeyDown(event) {
      // The callback should only be called when focus is on or within the container
      var elementContainsFocus = ref.current && document.activeElement === ref.current || ref.current.contains(document.activeElement);

      if (matches(event, [Escape]) && override && elementContainsFocus) {
        callback(event);
      }
    };

    useIsomorphicEffect$1(function () {
      document.addEventListener('keydown', handleKeyDown, false);
      return function () {
        return document.removeEventListener('keydown', handleKeyDown, false);
      };
    });
  }

  function NotificationActionButton$2(_ref) {
    var children = _ref.children,
        customClassName = _ref.className,
        onClick = _ref.onClick,
        inline = _ref.inline,
        rest = _objectWithoutProperties$2(_ref, _excluded$1t);

    var prefix = usePrefix();
    var className = cx(customClassName, _defineProperty$2({}, "".concat(prefix, "--actionable-notification__action-button"), true));
    return /*#__PURE__*/React__default["default"].createElement(Button$1, _extends$3({
      className: className,
      kind: inline ? 'ghost' : 'tertiary',
      onClick: onClick,
      size: "sm"
    }, rest), children);
  }
  NotificationActionButton$2.propTypes = {
    /**
     * Specify the content of the notification action button.
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the notification action button
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify if the visual treatment of the button should be for an inline notification
     */
    inline: PropTypes__default["default"].bool,

    /**
     * Optionally specify a click handler for the notification action button.
     */
    onClick: PropTypes__default["default"].func
  };
  function NotificationButton$2(_ref2) {
    var ariaLabel = _ref2.ariaLabel,
        className = _ref2.className,
        iconDescription = _ref2.iconDescription,
        type = _ref2.type,
        IconTag = _ref2.renderIcon,
        name = _ref2.name,
        notificationType = _ref2.notificationType,
        rest = _objectWithoutProperties$2(_ref2, _excluded2$8);

    var prefix = usePrefix();
    var buttonClassName = cx(className, _defineProperty$2({}, "".concat(prefix, "--").concat(notificationType, "-notification__close-button"), notificationType));
    var iconClassName = cx(_defineProperty$2({}, "".concat(prefix, "--").concat(notificationType, "-notification__close-icon"), notificationType));
    return /*#__PURE__*/React__default["default"].createElement("button", _extends$3({}, rest, {
      // eslint-disable-next-line react/button-has-type
      type: type,
      "aria-label": iconDescription,
      title: iconDescription,
      className: buttonClassName
    }), IconTag && /*#__PURE__*/React__default["default"].createElement(IconTag, {
      "aria-label": ariaLabel,
      className: iconClassName,
      name: name
    }));
  }
  NotificationButton$2.propTypes = {
    /**
     * Specify a label to be read by screen readers on the notification button
     */
    ariaLabel: PropTypes__default["default"].string,

    /**
     * Specify an optional className to be applied to the notification button
     */
    className: PropTypes__default["default"].string,

    /**
     * Provide a description for "close" icon that can be read by screen readers
     */
    iconDescription: PropTypes__default["default"].string,

    /**
     * Specify an optional icon for the Button through a string,
     * if something but regular "close" icon is desirable
     */
    name: PropTypes__default["default"].string,

    /**
     * Specify the notification type
     */
    notificationType: PropTypes__default["default"].oneOf(['toast', 'inline', 'actionable']),

    /**
     * Optional prop to allow overriding the icon rendering.
     * Can be a React component class
     */
    renderIcon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),

    /**
     * Optional prop to specify the type of the Button
     */
    type: PropTypes__default["default"].string
  };
  NotificationButton$2.defaultProps = {
    ariaLabel: 'close notification',
    // TODO: deprecate this prop
    notificationType: 'toast',
    type: 'button',
    iconDescription: 'close icon',
    renderIcon: Close20
  };
  var iconTypes$1 = (_iconTypes$1 = {
    error: ErrorFilled20,
    success: CheckmarkFilled20,
    warning: WarningFilled20
  }, _defineProperty$2(_iconTypes$1, 'warning-alt', WarningAltFilled20), _defineProperty$2(_iconTypes$1, "info", InformationFilled20), _defineProperty$2(_iconTypes$1, 'info-square', InformationSquareFilled20), _iconTypes$1);

  function NotificationIcon$1(_ref3) {
    var iconDescription = _ref3.iconDescription,
        kind = _ref3.kind,
        notificationType = _ref3.notificationType;
    var prefix = usePrefix();
    var IconForKind = iconTypes$1[kind];

    if (!IconForKind) {
      return null;
    }

    return /*#__PURE__*/React__default["default"].createElement(IconForKind, {
      className: "".concat(prefix, "--").concat(notificationType, "-notification__icon")
    }, /*#__PURE__*/React__default["default"].createElement("title", null, iconDescription));
  }

  NotificationIcon$1.propTypes = {
    iconDescription: PropTypes__default["default"].string.isRequired,
    kind: PropTypes__default["default"].oneOf(['error', 'success', 'warning', 'warning-alt', 'info', 'info-square']).isRequired,
    notificationType: PropTypes__default["default"].oneOf(['inline', 'toast']).isRequired
  };
  function ToastNotification$2(_ref4) {
    var _cx4;

    var role = _ref4.role,
        onClose = _ref4.onClose,
        onCloseButtonClick = _ref4.onCloseButtonClick,
        iconDescription = _ref4.iconDescription,
        statusIconDescription = _ref4.statusIconDescription,
        className = _ref4.className,
        children = _ref4.children,
        kind = _ref4.kind,
        lowContrast = _ref4.lowContrast,
        hideCloseButton = _ref4.hideCloseButton,
        timeout = _ref4.timeout,
        closeOnEscape = _ref4.closeOnEscape,
        rest = _objectWithoutProperties$2(_ref4, _excluded3$6);

    var _useState = React.useState(true),
        _useState2 = _slicedToArray$1(_useState, 2),
        isOpen = _useState2[0],
        setIsOpen = _useState2[1];

    var prefix = usePrefix();
    var containerClassName = cx(className, (_cx4 = {}, _defineProperty$2(_cx4, "".concat(prefix, "--toast-notification"), true), _defineProperty$2(_cx4, "".concat(prefix, "--toast-notification--low-contrast"), lowContrast), _defineProperty$2(_cx4, "".concat(prefix, "--toast-notification--").concat(kind), kind), _cx4));
    var contentRef = React.useRef(null);
    useNoInteractiveChildren(contentRef);

    var handleClose = function handleClose(evt) {
      if (!onClose || onClose(evt) !== false) {
        setIsOpen(false);
      }
    };

    var ref = React.useRef(null);
    useEscapeToClose(ref, handleCloseButtonClick, closeOnEscape);

    function handleCloseButtonClick(event) {
      onCloseButtonClick(event);
      handleClose(event);
    }

    var savedOnClose = React.useRef(onClose);
    React.useEffect(function () {
      savedOnClose.current = onClose;
    });
    React.useEffect(function () {
      if (!timeout) {
        return;
      }

      var timeoutId = window.setTimeout(function (event) {
        setIsOpen(false);

        if (savedOnClose.current) {
          savedOnClose.current(event);
        }
      }, timeout);
      return function () {
        window.clearTimeout(timeoutId);
      };
    }, [timeout]);

    if (!isOpen) {
      return null;
    }

    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      ref: ref
    }, rest, {
      role: role,
      className: containerClassName
    }), /*#__PURE__*/React__default["default"].createElement(NotificationIcon$1, {
      notificationType: "toast",
      kind: kind,
      iconDescription: statusIconDescription || "".concat(kind, " icon")
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      ref: contentRef,
      className: "".concat(prefix, "--toast-notification__content")
    }, children), !hideCloseButton && /*#__PURE__*/React__default["default"].createElement(NotificationButton$2, {
      iconDescription: iconDescription,
      notificationType: "toast",
      onClick: handleCloseButtonClick,
      "aria-hidden": "true"
    }));
  }
  ToastNotification$2.propTypes = {
    /**
     * Specify the content
     */
    children: PropTypes__default["default"].node.isRequired,

    /**
     * Specify an optional className to be applied to the notification box
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify if pressing the escape key should close notifications
     */
    closeOnEscape: PropTypes__default["default"].bool,

    /**
     * Specify the close button should be disabled, or not
     */
    hideCloseButton: PropTypes__default["default"].bool,

    /**
     * Provide a description for "close" icon that can be read by screen readers
     */
    iconDescription: PropTypes__default["default"].string,

    /**
     * Specify what state the notification represents
     */
    kind: PropTypes__default["default"].oneOf(['error', 'info', 'info-square', 'success', 'warning', 'warning-alt']).isRequired,

    /**
     * Specify whether you are using the low contrast variant of the ToastNotification.
     */
    lowContrast: PropTypes__default["default"].bool,

    /**
     * Provide a function that is called when menu is closed
     */
    onClose: PropTypes__default["default"].func,

    /**
     * Provide a function that is called when the close button is clicked
     */
    onCloseButtonClick: PropTypes__default["default"].func,

    /**
     * By default, this value is "alert". You can also provide an alternate
     * role if it makes sense from the accessibility-side
     */
    role: PropTypes__default["default"].oneOf(['alert', 'log', 'status']).isRequired,

    /**
     * Provide a description for "status" icon that can be read by screen readers
     */
    statusIconDescription: PropTypes__default["default"].string,

    /**
     * Specify an optional duration the notification should be closed in
     */
    timeout: PropTypes__default["default"].number
  };
  ToastNotification$2.defaultProps = {
    kind: 'error',
    children: 'provide content',
    role: 'status',
    iconDescription: 'closes notification',
    onCloseButtonClick: function onCloseButtonClick() {},
    hideCloseButton: false,
    timeout: 0,
    closeOnEscape: true
  };
  function InlineNotification$2(_ref5) {
    var _cx5;

    var children = _ref5.children,
        role = _ref5.role,
        onClose = _ref5.onClose,
        onCloseButtonClick = _ref5.onCloseButtonClick,
        iconDescription = _ref5.iconDescription,
        statusIconDescription = _ref5.statusIconDescription,
        className = _ref5.className,
        kind = _ref5.kind,
        lowContrast = _ref5.lowContrast,
        hideCloseButton = _ref5.hideCloseButton,
        closeOnEscape = _ref5.closeOnEscape,
        rest = _objectWithoutProperties$2(_ref5, _excluded4$6);

    var _useState3 = React.useState(true),
        _useState4 = _slicedToArray$1(_useState3, 2),
        isOpen = _useState4[0],
        setIsOpen = _useState4[1];

    var prefix = usePrefix();
    var containerClassName = cx(className, (_cx5 = {}, _defineProperty$2(_cx5, "".concat(prefix, "--inline-notification"), true), _defineProperty$2(_cx5, "".concat(prefix, "--inline-notification--low-contrast"), lowContrast), _defineProperty$2(_cx5, "".concat(prefix, "--inline-notification--").concat(kind), kind), _defineProperty$2(_cx5, "".concat(prefix, "--inline-notification--hide-close-button"), hideCloseButton), _cx5));
    var contentRef = React.useRef(null);
    useNoInteractiveChildren(contentRef);

    var handleClose = function handleClose(evt) {
      if (!onClose || onClose(evt) !== false) {
        setIsOpen(false);
      }
    };

    var ref = React.useRef(null);
    useEscapeToClose(ref, handleCloseButtonClick, closeOnEscape);

    function handleCloseButtonClick(event) {
      onCloseButtonClick(event);
      handleClose(event);
    }

    if (!isOpen) {
      return null;
    }

    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      ref: ref
    }, rest, {
      role: role,
      className: containerClassName
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--inline-notification__details")
    }, /*#__PURE__*/React__default["default"].createElement(NotificationIcon$1, {
      notificationType: "inline",
      kind: kind,
      iconDescription: statusIconDescription || "".concat(kind, " icon")
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--inline-notification__text-wrapper")
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      ref: contentRef,
      className: "".concat(prefix, "--inline-notification__content")
    }, children))), !hideCloseButton && /*#__PURE__*/React__default["default"].createElement(NotificationButton$2, {
      iconDescription: iconDescription,
      notificationType: "inline",
      onClick: handleCloseButtonClick,
      "aria-hidden": true
    }));
  }
  InlineNotification$2.propTypes = {
    /**
     * Specify the content
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the notification box
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify if pressing the escape key should close notifications
     */
    closeOnEscape: PropTypes__default["default"].bool,

    /**
     * Specify the close button should be disabled, or not
     */
    hideCloseButton: PropTypes__default["default"].bool,

    /**
     * Provide a description for "close" icon that can be read by screen readers
     */
    iconDescription: PropTypes__default["default"].string,

    /**
     * Specify what state the notification represents
     */
    kind: PropTypes__default["default"].oneOf(['error', 'info', 'info-square', 'success', 'warning', 'warning-alt']).isRequired,

    /**
     * Specify whether you are using the low contrast variant of the InlineNotification.
     */
    lowContrast: PropTypes__default["default"].bool,

    /**
     * Provide a function that is called when menu is closed
     */
    onClose: PropTypes__default["default"].func,

    /**
     * Provide a function that is called when the close button is clicked
     */
    onCloseButtonClick: PropTypes__default["default"].func,

    /**
     * By default, this value is "alert". You can also provide an alternate
     * role if it makes sense from the accessibility-side. If the `actions` prop is
     * configured, this will be overridden to "alertdialog".
     */
    role: PropTypes__default["default"].oneOf(['alert', 'log', 'status']).isRequired,

    /**
     * Provide a description for "status" icon that can be read by screen readers
     */
    statusIconDescription: PropTypes__default["default"].string
  };
  InlineNotification$2.defaultProps = {
    kind: 'error',
    children: 'provide content',
    role: 'status',
    iconDescription: 'closes notification',
    onCloseButtonClick: function onCloseButtonClick() {},
    hideCloseButton: false,
    closeOnEscape: true
  };
  function ActionableNotification$1(_ref6) {
    var _cx6;

    var actionButtonLabel = _ref6.actionButtonLabel,
        children = _ref6.children,
        role = _ref6.role,
        onActionButtonClick = _ref6.onActionButtonClick,
        onClose = _ref6.onClose,
        onCloseButtonClick = _ref6.onCloseButtonClick,
        iconDescription = _ref6.iconDescription,
        statusIconDescription = _ref6.statusIconDescription,
        className = _ref6.className,
        inline = _ref6.inline,
        kind = _ref6.kind,
        lowContrast = _ref6.lowContrast,
        hideCloseButton = _ref6.hideCloseButton,
        hasFocus = _ref6.hasFocus,
        closeOnEscape = _ref6.closeOnEscape,
        rest = _objectWithoutProperties$2(_ref6, _excluded5$3);

    var _useState5 = React.useState(true),
        _useState6 = _slicedToArray$1(_useState5, 2),
        isOpen = _useState6[0],
        setIsOpen = _useState6[1];

    var prefix = usePrefix();
    var containerClassName = cx(className, (_cx6 = {}, _defineProperty$2(_cx6, "".concat(prefix, "--actionable-notification"), true), _defineProperty$2(_cx6, "".concat(prefix, "--actionable-notification--toast"), !inline), _defineProperty$2(_cx6, "".concat(prefix, "--actionable-notification--low-contrast"), lowContrast), _defineProperty$2(_cx6, "".concat(prefix, "--actionable-notification--").concat(kind), kind), _defineProperty$2(_cx6, "".concat(prefix, "--actionable-notification--hide-close-button"), hideCloseButton), _cx6));
    var ref = React.useRef(null);
    useIsomorphicEffect$1(function () {
      if (ref.current && hasFocus) {
        ref.current.focus();
      }
    });

    var handleClose = function handleClose(evt) {
      if (!onClose || onClose(evt) !== false) {
        setIsOpen(false);
      }
    };

    useEscapeToClose(ref, handleCloseButtonClick, closeOnEscape);

    function handleCloseButtonClick(event) {
      onCloseButtonClick(event);
      handleClose(event);
    }

    if (!isOpen) {
      return null;
    }

    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({}, rest, {
      ref: ref,
      role: role,
      className: containerClassName
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--actionable-notification__details")
    }, /*#__PURE__*/React__default["default"].createElement(NotificationIcon$1, {
      notificationType: inline ? 'inline' : 'toast',
      kind: kind,
      iconDescription: statusIconDescription || "".concat(kind, " icon")
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--actionable-notification__text-wrapper")
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--actionable-notification__content")
    }, children))), /*#__PURE__*/React__default["default"].createElement(NotificationActionButton$2, {
      onClick: onActionButtonClick,
      inline: inline
    }, actionButtonLabel), !hideCloseButton && /*#__PURE__*/React__default["default"].createElement(NotificationButton$2, {
      iconDescription: iconDescription,
      notificationType: "actionable",
      onClick: handleCloseButtonClick,
      "aria-hidden": true
    }));
  }
  ActionableNotification$1.propTypes = {
    /**
     * Pass in the action button label that will be rendered within the ActionableNotification.
     */
    actionButtonLabel: PropTypes__default["default"].string.isRequired,

    /**
     * Specify the content
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the notification box
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify if pressing the escape key should close notifications
     */
    closeOnEscape: PropTypes__default["default"].bool,

    /**
     * Specify if focus should be moved to the component when the notification contains actions
     */
    hasFocus: PropTypes__default["default"].bool,

    /**
     * Specify the close button should be disabled, or not
     */
    hideCloseButton: PropTypes__default["default"].bool,

    /**
     * Provide a description for "close" icon that can be read by screen readers
     */
    iconDescription: PropTypes__default["default"].string,

    /*
     * Specify if the notification should have inline styling applied instead of toast
     */
    inline: PropTypes__default["default"].bool,

    /**
     * Specify what state the notification represents
     */
    kind: PropTypes__default["default"].oneOf(['error', 'info', 'info-square', 'success', 'warning', 'warning-alt']).isRequired,

    /**
     * Specify whether you are using the low contrast variant of the ActionableNotification.
     */
    lowContrast: PropTypes__default["default"].bool,

    /**
     * Provide a function that is called when the action is clicked
     */
    onActionButtonClick: PropTypes__default["default"].func,

    /**
     * Provide a function that is called when menu is closed
     */
    onClose: PropTypes__default["default"].func,

    /**
     * Provide a function that is called when the close button is clicked
     */
    onCloseButtonClick: PropTypes__default["default"].func,

    /**
     * By default, this value is "alertdialog". You can also provide an alternate
     * role if it makes sense from the accessibility-side.
     */
    role: PropTypes__default["default"].string,

    /**
     * Provide a description for "status" icon that can be read by screen readers
     */
    statusIconDescription: PropTypes__default["default"].string
  };
  ActionableNotification$1.defaultProps = {
    kind: 'error',
    children: 'provide content',
    role: 'alertdialog',
    iconDescription: 'closes notification',
    onCloseButtonClick: function onCloseButtonClick() {},
    hideCloseButton: false,
    hasFocus: true,
    closeOnEscape: true,
    inline: false
  };

  var _iconTypes;

  var _excluded$1s = ["children", "className", "onClick"],
      _excluded2$7 = ["ariaLabel", "className", "iconDescription", "type", "renderIcon", "name", "notificationType"],
      _excluded3$5 = ["title", "subtitle", "caption", "notificationType", "children"],
      _excluded4$5 = ["role", "notificationType", "onClose", "onCloseButtonClick", "iconDescription", "statusIconDescription", "className", "caption", "subtitle", "title", "kind", "lowContrast", "hideCloseButton", "children", "timeout"],
      _excluded5$2 = ["actions", "role", "notificationType", "onClose", "onCloseButtonClick", "iconDescription", "statusIconDescription", "className", "subtitle", "title", "kind", "lowContrast", "hideCloseButton", "children"];
  function NotificationActionButton$1(_ref) {
    var children = _ref.children,
        customClassName = _ref.className,
        onClick = _ref.onClick,
        rest = _objectWithoutProperties$2(_ref, _excluded$1s);

    var prefix = usePrefix();
    var className = cx(customClassName, "".concat(prefix, "--inline-notification__action-button"));
    return /*#__PURE__*/React__default["default"].createElement(Button$1, _extends$3({
      className: className,
      kind: "ghost",
      onClick: onClick,
      size: "small"
    }, rest), children);
  }
  NotificationActionButton$1.propTypes = {
    /**
     * Specify the content of the notification action button.
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the notification action button
     */
    className: PropTypes__default["default"].string,

    /**
     * Optionally specify a click handler for the notification action button.
     */
    onClick: PropTypes__default["default"].func
  };
  function NotificationButton$1(_ref2) {
    var ariaLabel = _ref2.ariaLabel,
        className = _ref2.className,
        iconDescription = _ref2.iconDescription,
        type = _ref2.type,
        IconTag = _ref2.renderIcon,
        name = _ref2.name,
        notificationType = _ref2.notificationType,
        rest = _objectWithoutProperties$2(_ref2, _excluded2$7);

    var prefix = usePrefix();
    var buttonClassName = cx(className, _defineProperty$2({}, "".concat(prefix, "--").concat(notificationType, "-notification__close-button"), notificationType));
    var iconClassName = cx(_defineProperty$2({}, "".concat(prefix, "--").concat(notificationType, "-notification__close-icon"), notificationType));
    return /*#__PURE__*/React__default["default"].createElement("button", _extends$3({}, rest, {
      // eslint-disable-next-line react/button-has-type
      type: type,
      "aria-label": iconDescription,
      title: iconDescription,
      className: buttonClassName
    }), IconTag && /*#__PURE__*/React__default["default"].createElement(IconTag, {
      "aria-label": ariaLabel,
      className: iconClassName,
      name: name
    }));
  }
  NotificationButton$1.propTypes = {
    /**
     * Specify a label to be read by screen readers on the notification button
     */
    ariaLabel: PropTypes__default["default"].string,

    /**
     * Specify an optional className to be applied to the notification button
     */
    className: PropTypes__default["default"].string,

    /**
     * Provide a description for "close" icon that can be read by screen readers
     */
    iconDescription: PropTypes__default["default"].string,

    /**
     * Specify an optional icon for the Button through a string,
     * if something but regular "close" icon is desirable
     */
    name: PropTypes__default["default"].string,

    /**
     * Specify the notification type
     */
    notificationType: PropTypes__default["default"].oneOf(['toast', 'inline']),

    /**
     * Optional prop to allow overriding the icon rendering.
     * Can be a React component class
     */
    renderIcon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),

    /**
     * Optional prop to specify the type of the Button
     */
    type: PropTypes__default["default"].string
  };
  NotificationButton$1.defaultProps = {
    ariaLabel: 'close notification',
    // TODO: deprecate this prop
    notificationType: 'toast',
    type: 'button',
    iconDescription: 'close icon',
    renderIcon: Close20
  };
  function NotificationTextDetails$1(_ref3) {
    var title = _ref3.title,
        subtitle = _ref3.subtitle,
        caption = _ref3.caption,
        notificationType = _ref3.notificationType,
        children = _ref3.children,
        rest = _objectWithoutProperties$2(_ref3, _excluded3$5);

    var prefix = usePrefix();

    if (notificationType === 'toast') {
      return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({}, rest, {
        className: "".concat(prefix, "--toast-notification__details")
      }), /*#__PURE__*/React__default["default"].createElement("h3", {
        className: "".concat(prefix, "--toast-notification__title")
      }, title), /*#__PURE__*/React__default["default"].createElement("div", {
        className: "".concat(prefix, "--toast-notification__subtitle")
      }, subtitle), caption && /*#__PURE__*/React__default["default"].createElement("div", {
        className: "".concat(prefix, "--toast-notification__caption")
      }, caption), children);
    }

    if (notificationType === 'inline') {
      return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({}, rest, {
        className: "".concat(prefix, "--inline-notification__text-wrapper")
      }), /*#__PURE__*/React__default["default"].createElement("p", {
        className: "".concat(prefix, "--inline-notification__title")
      }, title), /*#__PURE__*/React__default["default"].createElement("div", {
        className: "".concat(prefix, "--inline-notification__subtitle")
      }, subtitle), children);
    }
  }
  NotificationTextDetails$1.propTypes = {
    /**
     * Specify the caption
     */
    caption: PropTypes__default["default"].node,

    /**
     * Pass in the children that will be rendered in NotificationTextDetails
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify the notification type
     */
    notificationType: PropTypes__default["default"].oneOf(['toast', 'inline']),

    /**
     * Specify the sub-title
     */
    subtitle: PropTypes__default["default"].node,

    /**
     * Specify the title
     */
    title: PropTypes__default["default"].string
  };
  NotificationTextDetails$1.defaultProps = {
    title: 'title',
    notificationType: 'toast'
  };
  var iconTypes = (_iconTypes = {
    error: ErrorFilled20,
    success: CheckmarkFilled20,
    warning: WarningFilled20
  }, _defineProperty$2(_iconTypes, 'warning-alt', WarningAltFilled20), _defineProperty$2(_iconTypes, "info", InformationFilled20), _defineProperty$2(_iconTypes, 'info-square', InformationSquareFilled20), _iconTypes);

  function NotificationIcon(_ref4) {
    var iconDescription = _ref4.iconDescription,
        kind = _ref4.kind,
        notificationType = _ref4.notificationType;
    var prefix = usePrefix();
    var IconForKind = iconTypes[kind];

    if (!IconForKind) {
      return null;
    }

    return /*#__PURE__*/React__default["default"].createElement(IconForKind, {
      className: "".concat(prefix, "--").concat(notificationType, "-notification__icon")
    }, /*#__PURE__*/React__default["default"].createElement("title", null, iconDescription));
  }

  NotificationIcon.propTypes = {
    iconDescription: PropTypes__default["default"].string.isRequired,
    kind: PropTypes__default["default"].oneOf(['error', 'success', 'warning', 'warning-alt', 'info', 'info-square']).isRequired,
    notificationType: PropTypes__default["default"].oneOf(['inline', 'toast']).isRequired
  };
  function ToastNotification$1(_ref5) {
    var _cx3;

    var role = _ref5.role,
        notificationType = _ref5.notificationType,
        onClose = _ref5.onClose,
        onCloseButtonClick = _ref5.onCloseButtonClick,
        iconDescription = _ref5.iconDescription,
        statusIconDescription = _ref5.statusIconDescription,
        className = _ref5.className,
        caption = _ref5.caption,
        subtitle = _ref5.subtitle,
        title = _ref5.title,
        kind = _ref5.kind,
        lowContrast = _ref5.lowContrast,
        hideCloseButton = _ref5.hideCloseButton,
        children = _ref5.children,
        timeout = _ref5.timeout,
        rest = _objectWithoutProperties$2(_ref5, _excluded4$5);

    var prefix = usePrefix();

    var _useState = React.useState(true),
        _useState2 = _slicedToArray$1(_useState, 2),
        isOpen = _useState2[0],
        setIsOpen = _useState2[1];

    var containerClassName = cx(className, (_cx3 = {}, _defineProperty$2(_cx3, "".concat(prefix, "--toast-notification"), true), _defineProperty$2(_cx3, "".concat(prefix, "--toast-notification--low-contrast"), lowContrast), _defineProperty$2(_cx3, "".concat(prefix, "--toast-notification--").concat(kind), kind), _cx3));

    var handleClose = function handleClose(evt) {
      if (!onClose || onClose(evt) !== false) {
        setIsOpen(false);
      }
    };

    function handleCloseButtonClick(event) {
      onCloseButtonClick(event);
      handleClose(event);
    }

    var savedOnClose = React.useRef(onClose);
    React.useEffect(function () {
      savedOnClose.current = onClose;
    });
    React.useEffect(function () {
      if (!timeout) {
        return;
      }

      var timeoutId = window.setTimeout(function (event) {
        setIsOpen(false);

        if (savedOnClose.current) {
          savedOnClose.current(event);
        }
      }, timeout);
      return function () {
        window.clearTimeout(timeoutId);
      };
    }, [timeout]);

    if (!isOpen) {
      return null;
    }

    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({}, rest, {
      role: role,
      kind: kind,
      className: containerClassName
    }), /*#__PURE__*/React__default["default"].createElement(NotificationIcon, {
      notificationType: notificationType,
      kind: kind,
      iconDescription: statusIconDescription || "".concat(kind, " icon")
    }), /*#__PURE__*/React__default["default"].createElement(NotificationTextDetails$1, {
      title: title,
      subtitle: subtitle,
      caption: caption,
      notificationType: notificationType
    }, children), !hideCloseButton && /*#__PURE__*/React__default["default"].createElement(NotificationButton$1, {
      iconDescription: iconDescription,
      notificationType: notificationType,
      onClick: handleCloseButtonClick
    }));
  }
  ToastNotification$1.propTypes = {
    /**
     * Specify the caption
     */
    caption: PropTypes__default["default"].node,

    /**
     * Pass in the children that will be rendered within the ToastNotification
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the notification box
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the close button should be disabled, or not
     */
    hideCloseButton: PropTypes__default["default"].bool,

    /**
     * Provide a description for "close" icon that can be read by screen readers
     */
    iconDescription: PropTypes__default["default"].string,

    /**
     * Specify what state the notification represents
     */
    kind: PropTypes__default["default"].oneOf(['error', 'info', 'info-square', 'success', 'warning', 'warning-alt']).isRequired,

    /**
     * Specify whether you are using the low contrast variant of the ToastNotification.
     */
    lowContrast: PropTypes__default["default"].bool,

    /**
     * By default, this value is "toast". You can also provide an alternate type
     * if it makes sense for the underlying `<NotificationTextDetails>` and `<NotificationButton>`
     */
    notificationType: PropTypes__default["default"].string,

    /**
     * Provide a function that is called when menu is closed
     */
    onClose: PropTypes__default["default"].func,

    /**
     * Provide a function that is called when the close button is clicked
     */
    onCloseButtonClick: PropTypes__default["default"].func,

    /**
     * By default, this value is "alert". You can also provide an alternate
     * role if it makes sense from the accessibility-side
     */
    role: PropTypes__default["default"].string.isRequired,

    /**
     * Provide a description for "status" icon that can be read by screen readers
     */
    statusIconDescription: PropTypes__default["default"].string,

    /**
     * Specify the sub-title
     */
    subtitle: PropTypes__default["default"].node,

    /**
     * Specify an optional duration the notification should be closed in
     */
    timeout: PropTypes__default["default"].number,

    /**
     * Specify the title
     */
    title: PropTypes__default["default"].string.isRequired
  };
  ToastNotification$1.defaultProps = {
    kind: 'error',
    title: 'provide a title',
    role: 'alert',
    notificationType: 'toast',
    iconDescription: 'closes notification',
    onCloseButtonClick: function onCloseButtonClick() {},
    hideCloseButton: false,
    timeout: 0
  };
  function InlineNotification$1(_ref6) {
    var _cx4;

    var actions = _ref6.actions,
        role = _ref6.role,
        notificationType = _ref6.notificationType,
        onClose = _ref6.onClose,
        onCloseButtonClick = _ref6.onCloseButtonClick,
        iconDescription = _ref6.iconDescription,
        statusIconDescription = _ref6.statusIconDescription,
        className = _ref6.className,
        subtitle = _ref6.subtitle,
        title = _ref6.title,
        kind = _ref6.kind,
        lowContrast = _ref6.lowContrast,
        hideCloseButton = _ref6.hideCloseButton,
        children = _ref6.children,
        rest = _objectWithoutProperties$2(_ref6, _excluded5$2);

    var prefix = usePrefix();

    var _useState3 = React.useState(true),
        _useState4 = _slicedToArray$1(_useState3, 2),
        isOpen = _useState4[0],
        setIsOpen = _useState4[1];

    var containerClassName = cx(className, (_cx4 = {}, _defineProperty$2(_cx4, "".concat(prefix, "--inline-notification"), true), _defineProperty$2(_cx4, "".concat(prefix, "--inline-notification--low-contrast"), lowContrast), _defineProperty$2(_cx4, "".concat(prefix, "--inline-notification--").concat(kind), kind), _defineProperty$2(_cx4, "".concat(prefix, "--inline-notification--hide-close-button"), hideCloseButton), _cx4));

    var handleClose = function handleClose(evt) {
      if (!onClose || onClose(evt) !== false) {
        setIsOpen(false);
      }
    };

    function handleCloseButtonClick(event) {
      onCloseButtonClick(event);
      handleClose(event);
    }

    if (!isOpen) {
      return null;
    }

    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({}, rest, {
      role: role,
      kind: kind,
      className: containerClassName
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--inline-notification__details")
    }, /*#__PURE__*/React__default["default"].createElement(NotificationIcon, {
      notificationType: notificationType,
      kind: kind,
      iconDescription: statusIconDescription || "".concat(kind, " icon")
    }), /*#__PURE__*/React__default["default"].createElement(NotificationTextDetails$1, {
      title: title,
      subtitle: subtitle,
      notificationType: notificationType
    }, children)), actions, !hideCloseButton && /*#__PURE__*/React__default["default"].createElement(NotificationButton$1, {
      iconDescription: iconDescription,
      notificationType: notificationType,
      onClick: handleCloseButtonClick
    }));
  }
  InlineNotification$1.propTypes = {
    /**
     * Pass in the action nodes that will be rendered within the InlineNotification
     */
    actions: PropTypes__default["default"].node,

    /**
     * Pass in the children that will be rendered within the InlineNotification
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the notification box
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the close button should be disabled, or not
     */
    hideCloseButton: PropTypes__default["default"].bool,

    /**
     * Provide a description for "close" icon that can be read by screen readers
     */
    iconDescription: PropTypes__default["default"].string,

    /**
     * Specify what state the notification represents
     */
    kind: PropTypes__default["default"].oneOf(['error', 'info', 'info-square', 'success', 'warning', 'warning-alt']).isRequired,

    /**
     * Specify whether you are using the low contrast variant of the InlineNotification.
     */
    lowContrast: PropTypes__default["default"].bool,

    /**
     * By default, this value is "inline". You can also provide an alternate type
     * if it makes sense for the underlying `<NotificationTextDetails>` and `<NotificationButton>`
     */
    notificationType: PropTypes__default["default"].string,

    /**
     * Provide a function that is called when menu is closed
     */
    onClose: PropTypes__default["default"].func,

    /**
     * Provide a function that is called when the close button is clicked
     */
    onCloseButtonClick: PropTypes__default["default"].func,

    /**
     * By default, this value is "alert". You can also provide an alternate
     * role if it makes sense from the accessibility-side
     */
    role: PropTypes__default["default"].string.isRequired,

    /**
     * Provide a description for "status" icon that can be read by screen readers
     */
    statusIconDescription: PropTypes__default["default"].string,

    /**
     * Specify the sub-title
     */
    subtitle: PropTypes__default["default"].node,

    /**
     * Specify the title
     */
    title: PropTypes__default["default"].string.isRequired
  };
  InlineNotification$1.defaultProps = {
    role: 'alert',
    notificationType: 'inline',
    iconDescription: 'closes notification',
    onCloseButtonClick: function onCloseButtonClick() {},
    hideCloseButton: false
  };

  function createComponentToggle(spec) {
    var name = spec.name,
        _spec$flag = spec.flag,
        flag = _spec$flag === void 0 ? 'enable-v11-release' : _spec$flag,
        next = spec.next,
        classic = spec.classic;

    function ComponentToggle(props, ref) {
      var enabled = useFeatureFlag(flag);

      if (enabled) {
        if (next) {
          return /*#__PURE__*/React__default["default"].createElement(next, _objectSpread2$2(_objectSpread2$2({}, props), {}, {
            ref: ref
          }));
        }

        return null;
      }

      return /*#__PURE__*/React__default["default"].createElement(classic, _objectSpread2$2(_objectSpread2$2({}, props), {}, {
        ref: ref
      }));
    }

    var wrappedComponent = /*#__PURE__*/React__default["default"].forwardRef(ComponentToggle);
    wrappedComponent.displayName = "FeatureToggle(".concat(name, ")");
    return wrappedComponent;
  }

  var NotificationActionButton = createComponentToggle({
    name: 'NotificationActionButton',
    next: NotificationActionButton$2,
    classic: NotificationActionButton$1
  });
  var NotificationTextDetails = createComponentToggle({
    name: 'NotificationTextDetails',
    classic: NotificationTextDetails$1
  });
  var NotificationButton = createComponentToggle({
    name: 'NotificationButton',
    next: NotificationButton$2,
    classic: NotificationButton$1
  });
  var ToastNotification = createComponentToggle({
    name: 'ToastNotification',
    next: ToastNotification$2,
    classic: ToastNotification$1
  });
  var InlineNotification = createComponentToggle({
    name: 'InlineNotification',
    next: InlineNotification$2,
    classic: InlineNotification$1
  });
  var ActionableNotification = createComponentToggle({
    name: 'ActionableNotification',
    next: ActionableNotification$1,
    classic: null
  });

  var _excluded$1r = ["hideLabel", "className"];

  var NumberInputSkeleton = function NumberInputSkeleton(_ref) {
    var hideLabel = _ref.hideLabel,
        className = _ref.className,
        rest = _objectWithoutProperties$2(_ref, _excluded$1r);

    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: cx("".concat(prefix, "--form-item"), className)
    }, rest), !hideLabel && /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--label ").concat(prefix, "--skeleton")
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--number ").concat(prefix, "--skeleton")
    }));
  };

  NumberInputSkeleton.propTypes = {
    /**
     * Specify an optional className to add to the form item wrapper.
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the label should be hidden, or not
     */
    hideLabel: PropTypes__default["default"].bool
  };
  var NumberInputSkeleton$1 = NumberInputSkeleton;

  /**
   * @param {Function} propType The original prop type checker.
   * @returns {Function} The new prop type checker for `onChange` that makes it required if `value` exists and `readOnly` does not exist.
   */
  function requiredIfValueExists(propType) {
    return function check(props, propName, componentName) {
      var onChange = props[propName],
          value = props.value,
          readOnly = props.readOnly;
      var exists = onChange !== undefined;
      var valueExists = value !== undefined;

      if (!exists && valueExists && !readOnly) {
        return new Error("You provided a value prop to `".concat(componentName, "` without an `onChange` handler. ") + 'This will render a read-only field. ' + 'If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.');
      }

      for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        rest[_key - 3] = arguments[_key];
      }

      return propType.apply(void 0, [props, propName, componentName].concat(rest));
    };
  }

  var prefix$2 = settings_1.prefix;
  /**
   * @typedef {object} InputProps
   * @property {string} id - The input's id
   * @property {boolean} readOnly - Whether the input should be readonly
   * @property {boolean} disabled - Whether the input should be disabled
   * @property {boolean} invalid - Whether the input should be marked as invalid
   * @property {string} invalidText - The validation message displayed in case the input is considered invalid
   * @property {boolean} warn - Whether the input should be in warning state
   * @property {string} warnText - The validation message displayed in case the input is in warning state
   */

  /**
   * @typedef {object} NormalizedInputProps
   * @property {boolean} disabled - Whether the input is disabled
   * @property {boolean} invalid - Whether the input is invalid (takes precedence over warn)
   * @property {string} invalidId - The invalid message's id
   * @property {boolean} warn - Whether the input is in warning state
   * @property {string} warnId - The warning message's id
   * @property {React.ReactNode | null} validation – React node rendering the appropriate validation message (if any)
   * @property {React.ReactNode | null} icon – React node rendering the appropriate accompanying icon (if any)
   */

  /**
   * Returns an object containing non-colliding props and additional, generated ones.
   * This hook ensures that only either "invalid" or "warn" is true but never both at
   * the same time. Regardless whether "invalid" or "warn", the appropriate validation
   * message is passed as "validation". If the input should be accompanied by an icon
   * (to visually represent a readonly, invalid or warning state), the appropriate icon
   * is passed as "icon".
   * It also ensure that neither "invalid", nor "warn", nor "disabled" are enabled when
   * "readonly" is passed as "readonly" takes precedence over these variants.
   *
   * @param {InputProps} props - The props passed to the component
   * @returns {NormalizedInputProps}
   */

  function useNormalizedInputProps(_ref) {
    var id = _ref.id,
        readOnly = _ref.readOnly,
        disabled = _ref.disabled,
        invalid = _ref.invalid,
        invalidText = _ref.invalidText,
        warn = _ref.warn,
        warnText = _ref.warnText;
    var normalizedProps = {
      disabled: !readOnly && disabled,
      invalid: !readOnly && invalid,
      invalidId: "".concat(id, "-error-msg"),
      warn: !readOnly && !invalid && warn,
      warnId: "".concat(id, "-warn-msg"),
      validation: null,
      icon: null,
      helperId: "".concat(id, "-helper-text")
    };

    if (readOnly) {
      normalizedProps.icon = EditOff16;
    } else {
      if (normalizedProps.invalid) {
        normalizedProps.icon = WarningFilled16;
        normalizedProps.validation = /*#__PURE__*/React__default["default"].createElement("div", {
          className: "".concat(prefix$2, "--form-requirement"),
          id: normalizedProps.invalidId
        }, invalidText);
      } else if (normalizedProps.warn) {
        normalizedProps.icon = WarningAltFilled16;
        normalizedProps.validation = /*#__PURE__*/React__default["default"].createElement("div", {
          className: "".concat(prefix$2, "--form-requirement"),
          id: normalizedProps.warnId
        }, warnText);
      }
    }

    return normalizedProps;
  }

  /**
   * This file contains the list of the default values of compile-time feature flags.
   *
   * Build toolchain can replace variable here and/or the references
   * in order to apply non-default values to those feature flags.
   *
   * @example Render `foo` if `aFeatureFlag` is `true`, render `bar` otherwise.
   * import { aFeatureFlag } from '/path/to/FeatureFlags';
   * ...
   * const MyComponent = props => (<div {...props}>{aFeatureFlag ? 'foo' : 'bar'}</div>);
   */

  /**
   * With this flag, certain components will be created in either a controlled or controlled
   * mode based on the existence of a value prop.
   *
   * The following components will have the significance of their props slightly altered as outlined below.
   *
   * Components: `<NumberInput>`
   *
   * * `value` → when provided, enables controlled mode.
   *   For the rest of the component's lifecycle, it will be controlled by this prop as it's single source of truth.
   * * `defaultValue` → Optional starting value, used for for uncontrolled mode only (no value prop).
   *   The value prop takes precedence over defaultValue.
   * * `onChange` → Optional event handler.
   *   However, if value is provided and a handler is not, we'll throw a warning indicating the component is now read-only
   * * `readOnly` → silences the above warning, acknowledging the read-only state of the component
   *
   * This flag also disables prop -> state sync in several components, notably `<NumberInput>`.
   *
   * This flag also updates event handlers to pass an up-to-date value in the second parameter,
   * so applications can use it in both controlled and uncontrolled components.
   *
   * * _With_ this feature flag, the signature of the event handler will be altered to provide additional context in the second parameter: `onChange(event, { value, ...rest })` where:
   *   * `event` is the (React) raw event
   *   * `value` is the new value
   *   * `rest` tells you additional information based on the source component
   * * _Without_ this feature flag the event handler has component-specific signature, e.g. `onChange(event, direction)`.
   */

  var useControlledStateWithValue = enabled('enable-use-controlled-state-with-value');

  var _excluded$1q = ["className", "disabled", "iconDescription", "id", "hideLabel", "hideSteppers", "label", "max", "min", "step", "value", "readOnly", "invalid", "invalidText", "warn", "warnText", "helperText", "ariaLabel", "light", "allowEmpty", "innerRef", "translateWithId", "isMobile", "size", "defaultValue"];

  var _defaultTranslations$1;
  var translationIds$2 = {
    'increment.number': 'increment.number',
    'decrement.number': 'decrement.number'
  };
  var defaultTranslations$2 = (_defaultTranslations$1 = {}, _defineProperty$2(_defaultTranslations$1, translationIds$2['increment.number'], 'Increment number'), _defineProperty$2(_defaultTranslations$1, translationIds$2['decrement.number'], 'Decrement number'), _defaultTranslations$1);

  var NumberInput = /*#__PURE__*/function (_Component) {
    _inherits(NumberInput, _Component);

    var _super = _createSuper(NumberInput);

    function NumberInput(props) {
      var _this;

      _classCallCheck$1(this, NumberInput);

      _this = _super.call(this, props);

      _defineProperty$2(_assertThisInitialized$1(_this), "_inputRef", null);

      _defineProperty$2(_assertThisInitialized$1(_this), "handleChange", function (evt) {
        var _this$props = _this.props,
            disabled = _this$props.disabled,
            onChange = _this$props.onChange;

        if (!disabled) {
          evt.persist();
          evt.imaginaryTarget = _this._inputRef;
          var prevValue = _this.state.value;
          var value = evt.target.value;
          var direction = prevValue < value ? 'up' : 'down';

          _this.setState({
            value: value
          }, function () {
            if (useControlledStateWithValue) {
              onChange(evt, {
                value: value,
                direction: direction
              });
            } else if (onChange) {
              onChange(evt, {
                value: value,
                direction: direction
              });
            }
          });
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "getDecimalPlaces", function (num) {
        var parts = num.toString().split('.');
        return parts[1] ? parts[1].length : 0;
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "clamp", function (num, min, max) {
        return Math.min(max, Math.max(min, num));
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleArrowClick", function (evt, direction) {
        var value = typeof _this.state.value === 'string' ? Number(_this.state.value) : _this.state.value;
        var _this$props2 = _this.props,
            disabled = _this$props2.disabled,
            min = _this$props2.min,
            max = _this$props2.max,
            step = _this$props2.step,
            onChange = _this$props2.onChange,
            onClick = _this$props2.onClick,
            allowEmpty = _this$props2.allowEmpty;
        var conditional = direction === 'down' ? min !== undefined && value > min || min === undefined : max !== undefined && value < max || max === undefined;

        if (!disabled && conditional) {
          var rawValue = direction === 'down' ? value - step : value + step;
          var precision = Math.max(_this.getDecimalPlaces(value), _this.getDecimalPlaces(step));
          var floatValue = parseFloat(rawValue.toFixed(precision));

          var newValue = _this.clamp(floatValue, min !== null && min !== void 0 ? min : -Infinity, max !== null && max !== void 0 ? max : Infinity);

          var finalValue = allowEmpty && _this.state.value === '' && step === 0 ? '' : newValue;
          evt.persist();
          evt.imaginaryTarget = _this._inputRef;

          _this.setState({
            value: finalValue
          }, function () {
            //TO-DO v11: update these events to return the same things --> evt, {value, direction}
            if (useControlledStateWithValue) {
              onClick && onClick(evt, {
                finalValue: finalValue,
                direction: direction
              });
              onChange && onChange(evt, {
                finalValue: finalValue,
                direction: direction
              });
            } else {
              // value added as a 3rd argument rather than in same obj so it doesn't break in v10
              onClick && onClick(evt, direction, finalValue);
              onChange && onChange(evt, direction, finalValue);
            }
          });
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "_handleInputRef", function (ref) {
        _this._inputRef = ref;
      });

      _this.isControlled = props.value !== undefined;

      if (useControlledStateWithValue && _this.isControlled) {
        // Skips the logic of setting initial state if this component is controlled
        _this.state = {};
        return _possibleConstructorReturn(_this);
      }

      var _value = useControlledStateWithValue || typeof props.defaultValue !== 'undefined' ? props.defaultValue : props.value;

      _value = _value === undefined ? 0 : _value;

      if (props.min || props.min === 0) {
        _value = Math.max(props.min, _value);
      }

      _this.state = {
        value: _value
      };
      return _this;
    }

    _createClass$1(NumberInput, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props3 = this.props,
            className = _this$props3.className,
            disabled = _this$props3.disabled,
            iconDescription = _this$props3.iconDescription,
            id = _this$props3.id,
            hideLabel = _this$props3.hideLabel,
            hideSteppers = _this$props3.hideSteppers,
            label = _this$props3.label,
            max = _this$props3.max,
            min = _this$props3.min,
            step = _this$props3.step,
            value = _this$props3.value,
            readOnly = _this$props3.readOnly,
            invalid = _this$props3.invalid,
            invalidText = _this$props3.invalidText,
            warn = _this$props3.warn,
            warnText = _this$props3.warnText,
            helperText = _this$props3.helperText,
            ariaLabel = _this$props3.ariaLabel,
            light = _this$props3.light,
            allowEmpty = _this$props3.allowEmpty,
            ref = _this$props3.innerRef,
            t = _this$props3.translateWithId,
            isMobile = _this$props3.isMobile,
            size = _this$props3.size;
            _this$props3.defaultValue;
            var other = _objectWithoutProperties$2(_this$props3, _excluded$1q);

        var scope = this.context;
        var enabled;

        if (scope.enabled) {
          enabled = scope.enabled('enable-v11-release');
        }

        return /*#__PURE__*/React__default["default"].createElement(PrefixContext.Consumer, null, function (prefix) {
          var _classNames, _classNames3, _classNames5;

          var numberInputClasses = cx("".concat(prefix, "--number ").concat(prefix, "--number--helpertext"), [enabled ? null : className], (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--number--readonly"), readOnly), _defineProperty$2(_classNames, "".concat(prefix, "--number--light"), light), _defineProperty$2(_classNames, "".concat(prefix, "--number--nolabel"), hideLabel), _defineProperty$2(_classNames, "".concat(prefix, "--number--nosteppers"), hideSteppers), _defineProperty$2(_classNames, "".concat(prefix, "--number--mobile"), isMobile), _defineProperty$2(_classNames, "".concat(prefix, "--number--").concat(size), size), _classNames));
          var isInputInvalid; // If the user supplied `invalid` through props, we'll defer to the passed in value

          if (invalid) {
            isInputInvalid = true;
          } else {
            // Otherwise, if we don't allow an empty value then we check to see
            // if the value is empty, or if it is out of range
            if (!allowEmpty && _this2.state.value === '') {
              isInputInvalid = true;
            } else {
              if (_this2.state.value !== '' && (_this2.state.value > max || _this2.state.value < min)) {
                isInputInvalid = true;
              }
            }
          }

          var normalizedProps = useNormalizedInputProps({
            id: id,
            readOnly: readOnly,
            disabled: disabled,
            invalid: isInputInvalid,
            invalidText: invalidText,
            warn: warn,
            warnText: warnText
          });
          var props = {
            disabled: normalizedProps.disabled,
            id: id,
            max: max,
            min: min,
            step: step,
            onChange: _this2.handleChange,
            value: useControlledStateWithValue && _this2.isControlled ? value : _this2.state.value,
            readOnly: readOnly,
            'aria-label': label ? null : ariaLabel
          };
          var buttonProps = {
            disabled: disabled
          };
          var inputWrapperProps = {};

          if (normalizedProps.invalid) {
            inputWrapperProps['data-invalid'] = true;
          }

          var helperTextClasses = cx("".concat(prefix, "--form__helper-text"), _defineProperty$2({}, "".concat(prefix, "--form__helper-text--disabled"), normalizedProps.disabled));
          var helper = helperText ? /*#__PURE__*/React__default["default"].createElement("div", {
            className: helperTextClasses,
            id: normalizedProps.helperId
          }, helperText) : null;
          var labelClasses = cx("".concat(prefix, "--label"), (_classNames3 = {}, _defineProperty$2(_classNames3, "".concat(prefix, "--label--disabled"), normalizedProps.disabled), _defineProperty$2(_classNames3, "".concat(prefix, "--visually-hidden"), hideLabel), _classNames3));
          var labelText = label ? /*#__PURE__*/React__default["default"].createElement("label", {
            htmlFor: id,
            className: labelClasses
          }, label) : null;
          var _ref = [t('increment.number'), t('decrement.number')],
              incrementNumLabel = _ref[0],
              decrementNumLabel = _ref[1];
          var wrapperClasses = cx("".concat(prefix, "--number__input-wrapper"), _defineProperty$2({}, "".concat(prefix, "--number__input-wrapper--warning"), normalizedProps.warn));
          var iconClasses = cx((_classNames5 = {}, _defineProperty$2(_classNames5, "".concat(prefix, "--number__invalid"), normalizedProps.invalid || normalizedProps.warn), _defineProperty$2(_classNames5, "".concat(prefix, "--number__invalid--warning"), normalizedProps.warn), _defineProperty$2(_classNames5, "".concat(prefix, "--number__readonly-icon"), readOnly), _classNames5));
          var ariaDescribedBy = null;

          if (normalizedProps.invalid) {
            ariaDescribedBy = normalizedProps.invalidId;
          }

          if (normalizedProps.warn) {
            ariaDescribedBy = normalizedProps.warnId;
          }

          if (!normalizedProps.validation) {
            ariaDescribedBy = helperText ? normalizedProps.helperId : undefined;
          }

          return /*#__PURE__*/React__default["default"].createElement("div", {
            className: enabled ? cx("".concat(prefix, "--form-item"), className) : "".concat(prefix, "--form-item")
          }, /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
            className: numberInputClasses
          }, inputWrapperProps), function () {
            return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, labelText, /*#__PURE__*/React__default["default"].createElement("div", {
              className: wrapperClasses
            }, /*#__PURE__*/React__default["default"].createElement("input", _extends$3({
              "data-invalid": normalizedProps.invalid,
              "aria-invalid": normalizedProps.invalid,
              "aria-describedby": ariaDescribedBy,
              type: "number",
              pattern: "[0-9]*"
            }, other, props, {
              ref: mergeRefs$1(ref, _this2._handleInputRef)
            })), normalizedProps.icon && /*#__PURE__*/React__default["default"].createElement(normalizedProps.icon, {
              className: iconClasses
            }), !hideSteppers && /*#__PURE__*/React__default["default"].createElement("div", {
              className: "".concat(prefix, "--number__controls")
            }, /*#__PURE__*/React__default["default"].createElement("button", _extends$3({
              type: "button",
              className: "".concat(prefix, "--number__control-btn down-icon")
            }, buttonProps, {
              onClick: function onClick(evt) {
                return _this2.handleArrowClick(evt, 'down');
              },
              title: decrementNumLabel || iconDescription,
              "aria-label": decrementNumLabel || iconDescription,
              tabIndex: "-1"
            }), /*#__PURE__*/React__default["default"].createElement(Subtract16, {
              className: "down-icon"
            })), /*#__PURE__*/React__default["default"].createElement("div", {
              className: "".concat(prefix, "--number__rule-divider")
            }), /*#__PURE__*/React__default["default"].createElement("button", _extends$3({
              type: "button",
              className: "".concat(prefix, "--number__control-btn up-icon")
            }, buttonProps, {
              onClick: function onClick(evt) {
                return _this2.handleArrowClick(evt, 'up');
              },
              title: incrementNumLabel || iconDescription,
              "aria-label": incrementNumLabel || iconDescription,
              tabIndex: "-1"
            }), /*#__PURE__*/React__default["default"].createElement(Add16, {
              className: "up-icon"
            })), /*#__PURE__*/React__default["default"].createElement("div", {
              className: "".concat(prefix, "--number__rule-divider")
            }))), normalizedProps.validation ? null : helper);
          }(), normalizedProps.validation));
        });
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref2, state) {
        var value = _ref2.value;
        var prevValue = state.prevValue;

        if (useControlledStateWithValue && value === '' && prevValue !== '') {
          return {
            value: '',
            prevValue: ''
          };
        } // If `useControlledStateWithValue` feature flag is on, do nothing here.
        // Otherwise, do prop -> state sync with "value capping".
        //// Value capping removed in #8965


        return useControlledStateWithValue || prevValue === value ? null : {
          value: value,
          prevValue: value
        };
      }
      /**
       * The DOM node reference to the `<input>`.
       * @type {HTMLInputElement}
       */

    }]);

    return NumberInput;
  }(React.Component);

  _defineProperty$2(NumberInput, "propTypes", {
    /**
     * `true` to allow empty string.
     */
    allowEmpty: PropTypes__default["default"].bool,

    /**
     * Provide a description that would be used to best describe the use case of the NumberInput component
     */
    ariaLabel: PropTypes__default["default"].string,

    /**
     * Specify an optional className to be applied to the wrapper node
     */
    className: PropTypes__default["default"].string,

    /**
     * Optional starting value for uncontrolled state
     */
    defaultValue: PropTypes__default["default"].oneOfType([PropTypes__default["default"].number, PropTypes__default["default"].string]),

    /**
     * Specify if the control should be disabled, or not
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Provide text that is used alongside the control label for additional help
     */
    helperText: PropTypes__default["default"].node,

    /**
     * Specify whether you want the underlying label to be visually hidden
     */
    hideLabel: PropTypes__default["default"].bool,

    /**
     * Specify whether you want the steppers to be hidden
     */
    hideSteppers: PropTypes__default["default"].bool,

    /**
     * Provide a description for up/down icons that can be read by screen readers
     */
    iconDescription: PropTypes__default["default"].string.isRequired,

    /**
     * Specify a custom `id` for the input
     */
    id: PropTypes__default["default"].string.isRequired,

    /**
     * Specify if the currently value is invalid.
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * Message which is displayed if the value is invalid.
     */
    invalidText: PropTypes__default["default"].node,

    /**
     * `true` to use the mobile variant.
     */
    isMobile: deprecate(PropTypes__default["default"].bool, "The `isMobile` prop no longer needed as the default NumberInput styles are now identical to the mobile variant styles. This prop will be removed in the next major version of `carbon-components-react`"),

    /**
     * Generic `label` that will be used as the textual representation of what
     * this field is for
     */
    label: PropTypes__default["default"].node,

    /**
     * `true` to use the light version.
     */
    light: PropTypes__default["default"].bool,

    /**
     * The maximum value.
     */
    max: PropTypes__default["default"].number,

    /**
     * The minimum value.
     */
    min: PropTypes__default["default"].number,

    /**
     * The new value is available in 'imaginaryTarget.value'
     * i.e. to get the value: evt.imaginaryTarget.value
     *
     * * _With_ `useControlledStateWithValue` feature flag, the signature of the event handler will be altered to provide additional context in the second parameter: `onChange(event, { value, direction })` where:
     *   * `event` is the (React) raw event
     *   * `value` is the new value
     *   * `direction` tells you the button you hit is up button or down button
     * * _Without_ this feature flag the event handler has `onChange(event, direction)` signature.
     */
    onChange: !useControlledStateWithValue ? PropTypes__default["default"].func : requiredIfValueExists(PropTypes__default["default"].func),

    /**
     * Provide an optional function to be called when the up/down button is clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Specify if the component should be read-only
     */
    readOnly: PropTypes__default["default"].bool,

    /**
     * Specify the size of the Number Input. Currently supports either `sm`, 'md' (default) or 'lg` as an option.
     * TODO V11: remove `xl` (replaced with lg)
     */
    size: PropTypes__default["default"].oneOf(['sm', 'md', 'lg', 'xl']),

    /**
     * Specify how much the values should increase/decrease upon clicking on up/down button
     */
    step: PropTypes__default["default"].number,

    /**
     * Provide custom text for the component for each translation id
     */
    translateWithId: PropTypes__default["default"].func.isRequired,

    /**
     * Specify the value of the input
     */
    value: PropTypes__default["default"].oneOfType([PropTypes__default["default"].number, PropTypes__default["default"].string]),

    /**
     * Specify whether the control is currently in warning state
     */
    warn: PropTypes__default["default"].bool,

    /**
     * Provide the text that is displayed when the control is in warning state
     */
    warnText: PropTypes__default["default"].node
  });

  _defineProperty$2(NumberInput, "defaultProps", {
    disabled: false,
    hideLabel: false,
    iconDescription: enabled('enable-v11-release') ? undefined : 'choose a number',
    step: 1,
    invalid: false,
    invalidText: enabled('enable-v11-release') ? undefined : 'Provide invalidText',
    warn: false,
    warnText: '',
    ariaLabel: 'Numeric input field with increment and decrement buttons',
    helperText: '',
    light: false,
    allowEmpty: false,
    translateWithId: function translateWithId(id) {
      return defaultTranslations$2[id];
    }
  });

  _defineProperty$2(NumberInput, "contextType", FeatureFlagContext);
  var NumberInput$1 = (function () {
    var forwardRef = function forwardRef(props, ref) {
      return /*#__PURE__*/React__default["default"].createElement(NumberInput, _extends$3({}, props, {
        innerRef: ref
      }));
    };

    forwardRef.displayName = 'NumberInput';
    return /*#__PURE__*/React__default["default"].forwardRef(forwardRef);
  })();

  /**
   * This custom hook simplifies the behavior of a component if it has state that
   * can be both controlled and uncontrolled. It functions identical to a
   * useState() hook and provides [state, setState] for you to use. You can use
   * the `onChange` argument to allow updates to the `state` to be communicated to
   * owners of controlled components.
   *
   * Note: this hook will warn if a component is switching from controlled to
   * uncontrolled, or vice-verse.
   *
   * @param {object} config
   * @param {string} config.name - the name of the custom component
   * @param {any} config.defaultValue - the default value used for the state. This will be
   * the fallback value used if `value` is not defined.
   * @param {Function} config.onChange - an optional function that is called when
   * the value of the state changes. This is useful for communicating to parents of
   * controlled components that the value is requesting to be changed.
   * @param {any} config.value - a controlled value. Omitting this means that the state is
   * uncontrolled
   * @returns {[any, Function]}
   */

  function useControllableState(_ref) {
    var defaultValue = _ref.defaultValue,
        _ref$name = _ref.name,
        name = _ref$name === void 0 ? 'custom' : _ref$name,
        onChange = _ref.onChange,
        value = _ref.value;

    var _useState = React.useState(value !== null && value !== void 0 ? value : defaultValue),
        _useState2 = _slicedToArray$1(_useState, 2),
        state = _useState2[0],
        internalSetState = _useState2[1];

    var controlled = React.useRef(null);

    if (controlled.current === null) {
      controlled.current = value !== undefined;
    }

    function setState(stateOrUpdater) {
      var value = typeof stateOrUpdater === 'function' ? stateOrUpdater(state) : stateOrUpdater;

      if (controlled.current === false) {
        internalSetState(value);
      }

      if (onChange) {
        onChange(value);
      }
    }

    React.useEffect(function () {
      var controlledValue = value !== undefined; // Uncontrolled -> Controlled
      // If the component prop is uncontrolled, the prop value should be undefined

      if (controlled.current === false && controlledValue) {
        warning(false, 'A component is changing an uncontrolled %s component to be controlled. ' + 'This is likely caused by the value changing to a defined value ' + 'from undefined. Decide between using a controlled or uncontrolled ' + 'value for the lifetime of the component. ' + 'More info: https://reactjs.org/link/controlled-components', name) ;
      } // Controlled -> Uncontrolled
      // If the component prop is controlled, the prop value should be defined


      if (controlled.current === true && !controlledValue) {
        warning(false, 'A component is changing a controlled %s component to be uncontrolled. ' + 'This is likely caused by the value changing to an undefined value ' + 'from a defined one. Decide between using a controlled or ' + 'uncontrolled value for the lifetime of the component. ' + 'More info: https://reactjs.org/link/controlled-components', name) ;
      }
    }, [name, value]);

    if (controlled.current === true) {
      return [value, setState, controlled.current];
    }

    return [state, setState, controlled.current];
  }

  /*
   * Copyright 2020 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var $488c6ddbf4ef74c2$var$formatterCache = new Map();
  var $488c6ddbf4ef74c2$var$supportsSignDisplay = false;

  try {
    $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat('de-DE', {
      signDisplay: 'exceptZero'
    }).resolvedOptions().signDisplay === 'exceptZero'; // eslint-disable-next-line no-empty
  } catch (_unused) {}

  var $488c6ddbf4ef74c2$var$supportsUnit = false;

  try {
    $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat('de-DE', {
      style: 'unit',
      unit: 'degree'
    }).resolvedOptions().style === 'unit'; // eslint-disable-next-line no-empty
  } catch (_unused2) {} // Polyfill for units since Safari doesn't support them yet. See https://bugs.webkit.org/show_bug.cgi?id=215438.
  // Currently only polyfilling the unit degree in narrow format for ColorSlider in our supported locales.
  // Values were determined by switching to each locale manually in Chrome.


  var $488c6ddbf4ef74c2$var$UNITS = {
    degree: {
      narrow: {
        default: "\xb0",
        'ja-JP': " \u5EA6",
        'zh-TW': "\u5EA6",
        'sl-SI': " \xb0"
      }
    }
  };

  var $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 = /*#__PURE__*/function () {
    function $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5(locale) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck$1(this, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5);

      this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);
      this.options = options;
    }

    _createClass$1($488c6ddbf4ef74c2$export$cc77c4ff7e8673c5, [{
      key: "format",
      value:
      /** Formats a number value as a string, according to the locale and options provided to the constructor. */
      function format(value) {
        var res = '';
        if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);else res = this.numberFormatter.format(value);

        if (this.options.style === 'unit' && !$488c6ddbf4ef74c2$var$supportsUnit) {
          var _UNITS_unit;

          var _this$resolvedOptions = this.resolvedOptions(),
              unit = _this$resolvedOptions.unit,
              _this$resolvedOptions2 = _this$resolvedOptions.unitDisplay,
              unitDisplay = _this$resolvedOptions2 === void 0 ? 'short' : _this$resolvedOptions2,
              locale = _this$resolvedOptions.locale;

          if (!unit) return res;
          var values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];
          res += values[locale] || values.default;
        }

        return res;
      }
      /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */

    }, {
      key: "formatToParts",
      value: function formatToParts(value) {
        // TODO: implement signDisplay for formatToParts
        return this.numberFormatter.formatToParts(value);
      }
      /** Formats a number range as a string. */

    }, {
      key: "formatRange",
      value: function formatRange(start, end) {
        if (typeof this.numberFormatter.formatRange === 'function') return this.numberFormatter.formatRange(start, end);
        if (end < start) throw new RangeError('End date must be >= start date'); // Very basic fallback for old browsers.

        return "".concat(this.format(start), " \u2013 ").concat(this.format(end));
      }
      /** Formats a number range as an array of parts. */

    }, {
      key: "formatRangeToParts",
      value: function formatRangeToParts(start, end) {
        if (typeof this.numberFormatter.formatRangeToParts === 'function') return this.numberFormatter.formatRangeToParts(start, end);
        if (end < start) throw new RangeError('End date must be >= start date');
        var startParts = this.numberFormatter.formatToParts(start);
        var endParts = this.numberFormatter.formatToParts(end);
        return [].concat(_toConsumableArray(startParts.map(function (p) {
          return _objectSpread2$2(_objectSpread2$2({}, p), {}, {
            source: 'startRange'
          });
        })), [{
          type: 'literal',
          value: " \u2013 ",
          source: 'shared'
        }], _toConsumableArray(endParts.map(function (p) {
          return _objectSpread2$2(_objectSpread2$2({}, p), {}, {
            source: 'endRange'
          });
        })));
      }
      /** Returns the resolved formatting options based on the values passed to the constructor. */

    }, {
      key: "resolvedOptions",
      value: function resolvedOptions() {
        var options = this.numberFormatter.resolvedOptions();
        if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = _objectSpread2$2(_objectSpread2$2({}, options), {}, {
          signDisplay: this.options.signDisplay
        });
        if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === 'unit') options = _objectSpread2$2(_objectSpread2$2({}, options), {}, {
          style: 'unit',
          unit: this.options.unit,
          unitDisplay: this.options.unitDisplay
        });
        return options;
      }
    }]);

    return $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5;
  }();

  function $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _options = options,
        numberingSystem = _options.numberingSystem;

    if (numberingSystem && locale.includes('-nu-')) {
      if (!locale.includes('-u-')) locale += '-u-';
      locale += "-nu-".concat(numberingSystem);
    }

    if (options.style === 'unit' && !$488c6ddbf4ef74c2$var$supportsUnit) {
      var _UNITS_unit;

      var _options2 = options,
          unit = _options2.unit,
          _options2$unitDisplay = _options2.unitDisplay,
          unitDisplay = _options2$unitDisplay === void 0 ? 'short' : _options2$unitDisplay;
      if (!unit) throw new Error('unit option must be provided with style: "unit"');
      if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error("Unsupported unit ".concat(unit, " with unitDisplay = ").concat(unitDisplay));
      options = _objectSpread2$2(_objectSpread2$2({}, options), {}, {
        style: 'decimal'
      });
    }

    var cacheKey = locale + (options ? Object.entries(options).sort(function (a, b) {
      return a[0] < b[0] ? -1 : 1;
    }).join() : '');
    if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);
    var numberFormatter = new Intl.NumberFormat(locale, options);
    $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);
    return numberFormatter;
  }

  function $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {
    if (signDisplay === 'auto') return numberFormat.format(num);else if (signDisplay === 'never') return numberFormat.format(Math.abs(num));else {
      var needsPositiveSign = false;
      if (signDisplay === 'always') needsPositiveSign = num > 0 || Object.is(num, 0);else if (signDisplay === 'exceptZero') {
        if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);else needsPositiveSign = num > 0;
      }

      if (needsPositiveSign) {
        var negative = numberFormat.format(-num);
        var noSign = numberFormat.format(num); // ignore RTL/LTR marker character

        var minus = negative.replace(noSign, '').replace(/\u200e|\u061C/, '');
        if (_toConsumableArray(minus).length !== 1) console.warn('@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case');
        var positive = negative.replace(noSign, '!!!').replace(minus, '+').replace('!!!', noSign);
        return positive;
      } else return numberFormat.format(num);
    }
  }

  /*
   * Copyright 2020 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  var $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp('^.*\\(.*\\).*$');
  var $6c7bd7858deea686$var$NUMBERING_SYSTEMS = ['latn', 'arab', 'hanidec', 'deva', 'beng'];

  var $6c7bd7858deea686$export$cd11ab140839f11d = /*#__PURE__*/function () {
    function $6c7bd7858deea686$export$cd11ab140839f11d(locale) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck$1(this, $6c7bd7858deea686$export$cd11ab140839f11d);

      this.locale = locale;
      this.options = options;
    }

    _createClass$1($6c7bd7858deea686$export$cd11ab140839f11d, [{
      key: "parse",
      value:
      /**
      * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
      */
      function parse(value) {
        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);
      }
      /**
      * Returns whether the given string could potentially be a valid number. This should be used to
      * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
      * of the minus/plus sign characters can be checked.
      */

    }, {
      key: "isValidPartialNumber",
      value: function isValidPartialNumber(value, minValue, maxValue) {
        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);
      }
      /**
      * Returns a numbering system for which the given string is valid in the current locale.
      * If no numbering system could be detected, the default numbering system for the current
      * locale is returned.
      */

    }, {
      key: "getNumberingSystem",
      value: function getNumberingSystem(value) {
        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;
      }
    }]);

    return $6c7bd7858deea686$export$cd11ab140839f11d;
  }();

  var $6c7bd7858deea686$var$numberParserCache = new Map();

  function $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {
    // First try the default numbering system for the provided locale
    var defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options); // If that doesn't match, and the locale doesn't include a hard coded numbering system,
    // try each of the other supported numbering systems until we find one that matches.

    if (!locale.includes('-nu-') && !defaultParser.isValidPartialNumber(value)) {
      var _iterator = _createForOfIteratorHelper$1($6c7bd7858deea686$var$NUMBERING_SYSTEMS),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var numberingSystem = _step.value;

          if (numberingSystem !== defaultParser.options.numberingSystem) {
            var parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes('-u-') ? '-nu-' : '-u-nu-') + numberingSystem, options);
            if (parser.isValidPartialNumber(value)) return parser;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }

    return defaultParser;
  }

  function $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {
    var cacheKey = locale + (options ? Object.entries(options).sort(function (a, b) {
      return a[0] < b[0] ? -1 : 1;
    }).join() : '');
    var parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);

    if (!parser) {
      parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);
      $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);
    }

    return parser;
  } // The actual number parser implementation. Instances of this class are cached
  // based on the locale, options, and detected numbering system.


  var $6c7bd7858deea686$var$NumberParserImpl = /*#__PURE__*/function () {
    function $6c7bd7858deea686$var$NumberParserImpl(locale) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck$1(this, $6c7bd7858deea686$var$NumberParserImpl);

      this.locale = locale; // see https://tc39.es/ecma402/#sec-setnfdigitoptions, when using roundingIncrement, the maximumFractionDigits and minimumFractionDigits must be equal
      // by default, they are 0 and 3 respectively, so we set them to 0 if neither are set

      if (options.roundingIncrement !== 1 && options.roundingIncrement != null) {
        if (options.maximumFractionDigits == null && options.minimumFractionDigits == null) {
          options.maximumFractionDigits = 0;
          options.minimumFractionDigits = 0;
        } else if (options.maximumFractionDigits == null) options.maximumFractionDigits = options.minimumFractionDigits;else if (options.minimumFractionDigits == null) options.minimumFractionDigits = options.maximumFractionDigits; // if both are specified, let the normal Range Error be thrown

      }

      this.formatter = new Intl.NumberFormat(locale, options);
      this.options = this.formatter.resolvedOptions();
      this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);

      var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;

      if (this.options.style === 'percent' && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn('NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.');
    }

    _createClass$1($6c7bd7858deea686$var$NumberParserImpl, [{
      key: "parse",
      value: function parse(value) {
        // to parse the number, we need to remove anything that isn't actually part of the number, for example we want '-10.40' not '-10.40 USD'
        var fullySanitizedValue = this.sanitize(value);
        if (this.symbols.group) // Remove group characters, and replace decimal points and numerals with ASCII values.
          fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, '');
        if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, '.');
        if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, '-');
        fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);

        if (this.options.style === 'percent') {
          // javascript is bad at dividing by 100 and maintaining the same significant figures, so perform it on the string before parsing
          var isNegative = fullySanitizedValue.indexOf('-');
          fullySanitizedValue = fullySanitizedValue.replace('-', '');
          fullySanitizedValue = fullySanitizedValue.replace('+', '');
          var index = fullySanitizedValue.indexOf('.');
          if (index === -1) index = fullySanitizedValue.length;
          fullySanitizedValue = fullySanitizedValue.replace('.', '');
          if (index - 2 === 0) fullySanitizedValue = "0.".concat(fullySanitizedValue);else if (index - 2 === -1) fullySanitizedValue = "0.0".concat(fullySanitizedValue);else if (index - 2 === -2) fullySanitizedValue = '0.00';else fullySanitizedValue = "".concat(fullySanitizedValue.slice(0, index - 2), ".").concat(fullySanitizedValue.slice(index - 2));
          if (isNegative > -1) fullySanitizedValue = "-".concat(fullySanitizedValue);
        }

        var newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
        if (isNaN(newValue)) return NaN;

        if (this.options.style === 'percent') {
          var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits; // extra step for rounding percents to what our formatter would output


          var options = _objectSpread2$2(_objectSpread2$2({}, this.options), {}, {
            style: 'decimal',
            minimumFractionDigits: Math.min(((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) + 2, 20),
            maximumFractionDigits: Math.min(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2, 20)
          });

          return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new ($488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(this.locale, options).format(newValue));
        } // accounting will always be stripped to a positive number, so if it's accounting and has a () around everything, then we need to make it negative again


        if (this.options.currencySign === 'accounting' && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;
        return newValue;
      }
    }, {
      key: "sanitize",
      value: function sanitize(value) {
        // Remove literals and whitespace, which are allowed anywhere in the string
        value = value.replace(this.symbols.literals, ''); // Replace the ASCII minus sign with the minus sign used in the current locale
        // so that both are allowed in case the user's keyboard doesn't have the locale's minus sign.

        if (this.symbols.minusSign) value = value.replace('-', this.symbols.minusSign); // In arab numeral system, their decimal character is 1643, but most keyboards don't type that
        // instead they use the , (44) character or apparently the (1548) character.

        if (this.options.numberingSystem === 'arab') {
          if (this.symbols.decimal) {
            value = value.replace(',', this.symbols.decimal);
            value = value.replace(String.fromCharCode(1548), this.symbols.decimal);
          }

          if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, '.', this.symbols.group);
        } // fr-FR group character is narrow non-breaking space, char code 8239 (U+202F), but that's not a key on the french keyboard,
        // so allow space and non-breaking space as a group char as well


        if (this.options.locale === 'fr-FR' && this.symbols.group) {
          value = $6c7bd7858deea686$var$replaceAll(value, ' ', this.symbols.group);
          value = $6c7bd7858deea686$var$replaceAll(value, /\u00A0/g, this.symbols.group);
        }

        return value;
      }
    }, {
      key: "isValidPartialNumber",
      value: function isValidPartialNumber(value) {
        var minValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -Infinity;
        var maxValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;
        value = this.sanitize(value); // Remove minus or plus sign, which must be at the start of the string.

        if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) value = value.slice(this.symbols.plusSign.length); // Numbers cannot start with a group separator

        if (this.symbols.group && value.startsWith(this.symbols.group)) return false; // Numbers that can't have any decimal values fail if a decimal character is typed

        if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false; // Remove numerals, groups, and decimals

        if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, '');
        value = value.replace(this.symbols.numeral, '');
        if (this.symbols.decimal) value = value.replace(this.symbols.decimal, ''); // The number is valid if there are no remaining characters

        return value.length === 0;
      }
    }]);

    return $6c7bd7858deea686$var$NumberParserImpl;
  }();

  var $6c7bd7858deea686$var$nonLiteralParts = new Set(['decimal', 'fraction', 'integer', 'minusSign', 'plusSign', 'group']); // This list is derived from https://www.unicode.org/cldr/charts/43/supplemental/language_plural_rules.html#comparison and includes
  // all unique numbers which we need to check in order to determine all the plural forms for a given locale.
  // See: https://github.com/adobe/react-spectrum/pull/5134/files#r1337037855 for used script

  var $6c7bd7858deea686$var$pluralNumbers = [0, 4, 2, 1, 11, 20, 3, 7, 100, 21, 0.1, 1.1];

  function $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {
    var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1; // formatter needs access to all decimal places in order to generate the correct literal strings for the plural set


    var symbolFormatter = new Intl.NumberFormat(locale, _objectSpread2$2(_objectSpread2$2({}, intlOptions), {}, {
      // Resets so we get the full range of symbols
      minimumSignificantDigits: 1,
      maximumSignificantDigits: 21,
      roundingIncrement: 1,
      roundingPriority: 'auto',
      roundingMode: 'halfExpand'
    })); // Note: some locale's don't add a group symbol until there is a ten thousands place

    var allParts = symbolFormatter.formatToParts(-10000.111);
    var posAllParts = symbolFormatter.formatToParts(10000.111);
    var pluralParts = $6c7bd7858deea686$var$pluralNumbers.map(function (n) {
      return symbolFormatter.formatToParts(n);
    });

    var _allParts_find_value;

    var minusSign = (_allParts_find_value = (_allParts_find = allParts.find(function (p) {
      return p.type === 'minusSign';
    })) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : '-';
    var plusSign = (_posAllParts_find = posAllParts.find(function (p) {
      return p.type === 'plusSign';
    })) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value; // Safari does not support the signDisplay option, but our number parser polyfills it.
    // If no plus sign was returned, but the original options contained signDisplay, default to the '+' character.

    if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === 'exceptZero' || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === 'always')) plusSign = '+'; // If maximumSignificantDigits is 1 (the minimum) then we won't get decimal characters out of the above formatters
    // Percent also defaults to 0 fractionDigits, so we need to make a new one that isn't percent to get an accurate decimal

    var decimalParts = new Intl.NumberFormat(locale, _objectSpread2$2(_objectSpread2$2({}, intlOptions), {}, {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    })).formatToParts(0.001);
    var decimal = (_decimalParts_find = decimalParts.find(function (p) {
      return p.type === 'decimal';
    })) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;
    var group = (_allParts_find1 = allParts.find(function (p) {
      return p.type === 'group';
    })) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value; // this set is also for a regex, it's all literals that might be in the string we want to eventually parse that
    // don't contribute to the numerical value

    var allPartsLiterals = allParts.filter(function (p) {
      return !$6c7bd7858deea686$var$nonLiteralParts.has(p.type);
    }).map(function (p) {
      return $6c7bd7858deea686$var$escapeRegex(p.value);
    });
    var pluralPartsLiterals = pluralParts.flatMap(function (p) {
      return p.filter(function (p) {
        return !$6c7bd7858deea686$var$nonLiteralParts.has(p.type);
      }).map(function (p) {
        return $6c7bd7858deea686$var$escapeRegex(p.value);
      });
    });

    var sortedLiterals = _toConsumableArray(new Set([].concat(_toConsumableArray(allPartsLiterals), _toConsumableArray(pluralPartsLiterals)))).sort(function (a, b) {
      return b.length - a.length;
    });

    var literals = sortedLiterals.length === 0 ? new RegExp('[\\p{White_Space}]', 'gu') : new RegExp("".concat(sortedLiterals.join('|'), "|[\\p{White_Space}]"), 'gu'); // These are for replacing non-latn characters with the latn equivalent

    var numerals = _toConsumableArray(new Intl.NumberFormat(intlOptions.locale, {
      useGrouping: false
    }).format(9876543210)).reverse();

    var indexes = new Map(numerals.map(function (d, i) {
      return [d, i];
    }));
    var numeral = new RegExp("[".concat(numerals.join(''), "]"), 'g');

    var index = function index(d) {
      return String(indexes.get(d));
    };

    return {
      minusSign: minusSign,
      plusSign: plusSign,
      decimal: decimal,
      group: group,
      literals: literals,
      numeral: numeral,
      index: index
    };
  }

  function $6c7bd7858deea686$var$replaceAll(str, find, replace) {
    if (str.replaceAll) return str.replaceAll(find, replace);
    return str.split(find).join(replace);
  }

  function $6c7bd7858deea686$var$escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  var NumberFormatOptionsPropType = PropTypes__default["default"].shape({
    // Locale Options
    localeMatcher: PropTypes__default["default"].oneOf(['best fit', 'lookup']),
    // Style Options
    style: PropTypes__default["default"].oneOf(['decimal', 'currency', 'percent', 'unit']),
    currency: PropTypes__default["default"].string,
    // e.g., 'USD'
    currencyDisplay: PropTypes__default["default"].oneOf(['symbol', 'narrowSymbol', 'code', 'name']),
    currencySign: PropTypes__default["default"].oneOf(['standard', 'accounting']),
    unit: PropTypes__default["default"].string,
    // e.g., 'liter', 'mile-per-hour'
    unitDisplay: PropTypes__default["default"].oneOf(['short', 'narrow', 'long']),
    notation: PropTypes__default["default"].oneOf(['standard', 'scientific', 'engineering', 'compact']),
    compactDisplay: PropTypes__default["default"].oneOf(['short', 'long']),
    signDisplay: PropTypes__default["default"].oneOf(['auto', 'never', 'always', 'exceptZero']),
    // Digit Options
    minimumIntegerDigits: PropTypes__default["default"].number,
    minimumFractionDigits: PropTypes__default["default"].number,
    maximumFractionDigits: PropTypes__default["default"].number,
    minimumSignificantDigits: PropTypes__default["default"].number,
    maximumSignificantDigits: PropTypes__default["default"].number,
    useGrouping: PropTypes__default["default"].oneOfType([PropTypes__default["default"].bool, PropTypes__default["default"].oneOf(['always', 'auto', 'min2'])]),
    // Misc/Other Options
    numberingSystem: PropTypes__default["default"].string,
    // e.g., 'latn', 'arab'
    roundingIncrement: PropTypes__default["default"].number,
    roundingMode: PropTypes__default["default"].oneOf(['ceil', 'floor', 'expand', 'trunc', 'halfCeil', 'halfFloor', 'halfExpand', 'halfTrunc', 'halfEven']),
    trailingZeroDisplay: PropTypes__default["default"].oneOf(['auto', 'stripIfInteger'])
  });

  var _excluded$1p = ["allowEmpty", "className", "decorator", "disabled", "disableWheel", "defaultValue", "formatOptions", "helperText", "hideLabel", "hideSteppers", "iconDescription", "id", "inputMode", "invalid", "invalidText", "label", "light", "locale", "max", "min", "onChange", "onBlur", "onClick", "onKeyUp", "pattern", "readOnly", "size", "slug", "step", "translateWithId", "type", "warn", "warnText", "value"];

  var _defaultTranslations;
  var translationIds$1 = {
    'increment.number': 'increment.number',
    'decrement.number': 'decrement.number'
  };

  var clamp = function clamp(num, min, max) {
    return Math.min(max, Math.max(min, num));
  };
  /**
   * Message ids that will be passed to translateWithId().
   */


  var defaultTranslations$1 = (_defaultTranslations = {}, _defineProperty$2(_defaultTranslations, translationIds$1['increment.number'], 'Increment number'), _defineProperty$2(_defaultTranslations, translationIds$1['decrement.number'], 'Decrement number'), _defaultTranslations);
  var NumberInputV2 = /*#__PURE__*/React__default["default"].forwardRef(function NumberInputV2(props, forwardRef) {
    var _classNames, _classNames2, _classNames3, _classNames4, _normalizedDecorator, _normalizedDecorator$, _normalizedDecorator2, _normalizedDecorator3;

    var _props$allowEmpty = props.allowEmpty,
        allowEmpty = _props$allowEmpty === void 0 ? false : _props$allowEmpty,
        customClassName = props.className,
        decorator = props.decorator,
        _props$disabled = props.disabled,
        disabled = _props$disabled === void 0 ? false : _props$disabled,
        _props$disableWheel = props.disableWheel,
        disableWheelProp = _props$disableWheel === void 0 ? false : _props$disableWheel,
        _props$defaultValue = props.defaultValue,
        defaultValue = _props$defaultValue === void 0 ? type === 'number' ? 0 : NaN : _props$defaultValue,
        formatOptions = props.formatOptions,
        _props$helperText = props.helperText,
        helperText = _props$helperText === void 0 ? '' : _props$helperText,
        _props$hideLabel = props.hideLabel,
        hideLabel = _props$hideLabel === void 0 ? false : _props$hideLabel,
        hideSteppers = props.hideSteppers,
        iconDescription = props.iconDescription,
        id = props.id,
        inputMode = props.inputMode,
        _props$invalid = props.invalid,
        invalid = _props$invalid === void 0 ? false : _props$invalid,
        invalidText = props.invalidText,
        label = props.label,
        light = props.light,
        _props$locale = props.locale,
        locale = _props$locale === void 0 ? 'en-US' : _props$locale,
        max = props.max,
        min = props.min,
        onChange = props.onChange,
        _onBlur = props.onBlur,
        onClick = props.onClick,
        onKeyUp = props.onKeyUp,
        _props$pattern = props.pattern,
        pattern = _props$pattern === void 0 ? '[0-9]*' : _props$pattern,
        readOnly = props.readOnly,
        _props$size = props.size,
        size = _props$size === void 0 ? 'md' : _props$size,
        slug = props.slug,
        _props$step = props.step,
        step = _props$step === void 0 ? 1 : _props$step,
        _props$translateWithI = props.translateWithId,
        t = _props$translateWithI === void 0 ? function (id) {
      return defaultTranslations$1[id];
    } : _props$translateWithI,
        _props$type = props.type,
        type = _props$type === void 0 ? 'number' : _props$type,
        _props$warn = props.warn,
        warn = _props$warn === void 0 ? false : _props$warn,
        _props$warnText = props.warnText,
        warnText = _props$warnText === void 0 ? '' : _props$warnText,
        controlledValue = props.value,
        rest = _objectWithoutProperties$2(props, _excluded$1p);

    var prefix = usePrefix();

    var _useContext = React.useContext(FormContext),
        isFluid = _useContext.isFluid;

    var _useState = React.useState(false),
        _useState2 = _slicedToArray$1(_useState, 2),
        isFocused = _useState2[0],
        setIsFocused = _useState2[1];

    var _useState3 = React.useState(function () {
      if (controlledValue !== undefined) {
        return controlledValue;
      }

      if (defaultValue !== undefined) {
        return defaultValue;
      }

      if (allowEmpty) {
        return '';
      }

      return 0;
    }),
        _useState4 = _slicedToArray$1(_useState3, 2),
        value = _useState4[0],
        setValue = _useState4[1];

    var _useState5 = React.useState(controlledValue),
        _useState6 = _slicedToArray$1(_useState5, 2),
        prevControlledValue = _useState6[0],
        setPrevControlledValue = _useState6[1];

    var numberParser = React.useMemo(function () {
      return new $6c7bd7858deea686$export$cd11ab140839f11d(locale, formatOptions);
    }, [locale, formatOptions]);

    var _useControllableState = useControllableState({
      name: 'NumberInputV2',
      defaultValue: typeof defaultValue === 'string' ? numberParser.parse(defaultValue) : defaultValue,
      value: typeof controlledValue === 'string' ? numberParser.parse(controlledValue) : controlledValue
    }),
        _useControllableState2 = _slicedToArray$1(_useControllableState, 3),
        numberValue = _useControllableState2[0],
        setNumberValue = _useControllableState2[1],
        isControlled = _useControllableState2[2];
    /**
     * The number value that was previously "committed" to the input on blur
     * Only used when type="text"
     */


    var _useState7 = React.useState(numberValue),
        _useState8 = _slicedToArray$1(_useState7, 2),
        previousNumberValue = _useState8[0],
        setPreviousNumberValue = _useState8[1];

    var _useState9 = React.useState(function () {
      return isNaN(numberValue) ? '' : new $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5(locale, formatOptions).format(numberValue);
    }),
        _useState10 = _slicedToArray$1(_useState9, 2),
        inputValue = _useState10[0],
        setInputValue = _useState10[1];

    var numberingSystem = React.useMemo(function () {
      return numberParser.getNumberingSystem(inputValue);
    }, [numberParser, inputValue]);
    var numberFormatter = React.useMemo(function () {
      return new $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5(locale, _objectSpread2$2(_objectSpread2$2({}, formatOptions), {}, {
        numberingSystem: numberingSystem
      }));
    }, [locale, formatOptions, numberingSystem]);
    var format = React.useCallback(function (value) {
      return isNaN(value) || value === null ? '' : numberFormatter.format(value);
    }, [numberFormatter]);

    if (isControlled && !(isNaN(previousNumberValue) && isNaN(numberValue)) && previousNumberValue !== numberValue) {
      setInputValue(format(numberValue));
      setPreviousNumberValue(numberValue);
    }

    var inputRef = React.useRef(null);
    var ref = useMergedRefs([forwardRef, inputRef]);
    var numberInputClasses = cx((_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--number"), true), _defineProperty$2(_classNames, "".concat(prefix, "--number--helpertext"), true), _defineProperty$2(_classNames, "".concat(prefix, "--number--readonly"), readOnly), _defineProperty$2(_classNames, "".concat(prefix, "--number--light"), light), _defineProperty$2(_classNames, "".concat(prefix, "--number--nolabel"), hideLabel), _defineProperty$2(_classNames, "".concat(prefix, "--number--nosteppers"), hideSteppers), _defineProperty$2(_classNames, "".concat(prefix, "--number--").concat(size), size), _classNames));
    var isInputValid = getInputValidity({
      allowEmpty: allowEmpty,
      invalid: invalid,
      value: type === 'number' ? value : numberValue,
      max: max,
      min: min
    });
    var normalizedProps = useNormalizedInputProps({
      id: id,
      readOnly: readOnly,
      disabled: disabled,
      invalid: !isInputValid,
      invalidText: invalidText,
      warn: warn,
      warnText: warnText
    });
    var _ref = [t('increment.number'), t('decrement.number')],
        incrementNumLabel = _ref[0],
        decrementNumLabel = _ref[1];
    var wrapperClasses = cx("".concat(prefix, "--number__input-wrapper"), (_classNames2 = {}, _defineProperty$2(_classNames2, "".concat(prefix, "--number__input-wrapper--warning"), normalizedProps.warn), _defineProperty$2(_classNames2, "".concat(prefix, "--number__input-wrapper--slug"), slug), _defineProperty$2(_classNames2, "".concat(prefix, "--number__input-wrapper--decorator"), decorator), _classNames2));
    var iconClasses = cx((_classNames3 = {}, _defineProperty$2(_classNames3, "".concat(prefix, "--number__invalid"), normalizedProps.invalid || normalizedProps.warn), _defineProperty$2(_classNames3, "".concat(prefix, "--number__invalid--warning"), normalizedProps.warn), _defineProperty$2(_classNames3, "".concat(prefix, "--number__readonly-icon"), readOnly), _classNames3));

    if (controlledValue !== prevControlledValue && !(isNaN(Number(controlledValue)) === isNaN(Number(prevControlledValue)))) {
      setValue(controlledValue);
      setPrevControlledValue(controlledValue);
    }

    var ariaDescribedBy;

    if (normalizedProps.invalid) {
      ariaDescribedBy = normalizedProps.invalidId;
    } else if (normalizedProps.warn) {
      ariaDescribedBy = normalizedProps.warnId;
    } else if (!normalizedProps.validation) {
      ariaDescribedBy = helperText ? normalizedProps.helperId : undefined;
    }

    function handleOnChange(event) {
      if (disabled) {
        return;
      }

      if (type === 'number') {
        var state = {
          value: allowEmpty && event.target.value === '' ? '' : Number(event.target.value),
          direction: value < event.target.value ? 'up' : 'down'
        };
        setValue(state.value);

        if (onChange) {
          onChange(event, state);
        }

        return;
      }

      if (type === 'text') {
        var _value = allowEmpty && event.target.value === '' ? '' : event.target.value; // When isControlled, setNumberValue will not update numberValue in useControllableState.


        setNumberValue(numberParser.parse(_value));
        setInputValue(_value);
      }
    }

    var handleFocus = function handleFocus(evt) {
      setIsFocused(evt.type === 'focus');
    };

    var outerElementClasses = cx("".concat(prefix, "--form-item"), (_classNames4 = {}, _defineProperty$2(_classNames4, customClassName, !!customClassName), _defineProperty$2(_classNames4, "".concat(prefix, "--number-input--fluid--invalid"), isFluid && normalizedProps.invalid), _defineProperty$2(_classNames4, "".concat(prefix, "--number-input--fluid--focus"), isFluid && isFocused), _defineProperty$2(_classNames4, "".concat(prefix, "--number-input--fluid--disabled"), isFluid && disabled), _classNames4));
    var Icon = normalizedProps.icon;

    var getDecimalPlaces = function getDecimalPlaces(num) {
      var parts = num.toString().split('.');
      return parts[1] ? parts[1].length : 0;
    };

    var handleStep = function handleStep(event, direction) {
      if (inputRef.current) {
        var currentValue = type === 'number' ? Number(inputRef.current.value) : numberValue;
        var rawValue;

        if (Number.isNaN(currentValue)) {
          // When the field is empty (NaN), incrementing begins at min,
          // decrementing begins at max.
          // When there's no min or max to use, it begins at 0.
          if (direction === "up" && min) {
            rawValue = min;
          } else if (direction === "down" && max) {
            rawValue = max;
          } else {
            rawValue = 0;
          }
        } else if (direction === 'up') {
          rawValue = currentValue + step;
        } else {
          rawValue = currentValue - step;
        }

        var precision = Math.max(getDecimalPlaces(currentValue), getDecimalPlaces(step));
        var floatValue = parseFloat(rawValue.toFixed(precision));
        var newValue = clamp(floatValue, min !== null && min !== void 0 ? min : -Infinity, max !== null && max !== void 0 ? max : Infinity);
        var state = {
          value: newValue,
          direction: direction
        };

        if (type === 'number') {
          setValue(state.value);
        }

        if (type === 'text') {
          // Calling format() can alter the number (such as rounding it) causing
          // the numberValue to mismatch the formatted value in the input.
          // To avoid this, the newValue is re-parsed after formatting.
          var formattedNewValue = format(newValue);
          var parsedFormattedNewValue = numberParser.parse(formattedNewValue); // When isControlled, setNumberValue will not actually update
          // numberValue in useControllableState.

          setNumberValue(parsedFormattedNewValue);
          setInputValue(formattedNewValue);
          setPreviousNumberValue(parsedFormattedNewValue);
        }

        if (onChange) {
          onChange(event, state);
        }

        return state;
      }
    };

    var handleStepperClick = function handleStepperClick(event, direction) {
      if (inputRef.current) {
        var state = handleStep(event, direction);

        if (onClick) {
          onClick(event, state);
        }
      }
    };

    var normalizedDecorator = /*#__PURE__*/React__default["default"].isValidElement(slug !== null && slug !== void 0 ? slug : decorator) ? slug !== null && slug !== void 0 ? slug : decorator : null;

    if (((_normalizedDecorator = normalizedDecorator) === null || _normalizedDecorator === void 0 ? void 0 : (_normalizedDecorator$ = _normalizedDecorator.type) === null || _normalizedDecorator$ === void 0 ? void 0 : _normalizedDecorator$.displayName) === 'AILabel') {
      normalizedDecorator = /*#__PURE__*/React__default["default"].cloneElement(normalizedDecorator, {
        size: 'mini'
      });
    }

    var isRevertActive;

    if (((_normalizedDecorator2 = normalizedDecorator) === null || _normalizedDecorator2 === void 0 ? void 0 : (_normalizedDecorator3 = _normalizedDecorator2.type) === null || _normalizedDecorator3 === void 0 ? void 0 : _normalizedDecorator3.displayName) === 'AILabel') {
      isRevertActive = normalizedDecorator.props.revertActive;
    }

    React.useEffect(function () {
      if (!isRevertActive && slug && defaultValue) {
        setValue(defaultValue);
      }
    }, [defaultValue, isRevertActive, slug]);
    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: outerElementClasses,
      onFocus: isFluid ? handleFocus : undefined,
      onBlur: isFluid ? handleFocus : undefined
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: numberInputClasses,
      "data-invalid": normalizedProps.invalid ? true : undefined
    }, /*#__PURE__*/React__default["default"].createElement(Label, {
      disabled: normalizedProps.disabled,
      hideLabel: hideLabel,
      id: id,
      label: label
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      className: wrapperClasses
    }, /*#__PURE__*/React__default["default"].createElement("input", _extends$3({}, rest, {
      "data-invalid": normalizedProps.invalid ? true : undefined,
      "aria-invalid": normalizedProps.invalid,
      "aria-describedby": ariaDescribedBy,
      "aria-readonly": readOnly,
      disabled: normalizedProps.disabled,
      ref: ref,
      id: id,
      max: max,
      min: min,
      onClick: onClick,
      onChange: handleOnChange,
      onKeyUp: onKeyUp,
      onKeyDown: function onKeyDown(e) {
        if (type === 'text') {
          match(e, ArrowUp) && handleStep(e, 'up');
          match(e, ArrowDown) && handleStep(e, 'down');
        }

        if (rest !== null && rest !== void 0 && rest.onKeyDown) {
          rest.onKeyDown(e);
        }
      },
      onFocus: function onFocus(e) {
        if (disableWheelProp) {
          e.target.addEventListener('wheel', disableWheel);
        }

        if (rest.onFocus) {
          rest.onFocus(e);
        }
      },
      onBlur: function onBlur(e) {
        if (disableWheelProp) {
          e.target.removeEventListener('wheel', disableWheel);
        }

        if (type === 'text') {
          var _numberValue = isControlled ? numberParser.parse(inputValue) : numberValue;

          var formattedValue = isNaN(_numberValue) ? '' : format(_numberValue);
          setInputValue(formattedValue); // Calling format() can alter the number (such as rounding it)
          // causing the _numberValue to mismatch the formatted value in
          // the input. To avoid this, formattedValue is re-parsed.

          var parsedFormattedNewValue = numberParser.parse(formattedValue);

          if (onChange) {
            var state = {
              value: parsedFormattedNewValue,
              direction: previousNumberValue < parsedFormattedNewValue ? 'up' : 'down'
            }; // If the old and new values are NaN, don't call onChange
            // to avoid an unecessary re-render and potential infinite
            // loop when isControlled.

            if (!(isNaN(previousNumberValue) && isNaN(parsedFormattedNewValue))) {
              onChange(e, state);
            }
          } // If the old and new values are NaN, don't set state to avoid
          // an unecessary re-render and potential infinite loop when
          // isControlled.


          if (!(isNaN(previousNumberValue) && isNaN(numberValue))) {
            setPreviousNumberValue(numberValue);
          }

          if (!(isNaN(numberValue) && isNaN(parsedFormattedNewValue))) {
            setNumberValue(parsedFormattedNewValue);
          }
        }

        if (_onBlur) {
          _onBlur(e);
        }
      },
      pattern: pattern,
      inputMode: inputMode,
      readOnly: readOnly,
      step: step,
      type: type,
      value: type === 'number' ? value : inputValue
    })), slug ? normalizedDecorator : decorator ? /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--number__input-inner-wrapper--decorator")
    }, normalizedDecorator) : null, Icon ? /*#__PURE__*/React__default["default"].createElement(Icon, {
      className: iconClasses
    }) : null, !hideSteppers && /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--number__controls")
    }, /*#__PURE__*/React__default["default"].createElement("button", {
      "aria-label": decrementNumLabel || iconDescription,
      className: "".concat(prefix, "--number__control-btn down-icon"),
      disabled: disabled || readOnly,
      onClick: function onClick(event) {
        return handleStepperClick(event, 'down');
      },
      onBlur: _onBlur,
      tabIndex: -1,
      title: decrementNumLabel || iconDescription,
      type: "button"
    }, /*#__PURE__*/React__default["default"].createElement(Subtract16, {
      className: "down-icon"
    })), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--number__rule-divider")
    }), /*#__PURE__*/React__default["default"].createElement("button", {
      "aria-label": incrementNumLabel || iconDescription,
      className: "".concat(prefix, "--number__control-btn up-icon"),
      disabled: disabled || readOnly,
      onClick: function onClick(event) {
        return handleStepperClick(event, 'up');
      },
      onBlur: _onBlur,
      tabIndex: -1,
      title: incrementNumLabel || iconDescription,
      type: "button"
    }, /*#__PURE__*/React__default["default"].createElement(Add16, {
      className: "up-icon"
    })), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--number__rule-divider")
    }))), isFluid && /*#__PURE__*/React__default["default"].createElement("hr", {
      className: "".concat(prefix, "--number-input__divider")
    }), normalizedProps.validation ? normalizedProps.validation : /*#__PURE__*/React__default["default"].createElement(HelperText, {
      id: normalizedProps.helperId,
      disabled: disabled,
      description: helperText
    })));
  });
  NumberInputV2.propTypes = {
    /**
     * `true` to allow empty string.
     */
    allowEmpty: PropTypes__default["default"].bool,

    /**
     * Specify an optional className to be applied to the wrapper node
     */
    className: PropTypes__default["default"].string,

    /**
     * **Experimental**: Provide a `decorator` component to be rendered inside the `NumberInput` component
     */
    decorator: PropTypes__default["default"].node,

    /**
     * Optional starting value for uncontrolled state
     * Defaults to 0 when type="number"
     * Defaults to NaN when type="text"
     */
    defaultValue: PropTypes__default["default"].oneOfType([PropTypes__default["default"].number, PropTypes__default["default"].string]),

    /**
     * Specify if the wheel functionality for the input should be disabled, or no t
     */
    disableWheel: PropTypes__default["default"].bool,

    /**
     * Specify if the control should be disabled, or not
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * **Experimental:** Specify Intl.NumberFormat options applied to internal
     * number parsing and formatting. Use with `type="text"`, has no effect when
     * `type="number"`.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
     */
    formatOptions: NumberFormatOptionsPropType,

    /**
     * Provide text that is used alongside the control label for additional help
     */
    helperText: PropTypes__default["default"].node,

    /**
     * Specify whether you want the underlying label to be visually hidden
     */
    hideLabel: PropTypes__default["default"].bool,

    /**
     * Specify whether you want the steppers to be hidden
     */
    hideSteppers: PropTypes__default["default"].bool,

    /**
     * Provide a description for up/down icons that can be read by screen readers
     */
    iconDescription: PropTypes__default["default"].string,

    /**
     * Specify a custom `id` for the input
     */
    id: PropTypes__default["default"].string.isRequired,

    /**
     * Instruct the browser which keyboard to display on mobile devices. Note that
     * standard numeric keyboards vary across devices and operating systems.
     * @see https://css-tricks.com/everything-you-ever-wanted-to-know-about-inputmode/
     */
    inputMode: PropTypes__default["default"].oneOf(['none', 'text', 'tel', 'url', 'email', 'numeric', 'decimal', 'search']),

    /**
     * Specify if the currently value is invalid.
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * Message which is displayed if the value is invalid.
     */
    invalidText: PropTypes__default["default"].node,

    /**
     * Generic `label` that will be used as the textual representation of what
     * this field is for
     */
    label: PropTypes__default["default"].node,

    /**
     * `true` to use the light version.
     */
    light: deprecate(PropTypes__default["default"].bool, 'The `light` prop for `NumberInputV2` is no longer needed and has ' + 'been deprecated in v11 in favor of the new `Layer` component. It will be moved in the next major release.'),

    /**
     * **Experimental:** Specify a [BCP47](https://www.ietf.org/rfc/bcp/bcp47.txt)
     * language code for parsing and formatting. Use with `type="text"`, has no
     * effect when `type="number"`.
     */
    locale: PropTypes__default["default"].string,

    /**
     * The maximum value.
     */
    max: PropTypes__default["default"].number,

    /**
     * The minimum value.
     */
    min: PropTypes__default["default"].number,

    /**
     * Provide an optional handler that is called when the input or stepper
     * buttons are blurred.
     */
    onBlur: PropTypes__default["default"].func,

    /**
     * Provide an optional handler that is called when the internal state of
     * NumberInput changes. This handler is called with event and state info.
     * When type="number", this is called on every change of the input.
     * When type="text", this is only called on blur after the number has been
     * parsed and formatted.
     * `(event, { value, direction }) => void`
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Provide an optional function to be called when the up/down button is clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Provide an optional function to be called when a key is pressed in the number input
     */
    onKeyUp: PropTypes__default["default"].func,

    /**
     * When type="text", provide an optional pattern to restrict user input. Has
     * no effect when type="number".
     */
    pattern: PropTypes__default["default"].string,

    /**
     * Specify if the component should be read-only
     */
    readOnly: PropTypes__default["default"].bool,

    /**
     * Specify the size of the Number Input.
     */
    size: PropTypes__default["default"].oneOf(['sm', 'md', 'lg']),

    /**
     * **Experimental**: Provide a `Slug` component to be rendered inside the
     * `NumberInput` component
     */
    slug: deprecate(PropTypes__default["default"].node, 'The `slug` prop for `NumberInput` is no longer needed and has ' + 'been deprecated in v11 in favor of the new `decorator` prop. It will be moved in the next major release.'),

    /**
     * Specify how much the values should increase/decrease upon clicking on
     * up/down button
     */
    step: PropTypes__default["default"].number,

    /**
     * Provide custom text for the component for each translation id
     */
    translateWithId: PropTypes__default["default"].func,

    /**
     * **Experimental**: Specify if the input should be of type text or number.
     * Use type="text" with `locale`, `formatOptions`, and guide user input with
     * `pattern` and `inputMode`.
     */
    type: PropTypes__default["default"].oneOf(['number', 'text']),

    /**
     * Specify the value of the input
     */
    value: PropTypes__default["default"].oneOfType([PropTypes__default["default"].number, PropTypes__default["default"].string]),

    /**
     * Specify whether the control is currently in warning state
     */
    warn: PropTypes__default["default"].bool,

    /**
     * Provide the text that is displayed when the control is in warning state
     */
    warnText: PropTypes__default["default"].node
  };

  var Label = function Label(_ref2) {
    var _classNames5;

    var disabled = _ref2.disabled,
        id = _ref2.id,
        hideLabel = _ref2.hideLabel,
        label = _ref2.label;
    var prefix = usePrefix();
    var className = cx((_classNames5 = {}, _defineProperty$2(_classNames5, "".concat(prefix, "--label"), true), _defineProperty$2(_classNames5, "".concat(prefix, "--label--disabled"), disabled), _defineProperty$2(_classNames5, "".concat(prefix, "--visually-hidden"), hideLabel), _classNames5));

    if (label) {
      return /*#__PURE__*/React__default["default"].createElement(Text, {
        as: "label",
        htmlFor: id,
        className: className
      }, label);
    }

    return null;
  };

  Label.propTypes = {
    disabled: PropTypes__default["default"].bool,
    hideLabel: PropTypes__default["default"].bool,
    id: PropTypes__default["default"].string,
    label: PropTypes__default["default"].node
  };

  function HelperText(_ref3) {
    var disabled = _ref3.disabled,
        description = _ref3.description,
        id = _ref3.id;
    var prefix = usePrefix();
    var className = cx("".concat(prefix, "--form__helper-text"), _defineProperty$2({}, "".concat(prefix, "--form__helper-text--disabled"), disabled));

    if (description) {
      return /*#__PURE__*/React__default["default"].createElement(Text, {
        as: "div",
        id: id,
        className: className
      }, description);
    }

    return null;
  }

  HelperText.propTypes = {
    description: PropTypes__default["default"].node,
    disabled: PropTypes__default["default"].bool,
    id: PropTypes__default["default"].string
  };
  /**
   * Determine if the given value is invalid based on the given max, min and
   * conditions like `allowEmpty`. If `invalid` is passed through, it will default
   * to false.
   *
   * @param {object} config
   * @param {boolean} config.allowEmpty
   * @param {boolean} config.invalid
   * @param {number} config.value
   * @param {number} config.max
   * @param {number} config.min
   * @returns {boolean}
   */

  function getInputValidity(_ref4) {
    var allowEmpty = _ref4.allowEmpty,
        invalid = _ref4.invalid,
        value = _ref4.value,
        max = _ref4.max,
        min = _ref4.min;

    if (invalid) {
      return false;
    }

    if (value === '') {
      return allowEmpty;
    }

    if (value > max || value < min) {
      return false;
    }

    return true;
  }
  /**
   * It prevents any wheel event from emitting.
   *
   * We want to prevent this input field from changing by the user accidentally
   * when the user scrolling up or down in a long form. So we prevent the default
   * behavior of wheel events when it is focused.
   *
   * Because React uses passive event handler by default, we can't just call
   * `preventDefault` in the `onWheel` event handler. So we have to get the input
   * ref and add our event handler manually.
   *
   * @see https://github.com/facebook/react/pull/19654
   * @param {WheelEvent} e A wheel event.
   */


  function disableWheel(e) {
    e.preventDefault();
  }

  var NumberInputV2$1 = NumberInputV2;

  var _excluded$1o = ["children", "className", "nested", "native", "isExpressive"];

  var OrderedList = function OrderedList(_ref) {
    var _classnames;

    var children = _ref.children,
        className = _ref.className,
        nested = _ref.nested,
        native = _ref.native,
        isExpressive = _ref.isExpressive,
        other = _objectWithoutProperties$2(_ref, _excluded$1o);

    var prefix = usePrefix();
    var classNames = cx((_classnames = {}, _defineProperty$2(_classnames, "".concat(prefix, "--list--ordered"), !native), _defineProperty$2(_classnames, "".concat(prefix, "--list--ordered--native"), native), _defineProperty$2(_classnames, "".concat(prefix, "--list--nested"), nested), _defineProperty$2(_classnames, "".concat(prefix, "--list--expressive"), isExpressive), _classnames), className);
    return /*#__PURE__*/React__default["default"].createElement("ol", _extends$3({
      className: classNames
    }, other), children);
  };

  OrderedList.propTypes = {
    /**
     * Provide list items to be rendered in the ordered list
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide an optional className to be applied to the containing <ol> node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether this ordered list expressive or not
     */
    isExpressive: PropTypes__default["default"].bool,

    /**
     * Specify whether this ordered list should use native list styles instead of custom counter
     */
    native: PropTypes__default["default"].bool,

    /**
     * Specify whether this ordered list is nested inside of another nested list
     */
    nested: PropTypes__default["default"].bool
  };
  OrderedList.defaultProps = {
    nested: false,
    native: false,
    isExpressive: false
  };
  var OrderedList$1 = OrderedList;

  var _excluded$1n = ["hideLabel", "className"];

  var SelectSkeleton = function SelectSkeleton(_ref) {
    var hideLabel = _ref.hideLabel,
        className = _ref.className,
        rest = _objectWithoutProperties$2(_ref, _excluded$1n);

    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: cx("".concat(prefix, "--form-item"), className)
    }, rest), !hideLabel && /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--label ").concat(prefix, "--skeleton")
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--select ").concat(prefix, "--skeleton")
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--select-input")
    })));
  };

  SelectSkeleton.propTypes = {
    /**
     * Specify an optional className to add to the form item wrapper.
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the label should be hidden, or not
     */
    hideLabel: PropTypes__default["default"].bool
  };
  var SelectSkeleton$1 = SelectSkeleton;

  var _excluded$1m = ["className", "id", "inline", "labelText", "disabled", "children", "noLabel", "iconDescription", "hideLabel", "invalid", "invalidText", "helperText", "light", "size", "warn", "warnText"];
  var getInstanceId$8 = setupGetInstanceId$2();
  var Select = /*#__PURE__*/React__default["default"].forwardRef(function Select(_ref, ref) {
    var _classNames, _classNames2, _classNames3;

    var className = _ref.className,
        id = _ref.id,
        inline = _ref.inline,
        labelText = _ref.labelText,
        disabled = _ref.disabled,
        children = _ref.children,
        noLabel = _ref.noLabel;
        _ref.iconDescription;
        var hideLabel = _ref.hideLabel,
        invalid = _ref.invalid,
        invalidText = _ref.invalidText,
        helperText = _ref.helperText,
        light = _ref.light,
        size = _ref.size,
        warn = _ref.warn,
        warnText = _ref.warnText,
        other = _objectWithoutProperties$2(_ref, _excluded$1m);

    var prefix = usePrefix();
    var enabled = useFeatureFlag('enable-v11-release');

    var _useRef = React.useRef(getInstanceId$8()),
        selectInstanceId = _useRef.current;

    var selectClasses = cx((_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--select"), true), _defineProperty$2(_classNames, "".concat(prefix, "--select--inline"), inline), _defineProperty$2(_classNames, "".concat(prefix, "--select--light"), light), _defineProperty$2(_classNames, "".concat(prefix, "--select--invalid"), invalid), _defineProperty$2(_classNames, "".concat(prefix, "--select--disabled"), disabled), _defineProperty$2(_classNames, "".concat(prefix, "--select--warning"), warn), _classNames), [enabled ? null : className]);
    var labelClasses = cx("".concat(prefix, "--label"), (_classNames2 = {}, _defineProperty$2(_classNames2, "".concat(prefix, "--visually-hidden"), hideLabel), _defineProperty$2(_classNames2, "".concat(prefix, "--label--disabled"), disabled), _classNames2));
    var inputClasses = cx((_classNames3 = {}, _defineProperty$2(_classNames3, "".concat(prefix, "--select-input"), true), _defineProperty$2(_classNames3, "".concat(prefix, "--select-input--").concat(size), size), _classNames3));
    var errorId = "".concat(id, "-error-msg");

    var errorText = function () {
      if (invalid) {
        return invalidText;
      }

      if (warn) {
        return warnText;
      }
    }();

    var error = invalid || warn ? /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--form-requirement"),
      id: errorId
    }, errorText) : null;
    var helperTextClasses = cx("".concat(prefix, "--form__helper-text"), _defineProperty$2({}, "".concat(prefix, "--form__helper-text--disabled"), disabled));
    var helperId = !helperText ? undefined : "select-helper-text-".concat(selectInstanceId);
    var helper = helperText ? /*#__PURE__*/React__default["default"].createElement("div", {
      id: helperId,
      className: helperTextClasses
    }, helperText) : null;
    var ariaProps = {};

    if (invalid) {
      ariaProps['aria-describedby'] = errorId;
    } else if (!inline) {
      ariaProps['aria-describedby'] = helper ? helperId : undefined;
    }

    var input = function () {
      return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("select", _extends$3({}, other, ariaProps, {
        id: id,
        className: inputClasses,
        disabled: disabled || undefined,
        "aria-invalid": invalid || undefined,
        ref: ref
      }), children), /*#__PURE__*/React__default["default"].createElement(ChevronDown16, {
        className: "".concat(prefix, "--select__arrow")
      }), invalid && /*#__PURE__*/React__default["default"].createElement(WarningFilled16, {
        className: "".concat(prefix, "--select__invalid-icon")
      }), !invalid && warn && /*#__PURE__*/React__default["default"].createElement(WarningAltFilled16, {
        className: "".concat(prefix, "--select__invalid-icon ").concat(prefix, "--select__invalid-icon--warning")
      }));
    }();

    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: enabled ? cx("".concat(prefix, "--form-item"), className) : "".concat(prefix, "--form-item")
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: selectClasses
    }, !noLabel && /*#__PURE__*/React__default["default"].createElement("label", {
      htmlFor: id,
      className: labelClasses
    }, labelText), inline && /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--select-input--inline__wrapper")
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--select-input__wrapper"),
      "data-invalid": invalid || null
    }, input), error), !inline && /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--select-input__wrapper"),
      "data-invalid": invalid || null
    }, input), !inline && error ? error : helper));
  });
  Select.displayName = 'Select';
  Select.propTypes = {
    /**
     * Provide the contents of your Select
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the node containing the label and the select box
     */
    className: PropTypes__default["default"].string,

    /**
     * Optionally provide the default value of the `<select>`
     */
    defaultValue: PropTypes__default["default"].any,

    /**
     * Specify whether the control is disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Provide text that is used alongside the control label for additional help
     */
    helperText: PropTypes__default["default"].node,

    /**
     * Specify whether the label should be hidden, or not
     */
    hideLabel: PropTypes__default["default"].bool,

    /**
     * Provide a description for the twistie icon that can be read by screen readers
     */
    iconDescription: deprecate(PropTypes__default["default"].string, 'The `iconDescription` prop for `Select` is no longer needed and has ' + 'been deprecated. It will be moved in the next major release.'),

    /**
     * Specify a custom `id` for the `<select>`
     */
    id: PropTypes__default["default"].string.isRequired,

    /**
     * Specify whether you want the inline version of this control
     */
    inline: PropTypes__default["default"].bool,

    /**
     * Specify if the currently value is invalid.
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * Message which is displayed if the value is invalid.
     */
    invalidText: PropTypes__default["default"].node,

    /**
     * Provide label text to be read by screen readers when interacting with the
     * control
     */
    labelText: PropTypes__default["default"].node,

    /**
     * `true` to use the light version. For use on $ui-01 backgrounds only.
     * Don't use this to make tile background color same as container background color.
     */
    light: PropTypes__default["default"].bool,

    /**
     * Reserved for use with <Pagination> component. Will not render a label for the
     * select since Pagination renders one for us.
     */
    noLabel: PropTypes__default["default"].bool,

    /**
     * Provide an optional `onChange` hook that is called each time the value of
     * the underlying `<input>` changes
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Specify the size of the Select Input.
     */
    size: enabled('enable-v11-release') ? PropTypes__default["default"].oneOf(['sm', 'md', 'lg']) : PropTypes__default["default"].oneOf(['sm', 'md', 'lg', 'xl']),

    /**
     * Specify whether the control is currently in warning state
     */
    warn: PropTypes__default["default"].bool,

    /**
     * Provide the text that is displayed when the control is in warning state
     */
    warnText: PropTypes__default["default"].node
  };
  Select.defaultProps = {
    disabled: false,
    labelText: 'Select',
    inline: false,
    invalid: false,
    invalidText: '',
    helperText: '',
    light: false
  };
  var Select$1 = Select;

  var _excluded$1l = ["className", "value", "disabled", "hidden", "text"];

  var SelectItem = function SelectItem(_ref) {
    var _classNames;

    var className = _ref.className,
        value = _ref.value,
        disabled = _ref.disabled,
        hidden = _ref.hidden,
        text = _ref.text,
        other = _objectWithoutProperties$2(_ref, _excluded$1l);

    var prefix = usePrefix();
    var selectItemClasses = cx((_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--select-option"), true), _defineProperty$2(_classNames, className, className), _classNames));
    return /*#__PURE__*/React__default["default"].createElement("option", _extends$3({}, other, {
      className: selectItemClasses,
      value: value,
      disabled: disabled,
      hidden: hidden
    }), text);
  };

  SelectItem.propTypes = {
    /**
     * Specify an optional className to be applied to the node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the <SelectItem> should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Specify whether the <SelectItem> is hidden
     */
    hidden: PropTypes__default["default"].bool,

    /**
     * Provide the contents of your <SelectItem>
     */
    text: PropTypes__default["default"].string.isRequired,

    /**
     * Specify the value of the <SelectItem>
     */
    value: PropTypes__default["default"].any.isRequired
  };
  SelectItem.defaultProps = {
    disabled: false,
    hidden: false,
    value: '',
    text: ''
  };
  var SelectItem$1 = SelectItem;

  /**
   * Shallow compare two arrays for equality
   * @param {Array} arr1 the first array
   * @param {Array} arr2 the second array
   * @returns {boolean} true if both arrays have the same contents, otherwise false
   */
  function equals(arr1, arr2) {
    if (!Array.isArray(arr1) || !Array.isArray(arr2) || arr1.length !== arr2.length) {
      return false;
    }

    if (arr1 === arr2) {
      return true;
    }

    for (var i = 0; i < arr1.length; i++) {
      if (arr1[i] !== arr2[i]) {
        return false;
      }
    }

    return true;
  }

  var _excluded$1k = ["backwardText", "className", "forwardText", "id", "itemsPerPageText", "itemRangeText", "pageRangeText", "pageSize", "pageSizes", "itemText", "pageText", "pageNumberText", "pagesUnknown", "isLastPage", "disabled", "pageInputDisabled", "pageSizeInputDisabled", "totalItems", "onChange", "page", "size", "forwardedRef"];
  var instanceId = 0;

  var mapPageSizesToObject$1 = function mapPageSizesToObject(sizes) {
    return _typeof(sizes[0]) === 'object' && sizes[0] !== null ? sizes : sizes.map(function (size) {
      return {
        text: size,
        value: size
      };
    });
  };

  var Pagination$2 = /*#__PURE__*/function (_Component) {
    _inherits(Pagination, _Component);

    var _super = _createSuper(Pagination);

    function Pagination(props) {
      var _this;

      _classCallCheck$1(this, Pagination);

      _this = _super.call(this, props);

      _defineProperty$2(_assertThisInitialized$1(_this), "handleSizeChange", function (evt) {
        var pageSize = Number(evt.target.value);

        _this.setState({
          pageSize: pageSize,
          page: 1
        });

        _this.props.onChange({
          page: 1,
          pageSize: pageSize
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handlePageChange", function (evt) {
        _this.setState({
          page: evt.target.value
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handlePageInputChange", function (evt) {
        var page = Number(evt.target.value);

        if (page > 0 && page <= Math.max(Math.ceil(_this.props.totalItems / _this.state.pageSize), 1)) {
          _this.setState({
            page: page
          });

          _this.props.onChange({
            page: page,
            pageSize: _this.state.pageSize
          });
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "incrementPage", function () {
        var page = _this.state.page + 1;

        _this.setState({
          page: page
        });

        _this.props.onChange({
          page: page,
          pageSize: _this.state.pageSize
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "decrementPage", function () {
        var page = _this.state.page - 1;

        _this.setState({
          page: page
        });

        _this.props.onChange({
          page: page,
          pageSize: _this.state.pageSize
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "renderSelectItems", function (total) {
        var counter = 1;
        var itemArr = [];

        while (counter <= total) {
          itemArr.push( /*#__PURE__*/React__default["default"].createElement(SelectItem$1, {
            key: counter,
            value: counter,
            text: String(counter)
          }));
          counter++;
        }

        return itemArr;
      });

      var _this$props = _this.props,
          _pageSizes = _this$props.pageSizes,
          _page = _this$props.page,
          _pageSize = _this$props.pageSize;
      var pageSizes = mapPageSizesToObject$1(_pageSizes);
      _this.state = {
        page: _page,
        pageSize: _pageSize && pageSizes.some(function (sizeObj) {
          return _pageSize === sizeObj.value;
        }) ? _pageSize : pageSizes[0].value,
        prevPageSizes: pageSizes,
        prevPage: _page,
        prevPageSize: _pageSize
      };
      _this.uniqueId = ++instanceId;
      return _this;
    }

    _createClass$1(Pagination, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props2 = this.props,
            backwardText = _this$props2.backwardText,
            className = _this$props2.className,
            forwardText = _this$props2.forwardText,
            id = _this$props2.id,
            itemsPerPageText = _this$props2.itemsPerPageText,
            itemRangeText = _this$props2.itemRangeText,
            pageRangeText = _this$props2.pageRangeText;
            _this$props2.pageSize;
            var _pageSizes = _this$props2.pageSizes,
            itemText = _this$props2.itemText,
            pageText = _this$props2.pageText;
            _this$props2.pageNumberText;
            var pagesUnknown = _this$props2.pagesUnknown,
            isLastPage = _this$props2.isLastPage,
            disabled = _this$props2.disabled,
            pageInputDisabled = _this$props2.pageInputDisabled,
            pageSizeInputDisabled = _this$props2.pageSizeInputDisabled,
            totalItems = _this$props2.totalItems;
            _this$props2.onChange;
            _this$props2.page;
            var size = _this$props2.size,
            forwardedRef = _this$props2.forwardedRef,
            other = _objectWithoutProperties$2(_this$props2, _excluded$1k);

        return /*#__PURE__*/React__default["default"].createElement(PrefixContext.Consumer, null, function (prefix) {
          var classNames = cx("".concat(prefix, "--pagination"), className, _defineProperty$2({}, "".concat(prefix, "--pagination--").concat(size), size));
          var inputId = id || _this2.uniqueId;
          var _this2$state = _this2.state,
              statePage = _this2$state.page,
              statePageSize = _this2$state.pageSize;
          var totalPages = Math.max(Math.ceil(totalItems / statePageSize), 1);
          var backButtonDisabled = disabled || statePage === 1;
          var backButtonClasses = cx("".concat(prefix, "--pagination__button"), "".concat(prefix, "--pagination__button--backward"), _defineProperty$2({}, "".concat(prefix, "--pagination__button--no-index"), backButtonDisabled));
          var forwardButtonDisabled = disabled || statePage === totalPages;
          var forwardButtonClasses = cx("".concat(prefix, "--pagination__button"), "".concat(prefix, "--pagination__button--forward"), _defineProperty$2({}, "".concat(prefix, "--pagination__button--no-index"), forwardButtonDisabled));

          var selectItems = _this2.renderSelectItems(totalPages);

          var pageSizes = mapPageSizesToObject$1(_pageSizes);
          return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
            className: classNames,
            ref: forwardedRef
          }, other), /*#__PURE__*/React__default["default"].createElement("div", {
            className: "".concat(prefix, "--pagination__left")
          }, /*#__PURE__*/React__default["default"].createElement("label", {
            id: "".concat(prefix, "-pagination-select-").concat(inputId, "-count-label"),
            className: "".concat(prefix, "--pagination__text"),
            htmlFor: "".concat(prefix, "-pagination-select-").concat(inputId)
          }, itemsPerPageText), /*#__PURE__*/React__default["default"].createElement(Select$1, {
            id: "".concat(prefix, "-pagination-select-").concat(inputId),
            className: "".concat(prefix, "--select__item-count"),
            labelText: "",
            hideLabel: true,
            noLabel: true,
            inline: true,
            onChange: _this2.handleSizeChange,
            disabled: pageSizeInputDisabled || disabled,
            value: statePageSize
          }, pageSizes.map(function (sizeObj) {
            return /*#__PURE__*/React__default["default"].createElement(SelectItem$1, {
              key: sizeObj.value,
              value: sizeObj.value,
              text: String(sizeObj.text)
            });
          })), /*#__PURE__*/React__default["default"].createElement("span", {
            className: "".concat(prefix, "--pagination__text ").concat(prefix, "--pagination__items-count")
          }, pagesUnknown ? itemText(statePageSize * (statePage - 1) + 1, statePage * statePageSize) : itemRangeText(Math.min(statePageSize * (statePage - 1) + 1, totalItems), Math.min(statePage * statePageSize, totalItems), totalItems))), /*#__PURE__*/React__default["default"].createElement("div", {
            className: "".concat(prefix, "--pagination__right")
          }, /*#__PURE__*/React__default["default"].createElement(Select$1, {
            id: "".concat(prefix, "-pagination-select-").concat(inputId, "-right"),
            className: "".concat(prefix, "--select__page-number"),
            labelText: "Page number, of ".concat(totalPages, " pages"),
            inline: true,
            hideLabel: true,
            onChange: _this2.handlePageInputChange,
            value: statePage,
            disabled: pageInputDisabled || disabled
          }, selectItems), /*#__PURE__*/React__default["default"].createElement("span", {
            className: "".concat(prefix, "--pagination__text")
          }, pagesUnknown ? pageText(statePage) : pageRangeText(statePage, totalPages)), /*#__PURE__*/React__default["default"].createElement("div", {
            className: "".concat(prefix, "--pagination__control-buttons")
          }, /*#__PURE__*/React__default["default"].createElement(Button$1, {
            kind: "ghost",
            className: backButtonClasses,
            hasIconOnly: true,
            renderIcon: CaretLeft16,
            iconDescription: backwardText,
            tooltipAlignment: "center",
            tooltipPosition: "top",
            onClick: _this2.decrementPage,
            disabled: backButtonDisabled
          }), /*#__PURE__*/React__default["default"].createElement(Button$1, {
            kind: "ghost",
            className: forwardButtonClasses,
            hasIconOnly: true,
            renderIcon: CaretRight16,
            iconDescription: forwardText,
            tooltipAlignment: "end",
            tooltipPosition: "top",
            onClick: _this2.incrementPage,
            disabled: forwardButtonDisabled || isLastPage
          }))));
        });
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, state) {
        var _pageSizes = _ref.pageSizes,
            page = _ref.page,
            pageSize = _ref.pageSize;
        var prevPageSizes = state.prevPageSizes,
            prevPage = state.prevPage,
            prevPageSize = state.prevPageSize,
            currentPage = state.page,
            currentPageSize = state.pageSize;
        var pageSizes = mapPageSizesToObject$1(_pageSizes);
        var pageSizesValues = pageSizes.map(function (sizeObj) {
          return sizeObj.value;
        });
        var prevPageSizesValues = prevPageSizes.map(function (sizeObj) {
          return sizeObj.value;
        });
        var pageSizesChanged = !equals(pageSizesValues, prevPageSizesValues);

        if (pageSizesChanged && !pageSizes.some(function (sizeObj) {
          return pageSize === sizeObj.value;
        })) {
          pageSize = pageSizes[0].value;
        }

        var pageChanged = page !== prevPage;
        var pageSizeChanged = pageSize !== prevPageSize;
        return !pageSizesChanged && !pageChanged && !pageSizeChanged ? null : {
          page: pageSizeChanged && 1 || pageChanged && page || currentPage,
          pageSize: pageSizeChanged ? pageSize : currentPageSize,
          prevPageSizes: pageSizes,
          prevPage: page,
          prevPageSize: pageSize
        };
      }
    }]);

    return Pagination;
  }(React.Component);

  _defineProperty$2(Pagination$2, "propTypes", {
    /**
     * The description for the backward icon.
     */
    backwardText: PropTypes__default["default"].string,

    /**
     * The CSS class names.
     */
    className: PropTypes__default["default"].string,

    /**
     * `true` if the backward/forward buttons, as well as the page select elements,  should be disabled.
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * The description for the forward icon.
     */
    forwardText: PropTypes__default["default"].string,

    /**
     * The unique ID of this component instance.
     */
    id: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),
    // TODO: remove when v9 is deprecated

    /**
     * `true` if the current page should be the last page.
     */
    isLastPage: PropTypes__default["default"].bool,

    /**
     * The function returning a translatable text showing where the current page is,
     * in a manner of the range of items.
     */
    itemRangeText: PropTypes__default["default"].func,

    /**
     * A variant of `itemRangeText`, used if the total number of items is unknown.
     */
    itemText: PropTypes__default["default"].func,

    /**
     * The translatable text indicating the number of items per page.
     */
    itemsPerPageText: PropTypes__default["default"].string,

    /**
     * The callback function called when the current page changes.
     */
    onChange: PropTypes__default["default"].func,

    /**
     * The current page.
     */
    page: PropTypes__default["default"].number,

    /**
     * `true` if the select box to change the page should be disabled.
     */
    pageInputDisabled: PropTypes__default["default"].bool,
    pageNumberText: PropTypes__default["default"].string,

    /**
     * A function returning PII showing where the current page is.
     */
    pageRangeText: PropTypes__default["default"].func,

    /**
     * The number dictating how many items a page contains.
     */
    pageSize: PropTypes__default["default"].number,

    /**
     * `true` if the select box to change the items per page should be disabled.
     */
    pageSizeInputDisabled: PropTypes__default["default"].bool,

    /**
     * The choices for `pageSize`.
     */
    pageSizes: PropTypes__default["default"].oneOfType([PropTypes__default["default"].arrayOf(PropTypes__default["default"].number), PropTypes__default["default"].arrayOf(PropTypes__default["default"].shape({
      text: PropTypes__default["default"].text,
      value: PropTypes__default["default"].number
    }))]).isRequired,

    /**
     * The translatable text showing the current page.
     */
    pageText: PropTypes__default["default"].func,

    /**
     * `true` if the total number of items is unknown.
     */
    pagesUnknown: PropTypes__default["default"].bool,

    /**
     * Specify the size of the Pagination. Currently supports either `sm`, 'md' (default) or 'lg` as an option.
     */
    size: PropTypes__default["default"].oneOf(['sm', 'md', 'lg']),

    /**
     * The total number of items.
     */
    totalItems: PropTypes__default["default"].number
  });

  _defineProperty$2(Pagination$2, "defaultProps", {
    backwardText: 'Previous page',
    itemRangeText: function itemRangeText(min, max, total) {
      return "".concat(min, "\u2013").concat(max, " of ").concat(total, " items");
    },
    forwardText: 'Next page',
    itemsPerPageText: 'Items per page:',
    pageNumberText: 'Page Number',
    pageRangeText: function pageRangeText(current, total) {
      return "of ".concat(total, " ").concat(total === 1 ? 'page' : 'pages');
    },
    disabled: false,
    page: 1,
    pagesUnknown: false,
    isLastPage: false,
    itemText: function itemText(min, max) {
      return "".concat(min, "\u2013").concat(max, " items");
    },
    pageText: function pageText(page) {
      return "page ".concat(page);
    }
  });

  var _excluded$1j = ["backwardText", "className", "disabled", "forwardText", "id", "isLastPage", "itemText", "itemRangeText", "itemsPerPageText", "onChange", "pageNumberText", "pageRangeText", "page", "pageInputDisabled", "pageSize", "pageSizeInputDisabled", "pageSizes", "pageText", "pagesUnknown", "size", "totalItems"];

  function mapPageSizesToObject(sizes) {
    return _typeof(sizes[0]) === 'object' && sizes[0] !== null ? sizes : sizes.map(function (size) {
      return {
        text: size,
        value: size
      };
    });
  }

  function renderSelectItems(total) {
    var counter = 1;
    var itemArr = [];

    while (counter <= total) {
      itemArr.push( /*#__PURE__*/React__default["default"].createElement(SelectItem$1, {
        key: counter,
        value: counter,
        text: String(counter)
      }));
      counter++;
    }

    return itemArr;
  }

  function getPageSize(pageSizes, pageSize) {
    if (pageSize) {
      var hasSize = pageSizes.find(function (size) {
        return pageSize === size.value;
      });

      if (hasSize) {
        return pageSize;
      }
    }

    return pageSizes[0].value;
  }

  var Pagination$1 = /*#__PURE__*/React__default["default"].forwardRef(function Pagination(_ref, ref) {
    var _cx, _cx2, _cx3;

    var _ref$backwardText = _ref.backwardText,
        backwardText = _ref$backwardText === void 0 ? 'Previous page' : _ref$backwardText,
        customClassName = _ref.className,
        _ref$disabled = _ref.disabled,
        disabled = _ref$disabled === void 0 ? false : _ref$disabled,
        _ref$forwardText = _ref.forwardText,
        forwardText = _ref$forwardText === void 0 ? 'Next page' : _ref$forwardText,
        id = _ref.id,
        _ref$isLastPage = _ref.isLastPage,
        isLastPage = _ref$isLastPage === void 0 ? false : _ref$isLastPage,
        _ref$itemText = _ref.itemText,
        itemText = _ref$itemText === void 0 ? function (min, max) {
      return "".concat(min, "\u2013").concat(max, " items");
    } : _ref$itemText,
        _ref$itemRangeText = _ref.itemRangeText,
        itemRangeText = _ref$itemRangeText === void 0 ? function (min, max, total) {
      return "".concat(min, "\u2013").concat(max, " of ").concat(total, " items");
    } : _ref$itemRangeText,
        _ref$itemsPerPageText = _ref.itemsPerPageText,
        itemsPerPageText = _ref$itemsPerPageText === void 0 ? 'Items per page:' : _ref$itemsPerPageText,
        onChange = _ref.onChange;
        _ref.pageNumberText;
        var _ref$pageRangeText = _ref.pageRangeText,
        pageRangeText = _ref$pageRangeText === void 0 ? function (_current, total) {
      return "of ".concat(total, " ").concat(total === 1 ? 'page' : 'pages');
    } : _ref$pageRangeText,
        _ref$page = _ref.page,
        controlledPage = _ref$page === void 0 ? 1 : _ref$page,
        pageInputDisabled = _ref.pageInputDisabled,
        controlledPageSize = _ref.pageSize,
        pageSizeInputDisabled = _ref.pageSizeInputDisabled,
        controlledPageSizes = _ref.pageSizes,
        _ref$pageText = _ref.pageText,
        pageText = _ref$pageText === void 0 ? function (page) {
      return "page ".concat(page);
    } : _ref$pageText,
        _ref$pagesUnknown = _ref.pagesUnknown,
        pagesUnknown = _ref$pagesUnknown === void 0 ? false : _ref$pagesUnknown,
        size = _ref.size,
        totalItems = _ref.totalItems,
        rest = _objectWithoutProperties$2(_ref, _excluded$1j);

    var prefix = usePrefix();
    var inputId = useFallbackId(id);

    var _useState = React.useState(function () {
      return mapPageSizesToObject(controlledPageSizes);
    }),
        _useState2 = _slicedToArray$1(_useState, 2),
        pageSizes = _useState2[0],
        setPageSizes = _useState2[1];

    var _useState3 = React.useState(controlledPageSizes),
        _useState4 = _slicedToArray$1(_useState3, 2),
        prevPageSizes = _useState4[0],
        setPrevPageSizes = _useState4[1];

    var _useState5 = React.useState(controlledPage),
        _useState6 = _slicedToArray$1(_useState5, 2),
        page = _useState6[0],
        setPage = _useState6[1];

    var _useState7 = React.useState(controlledPage),
        _useState8 = _slicedToArray$1(_useState7, 2),
        prevControlledPage = _useState8[0],
        setPrevControlledPage = _useState8[1];

    var _useState9 = React.useState(function () {
      return getPageSize(pageSizes, controlledPageSize);
    }),
        _useState10 = _slicedToArray$1(_useState9, 2),
        pageSize = _useState10[0],
        setPageSize = _useState10[1];

    var _useState11 = React.useState(controlledPageSize),
        _useState12 = _slicedToArray$1(_useState11, 2),
        prevControlledPageSize = _useState12[0],
        setPrevControlledPageSize = _useState12[1];

    var className = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--pagination"), true), _defineProperty$2(_cx, "".concat(prefix, "--pagination--").concat(size), size), _defineProperty$2(_cx, customClassName, !!customClassName), _cx));
    var totalPages = Math.max(Math.ceil(totalItems / pageSize), 1);
    var backButtonDisabled = disabled || page === 1;
    var backButtonClasses = cx((_cx2 = {}, _defineProperty$2(_cx2, "".concat(prefix, "--pagination__button"), true), _defineProperty$2(_cx2, "".concat(prefix, "--pagination__button--backward"), true), _defineProperty$2(_cx2, "".concat(prefix, "--pagination__button--no-index"), backButtonDisabled), _cx2));
    var forwardButtonDisabled = disabled || page === totalPages;
    var forwardButtonClasses = cx((_cx3 = {}, _defineProperty$2(_cx3, "".concat(prefix, "--pagination__button"), true), _defineProperty$2(_cx3, "".concat(prefix, "--pagination__button--forward"), true), _defineProperty$2(_cx3, "".concat(prefix, "--pagination__button--no-index"), forwardButtonDisabled), _cx3));
    var selectItems = renderSelectItems(totalPages); // Sync state with props

    if (controlledPage !== prevControlledPage) {
      setPage(controlledPage);
      setPrevControlledPage(controlledPage);
    }

    if (controlledPageSize !== prevControlledPageSize) {
      setPageSize(getPageSize(pageSizes, controlledPageSize));
      setPrevControlledPageSize(controlledPageSize);
    }

    if (!equals(controlledPageSizes, prevPageSizes)) {
      var _pageSizes = mapPageSizesToObject(controlledPageSizes);

      var hasPageSize = _pageSizes.find(function (size) {
        return size.value === pageSize;
      }); // Reset page to 1 if the current pageSize is not included in the new page
      // sizes


      if (!hasPageSize) {
        setPage(1);
      }

      setPageSizes(_pageSizes);
      setPrevPageSizes(controlledPageSizes);
    }

    function handleSizeChange(event) {
      var pageSize = Number(event.target.value);
      var changes = {
        pageSize: pageSize,
        page: 1
      };
      setPage(changes.page);
      setPageSize(changes.pageSize);

      if (onChange) {
        onChange(changes);
      }
    }

    function handlePageInputChange(event) {
      var page = Number(event.target.value);

      if (page > 0 && page <= Math.max(Math.ceil(totalItems / pageSize), 1)) {
        setPage(page);

        if (onChange) {
          onChange({
            page: page,
            pageSize: pageSize
          });
        }
      }
    }

    function incrementPage() {
      var nextPage = page + 1;
      setPage(nextPage);

      if (onChange) {
        onChange({
          page: nextPage,
          pageSize: pageSize
        });
      }
    }

    function decrementPage() {
      var nextPage = page - 1;
      setPage(nextPage);

      if (onChange) {
        onChange({
          page: nextPage,
          pageSize: pageSize
        });
      }
    }

    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: className,
      ref: ref
    }, rest), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--pagination__left")
    }, /*#__PURE__*/React__default["default"].createElement("label", {
      id: "".concat(prefix, "-pagination-select-").concat(inputId, "-count-label"),
      className: "".concat(prefix, "--pagination__text"),
      htmlFor: "".concat(prefix, "-pagination-select-").concat(inputId)
    }, itemsPerPageText), /*#__PURE__*/React__default["default"].createElement(Select$1, {
      id: "".concat(prefix, "-pagination-select-").concat(inputId),
      className: "".concat(prefix, "--select__item-count"),
      labelText: "",
      hideLabel: true,
      noLabel: true,
      inline: true,
      onChange: handleSizeChange,
      disabled: pageSizeInputDisabled || disabled,
      value: pageSize
    }, pageSizes.map(function (sizeObj) {
      return /*#__PURE__*/React__default["default"].createElement(SelectItem$1, {
        key: sizeObj.value,
        value: sizeObj.value,
        text: String(sizeObj.text)
      });
    })), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--pagination__text ").concat(prefix, "--pagination__items-count")
    }, pagesUnknown ? itemText(pageSize * (page - 1) + 1, page * pageSize) : itemRangeText(Math.min(pageSize * (page - 1) + 1, totalItems), Math.min(page * pageSize, totalItems), totalItems))), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--pagination__right")
    }, /*#__PURE__*/React__default["default"].createElement(Select$1, {
      id: "".concat(prefix, "-pagination-select-").concat(inputId, "-right"),
      className: "".concat(prefix, "--select__page-number"),
      labelText: "Page number, of ".concat(totalPages, " pages"),
      inline: true,
      hideLabel: true,
      onChange: handlePageInputChange,
      value: page,
      disabled: pageInputDisabled || disabled
    }, selectItems), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--pagination__text")
    }, pagesUnknown ? pageText(page) : pageRangeText(page, totalPages)), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--pagination__control-buttons")
    }, /*#__PURE__*/React__default["default"].createElement(Button$1, {
      kind: "ghost",
      className: backButtonClasses,
      hasIconOnly: true,
      renderIcon: CaretLeft16,
      iconDescription: backwardText,
      tooltipAlignment: "center",
      tooltipPosition: "top",
      onClick: decrementPage,
      disabled: backButtonDisabled
    }), /*#__PURE__*/React__default["default"].createElement(Button$1, {
      kind: "ghost",
      className: forwardButtonClasses,
      hasIconOnly: true,
      renderIcon: CaretRight16,
      iconDescription: forwardText,
      tooltipAlignment: "end",
      tooltipPosition: "top",
      onClick: incrementPage,
      disabled: forwardButtonDisabled || isLastPage
    }))));
  });
  Pagination$1.propTypes = {
    /**
     * The description for the backward icon.
     */
    backwardText: PropTypes__default["default"].string,

    /**
     * The CSS class names.
     */
    className: PropTypes__default["default"].string,

    /**
     * `true` if the backward/forward buttons, as well as the page select elements,  should be disabled.
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * The description for the forward icon.
     */
    forwardText: PropTypes__default["default"].string,

    /**
     * The unique ID of this component instance.
     */
    id: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),
    // TODO: remove when v9 is deprecated

    /**
     * `true` if the current page should be the last page.
     */
    isLastPage: PropTypes__default["default"].bool,

    /**
     * The function returning a translatable text showing where the current page is,
     * in a manner of the range of items.
     */
    itemRangeText: PropTypes__default["default"].func,

    /**
     * A variant of `itemRangeText`, used if the total number of items is unknown.
     */
    itemText: PropTypes__default["default"].func,

    /**
     * The translatable text indicating the number of items per page.
     */
    itemsPerPageText: PropTypes__default["default"].string,

    /**
     * The callback function called when the current page changes.
     */
    onChange: PropTypes__default["default"].func,

    /**
     * The current page.
     */
    page: PropTypes__default["default"].number,

    /**
     * `true` if the select box to change the page should be disabled.
     */
    pageInputDisabled: PropTypes__default["default"].bool,
    pageNumberText: PropTypes__default["default"].string,

    /**
     * A function returning PII showing where the current page is.
     */
    pageRangeText: PropTypes__default["default"].func,

    /**
     * The number dictating how many items a page contains.
     */
    pageSize: PropTypes__default["default"].number,

    /**
     * `true` if the select box to change the items per page should be disabled.
     */
    pageSizeInputDisabled: PropTypes__default["default"].bool,

    /**
     * The choices for `pageSize`.
     */
    pageSizes: PropTypes__default["default"].oneOfType([PropTypes__default["default"].arrayOf(PropTypes__default["default"].number), PropTypes__default["default"].arrayOf(PropTypes__default["default"].shape({
      text: PropTypes__default["default"].text,
      value: PropTypes__default["default"].number
    }))]).isRequired,

    /**
     * The translatable text showing the current page.
     */
    pageText: PropTypes__default["default"].func,

    /**
     * `true` if the total number of items is unknown.
     */
    pagesUnknown: PropTypes__default["default"].bool,

    /**
     * Specify the size of the Pagination. Currently supports either `sm`, 'md' (default) or 'lg` as an option.
     */
    size: PropTypes__default["default"].oneOf(['sm', 'md', 'lg']),

    /**
     * The total number of items.
     */
    totalItems: PropTypes__default["default"].number
  };
  var PaginationNext = Pagination$1;

  var _excluded$1i = ["className"];

  function PaginationSkeleton(_ref) {
    var className = _ref.className,
        rest = _objectWithoutProperties$2(_ref, _excluded$1i);

    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: cx("".concat(prefix, "--pagination"), "".concat(prefix, "--skeleton"), className)
    }, rest), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--pagination__left")
    }, /*#__PURE__*/React__default["default"].createElement(SkeletonText$1, {
      width: "70px"
    }), /*#__PURE__*/React__default["default"].createElement(SkeletonText$1, {
      width: "35px"
    }), /*#__PURE__*/React__default["default"].createElement(SkeletonText$1, {
      width: "105px"
    })), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--pagination__right ").concat(prefix, "--pagination--inline")
    }, /*#__PURE__*/React__default["default"].createElement(SkeletonText$1, {
      width: "70px"
    })));
  }

  PaginationSkeleton.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes__default["default"].string
  };

  var index$1 = enabled('enable-v11-release') ? PaginationNext : Pagination$2;

  var _excluded$1h = ["className", "onChange", "totalItems", "itemsShown", "page", "loop", "translateWithId"];
  var translationIds = {
    'carbon.pagination-nav.next': 'Next',
    'carbon.pagination-nav.previous': 'Previous',
    'carbon.pagination-nav.item': 'Page',
    'carbon.pagination-nav.active': 'Active',
    'carbon.pagination-nav.of': 'of'
  };

  function translateWithId$1(messageId) {
    return translationIds[messageId];
  } // https://reactjs.org/docs/hooks-faq.html#how-to-get-the-previous-props-or-state


  function usePrevious(value) {
    var ref = React.useRef();
    React.useEffect(function () {
      ref.current = value;
    });
    return ref.current;
  }

  function getCuts(page, totalItems, itemsThatFit) {
    var splitPoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    if (itemsThatFit >= totalItems) {
      return {
        front: 0,
        back: 0
      };
    }

    var split = splitPoint || Math.ceil(itemsThatFit / 2) - 1;
    var frontHidden = page + 1 - split;
    var backHidden = totalItems - page - (itemsThatFit - split) + 1;

    if (frontHidden <= 1) {
      backHidden -= frontHidden <= 0 ? Math.abs(frontHidden) + 1 : 0;
      frontHidden = 0;
    }

    if (backHidden <= 1) {
      frontHidden -= backHidden <= 0 ? Math.abs(backHidden) + 1 : 0;
      backHidden = 0;
    }

    return {
      front: frontHidden,
      back: backHidden
    };
  }

  function DirectionButton(_ref) {
    var direction = _ref.direction,
        label = _ref.label,
        disabled = _ref.disabled,
        onClick = _ref.onClick;
    var prefix = usePrefix();
    var icon = direction === 'forward' ? CaretRight16 : CaretLeft16;
    return /*#__PURE__*/React__default["default"].createElement("li", {
      className: "".concat(prefix, "--pagination-nav__list-item")
    }, /*#__PURE__*/React__default["default"].createElement(Button$1, {
      disabled: disabled,
      renderIcon: icon,
      kind: "ghost",
      hasIconOnly: true,
      iconDescription: label,
      tooltipAlignment: "center",
      tooltipPosition: "bottom",
      onClick: onClick
    }));
  }

  function PaginationItem(_ref2) {
    var page = _ref2.page,
        isActive = _ref2.isActive,
        onClick = _ref2.onClick,
        _ref2$translateWithId = _ref2.translateWithId,
        t = _ref2$translateWithId === void 0 ? translateWithId$1 : _ref2$translateWithId;
    var prefix = usePrefix();
    var itemLabel = t('carbon.pagination-nav.item');
    return /*#__PURE__*/React__default["default"].createElement("li", {
      className: "".concat(prefix, "--pagination-nav__list-item")
    }, /*#__PURE__*/React__default["default"].createElement("button", {
      type: "button",
      className: cx("".concat(prefix, "--pagination-nav__page"), _defineProperty$2({}, "".concat(prefix, "--pagination-nav__page--active"), isActive)),
      onClick: onClick,
      "data-page": page,
      "aria-current": isActive ? 'page' : null
    }, /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--pagination-nav__accessibility-label")
    }, isActive ? "".concat(t('carbon.pagination-nav.active'), ", ").concat(itemLabel) : itemLabel), page));
  }

  function PaginationOverflow(_ref3) {
    var fromIndex = _ref3.fromIndex,
        count = _ref3.count,
        onSelect = _ref3.onSelect,
        _ref3$translateWithId = _ref3.translateWithId,
        t = _ref3$translateWithId === void 0 ? translateWithId$1 : _ref3$translateWithId;
    var prefix = usePrefix();

    if (count > 1) {
      return /*#__PURE__*/React__default["default"].createElement("li", {
        className: "".concat(prefix, "--pagination-nav__list-item")
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: "".concat(prefix, "--pagination-nav__select")
      }, /*#__PURE__*/React__default["default"].createElement("select", {
        className: "".concat(prefix, "--pagination-nav__page ").concat(prefix, "--pagination-nav__page--select"),
        "aria-label": "Select ".concat(t('carbon.pagination-nav.item'), " number"),
        onChange: function onChange(e) {
          var index = Number(e.target.value);
          onSelect(index);
        }
      }, /*#__PURE__*/React__default["default"].createElement("option", {
        value: "",
        hidden: true
      }), _toConsumableArray(Array(count)).map(function (e, i) {
        return /*#__PURE__*/React__default["default"].createElement("option", {
          value: (fromIndex + i).toString(),
          "data-page": fromIndex + i + 1,
          key: "overflow-".concat(fromIndex + i)
        }, fromIndex + i + 1);
      })), /*#__PURE__*/React__default["default"].createElement("div", {
        className: "".concat(prefix, "--pagination-nav__select-icon-wrapper")
      }, /*#__PURE__*/React__default["default"].createElement(OverflowMenuHorizontal16, {
        className: "".concat(prefix, "--pagination-nav__select-icon")
      }))));
    }

    if (count === 1) {
      return /*#__PURE__*/React__default["default"].createElement(PaginationItem, {
        page: fromIndex + 1,
        translateWithId: t,
        onClick: function onClick() {
          onSelect(fromIndex);
        }
      });
    }

    return null;
  }

  var PaginationNav = /*#__PURE__*/React__default["default"].forwardRef(function PaginationNav(_ref4, ref) {
    var className = _ref4.className,
        _ref4$onChange = _ref4.onChange,
        onChange = _ref4$onChange === void 0 ? function () {} : _ref4$onChange,
        totalItems = _ref4.totalItems,
        _ref4$itemsShown = _ref4.itemsShown,
        itemsShown = _ref4$itemsShown === void 0 ? 10 : _ref4$itemsShown,
        _ref4$page = _ref4.page,
        page = _ref4$page === void 0 ? 0 : _ref4$page,
        _ref4$loop = _ref4.loop,
        loop = _ref4$loop === void 0 ? false : _ref4$loop,
        _ref4$translateWithId = _ref4.translateWithId,
        t = _ref4$translateWithId === void 0 ? translateWithId$1 : _ref4$translateWithId,
        rest = _objectWithoutProperties$2(_ref4, _excluded$1h);

    var _useState = React.useState(page),
        _useState2 = _slicedToArray$1(_useState, 2),
        currentPage = _useState2[0],
        setCurrentPage = _useState2[1];

    var _useState3 = React.useState(itemsShown >= 4 ? itemsShown : 4),
        _useState4 = _slicedToArray$1(_useState3, 2),
        itemsThatFit = _useState4[0],
        setItemsThatFit = _useState4[1];

    var _useState5 = React.useState(getCuts(currentPage, totalItems, itemsThatFit)),
        _useState6 = _slicedToArray$1(_useState5, 2),
        cuts = _useState6[0],
        setCuts = _useState6[1];

    var prevPage = usePrevious(currentPage);
    var prefix = usePrefix();

    function jumpToItem(index) {
      if (index >= 0 && index < totalItems) {
        setCurrentPage(index);
        onChange(index);
      }
    }

    function jumpToNext() {
      var nextIndex = currentPage + 1;

      if (nextIndex >= totalItems) {
        if (loop) {
          jumpToItem(0);
        }
      } else {
        jumpToItem(nextIndex);
      }
    }

    function jumpToPrevious() {
      var previousIndex = currentPage - 1;

      if (previousIndex < 0) {
        if (loop) {
          jumpToItem(totalItems - 1);
        }
      } else {
        jumpToItem(previousIndex);
      }
    }

    function pageWouldBeHidden(page) {
      var startOffset = itemsThatFit <= 4 && page > 1 ? 0 : 1;
      var wouldBeHiddenInFront = page >= startOffset && page <= cuts.front;
      var wouldBeHiddenInBack = page >= totalItems - cuts.back - 1 && page <= totalItems - 2;
      return wouldBeHiddenInFront || wouldBeHiddenInBack;
    } // jump to new page if props.page is updated


    React.useEffect(function () {
      setCurrentPage(page);
    }, [page]); // re-calculate cuts if props.totalItems or props.itemsShown change

    React.useEffect(function () {
      setItemsThatFit(itemsShown >= 4 ? itemsShown : 4);
      setCuts(getCuts(currentPage, totalItems, itemsShown));
    }, [totalItems, itemsShown]); // eslint-disable-line react-hooks/exhaustive-deps
    // update cuts if necessary whenever currentPage changes

    React.useEffect(function () {
      if (pageWouldBeHidden(currentPage)) {
        var delta = currentPage - prevPage || 0;

        if (delta > 0) {
          var splitPoint = itemsThatFit - 3;
          setCuts(getCuts(currentPage, totalItems, itemsThatFit, splitPoint));
        } else {
          var _splitPoint = itemsThatFit > 4 ? 2 : 1;

          setCuts(getCuts(currentPage, totalItems, itemsThatFit, _splitPoint));
        }
      }
    }, [currentPage]); // eslint-disable-line react-hooks/exhaustive-deps

    var classNames = cx("".concat(prefix, "--pagination-nav"), className);
    var backwardButtonDisabled = !loop && currentPage === 0;
    var forwardButtonDisabled = !loop && currentPage === totalItems - 1;
    var startOffset = itemsThatFit <= 4 && currentPage > 1 ? 0 : 1;
    return /*#__PURE__*/React__default["default"].createElement("nav", _extends$3({
      className: classNames,
      ref: ref
    }, rest, {
      "aria-label": "pagination"
    }), /*#__PURE__*/React__default["default"].createElement("ul", {
      className: "".concat(prefix, "--pagination-nav__list")
    }, /*#__PURE__*/React__default["default"].createElement(DirectionButton, {
      direction: "backward",
      label: t('carbon.pagination-nav.previous'),
      disabled: backwardButtonDisabled,
      onClick: jumpToPrevious
    }), // render first item if at least 5 items can be displayed or
    // 4 items can be displayed and the current page is either 0 or 1
    (itemsThatFit >= 5 || itemsThatFit <= 4 && currentPage <= 1) && /*#__PURE__*/React__default["default"].createElement(PaginationItem, {
      page: 1,
      translateWithId: t,
      isActive: currentPage === 0,
      onClick: function onClick() {
        jumpToItem(0);
      }
    }), /*#__PURE__*/React__default["default"].createElement(PaginationOverflow, {
      fromIndex: startOffset,
      count: cuts.front,
      onSelect: jumpToItem
    }), // render items between overflows
    _toConsumableArray(Array(totalItems)).map(function (e, i) {
      return i;
    }).slice(startOffset + cuts.front, (1 + cuts.back) * -1).map(function (item) {
      return /*#__PURE__*/React__default["default"].createElement(PaginationItem, {
        key: "item-".concat(item),
        page: item + 1,
        translateWithId: t,
        isActive: currentPage === item,
        onClick: function onClick() {
          jumpToItem(item);
        }
      });
    }), /*#__PURE__*/React__default["default"].createElement(PaginationOverflow, {
      fromIndex: totalItems - cuts.back - 1,
      count: cuts.back,
      onSelect: jumpToItem
    }), // render last item unless there is only one in total
    totalItems > 1 && /*#__PURE__*/React__default["default"].createElement(PaginationItem, {
      page: totalItems,
      translateWithId: t,
      isActive: currentPage === totalItems - 1,
      onClick: function onClick() {
        jumpToItem(totalItems - 1);
      }
    }), /*#__PURE__*/React__default["default"].createElement(DirectionButton, {
      direction: "forward",
      label: t('carbon.pagination-nav.next'),
      disabled: forwardButtonDisabled,
      onClick: jumpToNext
    })), /*#__PURE__*/React__default["default"].createElement("div", {
      "aria-live": "polite",
      "aria-atomic": "true",
      className: "".concat(prefix, "--pagination-nav__accessibility-label")
    }, "".concat(t('carbon.pagination-nav.item'), " ").concat(currentPage + 1, " ").concat(t('carbon.pagination-nav.of'), " ").concat(totalItems)));
  });
  DirectionButton.propTypes = {
    /**
     * The direction this button represents ("forward" or "backward").
     */
    direction: PropTypes__default["default"].oneOf(['forward', 'backward']),

    /**
     * Whether or not the button should be disabled.
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * The label shown in the button's tooltip.
     */
    label: PropTypes__default["default"].string,

    /**
     * The callback function called when the button is clicked.
     */
    onClick: PropTypes__default["default"].func
  };
  PaginationItem.propTypes = {
    /**
     * Whether or not this is the currently active page.
     */
    isActive: PropTypes__default["default"].bool,

    /**
     * The callback function called when the item is clicked.
     */
    onClick: PropTypes__default["default"].func,

    /**
     * The page number this item represents.
     */
    page: PropTypes__default["default"].number,

    /**
     * Specify a custom translation function that takes in a message identifier
     * and returns the localized string for the message
     */
    translateWithId: PropTypes__default["default"].func
  };
  PaginationOverflow.propTypes = {
    /**
     * How many items to display in this overflow.
     */
    count: PropTypes__default["default"].number,

    /**
     * From which index on this overflow should start displaying pages.
     */
    fromIndex: PropTypes__default["default"].number,

    /**
     * The callback function called when the user selects a page from the overflow.
     */
    onSelect: PropTypes__default["default"].func,

    /**
     * Specify a custom translation function that takes in a message identifier
     * and returns the localized string for the message
     */
    translateWithId: PropTypes__default["default"].func
  };
  PaginationNav.displayName = 'PaginationNav';
  PaginationNav.propTypes = {
    /**
     * Additional CSS class names.
     */
    className: PropTypes__default["default"].string,

    /**
     * The number of items to be shown.
     */
    itemsShown: PropTypes__default["default"].number,

    /**
     * Whether user should be able to loop through the items when reaching first / last.
     */
    loop: PropTypes__default["default"].bool,

    /**
     * The callback function called when the current page changes.
     */
    onChange: PropTypes__default["default"].func,

    /**
     * The current page.
     */
    page: PropTypes__default["default"].number,

    /**
     * The total number of items.
     */
    totalItems: PropTypes__default["default"].number,

    /**
     * Specify a custom translation function that takes in a message identifier
     * and returns the localized string for the message
     */
    translateWithId: PropTypes__default["default"].func
  };
  var PaginationNav$1 = PaginationNav;

  var invalidProps = function invalidProps(invalidId) {
    return {
      'data-invalid': true,
      'aria-invalid': true,
      'aria-describedby': invalidId
    };
  };

  var warnProps = function warnProps(warnId) {
    return {
      'aria-describedby': warnId
    };
  };

  var helperProps = function helperProps(helperId) {
    return {
      'aria-describedby': helperId
    };
  };

  var textInputProps = function textInputProps(_ref) {
    var sharedTextInputProps = _ref.sharedTextInputProps,
        invalid = _ref.invalid,
        invalidId = _ref.invalidId,
        warn = _ref.warn,
        warnId = _ref.warnId,
        hasHelper = _ref.hasHelper,
        helperId = _ref.helperId;
    return _objectSpread2$2(_objectSpread2$2(_objectSpread2$2(_objectSpread2$2({}, sharedTextInputProps), invalid ? invalidProps(invalidId) : {}), warn ? warnProps(warnId) : {}), hasHelper ? helperProps(helperId) : {});
  };

  var _excluded$1g = ["labelText", "className", "id", "placeholder", "onChange", "onClick", "hideLabel", "invalid", "invalidText", "helperText", "light", "type", "togglePasswordVisibility", "tooltipPosition", "tooltipAlignment", "hidePasswordLabel", "showPasswordLabel", "size"];
  var getInstanceId$7 = setupGetInstanceId$2();
  var didWarnAboutDeprecation$5 = false;
  var ControlledPasswordInput = /*#__PURE__*/React__default["default"].forwardRef(function ControlledPasswordInput(_ref, ref) {
    var _classNames, _classNames2, _classNames4;

    var labelText = _ref.labelText,
        className = _ref.className,
        id = _ref.id,
        placeholder = _ref.placeholder,
        _onChange = _ref.onChange,
        _onClick = _ref.onClick,
        hideLabel = _ref.hideLabel,
        invalid = _ref.invalid,
        invalidText = _ref.invalidText,
        helperText = _ref.helperText,
        light = _ref.light,
        _ref$type = _ref.type,
        type = _ref$type === void 0 ? 'password' : _ref$type,
        togglePasswordVisibility = _ref.togglePasswordVisibility,
        _ref$tooltipPosition = _ref.tooltipPosition,
        tooltipPosition = _ref$tooltipPosition === void 0 ? 'bottom' : _ref$tooltipPosition,
        _ref$tooltipAlignment = _ref.tooltipAlignment,
        tooltipAlignment = _ref$tooltipAlignment === void 0 ? 'center' : _ref$tooltipAlignment,
        _ref$hidePasswordLabe = _ref.hidePasswordLabel,
        hidePasswordLabel = _ref$hidePasswordLabe === void 0 ? 'Hide password' : _ref$hidePasswordLabe,
        _ref$showPasswordLabe = _ref.showPasswordLabel,
        showPasswordLabel = _ref$showPasswordLabe === void 0 ? 'Show password' : _ref$showPasswordLabe,
        size = _ref.size,
        other = _objectWithoutProperties$2(_ref, _excluded$1g);

    var prefix = usePrefix();

    var _useRef = React.useRef(getInstanceId$7()),
        controlledPasswordInstanceId = _useRef.current;

    {
      warning(didWarnAboutDeprecation$5, '`<TextInput.ControlledPasswordInput>` has been deprecated in favor of `<TextInput.PasswordInput />` and will be removed in the next major release of `carbon-components-react`') ;
      didWarnAboutDeprecation$5 = true;
    }

    var errorId = id + '-error-msg';
    var textInputClasses = cx("".concat(prefix, "--text-input"), "".concat(prefix, "--password-input"), className, (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--text-input--light"), light), _defineProperty$2(_classNames, "".concat(prefix, "--text-input--invalid"), invalid), _defineProperty$2(_classNames, "".concat(prefix, "--text-input--").concat(size), size), _classNames));

    var sharedTextInputProps = _objectSpread2$2({
      id: id,
      onChange: function onChange(evt) {
        if (!other.disabled) {
          _onChange(evt);
        }
      },
      onClick: function onClick(evt) {
        if (!other.disabled) {
          _onClick(evt);
        }
      },
      placeholder: placeholder,
      type: type,
      ref: ref,
      className: textInputClasses
    }, other);

    var labelClasses = cx("".concat(prefix, "--label"), (_classNames2 = {}, _defineProperty$2(_classNames2, "".concat(prefix, "--visually-hidden"), hideLabel), _defineProperty$2(_classNames2, "".concat(prefix, "--label--disabled"), other.disabled), _classNames2));
    var helperTextClasses = cx("".concat(prefix, "--form__helper-text"), _defineProperty$2({}, "".concat(prefix, "--form__helper-text--disabled"), other.disabled));
    var label = labelText ? /*#__PURE__*/React__default["default"].createElement("label", {
      htmlFor: id,
      className: labelClasses
    }, labelText) : null;
    var error = invalid ? /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--form-requirement"),
      id: errorId
    }, invalidText) : null;
    var passwordIsVisible = type === 'text';
    var passwordVisibilityIcon = passwordIsVisible ? /*#__PURE__*/React__default["default"].createElement(ViewOff16, {
      className: "".concat(prefix, "--icon-visibility-off")
    }) : /*#__PURE__*/React__default["default"].createElement(View16, {
      className: "".concat(prefix, "--icon-visibility-on")
    });
    var passwordVisibilityToggleClasses = cx("".concat(prefix, "--text-input--password__visibility__toggle"), "".concat(prefix, "--btn"), "".concat(prefix, "--btn--icon-only"), "".concat(prefix, "--tooltip__trigger"), "".concat(prefix, "--tooltip--a11y"), (_classNames4 = {}, _defineProperty$2(_classNames4, "".concat(prefix, "--tooltip--").concat(tooltipPosition), tooltipPosition), _defineProperty$2(_classNames4, "".concat(prefix, "--tooltip--align-").concat(tooltipAlignment), tooltipAlignment), _classNames4));
    var helperId = !helperText ? undefined : "controlled-password-helper-text-".concat(controlledPasswordInstanceId);
    var input = /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("input", _extends$3({}, textInputProps({
      invalid: invalid,
      sharedTextInputProps: sharedTextInputProps,
      invalidId: errorId,
      hasHelper: !error && helperText,
      helperId: helperId
    }), {
      "data-toggle-password-visibility": type === 'password'
    })), /*#__PURE__*/React__default["default"].createElement("button", {
      type: "button",
      className: passwordVisibilityToggleClasses,
      onClick: togglePasswordVisibility
    }, /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--assistive-text")
    }, passwordIsVisible ? hidePasswordLabel : showPasswordLabel), passwordVisibilityIcon));
    var helper = helperText ? /*#__PURE__*/React__default["default"].createElement("div", {
      id: helperId,
      className: helperTextClasses
    }, helperText) : null;
    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--form-item ").concat(prefix, "--text-input-wrapper ").concat(prefix, "--password-input-wrapper")
    }, label, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--text-input__field-wrapper"),
      "data-invalid": invalid || null
    }, invalid && /*#__PURE__*/React__default["default"].createElement(WarningFilled16, {
      className: "".concat(prefix, "--text-input__invalid-icon")
    }), input), error ? error : helper);
  });
  ControlledPasswordInput.displayName = 'ControlledPasswordInput';
  ControlledPasswordInput.propTypes = {
    /**
     * Provide a custom className that is applied directly to the underlying
     * `<input>` node
     */
    className: PropTypes__default["default"].string,

    /**
     * Optionally provide the default value of the `<input>`
     */
    defaultValue: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),

    /**
     * Specify whether the control is disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Provide text that is used alongside the control label for additional help
     */
    helperText: PropTypes__default["default"].node,

    /**
     * Specify whether or not the underlying label is visually hidden
     */
    hideLabel: PropTypes__default["default"].bool,

    /**
     * "Hide password" tooltip text on password visibility toggle
     */
    hidePasswordLabel: PropTypes__default["default"].string,

    /**
     * Provide a unique identifier for the input field
     */
    id: PropTypes__default["default"].string.isRequired,

    /**
     * Specify whether the control is currently invalid
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * Provide the text that is displayed when the control is in an invalid state
     */
    invalidText: PropTypes__default["default"].node,

    /**
     * Provide the text that will be read by a screen reader when visiting this
     * control
     */
    labelText: PropTypes__default["default"].node.isRequired,

    /**
     * `true` to use the light version. For use on $ui-01 backgrounds only.
     * Don't use this to make tile background color same as container background color.
     */
    light: PropTypes__default["default"].bool,

    /**
     * Optionally provide an `onChange` handler that is called whenever `<input>`
     * is updated
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Optionally provide an `onClick` handler that is called whenever the
     * `<input>` is clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Specify the placeholder attribute for the `<input>`
     */
    placeholder: PropTypes__default["default"].string,

    /**
     * "Show password" tooltip text on password visibility toggle
     */
    showPasswordLabel: PropTypes__default["default"].string,

    /**
     * Specify the size of the Text Input. Currently supports either `small` or `large` as an option. If omitted, defaults to standard size
     */
    size: PropTypes__default["default"].string,

    /**
     * Specify the alignment of the tooltip to the icon-only button.
     * Can be one of: start, center, or end.
     */
    tooltipAlignment: PropTypes__default["default"].oneOf(['start', 'center', 'end']),

    /**
     * Specify the direction of the tooltip for icon-only buttons.
     * Can be either top, right, bottom, or left.
     */
    tooltipPosition: PropTypes__default["default"].oneOf(['top', 'right', 'bottom', 'left']),

    /**
     * Provide the current value of the `<input>`
     */
    value: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number])
  };
  ControlledPasswordInput.defaultProps = {
    className: '${prefix}--text__input',
    disabled: false,
    onChange: function onChange() {},
    onClick: function onClick() {},
    invalid: false,
    invalidText: '',
    helperText: '',
    light: false,
    size: ''
  };
  var ControlledPasswordInput$1 = ControlledPasswordInput;

  var _excluded$1f = ["className", "disabled", "helperText", "hideLabel", "hidePasswordLabel", "id", "inline", "invalid", "invalidText", "labelText", "light", "onChange", "onClick", "onTogglePasswordVisibility", "placeholder", "size", "showPasswordLabel", "tooltipPosition", "tooltipAlignment", "type", "warn", "warnText"];
  var PasswordInput = /*#__PURE__*/React__default["default"].forwardRef(function PasswordInput(_ref, ref) {
    var _classNames, _classNames2, _classNames3, _classNames4, _classNames7, _classNames8;

    var className = _ref.className,
        _ref$disabled = _ref.disabled,
        disabled = _ref$disabled === void 0 ? false : _ref$disabled,
        helperText = _ref.helperText,
        hideLabel = _ref.hideLabel,
        _ref$hidePasswordLabe = _ref.hidePasswordLabel,
        hidePasswordLabel = _ref$hidePasswordLabe === void 0 ? 'Hide password' : _ref$hidePasswordLabe,
        id = _ref.id,
        inline = _ref.inline,
        _ref$invalid = _ref.invalid,
        invalid = _ref$invalid === void 0 ? false : _ref$invalid,
        invalidText = _ref.invalidText,
        labelText = _ref.labelText,
        _ref$light = _ref.light,
        light = _ref$light === void 0 ? false : _ref$light,
        _ref$onChange = _ref.onChange,
        _onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
        _ref$onClick = _ref.onClick,
        _onClick = _ref$onClick === void 0 ? function () {} : _ref$onClick,
        onTogglePasswordVisibility = _ref.onTogglePasswordVisibility,
        placeholder = _ref.placeholder,
        _ref$size = _ref.size,
        size = _ref$size === void 0 ? 'md' : _ref$size,
        _ref$showPasswordLabe = _ref.showPasswordLabel,
        showPasswordLabel = _ref$showPasswordLabe === void 0 ? 'Show password' : _ref$showPasswordLabe,
        _ref$tooltipPosition = _ref.tooltipPosition,
        tooltipPosition = _ref$tooltipPosition === void 0 ? 'bottom' : _ref$tooltipPosition,
        _ref$tooltipAlignment = _ref.tooltipAlignment,
        tooltipAlignment = _ref$tooltipAlignment === void 0 ? 'center' : _ref$tooltipAlignment,
        _ref$type = _ref.type,
        type = _ref$type === void 0 ? 'password' : _ref$type,
        warn = _ref.warn,
        warnText = _ref.warnText,
        rest = _objectWithoutProperties$2(_ref, _excluded$1f);

    var _useState = React.useState(type),
        _useState2 = _slicedToArray$1(_useState, 2),
        inputType = _useState2[0],
        setInputType = _useState2[1];

    var prefix = usePrefix();
    var normalizedProps = useNormalizedInputProps({
      id: id,
      invalid: invalid,
      invalidText: invalidText,
      warn: warn,
      warnText: warnText
    });

    var handleTogglePasswordVisibility = function handleTogglePasswordVisibility(event) {
      setInputType(inputType === 'password' ? 'text' : 'password');
      onTogglePasswordVisibility && onTogglePasswordVisibility(event);
    };

    var textInputClasses = cx("".concat(prefix, "--text-input"), "".concat(prefix, "--password-input"), className, (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--text-input--light"), light), _defineProperty$2(_classNames, "".concat(prefix, "--text-input--invalid"), normalizedProps.invalid), _defineProperty$2(_classNames, "".concat(prefix, "--text-input--warning"), normalizedProps.warn), _defineProperty$2(_classNames, "".concat(prefix, "--text-input--").concat(size), size), _classNames));

    var sharedTextInputProps = _objectSpread2$2({
      id: id,
      onChange: function onChange(evt) {
        if (!disabled) {
          _onChange(evt);
        }
      },
      onClick: function onClick(evt) {
        if (!disabled) {
          _onClick(evt);
        }
      },
      placeholder: placeholder,
      type: inputType,
      className: textInputClasses,
      ref: ref
    }, rest);

    var inputWrapperClasses = cx("".concat(prefix, "--form-item"), "".concat(prefix, "--text-input-wrapper"), "".concat(prefix, "--password-input-wrapper"), (_classNames2 = {}, _defineProperty$2(_classNames2, "".concat(prefix, "--text-input-wrapper--light"), light), _defineProperty$2(_classNames2, "".concat(prefix, "--text-input-wrapper--inline"), inline), _classNames2));
    var labelClasses = cx("".concat(prefix, "--label"), (_classNames3 = {}, _defineProperty$2(_classNames3, "".concat(prefix, "--visually-hidden"), hideLabel), _defineProperty$2(_classNames3, "".concat(prefix, "--label--disabled"), disabled), _defineProperty$2(_classNames3, "".concat(prefix, "--label--inline"), inline), _defineProperty$2(_classNames3, "".concat(prefix, "--label--inline--").concat(size), inline && !!size), _classNames3));
    var helperTextClasses = cx("".concat(prefix, "--form__helper-text"), (_classNames4 = {}, _defineProperty$2(_classNames4, "".concat(prefix, "--form__helper-text--disabled"), disabled), _defineProperty$2(_classNames4, "".concat(prefix, "--form__helper-text--inline"), inline), _classNames4));
    var fieldOuterWrapperClasses = cx("".concat(prefix, "--text-input__field-outer-wrapper"), _defineProperty$2({}, "".concat(prefix, "--text-input__field-outer-wrapper--inline"), inline));
    var fieldWrapperClasses = cx("".concat(prefix, "--text-input__field-wrapper"), _defineProperty$2({}, "".concat(prefix, "--text-input__field-wrapper--warning"), normalizedProps.warn));
    var iconClasses = cx((_classNames7 = {}, _defineProperty$2(_classNames7, "".concat(prefix, "--text-input__invalid-icon"), normalizedProps.invalid || normalizedProps.warn), _defineProperty$2(_classNames7, "".concat(prefix, "--text-input__invalid-icon--warning"), normalizedProps.warn), _classNames7));
    var label = labelText ? /*#__PURE__*/React__default["default"].createElement("label", {
      htmlFor: id,
      className: labelClasses
    }, labelText) : null;
    var helper = helperText ? /*#__PURE__*/React__default["default"].createElement("div", {
      d: normalizedProps.helperId,
      className: helperTextClasses
    }, helperText) : null;
    var passwordIsVisible = inputType === 'text';
    var passwordVisibilityIcon = passwordIsVisible ? /*#__PURE__*/React__default["default"].createElement(ViewOff16, {
      className: "".concat(prefix, "--icon-visibility-off")
    }) : /*#__PURE__*/React__default["default"].createElement(View16, {
      className: "".concat(prefix, "--icon-visibility-on")
    });
    var passwordVisibilityToggleClasses = cx("".concat(prefix, "--text-input--password__visibility__toggle"), "".concat(prefix, "--btn"), "".concat(prefix, "--btn--icon-only"), "".concat(prefix, "--tooltip__trigger"), "".concat(prefix, "--tooltip--a11y"), (_classNames8 = {}, _defineProperty$2(_classNames8, "".concat(prefix, "--btn--disabled"), disabled), _defineProperty$2(_classNames8, "".concat(prefix, "--tooltip--").concat(tooltipPosition), tooltipPosition), _defineProperty$2(_classNames8, "".concat(prefix, "--tooltip--align-").concat(tooltipAlignment), tooltipAlignment), _classNames8));
    var input = /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("input", _extends$3({}, textInputProps({
      sharedTextInputProps: sharedTextInputProps,
      invalid: normalizedProps.invalid,
      invalidId: normalizedProps.invalidId,
      warn: normalizedProps.warn,
      warnId: normalizedProps.warnId,
      hasHelper: Boolean(helperText && !isFluid && (inline || !inline && !normalizedProps.validation)),
      helperId: normalizedProps.helperId
    }), {
      disabled: disabled,
      "data-toggle-password-visibility": inputType === 'password'
    })), /*#__PURE__*/React__default["default"].createElement("button", {
      type: "button",
      className: passwordVisibilityToggleClasses,
      disabled: disabled,
      onClick: handleTogglePasswordVisibility
    }, !disabled && /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--assistive-text")
    }, passwordIsVisible ? hidePasswordLabel : showPasswordLabel), passwordVisibilityIcon));

    var _useContext = React.useContext(FormContext),
        isFluid = _useContext.isFluid;

    React.useEffect(function () {
      setInputType(type);
    }, [type]);
    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: inputWrapperClasses
    }, !inline ? label : /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--text-input__label-helper-wrapper")
    }, label, !isFluid && helper), /*#__PURE__*/React__default["default"].createElement("div", {
      className: fieldOuterWrapperClasses
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: fieldWrapperClasses,
      "data-invalid": normalizedProps.invalid || null
    }, normalizedProps.icon && /*#__PURE__*/React__default["default"].createElement(normalizedProps.icon, {
      className: iconClasses
    }), input, isFluid && !inline && normalizedProps.validation), !isFluid && !inline && (normalizedProps.validation || helper)));
  });
  PasswordInput.displayName = 'PasswordInput';
  PasswordInput.propTypes = {
    /**
     * Provide a custom className that is applied directly to the underlying
     * `<input>` node
     */
    className: PropTypes__default["default"].string,

    /**
     * Optionally provide the default value of the `<input>`
     */
    defaultValue: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),

    /**
     * Specify whether the control is disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Provide text that is used alongside the control label for additional help
     */
    helperText: PropTypes__default["default"].node,

    /**
     * Specify whether or not the underlying label is visually hidden
     */
    hideLabel: PropTypes__default["default"].bool,

    /**
     * "Hide password" tooltip text on password visibility toggle
     */
    hidePasswordLabel: PropTypes__default["default"].string,

    /**
     * Provide a unique identifier for the input field
     */
    id: PropTypes__default["default"].string.isRequired,

    /**
     * `true` to use the inline version.
     */
    inline: PropTypes__default["default"].bool,

    /**
     * Specify whether the control is currently invalid
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * Provide the text that is displayed when the control is in an invalid state
     */
    invalidText: PropTypes__default["default"].node,

    /**
     * Provide the text that will be read by a screen reader when visiting this
     * control
     */
    labelText: PropTypes__default["default"].node.isRequired,

    /**
     * `true` to use the light version. For use on $ui-01 backgrounds only.
     * Don't use this to make tile background color same as container background color.
     */
    light: PropTypes__default["default"].bool,

    /**
     * Optionally provide an `onChange` handler that is called whenever `<input>`
     * is updated
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Optionally provide an `onClick` handler that is called whenever the
     * `<input>` is clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Callback function that is called whenever the toggle password visibility
     * button is clicked
     */
    onTogglePasswordVisibility: PropTypes__default["default"].func,

    /**
     * Specify the placeholder attribute for the `<input>`
     */
    placeholder: PropTypes__default["default"].string,

    /**
     * "Show password" tooltip text on password visibility toggle
     */
    showPasswordLabel: PropTypes__default["default"].string,

    /**
     * Specify the size of the Text Input. Supports `sm`, `md`, or `lg`.
     */
    size: enabled('enable-v11-release') ? PropTypes__default["default"].oneOf(['sm', 'md', 'lg']) : PropTypes__default["default"].string,

    /**
     * Specify the alignment of the tooltip to the icon-only button.
     * Can be one of: start, center, or end.
     */
    tooltipAlignment: PropTypes__default["default"].oneOf(['start', 'center', 'end']),

    /**
     * Specify the direction of the tooltip for icon-only buttons.
     * Can be either top, right, bottom, or left.
     */
    tooltipPosition: PropTypes__default["default"].oneOf(['top', 'right', 'bottom', 'left']),

    /**
     * The input type, either password or text
     */
    type: PropTypes__default["default"].oneOf(['password', 'text']),

    /**
     * Provide the current value of the `<input>`
     */
    value: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),

    /**
     * Specify whether the control is currently in warning state
     */
    warn: PropTypes__default["default"].bool,

    /**
     * Provide the text that is displayed when the control is in warning state
     */
    warnText: PropTypes__default["default"].node
  };
  var PasswordInput$1 = PasswordInput;

  var PrimaryButton = function PrimaryButton(props) {
    return /*#__PURE__*/React__default["default"].createElement(Button$1, _extends$3({
      kind: "primary"
    }, props));
  };

  var PrimaryButton$1 = PrimaryButton;

  var _excluded$1e = ["className"];

  function Step() {
    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("li", {
      className: "".concat(prefix, "--progress-step ").concat(prefix, "--progress-step--incomplete")
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--progress-step-button ").concat(prefix, "--progress-step-button--unclickable")
    }, /*#__PURE__*/React__default["default"].createElement("svg", null, /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M 7, 7 m -7, 0 a 7,7 0 1,0 14,0 a 7,7 0 1,0 -14,0"
    })), /*#__PURE__*/React__default["default"].createElement("p", {
      className: "".concat(prefix, "--progress-label")
    }), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--progress-line")
    })));
  }

  function ProgressIndicatorSkeleton(_ref) {
    var className = _ref.className,
        rest = _objectWithoutProperties$2(_ref, _excluded$1e);

    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("ul", _extends$3({
      className: cx("".concat(prefix, "--progress"), "".concat(prefix, "--skeleton"), className)
    }, rest), /*#__PURE__*/React__default["default"].createElement(Step, null), /*#__PURE__*/React__default["default"].createElement(Step, null), /*#__PURE__*/React__default["default"].createElement(Step, null), /*#__PURE__*/React__default["default"].createElement(Step, null));
  }

  ProgressIndicatorSkeleton.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes__default["default"].string
  };

  var _excluded$1d = ["label", "description", "className", "current", "complete", "invalid", "secondaryLabel", "disabled", "onClick", "renderLabel", "translateWithId"],
      _excluded2$6 = ["className", "currentIndex", "vertical", "spaceEqually"];

  var defaultRenderLabel = function defaultRenderLabel(props) {
    return /*#__PURE__*/React__default["default"].createElement("p", props);
  };

  var defaultTranslations = {
    'carbon.progress-step.complete': 'Complete',
    'carbon.progress-step.incomplete': 'Incomplete',
    'carbon.progress-step.current': 'Current',
    'carbon.progress-step.invalid': 'Invalid'
  };

  function translateWithId(messageId) {
    return defaultTranslations[messageId];
  }

  function ProgressStep(_ref) {
    var _classnames;

    var label = _ref.label,
        description = _ref.description,
        className = _ref.className,
        current = _ref.current,
        complete = _ref.complete,
        invalid = _ref.invalid,
        secondaryLabel = _ref.secondaryLabel,
        disabled = _ref.disabled,
        onClick = _ref.onClick,
        ProgressStepLabel = _ref.renderLabel,
        t = _ref.translateWithId,
        rest = _objectWithoutProperties$2(_ref, _excluded$1d);

    var prefix = usePrefix();
    var classes = cx((_classnames = {}, _defineProperty$2(_classnames, "".concat(prefix, "--progress-step"), true), _defineProperty$2(_classnames, "".concat(prefix, "--progress-step--current"), current), _defineProperty$2(_classnames, "".concat(prefix, "--progress-step--complete"), complete), _defineProperty$2(_classnames, "".concat(prefix, "--progress-step--incomplete"), !complete && !current), _defineProperty$2(_classnames, "".concat(prefix, "--progress-step--disabled"), disabled), _defineProperty$2(_classnames, className, className), _classnames));

    var handleKeyDown = function handleKeyDown(e) {
      if (matches(e, [Enter, Space])) {
        onClick();
      }
    }; // eslint-disable-next-line react/prop-types


    var SVGIcon = function SVGIcon(_ref2) {
      var complete = _ref2.complete,
          current = _ref2.current,
          description = _ref2.description,
          invalid = _ref2.invalid,
          prefix = _ref2.prefix;

      if (invalid) {
        return /*#__PURE__*/React__default["default"].createElement(Warning16, {
          className: "".concat(prefix, "--progress__warning")
        }, /*#__PURE__*/React__default["default"].createElement("title", null, description));
      }

      if (current) {
        return /*#__PURE__*/React__default["default"].createElement(Incomplete16, null, /*#__PURE__*/React__default["default"].createElement("title", null, description));
      }

      if (complete) {
        return /*#__PURE__*/React__default["default"].createElement(CheckmarkOutline16, null, /*#__PURE__*/React__default["default"].createElement("title", null, description));
      }

      return /*#__PURE__*/React__default["default"].createElement(CircleDash16, null, /*#__PURE__*/React__default["default"].createElement("title", null, description));
    };

    var message = t('carbon.progress-step.incomplete');

    if (current) {
      message = t('carbon.progress-step.current');
    }

    if (complete) {
      message = t('carbon.progress-step.complete');
    }

    if (invalid) {
      message = t('carbon.progress-step.invalid');
    }

    return /*#__PURE__*/React__default["default"].createElement("li", {
      className: classes
    }, /*#__PURE__*/React__default["default"].createElement("button", _extends$3({
      type: "button",
      className: cx("".concat(prefix, "--progress-step-button"), _defineProperty$2({}, "".concat(prefix, "--progress-step-button--unclickable"), !onClick || current)),
      disabled: disabled,
      "aria-disabled": disabled,
      tabIndex: !current && onClick && !disabled ? 0 : -1,
      onClick: !current ? onClick : undefined,
      onKeyDown: handleKeyDown,
      title: label
    }, rest), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--assistive-text")
    }, message), /*#__PURE__*/React__default["default"].createElement(SVGIcon, {
      complete: complete,
      current: current,
      description: description,
      invalid: invalid,
      prefix: prefix
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--progress-text")
    }, /*#__PURE__*/React__default["default"].createElement(ProgressStepLabel, {
      className: "".concat(prefix, "--progress-label")
    }, label), secondaryLabel !== null && secondaryLabel !== undefined ? /*#__PURE__*/React__default["default"].createElement("p", {
      className: "".concat(prefix, "--progress-optional")
    }, secondaryLabel) : null), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--progress-line")
    })));
  }
  ProgressStep.propTypes = {
    /**
     * Provide an optional className to be applied to the containing `<li>` node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the step has been completed
     */
    complete: PropTypes__default["default"].bool,

    /**
     * Specify whether the step is the current step
     */
    current: PropTypes__default["default"].bool,

    /**
     * Provide a description for the <ProgressStep>
     */
    description: PropTypes__default["default"].string,

    /**
     * Specify whether the step is disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Index of the current step within the ProgressIndicator
     */
    index: PropTypes__default["default"].number,

    /**
     * Specify whether the step is invalid
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * Provide the label for the <ProgressStep>
     */
    label: PropTypes__default["default"].node.isRequired,

    /**
     * A callback called if the step is clicked or the enter key is pressed
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Provide the props that describe a progress step tooltip
     */
    overflowTooltipProps: PropTypes__default["default"].object,

    /*
     * An optional parameter to allow for overflow content to be rendered in a
     * tooltip.
     */
    renderLabel: PropTypes__default["default"].func,

    /**
     * Provide an optional secondary label
     */
    secondaryLabel: PropTypes__default["default"].string,

    /**
     * The ID of the tooltip content.
     */
    tooltipId: PropTypes__default["default"].string,

    /**
     * Optional method that takes in a message id and returns an
     * internationalized string.
     */
    translateWithId: PropTypes__default["default"].func
  };
  ProgressStep.defaultProps = {
    renderLabel: defaultRenderLabel,
    translateWithId: translateWithId
  };
  var ProgressIndicator$2 = /*#__PURE__*/function (_Component) {
    _inherits(ProgressIndicator, _Component);

    var _super = _createSuper(ProgressIndicator);

    function ProgressIndicator() {
      var _this;

      _classCallCheck$1(this, ProgressIndicator);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty$2(_assertThisInitialized$1(_this), "state", {});

      _defineProperty$2(_assertThisInitialized$1(_this), "renderSteps", function () {
        var onChange = _this.props.onChange;
        return React__default["default"].Children.map(_this.props.children, function (child, index) {
          // only setup click handlers if onChange event is passed
          var onClick = onChange ? function () {
            return onChange(index);
          } : undefined;

          if (index === _this.state.currentIndex) {
            return /*#__PURE__*/React__default["default"].cloneElement(child, {
              current: true,
              index: index,
              onClick: onClick
            });
          }

          if (index < _this.state.currentIndex) {
            return /*#__PURE__*/React__default["default"].cloneElement(child, {
              complete: true,
              index: index,
              onClick: onClick
            });
          }

          if (index > _this.state.currentIndex) {
            return /*#__PURE__*/React__default["default"].cloneElement(child, {
              complete: child.props.complete || false,
              index: index,
              onClick: onClick
            });
          }

          return null;
        });
      });

      return _this;
    }

    _createClass$1(ProgressIndicator, [{
      key: "render",
      value: function render() {
        var _classnames3;

        var _this$props = this.props,
            className = _this$props.className;
            _this$props.currentIndex;
            var vertical = _this$props.vertical,
            spaceEqually = _this$props.spaceEqually,
            other = _objectWithoutProperties$2(_this$props, _excluded2$6);

        var prefix = this.context;
        var classes = cx((_classnames3 = {}, _defineProperty$2(_classnames3, "".concat(prefix, "--progress"), true), _defineProperty$2(_classnames3, "".concat(prefix, "--progress--vertical"), vertical), _defineProperty$2(_classnames3, "".concat(prefix, "--progress--space-equal"), spaceEqually && !vertical), _defineProperty$2(_classnames3, className, className), _classnames3));
        return /*#__PURE__*/React__default["default"].createElement("ul", _extends$3({
          className: classes
        }, other), this.renderSteps());
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref3, state) {
        var currentIndex = _ref3.currentIndex;
        var prevCurrentIndex = state.prevCurrentIndex;
        return prevCurrentIndex === currentIndex ? null : {
          currentIndex: currentIndex,
          prevCurrentIndex: currentIndex
        };
      }
    }]);

    return ProgressIndicator;
  }(React.Component);

  _defineProperty$2(ProgressIndicator$2, "propTypes", {
    /**
     * Provide <ProgressStep> components to be rendered in the
     * <ProgressIndicator>
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide an optional className to be applied to the containing node
     */
    className: PropTypes__default["default"].string,

    /**
     * Optionally specify the current step array index
     */
    currentIndex: PropTypes__default["default"].number,

    /**
     * Optional callback called if a ProgressStep is clicked on.  Returns the index of the step.
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Specify whether the progress steps should be split equally in size in the div
     */
    spaceEqually: PropTypes__default["default"].bool,

    /**
     * Determines whether or not the ProgressIndicator should be rendered vertically.
     */
    vertical: PropTypes__default["default"].bool
  });

  _defineProperty$2(ProgressIndicator$2, "contextType", PrefixContext);

  _defineProperty$2(ProgressIndicator$2, "defaultProps", {
    currentIndex: 0
  });

  var _excluded$1c = ["children", "className", "currentIndex", "onChange", "spaceEqually", "vertical"];

  function ProgressIndicator$1(_ref) {
    var _cx;

    var children = _ref.children,
        customClassName = _ref.className,
        _ref$currentIndex = _ref.currentIndex,
        controlledIndex = _ref$currentIndex === void 0 ? 0 : _ref$currentIndex,
        onChange = _ref.onChange,
        spaceEqually = _ref.spaceEqually,
        vertical = _ref.vertical,
        rest = _objectWithoutProperties$2(_ref, _excluded$1c);

    var prefix = usePrefix();

    var _useState = React.useState(controlledIndex),
        _useState2 = _slicedToArray$1(_useState, 2),
        currentIndex = _useState2[0],
        setCurrentIndex = _useState2[1];

    var _useState3 = React.useState(controlledIndex),
        _useState4 = _slicedToArray$1(_useState3, 2),
        prevControlledIndex = _useState4[0],
        setPrevControlledIndex = _useState4[1];

    var className = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--progress"), true), _defineProperty$2(_cx, "".concat(prefix, "--progress--vertical"), vertical), _defineProperty$2(_cx, "".concat(prefix, "--progress--space-equal"), spaceEqually && !vertical), _defineProperty$2(_cx, customClassName, customClassName), _cx));

    if (controlledIndex !== prevControlledIndex) {
      setCurrentIndex(controlledIndex);
      setPrevControlledIndex(controlledIndex);
    }

    return /*#__PURE__*/React__default["default"].createElement("ul", _extends$3({
      className: className
    }, rest), React__default["default"].Children.map(children, function (child, index) {
      // only setup click handlers if onChange event is passed
      var onClick = onChange ? function () {
        return onChange(index);
      } : undefined;

      if (index === currentIndex) {
        return /*#__PURE__*/React__default["default"].cloneElement(child, {
          current: true,
          index: index,
          onClick: onClick
        });
      }

      if (index < currentIndex) {
        return /*#__PURE__*/React__default["default"].cloneElement(child, {
          complete: true,
          index: index,
          onClick: onClick
        });
      }

      if (index > currentIndex) {
        return /*#__PURE__*/React__default["default"].cloneElement(child, {
          complete: child.props.complete || false,
          index: index,
          onClick: onClick
        });
      }

      return null;
    }));
  }

  ProgressIndicator$1.propTypes = {
    /**
     * Provide <ProgressStep> components to be rendered in the
     * <ProgressIndicator>
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide an optional className to be applied to the containing node
     */
    className: PropTypes__default["default"].string,

    /**
     * Optionally specify the current step array index
     */
    currentIndex: PropTypes__default["default"].number,

    /**
     * Optional callback called if a ProgressStep is clicked on.  Returns the index of the step.
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Specify whether the progress steps should be split equally in size in the div
     */
    spaceEqually: PropTypes__default["default"].bool,

    /**
     * Determines whether or not the ProgressIndicator should be rendered vertically.
     */
    vertical: PropTypes__default["default"].bool
  };

  var ProgressIndicator = enabled('enable-v11-release') ? ProgressIndicator$1 : ProgressIndicator$2;

  var RadioButtonGroup$3 = /*#__PURE__*/React__default["default"].forwardRef(function RadioButtonGroup(_ref, ref) {
    var _classNames;

    var children = _ref.children,
        className = _ref.className,
        defaultSelected = _ref.defaultSelected,
        disabled = _ref.disabled,
        _ref$labelPosition = _ref.labelPosition,
        labelPosition = _ref$labelPosition === void 0 ? 'right' : _ref$labelPosition,
        legendText = _ref.legendText,
        name = _ref.name,
        _ref$onChange = _ref.onChange,
        onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
        _ref$orientation = _ref.orientation,
        orientation = _ref$orientation === void 0 ? 'horizontal' : _ref$orientation,
        valueSelected = _ref.valueSelected;
    var prefix = usePrefix();

    var _useState = React.useState(valueSelected !== 'undefined' ? valueSelected : defaultSelected),
        _useState2 = _slicedToArray$1(_useState, 2),
        selected = _useState2[0],
        setSelected = _useState2[1];

    var _useState3 = React.useState(selected),
        _useState4 = _slicedToArray$1(_useState3, 2),
        prevValueSelected = _useState4[0],
        setPrevValueSelected = _useState4[1];
    /**
     * prop + state alignment - getDerivedStateFromProps
     * only update if selected prop changes
     */


    if (prevValueSelected !== valueSelected) {
      setSelected(valueSelected !== 'undefined' ? valueSelected : defaultSelected);
      setPrevValueSelected(valueSelected);
    }

    function getRadioButtons() {
      var mappedChildren = React__default["default"].Children.map(children, function (radioButton) {
        var value = radioButton.props.value;
        return /*#__PURE__*/React__default["default"].cloneElement(radioButton, {
          name: name,
          key: value,
          value: value,
          onChange: handleOnChange,
          checked: value === selected
        });
      });
      return mappedChildren;
    }

    function handleOnChange(newSelection, value, evt) {
      if (newSelection !== selected) {
        setSelected(newSelection);
        onChange(newSelection, name, evt);
      }
    }

    var fieldsetClasses = cx("".concat(prefix, "--radio-button-group"), (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--radio-button-group--").concat(orientation), orientation === 'vertical'), _defineProperty$2(_classNames, "".concat(prefix, "--radio-button-group--label-").concat(labelPosition), labelPosition), _classNames));
    var wrapperClasses = cx("".concat(prefix, "--form-item"), className);
    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: wrapperClasses,
      ref: ref
    }, /*#__PURE__*/React__default["default"].createElement("fieldset", {
      className: fieldsetClasses,
      disabled: disabled
    }, legendText && /*#__PURE__*/React__default["default"].createElement(Legend, {
      className: "".concat(prefix, "--label")
    }, legendText), getRadioButtons()));
  });
  RadioButtonGroup$3.propTypes = {
    /**
     * Provide a collection of <RadioButton> components to render in the group
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the <RadioButton> to be selected by default
     */
    defaultSelected: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),

    /**
     * Specify whether the group is disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Provide where label text should be placed
     */
    labelPosition: PropTypes__default["default"].oneOf(['left', 'right']),

    /**
     * Provide a legend to the RadioButtonGroup input that you are
     * exposing to the user
     */
    legendText: PropTypes__default["default"].node,

    /**
     * Specify the name of the underlying `<input>` nodes
     */
    name: PropTypes__default["default"].string.isRequired,

    /**
     * Provide an optional `onChange` hook that is called whenever the value of
     * the group changes
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Provide where radio buttons should be placed
     */
    orientation: PropTypes__default["default"].oneOf(['horizontal', 'vertical']),

    /**
     * Specify the value that is currently selected in the group
     */
    valueSelected: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number])
  };
  var RadioButtonGroupNext = RadioButtonGroup$3;

  var RadioButtonGroup$2 = /*#__PURE__*/function (_React$Component) {
    _inherits(RadioButtonGroup, _React$Component);

    var _super = _createSuper(RadioButtonGroup);

    function RadioButtonGroup() {
      var _this;

      _classCallCheck$1(this, RadioButtonGroup);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty$2(_assertThisInitialized$1(_this), "state", {
        selected: typeof _this.props.valueSelected !== 'undefined' ? _this.props.valueSelected : _this.props.defaultSelected
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "getRadioButtons", function () {
        var children = React__default["default"].Children.map(_this.props.children, function (radioButton) {
          var value = radioButton.props.value;
          /* istanbul ignore if */

          if (typeof radioButton.props.checked !== 'undefined') {
            warning(false, "Instead of using the checked property on the RadioButton, set\n            the defaultSelected property or valueSelected property on the RadioButtonGroup.") ;
          }

          return /*#__PURE__*/React__default["default"].cloneElement(radioButton, {
            name: _this.props.name,
            key: value,
            value: value,
            onChange: _this.handleChange,
            checked: value === _this.state.selected
          });
        });
        return children;
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleChange", function (newSelection, value, evt) {
        if (newSelection !== _this.state.selected) {
          _this.setState({
            selected: newSelection
          });

          _this.props.onChange(newSelection, _this.props.name, evt);
        }
      });

      return _this;
    }

    _createClass$1(RadioButtonGroup, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props = this.props,
            disabled = _this$props.disabled,
            className = _this$props.className,
            hideLegend = _this$props.hideLegend,
            orientation = _this$props.orientation,
            labelPosition = _this$props.labelPosition,
            legendText = _this$props.legendText;
        var scope = this.context;
        var enabled;

        if (scope.enabled) {
          enabled = scope.enabled('enable-v11-release');
        }

        return /*#__PURE__*/React__default["default"].createElement(PrefixContext.Consumer, null, function (prefix) {
          var _classNames;

          var wrapperClasses = cx("".concat(prefix, "--radio-button-group"), [enabled ? null : className], (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--radio-button-group--").concat(orientation), orientation === 'vertical'), _defineProperty$2(_classNames, "".concat(prefix, "--radio-button-group--label-").concat(labelPosition), labelPosition), _classNames));
          var legendClasses = cx("".concat(prefix, "--label"), _defineProperty$2({}, "".concat(prefix, "--visually-hidden"), hideLegend));
          return /*#__PURE__*/React__default["default"].createElement("div", {
            className: enabled ? cx("".concat(prefix, "--form-item"), className) : "".concat(prefix, "--form-item")
          }, /*#__PURE__*/React__default["default"].createElement("fieldset", {
            className: wrapperClasses,
            disabled: disabled
          }, legendText && /*#__PURE__*/React__default["default"].createElement(Legend, {
            className: legendClasses
          }, legendText), _this2.getRadioButtons()));
        });
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, state) {
        var valueSelected = _ref.valueSelected,
            defaultSelected = _ref.defaultSelected;
        var prevValueSelected = state.prevValueSelected;
        return prevValueSelected === valueSelected ? null : {
          selected: typeof valueSelected !== 'undefined' ? valueSelected : defaultSelected,
          prevValueSelected: valueSelected
        };
      }
    }]);

    return RadioButtonGroup;
  }(React__default["default"].Component);

  _defineProperty$2(RadioButtonGroup$2, "propTypes", {
    /**
     * Provide a collection of <RadioButton> components to render in the group
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the <RadioButton> to be selected by default
     */
    defaultSelected: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),

    /**
     * Specify whether the group is disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Specify whether the legend should be hidden, or not
     */
    hideLegend: PropTypes__default["default"].bool,

    /**
     * Provide where label text should be placed
     */
    labelPosition: PropTypes__default["default"].oneOf(['left', 'right']),

    /**
     * Provide a legend to the RadioButtonGroup input that you are
     * exposing to the user
     */
    legendText: PropTypes__default["default"].node,

    /**
     * Specify the name of the underlying `<input>` nodes
     */
    name: PropTypes__default["default"].string.isRequired,

    /**
     * Provide an optional `onChange` hook that is called whenever the value of
     * the group changes
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Provide where radio buttons should be placed
     */
    orientation: PropTypes__default["default"].oneOf(['horizontal', 'vertical']),

    /**
     * Specify the value that is currently selected in the group
     */
    valueSelected: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number])
  });

  _defineProperty$2(RadioButtonGroup$2, "defaultProps", {
    orientation: 'horizontal',
    labelPosition: 'right',
    hideLegend: false,
    onChange:
    /* istanbul ignore next */
    function onChange() {}
  });

  _defineProperty$2(RadioButtonGroup$2, "contextType", FeatureFlagContext);

  var RadioButtonGroup = enabled('enable-v11-release') ? RadioButtonGroupNext : RadioButtonGroup$2;
  var RadioButtonGroup$1 = RadioButtonGroup;

  var _excluded$1b = ["labelText", "iconDescription"];
  var didWarnAboutDeprecation$4 = false;
  /**
   * The filter button for `<Search>`.
   */

  var SearchFilterButton = function SearchFilterButton(_ref) {
    var labelText = _ref.labelText,
        iconDescription = _ref.iconDescription,
        other = _objectWithoutProperties$2(_ref, _excluded$1b);

    var prefix = usePrefix();

    {
      warning(didWarnAboutDeprecation$4, 'The SearchFilterButton component has been deprecated and will be removed in the next major release of `carbon-components-react`') ;
      didWarnAboutDeprecation$4 = true;
    }

    return /*#__PURE__*/React__default["default"].createElement("button", _extends$3({
      className: "".concat(prefix, "--search-button"),
      type: "button",
      "aria-label": labelText,
      title: labelText
    }, other), /*#__PURE__*/React__default["default"].createElement(Filter16, {
      className: "".concat(prefix, "--search-filter"),
      "aria-label": iconDescription
    }));
  };

  SearchFilterButton.propTypes = {
    /**
     * The icon description.
     */
    iconDescription: PropTypes__default["default"].string,

    /**
     * The a11y label text.
     */
    labelText: PropTypes__default["default"].string
  };
  SearchFilterButton.defaultProps = {
    labelText: 'Search',
    iconDescription: 'filter'
  };
  var SearchFilterButton$1 = SearchFilterButton;

  var didWarnAboutDeprecation$3 = false;
  /**
   * The layout button for `<Search>`.
   */

  var SearchLayoutButton = /*#__PURE__*/function (_Component) {
    _inherits(SearchLayoutButton, _Component);

    var _super = _createSuper(SearchLayoutButton);

    function SearchLayoutButton(props) {
      var _this;

      _classCallCheck$1(this, SearchLayoutButton);

      _this = _super.call(this, props);

      _defineProperty$2(_assertThisInitialized$1(_this), "state", {
        format: 'list'
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "toggleLayout", function () {
        var format = _this.state.format === 'list' ? 'grid' : 'list';

        _this.setState({
          format: format
        }, function () {
          var onChangeFormat = _this.props.onChangeFormat;

          if (typeof onChangeFormat === 'function') {
            onChangeFormat({
              format: format
            });
          }
        });
      });

      {
        warning(didWarnAboutDeprecation$3, 'The SearchLayoutButton component has been deprecated and will be removed in the next major release of `carbon-components-react`') ;
        didWarnAboutDeprecation$3 = true;
      }

      return _this;
    }
    /**
     * Toggles the button state upon user-initiated event.
     */


    _createClass$1(SearchLayoutButton, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var prefix = this.context;
        var _this$props = this.props,
            labelText = _this$props.labelText,
            iconDescriptionList = _this$props.iconDescriptionList,
            iconDescriptionGrid = _this$props.iconDescriptionGrid;

        var SearchLayoutButtonIcon = function SearchLayoutButtonIcon() {
          if (_this2.state.format === 'list') {
            return /*#__PURE__*/React__default["default"].createElement(ListBulleted16, {
              className: "".concat(prefix, "--search-view"),
              "aria-label": iconDescriptionList
            });
          }

          return /*#__PURE__*/React__default["default"].createElement(Grid16, {
            className: "".concat(prefix, "--search-view"),
            "aria-label": iconDescriptionGrid
          });
        };

        return /*#__PURE__*/React__default["default"].createElement("button", {
          className: "".concat(prefix, "--search-button"),
          type: "button",
          onClick: this.toggleLayout,
          "aria-label": labelText,
          title: labelText
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: "".concat(prefix, "--search__toggle-layout__container")
        }, /*#__PURE__*/React__default["default"].createElement(SearchLayoutButtonIcon, null)));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, state) {
        var format = _ref.format;
        var prevFormat = state.prevFormat;
        return prevFormat === format ? null : {
          format: format || 'list',
          prevFormat: format
        };
      }
    }]);

    return SearchLayoutButton;
  }(React.Component);

  _defineProperty$2(SearchLayoutButton, "contextType", PrefixContext);

  _defineProperty$2(SearchLayoutButton, "propTypes", {
    /**
     * The layout.
     */
    format: PropTypes__default["default"].oneOf(['list', 'grid']),

    /**
     * The description for the "grid" icon.
     */
    iconDescriptionGrid: PropTypes__default["default"].string,

    /**
     * The description for the "list" icon.
     */
    iconDescriptionList: PropTypes__default["default"].string,

    /**
     * The a11y label text.
     */
    labelText: PropTypes__default["default"].string,

    /**
     * The callback called when layout switches.
     */
    onChangeFormat: PropTypes__default["default"].func
  });

  _defineProperty$2(SearchLayoutButton, "defaultProps", {
    labelText: 'Filter',
    iconDescriptionList: 'list',
    iconDescriptionGrid: 'grid'
  });

  var SearchLayoutButton$1 = SearchLayoutButton;

  function ExpandableSearch(props) {
    var _useState = React.useState(false),
        _useState2 = _slicedToArray$1(_useState, 2),
        expanded = _useState2[0],
        setExpanded = _useState2[1];

    var searchRef = React.useRef(null);
    var prefix = usePrefix();

    function handleFocus() {
      if (!expanded) {
        setExpanded(true);
      }
    }

    function handleBlur(evt) {
      var relatedTargetIsAllowed = evt.relatedTarget && evt.relatedTarget.classList.contains("".concat(prefix, "--search-close"));

      if (expanded && !relatedTargetIsAllowed && !searchRef.current.state.hasContent) {
        setExpanded(false);
      }
    }

    React.useEffect(function () {
      var _searchRef$current2;

      function focusInput() {
        var _searchRef$current;

        if (!expanded && (_searchRef$current = searchRef.current) !== null && _searchRef$current !== void 0 && _searchRef$current.input) {
          searchRef.current.input.focus();
        }
      }

      if ((_searchRef$current2 = searchRef.current) !== null && _searchRef$current2 !== void 0 && _searchRef$current2.magnifier) {
        var magnifier = searchRef.current.magnifier;
        magnifier.addEventListener('click', focusInput);
        return function () {
          magnifier.removeEventListener('click', focusInput);
        };
      }
    }, [expanded, searchRef]);
    var classes = cx("".concat(prefix, "--search--expandable"), _defineProperty$2({}, "".concat(prefix, "--search--expanded"), expanded), props.className);
    return /*#__PURE__*/React__default["default"].createElement(Search$1, _extends$3({}, props, {
      ref: searchRef,
      className: classes,
      onFocus: handleFocus,
      onBlur: handleBlur
    }));
  }

  ExpandableSearch.propTypes = Search$1.propTypes;

  var SecondaryButton = function SecondaryButton(props) {
    return /*#__PURE__*/React__default["default"].createElement(Button$1, _extends$3({
      kind: "secondary"
    }, props));
  };

  var SecondaryButton$1 = SecondaryButton;

  var _excluded$1a = ["children", "className", "disabled", "label"];

  var SelectItemGroup = function SelectItemGroup(_ref) {
    var children = _ref.children,
        className = _ref.className,
        disabled = _ref.disabled,
        label = _ref.label,
        other = _objectWithoutProperties$2(_ref, _excluded$1a);

    var prefix = usePrefix();
    var classNames = cx("".concat(prefix, "--select-optgroup"), className);
    return /*#__PURE__*/React__default["default"].createElement("optgroup", _extends$3({
      className: classNames,
      label: label,
      disabled: disabled
    }, other), children);
  };

  SelectItemGroup.propTypes = {
    /**
     * Provide the contents of your <SelectItemGroup>
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the <SelectItemGroup> should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Specify the label to be displayed
     */
    label: PropTypes__default["default"].string.isRequired
  };
  SelectItemGroup.defaultProps = {
    disabled: false,
    label: enabled('enable-v11-release') ? undefined : 'Provide label'
  };
  var SelectItemGroup$1 = SelectItemGroup;

  var _excluded$19 = ["children", "className", "disabled", "index", "name", "onClick", "onKeyDown", "selected", "text"];
  var Switch = /*#__PURE__*/React__default["default"].forwardRef(function Switch(props, tabRef) {
    var children = props.children,
        className = props.className,
        disabled = props.disabled,
        index = props.index,
        name = props.name,
        onClick = props.onClick,
        onKeyDown = props.onKeyDown,
        selected = props.selected,
        text = props.text,
        other = _objectWithoutProperties$2(props, _excluded$19);

    var prefix = usePrefix();

    var handleClick = function handleClick(e) {
      e.preventDefault();
      onClick({
        index: index,
        name: name,
        text: text
      });
    };

    var handleKeyDown = function handleKeyDown(event) {
      var key = event.key || event.which;
      onKeyDown({
        index: index,
        name: name,
        text: text,
        key: key
      });
    };

    var classes = cx(className, "".concat(prefix, "--content-switcher-btn"), _defineProperty$2({}, "".concat(prefix, "--content-switcher--selected"), selected));
    var commonProps = {
      onClick: handleClick,
      onKeyDown: handleKeyDown,
      className: classes,
      disabled: disabled
    };
    return /*#__PURE__*/React__default["default"].createElement("button", _extends$3({
      type: "button",
      ref: tabRef,
      role: "tab",
      tabIndex: selected ? '0' : '-1',
      "aria-selected": selected
    }, other, commonProps), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--content-switcher__label"),
      title: text
    }, text !== undefined ? text : children));
  });
  Switch.displayName = 'Switch';
  Switch.propTypes = {
    /**
     * Provide child elements to be rendered inside of the Switch
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be added to your Switch
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether or not the Switch should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * The index of your Switch in your ContentSwitcher that is used for event handlers.
     * Reserved for usage in ContentSwitcher
     */
    index: PropTypes__default["default"].number,

    /**
     * Provide the name of your Switch that is used for event handlers
     */
    name: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),

    /**
     * A handler that is invoked when a user clicks on the control.
     * Reserved for usage in ContentSwitcher
     */
    onClick: PropTypes__default["default"].func,

    /**
     * A handler that is invoked on the key down event for the control.
     * Reserved for usage in ContentSwitcher
     */
    onKeyDown: PropTypes__default["default"].func,

    /**
     * Whether your Switch is selected. Reserved for usage in ContentSwitcher
     */
    selected: PropTypes__default["default"].bool,

    /**
     * Provide the contents of your Switch
     */
    text: PropTypes__default["default"].string
  };
  Switch.defaultProps = {
    selected: false,
    onClick: function onClick() {},
    onKeyDown: function onKeyDown() {}
  };
  var Switch$1 = Switch;

  /** Used as the `TypeError` message for "Functions" methods. */

  var FUNC_ERROR_TEXT = 'Expected a function';
  /** Used as references for various `Number` constants. */

  var NAN = 0 / 0;
  /** `Object#toString` result references. */

  var symbolTag = '[object Symbol]';
  /** Used to match leading and trailing whitespace. */

  var reTrim = /^\s+|\s+$/g;
  /** Used to detect bad signed hexadecimal string values. */

  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  /** Used to detect binary string values. */

  var reIsBinary = /^0b[01]+$/i;
  /** Used to detect octal string values. */

  var reIsOctal = /^0o[0-7]+$/i;
  /** Built-in method references without a dependency on `root`. */

  var freeParseInt = parseInt;
  /** Detect free variable `global` from Node.js. */

  var freeGlobal = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  /** Detect free variable `self`. */

  var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
  /** Used as a reference to the global object. */

  var root = freeGlobal || freeSelf || Function('return this')();
  /** Used for built-in method references. */

  var objectProto = Object.prototype;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var objectToString = objectProto.toString;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeMax = Math.max,
      nativeMin = Math.min;
  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */

  var now = function now() {
    return root.Date.now();
  };
  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */


  function debounce(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    wait = toNumber(wait) || 0;

    if (isObject(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;
      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time; // Start the timer for the trailing edge.

      timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          result = wait - timeSinceLastCall;
      return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.

      return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }

    function timerExpired() {
      var time = now();

      if (shouldInvoke(time)) {
        return trailingEdge(time);
      } // Restart the timer.


      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.

      if (trailing && lastArgs) {
        return invokeFunc(time);
      }

      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }

      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now());
    }

    function debounced() {
      var time = now(),
          isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }

        if (maxing) {
          // Handle invocations in a tight loop.
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }

      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }

      return result;
    }

    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  /**
   * Creates a throttled function that only invokes `func` at most once per
   * every `wait` milliseconds. The throttled function comes with a `cancel`
   * method to cancel delayed `func` invocations and a `flush` method to
   * immediately invoke them. Provide `options` to indicate whether `func`
   * should be invoked on the leading and/or trailing edge of the `wait`
   * timeout. The `func` is invoked with the last arguments provided to the
   * throttled function. Subsequent calls to the throttled function return the
   * result of the last `func` invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the throttled function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.throttle` and `_.debounce`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to throttle.
   * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=true]
   *  Specify invoking on the leading edge of the timeout.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new throttled function.
   * @example
   *
   * // Avoid excessively updating the position while scrolling.
   * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
   *
   * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
   * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
   * jQuery(element).on('click', throttled);
   *
   * // Cancel the trailing throttled invocation.
   * jQuery(window).on('popstate', throttled.cancel);
   */


  function throttle(func, wait, options) {
    var leading = true,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    if (isObject(options)) {
      leading = 'leading' in options ? !!options.leading : leading;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    return debounce(func, wait, {
      'leading': leading,
      'maxWait': wait,
      'trailing': trailing
    });
  }
  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */


  function isObject(value) {
    var type = _typeof(value);

    return !!value && (type == 'object' || type == 'function');
  }
  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */


  function isObjectLike(value) {
    return !!value && _typeof(value) == 'object';
  }
  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */


  function isSymbol(value) {
    return _typeof(value) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */


  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }

    if (isSymbol(value)) {
      return NAN;
    }

    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? other + '' : other;
    }

    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }

    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }

  var lodash_throttle = throttle;

  var _excluded$18 = ["ariaLabelInput", "className", "hideTextInput", "id", "min", "minLabel", "max", "maxLabel", "formatLabel", "labelText", "step", "stepMuliplier", "stepMultiplier", "inputType", "required", "disabled", "name", "light"];

  var defaultFormatLabel = function defaultFormatLabel(value, label) {
    return typeof label === 'function' ? label(value) : "".concat(value).concat(label);
  };
  /**
   * Minimum time between processed "drag" events.
   */


  var EVENT_THROTTLE = 16; // ms

  /**
   * Event types that trigger "drags".
   */

  var DRAG_EVENT_TYPES = new Set(['mousemove', 'touchmove']);
  /**
   * Event types that trigger a "drag" to stop.
   */

  var DRAG_STOP_EVENT_TYPES = new Set(['mouseup', 'touchend', 'touchcancel']);

  var Slider = /*#__PURE__*/function (_PureComponent) {
    _inherits(Slider, _PureComponent);

    var _super = _createSuper(Slider);

    function Slider() {
      var _this;

      _classCallCheck$1(this, Slider);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty$2(_assertThisInitialized$1(_this), "state", {
        value: _this.props.value,
        left: 0,
        needsOnRelease: false,
        isValid: true
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "onDragStart", function (evt) {
        // Do nothing if component is disabled
        if (_this.props.disabled) {
          return;
        } // Register drag stop handlers


        DRAG_STOP_EVENT_TYPES.forEach(function (element) {
          _this.element.ownerDocument.addEventListener(element, _this.onDragStop);
        }); // Register drag handlers

        DRAG_EVENT_TYPES.forEach(function (element) {
          _this.element.ownerDocument.addEventListener(element, _this.onDrag);
        }); // Perform first recalculation since we probably didn't click exactly in the
        // middle of the thumb

        _this.onDrag(evt);
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "onDragStop", function () {
        // Do nothing if component is disabled
        if (_this.props.disabled) {
          return;
        } // Remove drag stop handlers


        DRAG_STOP_EVENT_TYPES.forEach(function (element) {
          _this.element.ownerDocument.removeEventListener(element, _this.onDragStop);
        }); // Remove drag handlers

        DRAG_EVENT_TYPES.forEach(function (element) {
          _this.element.ownerDocument.removeEventListener(element, _this.onDrag);
        }); // Set needsOnRelease flag so event fires on next update

        _this.setState({
          needsOnRelease: true,
          isValid: true
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "_onDrag", function (evt) {
        // Do nothing if component is disabled or we have no event
        if (_this.props.disabled || !evt) {
          return;
        }

        var clientX;

        if ('clientX' in evt) {
          clientX = evt.clientX;
        } else if ('touches' in evt && 0 in evt.touches && 'clientX' in evt.touches[0]) {
          clientX = evt.touches[0].clientX;
        } else {
          // Do nothing if we have no valid clientX
          return;
        }

        var _this$calcValue = _this.calcValue({
          clientX: clientX
        }),
            value = _this$calcValue.value,
            left = _this$calcValue.left;

        _this.setState({
          value: value,
          left: left,
          isValid: true
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "onDrag", lodash_throttle(_this._onDrag, EVENT_THROTTLE, {
        leading: true,
        trailing: false
      }));

      _defineProperty$2(_assertThisInitialized$1(_this), "onKeyDown", function (evt) {
        // Do nothing if component is disabled or we don't have a valid event
        if (_this.props.disabled || !('which' in evt)) {
          return;
        }

        var which = Number.parseInt(evt.which);
        var delta = 0;

        if (matches(which, [ArrowDown, ArrowLeft])) {
          delta = -_this.props.step;
        } else if (matches(which, [ArrowUp, ArrowRight])) {
          delta = _this.props.step;
        } else {
          // Ignore keys we don't want to handle
          return;
        } // If shift was held, account for the stepMultiplier


        if (evt.shiftKey) {
          var stepMultiplier = _this.props.stepMultiplier || _this.props.stepMuliplier;
          delta *= stepMultiplier;
        }

        Math.floor(_this.state.value / _this.props.step) * _this.props.step;

        var _this$calcValue2 = _this.calcValue({
          // Ensures custom value from `<input>` won't cause skipping next stepping point with right arrow key,
          // e.g. Typing 51 in `<input>`, moving focus onto the thumb and the hitting right arrow key should yield 52 instead of 54
          value: (delta > 0 ? Math.floor(_this.state.value / _this.props.step) * _this.props.step : _this.state.value) + delta
        }),
            value = _this$calcValue2.value,
            left = _this$calcValue2.left;

        _this.setState({
          value: value,
          left: left,
          isValid: true
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "onChange", function (evt) {
        // Do nothing if component is disabled
        if (_this.props.disabled) {
          return;
        } // Do nothing if we have no valid event, target, or value


        if (!evt || !('target' in evt) || typeof evt.target.value !== 'string') {
          return;
        }

        var targetValue = Number.parseFloat(evt.target.value); // Avoid calling calcValue for invalid numbers, but still update the state

        if (isNaN(targetValue)) {
          _this.setState({
            value: evt.target.value
          });
        } else {
          var _this$calcValue3 = _this.calcValue({
            value: targetValue,
            useRawValue: true
          }),
              value = _this$calcValue3.value,
              left = _this$calcValue3.left;

          _this.setState({
            value: value,
            left: left,
            needsOnRelease: true
          });
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "onBlur", function (evt) {
        // Do nothing if we have no valid event, target, or value
        if (!evt || !('target' in evt) || typeof evt.target.value !== 'string') {
          return;
        } // determine validity of input change after clicking out of input


        var validity = evt.target.checkValidity();
        var value = evt.target.value;

        _this.setState({
          isValid: validity
        });

        _this.props.onBlur({
          value: value
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "calcValue", function (_ref) {
        var _ref$clientX = _ref.clientX,
            clientX = _ref$clientX === void 0 ? null : _ref$clientX,
            _ref$value = _ref.value,
            value = _ref$value === void 0 ? null : _ref$value,
            _ref$useRawValue = _ref.useRawValue,
            useRawValue = _ref$useRawValue === void 0 ? false : _ref$useRawValue;
        var range = _this.props.max - _this.props.min;

        var boundingRect = _this.element.getBoundingClientRect();

        var totalSteps = range / _this.props.step;
        var width = boundingRect.right - boundingRect.left; // Enforce a minimum width of at least 1 for calculations

        if (width <= 0) {
          width = 1;
        } // If a clientX is specified, use it to calculate the leftPercent. If not,
        // use the provided value or state's value to calculate it instead.


        var leftPercent;

        if (clientX != null) {
          var leftOffset = clientX - boundingRect.left;
          leftPercent = leftOffset / width;
        } else {
          if (value == null) {
            value = _this.state.value;
          } // prevent NaN calculation if the range is 0


          leftPercent = range === 0 ? 0 : (value - _this.props.min) / range;
        }

        if (useRawValue) {
          // Adjusts only for min/max of thumb position
          return {
            value: value,
            left: Math.min(1, Math.max(0, leftPercent)) * 100
          };
        }

        var steppedValue = Math.round(leftPercent * totalSteps) * _this.props.step;

        var steppedPercent = _this.clamp(steppedValue / range, 0, 1);

        steppedValue = _this.clamp(steppedValue + _this.props.min, _this.props.min, _this.props.max);
        return {
          value: steppedValue,
          left: steppedPercent * 100
        };
      });

      return _this;
    }

    _createClass$1(Slider, [{
      key: "componentDidMount",
      value:
      /**
       * Sets up initial slider position and value in response to component mount.
       */
      function componentDidMount() {
        if (this.element) {
          var _this$calcValue4 = this.calcValue({
            useRawValue: true
          }),
              value = _this$calcValue4.value,
              left = _this$calcValue4.left;

          this.setState({
            value: value,
            left: left
          });
        }
      }
      /**
       * Handles firing of `onChange` and `onRelease` callbacks to parent in
       * response to state changes.
       *
       * @param {*} prevProps prevProps
       * @param {*} prevState The previous Slider state, used to see if callbacks
       * should be called.
       */

    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps, prevState) {
        // Fire onChange event handler if present, if there's a usable value, and
        // if the value is different from the last one
        if (this.state.value !== '' && prevState.value !== this.state.value && typeof this.props.onChange === 'function') {
          // TODO: pass event object as first param (breaking change/feat for v11)
          this.props.onChange({
            value: this.state.value
          });
        } // Fire onRelease event handler if present and if needed


        if (this.state.needsOnRelease && typeof this.props.onRelease === 'function') {
          // TODO: pass event object as first param (breaking change/feat for v11)
          this.props.onRelease({
            value: this.state.value
          }); // Reset the flag

          this.setState({
            needsOnRelease: false
          });
        } // If value from props does not change, do nothing here.
        // Otherwise, do prop -> state sync without "value capping".


        if (prevProps.value === this.props.value && prevProps.max === this.props.max && prevProps.min === this.props.min) {
          return;
        }

        this.setState(this.calcValue({
          value: this.props.value,
          useRawValue: true
        }));
      }
      /**
       * Synonymous to ECMA2017+ `Math.clamp`.
       *
       * @param {number} val
       * @param {number} min
       * @param {number} max
       *
       * @returns `val` if `max>=val>=min`; `min` if `val<min`; `max` if `val>max`.
       */

    }, {
      key: "clamp",
      value: function clamp(val, min, max) {
        return Math.max(min, Math.min(val, max));
      }
      /**
       * Sets up "drag" event handlers and calls `this.onDrag` in case dragging
       * started on somewhere other than the thumb without a corresponding "move"
       * event.
       *
       * @param {Event} evt The event.
       */

    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props = this.props,
            ariaLabelInput = _this$props.ariaLabelInput,
            className = _this$props.className,
            hideTextInput = _this$props.hideTextInput,
            _this$props$id = _this$props.id,
            id = _this$props$id === void 0 ? this.inputId = this.inputId || "__carbon-slider_".concat(Math.random().toString(36).substr(2)) : _this$props$id,
            min = _this$props.min,
            minLabel = _this$props.minLabel,
            max = _this$props.max,
            maxLabel = _this$props.maxLabel,
            _this$props$formatLab = _this$props.formatLabel,
            formatLabel = _this$props$formatLab === void 0 ? defaultFormatLabel : _this$props$formatLab,
            labelText = _this$props.labelText,
            step = _this$props.step;
            _this$props.stepMuliplier;
            _this$props.stepMultiplier;
            var inputType = _this$props.inputType,
            required = _this$props.required,
            disabled = _this$props.disabled,
            name = _this$props.name,
            light = _this$props.light,
            other = _objectWithoutProperties$2(_this$props, _excluded$18);

        delete other.onRelease;
        delete other.invalid;
        var _this$state = this.state,
            value = _this$state.value,
            left = _this$state.left,
            isValid = _this$state.isValid;
        var scope = this.context;
        var enabled;

        if (scope.enabled) {
          enabled = scope.enabled('enable-v11-release');
        }

        return /*#__PURE__*/React__default["default"].createElement(PrefixContext.Consumer, null, function (prefix) {
          var _classNames3;

          var labelId = "".concat(id, "-label");
          var labelClasses = cx("".concat(prefix, "--label"), _defineProperty$2({}, "".concat(prefix, "--label--disabled"), disabled));
          var sliderClasses = cx("".concat(prefix, "--slider"), _defineProperty$2({}, "".concat(prefix, "--slider--disabled"), disabled), [enabled ? null : className]);
          var inputClasses = cx("".concat(prefix, "--text-input"), "".concat(prefix, "--slider-text-input"), (_classNames3 = {}, _defineProperty$2(_classNames3, "".concat(prefix, "--text-input--light"), light), _defineProperty$2(_classNames3, "".concat(prefix, "--text-input--invalid"), isValid === false), _classNames3));
          var filledTrackStyle = {
            transform: "translate(0%, -50%) scaleX(".concat(left / 100, ")")
          };
          var thumbStyle = {
            left: "".concat(left, "%")
          };
          var hiddenInputStyle = {
            display: 'none'
          };
          return /*#__PURE__*/React__default["default"].createElement("div", {
            className: enabled ? cx("".concat(prefix, "--form-item"), className) : "".concat(prefix, "--form-item")
          }, /*#__PURE__*/React__default["default"].createElement("label", {
            htmlFor: id,
            className: labelClasses,
            id: labelId
          }, labelText), /*#__PURE__*/React__default["default"].createElement("div", {
            className: "".concat(prefix, "--slider-container")
          }, /*#__PURE__*/React__default["default"].createElement("span", {
            className: "".concat(prefix, "--slider__range-label")
          }, formatLabel(min, minLabel)), /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
            className: sliderClasses,
            ref: function ref(node) {
              _this2.element = node;
            },
            onMouseDown: _this2.onDragStart,
            onTouchStart: _this2.onDragStart,
            onKeyDown: _this2.onKeyDown,
            role: "presentation",
            tabIndex: -1,
            "data-invalid": isValid ? null : true
          }, other), /*#__PURE__*/React__default["default"].createElement("div", {
            className: "".concat(prefix, "--slider__thumb"),
            role: "slider",
            id: id,
            tabIndex: 0,
            "aria-valuemax": max,
            "aria-valuemin": min,
            "aria-valuenow": value,
            style: thumbStyle,
            "aria-labelledby": labelId
          }), /*#__PURE__*/React__default["default"].createElement("div", {
            className: "".concat(prefix, "--slider__track"),
            ref: function ref(node) {
              _this2.track = node;
            }
          }), /*#__PURE__*/React__default["default"].createElement("div", {
            className: "".concat(prefix, "--slider__filled-track"),
            style: filledTrackStyle
          })), /*#__PURE__*/React__default["default"].createElement("span", {
            className: "".concat(prefix, "--slider__range-label")
          }, formatLabel(max, maxLabel)), /*#__PURE__*/React__default["default"].createElement("input", {
            type: hideTextInput ? 'hidden' : inputType,
            style: hideTextInput ? hiddenInputStyle : null,
            id: "".concat(id, "-input-for-slider"),
            name: name,
            className: inputClasses,
            value: value,
            "aria-labelledby": !ariaLabelInput ? labelId : null,
            "aria-label": ariaLabelInput ? ariaLabelInput : null,
            disabled: disabled,
            required: required,
            min: min,
            max: max,
            step: step,
            onChange: _this2.onChange,
            onBlur: _this2.onBlur,
            "data-invalid": isValid ? null : true,
            "aria-invalid": isValid ? null : true
          })));
        });
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: // syncs invalid state and prop
      function getDerivedStateFromProps(props, state) {
        var isValid = state.isValid; // will override state in favor of invalid prop

        if (props.invalid === true && isValid === true) {
          return {
            isValid: false
          };
        }

        if (props.invalid === false && isValid === false) {
          return {
            isValid: true
          };
        } //if invalid prop is not provided, state will remain the same


        return null;
      }
    }]);

    return Slider;
  }(React.PureComponent);

  _defineProperty$2(Slider, "propTypes", {
    /**
     * The `ariaLabel` for the `<input>`.
     */
    ariaLabelInput: PropTypes__default["default"].string,

    /**
     * The child nodes.
     */
    children: PropTypes__default["default"].node,

    /**
     * The CSS class name for the slider.
     */
    className: PropTypes__default["default"].string,

    /**
     * `true` to disable this slider.
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * The callback to format the label associated with the minimum/maximum value.
     */
    formatLabel: PropTypes__default["default"].func,

    /**
     * `true` to hide the number input box.
     */
    hideTextInput: PropTypes__default["default"].bool,

    /**
     * The ID of the `<input>`.
     */
    id: PropTypes__default["default"].string,

    /**
     * The `type` attribute of the `<input>`.
     */
    inputType: PropTypes__default["default"].string,

    /**
     * `true` to specify if the control is invalid.
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * The label for the slider.
     */
    labelText: PropTypes__default["default"].node,

    /**
     * `true` to use the light version.
     */
    light: PropTypes__default["default"].bool,

    /**
     * The maximum value.
     */
    max: PropTypes__default["default"].number.isRequired,

    /**
     * The label associated with the maximum value.
     */
    maxLabel: PropTypes__default["default"].string,

    /**
     * The minimum value.
     */
    min: PropTypes__default["default"].number.isRequired,

    /**
     * The label associated with the minimum value.
     */
    minLabel: PropTypes__default["default"].string,

    /**
     * The `name` attribute of the `<input>`.
     */
    name: PropTypes__default["default"].string,

    /**
     * Provide an optional function to be called when the input element
     * loses focus
     */
    onBlur: PropTypes__default["default"].func,

    /**
     * The callback to get notified of change in value.
     */
    onChange: PropTypes__default["default"].func,

    /**
     * The callback to get notified of value on handle release.
     */
    onRelease: PropTypes__default["default"].func,

    /**
     * `true` to specify if the control is required.
     */
    required: PropTypes__default["default"].bool,

    /**
     * A value determining how much the value should increase/decrease by moving the thumb by mouse.
     */
    step: PropTypes__default["default"].number,

    /**
     * A value determining how much the value should increase/decrease by Shift+arrow keys,
     * which will be `(max - min) / stepMuliplier`.
     */
    stepMuliplier: deprecate(PropTypes__default["default"].number, ' The `stepMuliplier` prop has been deprecated in favor of `stepMultiplier`. It will be removed in the next major release.'),

    /**
     * A value determining how much the value should increase/decrease by Shift+arrow keys,
     * which will be `(max - min) / stepMultiplier`.
     */
    stepMultiplier: PropTypes__default["default"].number,

    /**
     * The value.
     */
    value: PropTypes__default["default"].number.isRequired
  });

  _defineProperty$2(Slider, "defaultProps", {
    hideTextInput: false,
    step: 1,
    stepMultiplier: 4,
    disabled: false,
    minLabel: '',
    maxLabel: '',
    inputType: 'number',
    ariaLabelInput: enabled('enable-v11-release') ? undefined : 'Slider number input',
    light: false
  });

  _defineProperty$2(Slider, "contextType", FeatureFlagContext);

  var _excluded$17 = ["hideLabel", "className"];

  var SliderSkeleton = function SliderSkeleton(_ref) {
    var hideLabel = _ref.hideLabel,
        className = _ref.className,
        rest = _objectWithoutProperties$2(_ref, _excluded$17);

    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: cx("".concat(prefix, "--form-item"), className)
    }, rest), !hideLabel && /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--label ").concat(prefix, "--skeleton")
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--slider-container ").concat(prefix, "--skeleton")
    }, /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--slider__range-label")
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--slider")
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--slider__track")
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--slider__filled-track")
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--slider__thumb")
    })), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--slider__range-label")
    })));
  };

  SliderSkeleton.propTypes = {
    /**
     * Specify an optional className to add to the form item wrapper.
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the label should be hidden, or not
     */
    hideLabel: PropTypes__default["default"].bool
  };
  var SliderSkeleton$1 = SliderSkeleton;

  var index = enabled('enable-v11-release') ? createClassWrapper(Slider) : Slider;

  var _excluded$16 = ["children", "selection", "className", "ariaLabel", "border"],
      _excluded2$5 = ["children", "className"],
      _excluded3$4 = ["children", "className"],
      _excluded4$4 = ["onKeyDown", "children", "className", "head"],
      _excluded5$1 = ["className", "name", "title", "id"],
      _excluded6$1 = ["children", "className", "head", "noWrap"];
  var GridSelectedRowStateContext = /*#__PURE__*/React__default["default"].createContext(null);
  var GridSelectedRowDispatchContext = /*#__PURE__*/React__default["default"].createContext(null);
  function StructuredListWrapper$2(props) {
    var children = props.children,
        selection = props.selection,
        className = props.className,
        ariaLabel = props.ariaLabel;
        props.border;
        var other = _objectWithoutProperties$2(props, _excluded$16);

    var prefix = usePrefix();
    var classes = cx("".concat(prefix, "--structured-list"), className, _defineProperty$2({}, "".concat(prefix, "--structured-list--selection"), selection));

    var _React$useState = React__default["default"].useState(null),
        _React$useState2 = _slicedToArray$1(_React$useState, 2),
        selectedRow = _React$useState2[0],
        setSelectedRow = _React$useState2[1];

    return /*#__PURE__*/React__default["default"].createElement(GridSelectedRowStateContext.Provider, {
      value: selectedRow
    }, /*#__PURE__*/React__default["default"].createElement(GridSelectedRowDispatchContext.Provider, {
      value: setSelectedRow
    }, /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      role: "grid",
      className: classes
    }, other, {
      "aria-label": ariaLabel
    }), children)));
  }
  StructuredListWrapper$2.propTypes = {
    /**
     * Specify a label to be read by screen readers on the container node
     */
    ariaLabel: PropTypes__default["default"].string,

    /**
     * Specify whether a border should be added to your StructuredListWrapper
     */
    border: deprecate(PropTypes__default["default"].bool, "\nThe prop `border` will be removed in the next major version of Carbon."),

    /**
     * Provide the contents of your StructuredListWrapper
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether your StructuredListWrapper should have selections
     */
    selection: PropTypes__default["default"].bool
  };
  StructuredListWrapper$2.defaultProps = {
    selection: false,
    ariaLabel: 'Structured list section'
  };
  function StructuredListHead$2(props) {
    var children = props.children,
        className = props.className,
        other = _objectWithoutProperties$2(props, _excluded2$5);

    var prefix = usePrefix();
    var classes = cx("".concat(prefix, "--structured-list-thead"), className);
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      role: "rowgroup",
      className: classes
    }, other), children);
  }
  StructuredListHead$2.propTypes = {
    /**
     * Provide the contents of your StructuredListHead
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the node
     */
    className: PropTypes__default["default"].string
  };
  function StructuredListBody$2(props) {
    var children = props.children,
        className = props.className,
        other = _objectWithoutProperties$2(props, _excluded3$4);

    var prefix = usePrefix();
    var classes = cx("".concat(prefix, "--structured-list-tbody"), className);
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: classes,
      role: "rowgroup"
    }, other), children);
  }
  StructuredListBody$2.propTypes = {
    /**
     * Provide the contents of your StructuredListBody
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,
    head: PropTypes__default["default"].bool,

    /**
     * Provide a handler that is invoked on the key down event for the control
     */
    onKeyDown: PropTypes__default["default"].func
  };
  StructuredListBody$2.defaultProps = {
    onKeyDown: function onKeyDown() {}
  };
  var GridRowContext = /*#__PURE__*/React__default["default"].createContext(null);
  function StructuredListRow$2(props) {
    var _classNames2;

    var onKeyDown = props.onKeyDown,
        children = props.children,
        className = props.className,
        head = props.head,
        other = _objectWithoutProperties$2(props, _excluded4$4);

    var _useState = React.useState(false),
        _useState2 = _slicedToArray$1(_useState, 2),
        hasFocusWithin = _useState2[0],
        setHasFocusWithin = _useState2[1];

    var id = useId('grid-input');
    var setSelectedRow = React__default["default"].useContext(GridSelectedRowDispatchContext);
    var prefix = usePrefix();
    var value = {
      id: id
    };
    var classes = cx("".concat(prefix, "--structured-list-row"), className, (_classNames2 = {}, _defineProperty$2(_classNames2, "".concat(prefix, "--structured-list-row--header-row"), head), _defineProperty$2(_classNames2, "".concat(prefix, "--structured-list-row--focused-within"), hasFocusWithin), _classNames2));
    return head ? /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      role: "row"
    }, other, {
      className: classes
    }), children) :
    /*#__PURE__*/
    // eslint-disable-next-line jsx-a11y/interactive-supports-focus
    React__default["default"].createElement("div", _extends$3({}, other, {
      role: "row",
      className: classes,
      onClick: function onClick() {
        return setSelectedRow(id);
      },
      onFocus: function onFocus() {
        setHasFocusWithin(true);
      },
      onBlur: function onBlur() {
        setHasFocusWithin(false);
      },
      onKeyDown: onKeyDown
    }), /*#__PURE__*/React__default["default"].createElement(GridRowContext.Provider, {
      value: value
    }, children));
  }
  StructuredListRow$2.propTypes = {
    /**
     * Provide the contents of your StructuredListRow
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether your StructuredListRow should be used as a header row
     */
    head: PropTypes__default["default"].bool,

    /**
     * Specify whether a `<label>` should be used
     */
    label: deprecate(PropTypes__default["default"].bool, "\nThe `label` prop is no longer needed and will be removed in the next major version of Carbon."),

    /**
     * Provide a handler that is invoked on the key down event for the control,
     */
    onKeyDown: PropTypes__default["default"].func
  };
  StructuredListRow$2.defaultProps = {
    head: false,
    onKeyDown: function onKeyDown() {}
  };
  function StructuredListInput$2(props) {
    var defaultId = useId('structureListInput');

    var className = props.className,
        _props$name = props.name,
        name = _props$name === void 0 ? "structured-list-input-".concat(defaultId) : _props$name,
        title = props.title,
        id = props.id,
        other = _objectWithoutProperties$2(props, _excluded5$1);

    var prefix = usePrefix();
    var classes = cx("".concat(prefix, "--structured-list-input"), "".concat(prefix, "--visually-hidden"), className);
    var row = React__default["default"].useContext(GridRowContext);
    var selectedRow = React__default["default"].useContext(GridSelectedRowStateContext);
    var setSelectedRow = React__default["default"].useContext(GridSelectedRowDispatchContext);
    return /*#__PURE__*/React__default["default"].createElement("input", _extends$3({}, other, {
      type: "radio",
      tabIndex: 0,
      checked: row && row.id === selectedRow,
      value: row ? row.id : '',
      onChange: function onChange(event) {
        setSelectedRow(event.target.value);
      },
      id: !id && defaultId,
      className: classes,
      name: name,
      title: title
    }));
  }
  StructuredListInput$2.propTypes = {
    /**
     * Specify an optional className to be applied to the input
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the underlying input should be checked by default
     */
    defaultChecked: deprecate(PropTypes__default["default"].bool, "\nThe prop `defaultChecked` is no longer needed and will be removed in the next major version of Carbon."),

    /**
     * Specify a custom `id` for the input
     */
    id: PropTypes__default["default"].string,

    /**
     * Provide a `name` for the input
     */
    name: PropTypes__default["default"].string,

    /**
     * Provide an optional hook that is called each time the input is updated
     */
    onChange: deprecate(PropTypes__default["default"].func, "\nThe prop `onChange` will be removed in the next major version of Carbon."),

    /**
     * Provide a `title` for the input
     */
    title: PropTypes__default["default"].string,

    /**
     * Specify the value of the input
     */
    value: deprecate(PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]).isRequired, "\nThe prop `value` will be removed in the next major version of Carbon.")
  };
  StructuredListInput$2.defaultProps = {
    title: 'title'
  };
  function StructuredListCell$2(props) {
    var _classNames3;

    var children = props.children,
        className = props.className,
        head = props.head,
        noWrap = props.noWrap,
        other = _objectWithoutProperties$2(props, _excluded6$1);

    var prefix = usePrefix();
    var classes = cx(className, (_classNames3 = {}, _defineProperty$2(_classNames3, "".concat(prefix, "--structured-list-th"), head), _defineProperty$2(_classNames3, "".concat(prefix, "--structured-list-td"), !head), _defineProperty$2(_classNames3, "".concat(prefix, "--structured-list-content--nowrap"), noWrap), _classNames3));

    if (head) {
      return /*#__PURE__*/React__default["default"].createElement("span", _extends$3({
        className: classes,
        role: "columnheader"
      }, other), children);
    }

    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: classes,
      role: "cell"
    }, other), children);
  }
  StructuredListCell$2.propTypes = {
    /**
     * Provide the contents of your StructuredListCell
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether your StructuredListCell should be used as a header cell
     */
    head: PropTypes__default["default"].bool,

    /**
     * Specify whether your StructuredListCell should have text wrapping
     */
    noWrap: PropTypes__default["default"].bool
  };
  StructuredListCell$2.defaultProps = {
    head: false,
    noWrap: false
  };

  var _excluded$15 = ["children", "selection", "className", "ariaLabel", "isCondensed", "isFlush", "border"],
      _excluded2$4 = ["children", "className"],
      _excluded3$3 = ["children", "className"],
      _excluded4$3 = ["onKeyDown", "tabIndex", "children", "className", "head", "label"],
      _excluded5 = ["className", "value", "name", "title", "id"],
      _excluded6 = ["children", "className", "head", "noWrap"];
  var getInstanceId$6 = setupGetInstanceId$2();
  function StructuredListWrapper$1(props) {
    var _classNames;

    var children = props.children,
        selection = props.selection,
        className = props.className,
        ariaLabel = props.ariaLabel,
        isCondensed = props.isCondensed,
        isFlush = props.isFlush;
        props.border;
        var other = _objectWithoutProperties$2(props, _excluded$15);

    var prefix = usePrefix();
    var classes = cx("".concat(prefix, "--structured-list"), className, (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--structured-list--selection"), selection), _defineProperty$2(_classNames, "".concat(prefix, "--structured-list--condensed"), isCondensed), _defineProperty$2(_classNames, "".concat(prefix, "--structured-list--flush"), isFlush), _classNames));
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      role: "table",
      className: classes
    }, other, {
      "aria-label": ariaLabel
    }), children);
  }
  StructuredListWrapper$1.propTypes = {
    /**
     * Specify a label to be read by screen readers on the container node
     */
    ariaLabel: PropTypes__default["default"].string,

    /**
     * Specify whether a border should be added to your StructuredListWrapper
     */
    border: deprecate(PropTypes__default["default"].bool, "\nThe prop `border` will be removed in the next major version of Carbon."),

    /**
     * Provide the contents of your StructuredListWrapper
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify if structured list is condensed, default is false
     */
    isCondensed: PropTypes__default["default"].bool,

    /**
     * Specify if structured list is flush, default is false
     */
    isFlush: PropTypes__default["default"].bool,

    /**
     * Specify whether your StructuredListWrapper should have selections
     */
    selection: PropTypes__default["default"].bool
  };
  StructuredListWrapper$1.defaultProps = {
    selection: false,
    ariaLabel: 'Structured list section',
    isCondensed: false,
    isFlush: false
  };
  function StructuredListHead$1(props) {
    var children = props.children,
        className = props.className,
        other = _objectWithoutProperties$2(props, _excluded2$4);

    var prefix = usePrefix();
    var classes = cx("".concat(prefix, "--structured-list-thead"), className);
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      role: "rowgroup",
      className: classes
    }, other), children);
  }
  StructuredListHead$1.propTypes = {
    /**
     * Provide the contents of your StructuredListHead
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the node
     */
    className: PropTypes__default["default"].string
  };
  function StructuredListBody$1(props) {
    var children = props.children,
        className = props.className,
        other = _objectWithoutProperties$2(props, _excluded3$3);

    var prefix = usePrefix();
    var classes = cx("".concat(prefix, "--structured-list-tbody"), className);
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: classes,
      role: "rowgroup"
    }, other), children);
  }
  StructuredListBody$1.propTypes = {
    /**
     * Provide the contents of your StructuredListBody
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,
    head: PropTypes__default["default"].bool,

    /**
     * Provide a handler that is invoked on the key down event for the control
     */
    onKeyDown: PropTypes__default["default"].func
  };
  StructuredListBody$1.defaultProps = {
    onKeyDown: function onKeyDown() {}
  };
  function StructuredListRow$1(props) {
    var onKeyDown = props.onKeyDown,
        tabIndex = props.tabIndex,
        children = props.children,
        className = props.className,
        head = props.head,
        label = props.label,
        other = _objectWithoutProperties$2(props, _excluded4$3);

    var prefix = usePrefix();
    var classes = cx("".concat(prefix, "--structured-list-row"), className, _defineProperty$2({}, "".concat(prefix, "--structured-list-row--header-row"), head));
    return label ?
    /*#__PURE__*/
    // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
    React__default["default"].createElement("label", _extends$3({}, other, {
      tabIndex: tabIndex,
      className: classes,
      onKeyDown: onKeyDown
    }), children) : /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      role: "row"
    }, other, {
      className: classes
    }), children);
  }
  StructuredListRow$1.propTypes = {
    /**
     * Provide the contents of your StructuredListRow
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether your StructuredListRow should be used as a header row
     */
    head: PropTypes__default["default"].bool,

    /**
     * Specify whether a `<label>` should be used
     */
    label: PropTypes__default["default"].bool,

    /**
     * Provide a handler that is invoked on the key down event for the control,
     * if `<label>` is in use
     */
    onKeyDown: PropTypes__default["default"].func,

    /**
     * Specify the tab index of the container node, if `<label>` is in use
     */
    tabIndex: PropTypes__default["default"].number
  };
  StructuredListRow$1.defaultProps = {
    head: false,
    label: false,
    tabIndex: 0,
    onKeyDown: function onKeyDown() {}
  };
  function StructuredListInput$1(props) {
    var className = props.className,
        value = props.value,
        name = props.name,
        title = props.title,
        id = props.id,
        other = _objectWithoutProperties$2(props, _excluded5);

    var prefix = usePrefix();
    var classes = cx("".concat(prefix, "--structured-list-input"), className);
    var instanceId = id || getInstanceId$6();
    return /*#__PURE__*/React__default["default"].createElement("input", _extends$3({}, other, {
      type: "radio",
      tabIndex: -1,
      id: instanceId,
      className: classes,
      value: value,
      name: name,
      title: title
    }));
  }
  StructuredListInput$1.propTypes = {
    /**
     * Specify an optional className to be applied to the input
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the underlying input should be checked by default
     */
    defaultChecked: PropTypes__default["default"].bool,

    /**
     * Specify a custom `id` for the input
     */
    id: PropTypes__default["default"].string,

    /**
     * Provide a `name` for the input
     */
    name: PropTypes__default["default"].string,

    /**
     * Provide an optional hook that is called each time the input is updated
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Provide a `title` for the input
     */
    title: PropTypes__default["default"].string,

    /**
     * Specify the value of the input
     */
    value: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]).isRequired
  };
  StructuredListInput$1.defaultProps = {
    onChange: function onChange() {},
    value: 'value',
    title: 'title'
  };
  function StructuredListCell$1(props) {
    var _classNames3;

    var children = props.children,
        className = props.className,
        head = props.head,
        noWrap = props.noWrap,
        other = _objectWithoutProperties$2(props, _excluded6);

    var prefix = usePrefix();
    var classes = cx(className, (_classNames3 = {}, _defineProperty$2(_classNames3, "".concat(prefix, "--structured-list-th"), head), _defineProperty$2(_classNames3, "".concat(prefix, "--structured-list-td"), !head), _defineProperty$2(_classNames3, "".concat(prefix, "--structured-list-content--nowrap"), noWrap), _classNames3));
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: classes,
      role: head ? 'columnheader' : 'cell'
    }, other), children);
  }
  StructuredListCell$1.propTypes = {
    /**
     * Provide the contents of your StructuredListCell
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether your StructuredListCell should be used as a header cell
     */
    head: PropTypes__default["default"].bool,

    /**
     * Specify whether your StructuredListCell should have text wrapping
     */
    noWrap: PropTypes__default["default"].bool
  };
  StructuredListCell$1.defaultProps = {
    head: false,
    noWrap: false
  };

  var _excluded$14 = ["rowCount", "border", "className"];

  var StructuredListSkeleton = function StructuredListSkeleton(_ref) {
    var _cx;

    var rowCount = _ref.rowCount,
        border = _ref.border,
        className = _ref.className,
        rest = _objectWithoutProperties$2(_ref, _excluded$14);

    var prefix = usePrefix();
    var StructuredListSkeletonClasses = cx(className, (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--skeleton"), true), _defineProperty$2(_cx, "".concat(prefix, "--structured-list"), true), _defineProperty$2(_cx, "".concat(prefix, "--structured-list--border"), border), _cx));
    var rows = [];

    for (var i = 0; i < rowCount; i++) {
      rows.push( /*#__PURE__*/React__default["default"].createElement("div", {
        className: "".concat(prefix, "--structured-list-row"),
        key: i
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: "".concat(prefix, "--structured-list-td")
      }), /*#__PURE__*/React__default["default"].createElement("div", {
        className: "".concat(prefix, "--structured-list-td")
      }), /*#__PURE__*/React__default["default"].createElement("div", {
        className: "".concat(prefix, "--structured-list-td")
      })));
    }

    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: StructuredListSkeletonClasses
    }, rest), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--structured-list-thead")
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--structured-list-row ").concat(prefix, "--structured-list-row--header-row")
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--structured-list-th")
    }, /*#__PURE__*/React__default["default"].createElement("span", null)), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--structured-list-th")
    }, /*#__PURE__*/React__default["default"].createElement("span", null)), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--structured-list-th")
    }, /*#__PURE__*/React__default["default"].createElement("span", null)))), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--structured-list-tbody")
    }, rows));
  };

  StructuredListSkeleton.propTypes = {
    /**
     * Specify whether a border should be added to your StructuredListSkeleton
     */
    border: PropTypes__default["default"].bool,

    /**
     * Specify an optional className to add.
     */
    className: PropTypes__default["default"].string,

    /**
     * number of table rows
     */
    rowCount: PropTypes__default["default"].number
  };
  StructuredListSkeleton.defaultProps = {
    rowCount: 5,
    border: false
  };
  var StructuredListSkeleton$1 = StructuredListSkeleton;

  var StructuredListWrapper = createComponentToggle({
    name: 'StructuredListWrapper',
    next: StructuredListWrapper$2,
    classic: StructuredListWrapper$1
  });
  var StructuredListHead = createComponentToggle({
    name: 'StructuredListHead',
    next: StructuredListHead$2,
    classic: StructuredListHead$1
  });
  var StructuredListInput = createComponentToggle({
    name: 'StructuredListInput',
    next: StructuredListInput$2,
    classic: StructuredListInput$1
  });
  var StructuredListBody = createComponentToggle({
    name: 'StructuredListBody',
    next: StructuredListBody$2,
    classic: StructuredListBody$1
  });
  var StructuredListRow = createComponentToggle({
    name: 'StructuredListRow',
    next: StructuredListRow$2,
    classic: StructuredListRow$1
  });
  var StructuredListCell = createComponentToggle({
    name: 'StructuredListCell',
    next: StructuredListCell$2,
    classic: StructuredListCell$1
  });

  var _excluded$13 = ["align", "as", "caret", "className", "children", "dropShadow", "highContrast", "open"],
      _excluded2$3 = ["className", "children"];
  var Popover = /*#__PURE__*/React__default["default"].forwardRef(function Popover(props, ref) {
    var _cx;

    var _props$align = props.align,
        align = _props$align === void 0 ? 'bottom' : _props$align,
        _props$as = props.as,
        BaseComponent = _props$as === void 0 ? 'span' : _props$as,
        _props$caret = props.caret,
        caret = _props$caret === void 0 ? true : _props$caret,
        customClassName = props.className,
        children = props.children,
        _props$dropShadow = props.dropShadow,
        dropShadow = _props$dropShadow === void 0 ? true : _props$dropShadow,
        _props$highContrast = props.highContrast,
        highContrast = _props$highContrast === void 0 ? false : _props$highContrast,
        open = props.open,
        rest = _objectWithoutProperties$2(props, _excluded$13);

    var prefix = usePrefix();
    var className = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--popover-container"), true), _defineProperty$2(_cx, "".concat(prefix, "--popover--caret"), caret), _defineProperty$2(_cx, "".concat(prefix, "--popover--drop-shadow"), dropShadow), _defineProperty$2(_cx, "".concat(prefix, "--popover--high-contrast"), highContrast), _defineProperty$2(_cx, "".concat(prefix, "--popover--open"), open), _defineProperty$2(_cx, "".concat(prefix, "--popover--").concat(align), true), _defineProperty$2(_cx, customClassName, !!customClassName), _cx));
    return /*#__PURE__*/React__default["default"].createElement(BaseComponent, _extends$3({}, rest, {
      className: className,
      ref: ref
    }), children);
  }); // Note: this displayName is temporarily set so that Storybook ArgTable
  // correctly displays the name of this component

  {
    Popover.displayName = 'Popover';
  }

  Popover.propTypes = {
    /**
     * Specify how the popover should align with the trigger element
     */
    align: PropTypes__default["default"].oneOf(['top', 'top-left', 'top-right', 'bottom', 'bottom-left', 'bottom-right', 'left', 'left-bottom', 'left-top', 'right', 'right-bottom', 'right-top']),

    /**
     * Provide a custom element or component to render the top-level node for the
     * component.
     */
    as: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].elementType]),

    /**
     * Specify whether a caret should be rendered
     */
    caret: PropTypes__default["default"].bool,

    /**
     * Provide elements to be rendered inside of the component
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide a custom class name to be added to the outermost node in the
     * component
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether a drop shadow should be rendered on the popover
     */
    dropShadow: PropTypes__default["default"].bool,

    /**
     * Render the component using the high-contrast variant
     */
    highContrast: PropTypes__default["default"].bool,

    /**
     * Specify whether the component is currently open or closed
     */
    open: PropTypes__default["default"].bool.isRequired
  };
  var PopoverContent = /*#__PURE__*/React__default["default"].forwardRef(function PopoverContent(_ref, ref) {
    var className = _ref.className,
        children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, _excluded2$3);

    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("span", _extends$3({}, rest, {
      className: "".concat(prefix, "--popover")
    }), /*#__PURE__*/React__default["default"].createElement("span", {
      className: cx("".concat(prefix, "--popover-content"), className),
      ref: ref
    }, children), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--popover-caret")
    }));
  });
  PopoverContent.propTypes = {
    /**
     * Provide elements to be rendered inside of the component
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide a custom class name to be added to the outermost node in the
     * component
     */
    className: PropTypes__default["default"].string
  };

  var _excluded$12 = ["align", "className", "children", "definition", "defaultOpen", "id", "tooltipText", "triggerClassName"];

  function DefinitionTooltip(_ref) {
    var _ref$align = _ref.align,
        align = _ref$align === void 0 ? 'bottom-left' : _ref$align,
        className = _ref.className,
        children = _ref.children,
        definition = _ref.definition,
        _ref$defaultOpen = _ref.defaultOpen,
        defaultOpen = _ref$defaultOpen === void 0 ? false : _ref$defaultOpen,
        id = _ref.id,
        tooltipText = _ref.tooltipText,
        triggerClassName = _ref.triggerClassName,
        rest = _objectWithoutProperties$2(_ref, _excluded$12);

    var _useState = React.useState(defaultOpen),
        _useState2 = _slicedToArray$1(_useState, 2),
        isOpen = _useState2[0],
        setOpen = _useState2[1];

    var prefix = usePrefix();
    var tooltipId = useFallbackId(id);

    function onKeyDown(event) {
      if (isOpen && match(event, Escape)) {
        event.stopPropagation();
        setOpen(false);
      }
    }

    return /*#__PURE__*/React__default["default"].createElement(Popover, {
      align: align,
      className: className,
      dropShadow: false,
      highContrast: true,
      onMouseLeave: function onMouseLeave() {
        setOpen(false);
      },
      open: isOpen
    }, /*#__PURE__*/React__default["default"].createElement("button", _extends$3({}, rest, {
      className: cx("".concat(prefix, "--definition-term"), triggerClassName),
      "aria-controls": tooltipId,
      "aria-expanded": isOpen,
      onBlur: function onBlur() {
        setOpen(false);
      },
      onClick: function onClick() {
        setOpen(!isOpen);
      },
      onKeyDown: onKeyDown,
      type: "button"
    }), children), /*#__PURE__*/React__default["default"].createElement(PopoverContent, {
      className: "".concat(prefix, "--definition-tooltip"),
      id: tooltipId
    }, tooltipText !== null && tooltipText !== void 0 ? tooltipText : definition));
  }

  DefinitionTooltip.propTypes = {
    /**
     * Specify how the trigger should align with the tooltip
     */
    align: PropTypes__default["default"].oneOf(['top', 'top-left', 'top-right', 'bottom', 'bottom-left', 'bottom-right']),

    /**
     * The `children` prop will be used as the value that is being defined
     */
    children: PropTypes__default["default"].node.isRequired,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the tooltip should be open when it first renders
     */
    defaultOpen: PropTypes__default["default"].bool,

    /**
     * The `definition` prop is used as the content inside of the tooltip that
     * appears when a user interacts with the element rendered by the `children`
     * prop
     */
    definition: PropTypes__default["default"].node.isRequired,

    /**
     * Provide a value that will be assigned as the id of the tooltip
     */
    id: PropTypes__default["default"].string,

    /**
     * [Deprecated] Please use the `definition` prop instead.
     *
     * Provide the text that will be displayed in the tooltip when it is rendered.
     */
    tooltipText: deprecate(PropTypes__default["default"].node, 'The tooltipText prop has been deprecated. Please use the `definition` prop instead.'),

    /**
     * The CSS class name of the trigger element
     */
    triggerClassName: PropTypes__default["default"].string
  };

  /**
   * `useDelayedState` mirrors `useState` but also allows you to add a delay to
   * when your state updates. You can provide a second argument to `setState`,
   * `delayMs`, which will be the time in milliseconds after which the state is
   * updated.
   *
   * This hook will clean up pending timers in `useEffect` and will cancel any
   * pending timers when a `setState` is called before the state is updated from
   * a previous call
   */

  function useDelayedState(initialState) {
    var _useState = React.useState(initialState),
        _useState2 = _slicedToArray$1(_useState, 2),
        state = _useState2[0],
        setState = _useState2[1];

    var timeoutId = React.useRef(null); // We use `useCallback` to match the signature of React's `useState` which will
    // always return the same reference for the `setState` updater

    var setStateWithDelay = React.useCallback(function (stateToSet) {
      var delayMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      clearTimeout(timeoutId.current);
      timeoutId.current = null;

      if (delayMs === 0) {
        setState(stateToSet);
        return;
      }

      timeoutId.current = setTimeout(function () {
        setState(stateToSet);
        timeoutId.current = null;
      }, delayMs);
    }, []);
    React.useEffect(function () {
      return function () {
        clearTimeout(timeoutId.current);
      };
    }, []);
    return [state, setStateWithDelay];
  }

  var _excluded$11 = ["align", "className", "children", "label", "description", "enterDelayMs", "leaveDelayMs", "defaultOpen"];

  function Tooltip$2(_ref) {
    var _ref$align = _ref.align,
        align = _ref$align === void 0 ? 'top' : _ref$align,
        customClassName = _ref.className,
        children = _ref.children,
        label = _ref.label,
        description = _ref.description,
        _ref$enterDelayMs = _ref.enterDelayMs,
        enterDelayMs = _ref$enterDelayMs === void 0 ? 100 : _ref$enterDelayMs,
        _ref$leaveDelayMs = _ref.leaveDelayMs,
        leaveDelayMs = _ref$leaveDelayMs === void 0 ? 300 : _ref$leaveDelayMs,
        _ref$defaultOpen = _ref.defaultOpen,
        defaultOpen = _ref$defaultOpen === void 0 ? false : _ref$defaultOpen,
        rest = _objectWithoutProperties$2(_ref, _excluded$11);

    var containerRef = React.useRef(null);
    var tooltipRef = React.useRef(null);

    var _useDelayedState = useDelayedState(defaultOpen),
        _useDelayedState2 = _slicedToArray$1(_useDelayedState, 2),
        open = _useDelayedState2[0],
        setOpen = _useDelayedState2[1];

    var id = useId('tooltip');
    var prefix = usePrefix();
    var child = React__default["default"].Children.only(children);
    var triggerProps = {
      onFocus: function onFocus() {
        return setOpen(true);
      },
      onBlur: function onBlur() {
        return setOpen(false);
      },
      // This should be placed on the trigger in case the element is disabled
      onMouseEnter: onMouseEnter
    };

    if (label) {
      triggerProps['aria-labelledby'] = id;
    } else {
      triggerProps['aria-describedby'] = id;
    }

    function onKeyDown(event) {
      if (open && match(event, Escape)) {
        event.stopPropagation();
        setOpen(false);
      }
    }

    function onMouseEnter() {
      setOpen(true, enterDelayMs);
    }

    function onMouseLeave() {
      setOpen(false, leaveDelayMs);
    }

    useNoInteractiveChildren(tooltipRef, 'The Tooltip component must have no interactive content rendered by the' + '`label` or `description` prop');
    return /*#__PURE__*/React__default["default"].createElement(Popover, _extends$3({}, rest, {
      align: align,
      className: cx("".concat(prefix, "--tooltip"), customClassName),
      dropShadow: false,
      highContrast: true,
      onKeyDown: onKeyDown,
      onMouseLeave: onMouseLeave,
      open: open,
      ref: containerRef
    }), /*#__PURE__*/React__default["default"].cloneElement(child, triggerProps), /*#__PURE__*/React__default["default"].createElement(PopoverContent, {
      "aria-hidden": "true",
      className: "".concat(prefix, "--tooltip-content"),
      id: id,
      ref: tooltipRef,
      role: "tooltip"
    }, label || description));
  }

  Tooltip$2.propTypes = {
    /**
     * Specify how the trigger should align with the tooltip
     */
    align: PropTypes__default["default"].oneOf(['top', 'top-left', 'top-right', 'bottom', 'bottom-left', 'bottom-right', 'left', 'left-bottom', 'left-top', 'right', 'right-bottom', 'right-top']),

    /**
     * Pass in the child to which the tooltip will be applied
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the tooltip should be open when it first renders
     */
    defaultOpen: PropTypes__default["default"].bool,

    /**
     * Provide the description to be rendered inside of the Tooltip. The
     * description will use `aria-describedby` and will describe the child node
     * in addition to the text rendered inside of the child. This means that if you
     * have text in the child node, that it will be announced alongside the
     * description to the screen reader.
     *
     * Note: if label and description are both provided, label will be used and
     * description will not be used
     */
    description: PropTypes__default["default"].node,

    /**
     * Specify the duration in milliseconds to delay before displaying the tooltip
     */
    enterDelayMs: PropTypes__default["default"].number,

    /**
     * Provide the label to be rendered inside of the Tooltip. The label will use
     * `aria-labelledby` and will fully describe the child node that is provided.
     * This means that if you have text in the child node, that it will not be
     * announced to the screen reader.
     *
     * Note: if label and description are both provided, description will not be
     * used
     */
    label: PropTypes__default["default"].node,

    /**
     * Specify the duration in milliseconds to delay before hiding the tooltip
     */
    leaveDelayMs: PropTypes__default["default"].number
  };

  /**
   * A custom hook which will call the given callback exactly once when your
   * component is initially rendered and effects are first called
   *
   * @param {Function} callback
   */

  function useEffectOnce(callback) {
    var savedCallback = React.useRef(callback);
    var effectGuard = React.useRef(false);
    React.useEffect(function () {
      savedCallback.current = callback;
    });
    React.useEffect(function () {
      if (effectGuard.current !== true) {
        effectGuard.current = true;
        savedCallback.current();
      }
    }, []);
  }

  function usePressable(ref) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        onPress = _ref.onPress,
        onPressIn = _ref.onPressIn,
        onPressOut = _ref.onPressOut,
        onLongPress = _ref.onLongPress,
        _ref$delayLongPressMs = _ref.delayLongPressMs,
        delayLongPressMs = _ref$delayLongPressMs === void 0 ? 500 : _ref$delayLongPressMs;

    var savedOnPress = React.useRef(onPress);
    var savedOnPressIn = React.useRef(onPressIn);
    var savedOnPressOut = React.useRef(onPressOut);
    var savedOnLongPress = React.useRef(onLongPress);

    var _useState = React.useState(false),
        _useState2 = _slicedToArray$1(_useState, 2),
        pendingLongPress = _useState2[0],
        setPendingLongPress = _useState2[1];

    var _useState3 = React.useState(false),
        _useState4 = _slicedToArray$1(_useState3, 2),
        longPress = _useState4[0],
        setLongPress = _useState4[1];

    var state = React.useRef({
      longPress: false
    });
    React.useEffect(function () {
      savedOnPress.current = onPress;
    }, [onPress]);
    React.useEffect(function () {
      savedOnPressIn.current = onPressIn;
    }, [onPressIn]);
    React.useEffect(function () {
      savedOnPressOut.current = onPressOut;
    }, [onPressOut]);
    React.useEffect(function () {
      savedOnLongPress.current = onLongPress;
    }, [onLongPress]);
    React.useEffect(function () {
      var element = ref.current; // Fired when a pointer becomes active buttons state.

      function onPointerDown() {
        var _savedOnPressIn$curre;

        setPendingLongPress(true);
        (_savedOnPressIn$curre = savedOnPressIn.current) === null || _savedOnPressIn$curre === void 0 ? void 0 : _savedOnPressIn$curre.call(savedOnPressIn);
      } // Fired when a pointer is no longer active buttons state.


      function onPointerUp() {
        var _savedOnPressOut$curr;

        setPendingLongPress(false);
        setLongPress(false);
        (_savedOnPressOut$curr = savedOnPressOut.current) === null || _savedOnPressOut$curr === void 0 ? void 0 : _savedOnPressOut$curr.call(savedOnPressOut, state.current);
      } // A browser fires this event if it concludes the pointer
      // will no longer be able to generate events (for example
      // the related device is deactivated).


      function onPointerCancel() {
        var _savedOnPressOut$curr2;

        setPendingLongPress(false);
        setLongPress(false);
        (_savedOnPressOut$curr2 = savedOnPressOut.current) === null || _savedOnPressOut$curr2 === void 0 ? void 0 : _savedOnPressOut$curr2.call(savedOnPressOut);
        state.current.longPress = false;
      } // Fired when a pointer is moved out of the hit test
      // boundaries of an element. For pen devices, this event
      // is fired when the stylus leaves the hover range
      // detectable by the digitizer.


      function onPointerLeave() {
        var _savedOnPressOut$curr3;

        setPendingLongPress(false);
        setLongPress(false);
        (_savedOnPressOut$curr3 = savedOnPressOut.current) === null || _savedOnPressOut$curr3 === void 0 ? void 0 : _savedOnPressOut$curr3.call(savedOnPressOut);
        state.current.longPress = false;
      }

      function onClick() {
        var _savedOnPress$current;

        setLongPress(false);
        setPendingLongPress(false);
        (_savedOnPress$current = savedOnPress.current) === null || _savedOnPress$current === void 0 ? void 0 : _savedOnPress$current.call(savedOnPress, state.current);
        state.current.longPress = false;
      }

      function onTouchStart(event) {
        // We prevent the default event on touchstart so that text selection is
        // disabled on iOS  Safari when interacting with a "pressable" element
        event.preventDefault();
      }

      element.addEventListener('touchstart', onTouchStart);
      element.addEventListener('pointerdown', onPointerDown);
      element.addEventListener('pointerup', onPointerUp);
      element.addEventListener('pointercancel', onPointerCancel);
      element.addEventListener('pointerleave', onPointerLeave);
      element.addEventListener('click', onClick);
      return function () {
        element.removeEventListener('touchstart', onTouchStart);
        element.removeEventListener('pointerdown', onPointerDown);
        element.removeEventListener('pointerup', onPointerUp);
        element.removeEventListener('pointercancel', onPointerCancel);
        element.removeEventListener('pointerleave', onPointerLeave);
        element.removeEventListener('click', onClick);
      };
    }, [ref]);
    React.useEffect(function () {
      if (pendingLongPress) {
        var timeoutId = setTimeout(function () {
          setPendingLongPress(false);
          setLongPress(true);
        }, delayLongPressMs);
        return function () {
          clearTimeout(timeoutId);
        };
      }
    }, [pendingLongPress, delayLongPressMs]);
    React.useEffect(function () {
      if (longPress) {
        var _savedOnLongPress$cur;

        state.current.longPress = true;
        return (_savedOnLongPress$cur = savedOnLongPress.current) === null || _savedOnLongPress$cur === void 0 ? void 0 : _savedOnLongPress$cur.call(savedOnLongPress);
      }
    }, [longPress]);
  }

  var _excluded$10 = ["activation", "aria-label", "children", "className", "contained", "iconSize", "leftOverflowButtonProps", "light", "rightOverflowButtonProps", "scrollDebounceWait", "scrollIntoView"],
      _excluded2$2 = ["as", "children", "className", "disabled", "onClick", "onKeyDown"],
      _excluded3$2 = ["children", "className", "defaultOpen", "enterDelayMs", "leaveDelayMs", "label"],
      _excluded4$2 = ["children", "className"];

  var TabsContext = /*#__PURE__*/React__default["default"].createContext(); // Used to keep track of position in a tablist

  var TabContext = /*#__PURE__*/React__default["default"].createContext(); // Used to keep track of position in a list of tab panels

  var TabPanelContext = /*#__PURE__*/React__default["default"].createContext();

  function Tabs$3(_ref) {
    var children = _ref.children,
        _ref$defaultSelectedI = _ref.defaultSelectedIndex,
        defaultSelectedIndex = _ref$defaultSelectedI === void 0 ? 0 : _ref$defaultSelectedI,
        _onChange = _ref.onChange,
        controlledSelectedIndex = _ref.selectedIndex;
    var baseId = useId('ccs'); // The active index is used to track the element which has focus in our tablist

    var _useState = React.useState(defaultSelectedIndex),
        _useState2 = _slicedToArray$1(_useState, 2),
        activeIndex = _useState2[0],
        setActiveIndex = _useState2[1]; // The selected index is used for the tab/panel pairing which is "visible"


    var _useControllableState = useControllableState({
      value: controlledSelectedIndex,
      defaultValue: defaultSelectedIndex,
      onChange: function onChange(value) {
        if (_onChange) {
          _onChange({
            selectedIndex: value
          });
        }
      }
    }),
        _useControllableState2 = _slicedToArray$1(_useControllableState, 2),
        selectedIndex = _useControllableState2[0],
        setSelectedIndex = _useControllableState2[1];

    var value = {
      baseId: baseId,
      activeIndex: activeIndex,
      defaultSelectedIndex: defaultSelectedIndex,
      setActiveIndex: setActiveIndex,
      selectedIndex: selectedIndex,
      setSelectedIndex: setSelectedIndex
    };
    return /*#__PURE__*/React__default["default"].createElement(TabsContext.Provider, {
      value: value
    }, children);
  }

  Tabs$3.propTypes = {
    /**
     * Provide child elements to be rendered inside of the `Tabs`.
     * These elements should render either `TabsList` or `TabsPanels`
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify which content tab should be initially selected when the component
     * is first rendered
     */
    defaultSelectedIndex: PropTypes__default["default"].number,

    /**
     * Provide an optional function which is called whenever the state of the
     * `Tabs` changes
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Control which content panel is currently selected. This puts the component
     * in a controlled mode and should be used along with `onChange`
     */
    selectedIndex: PropTypes__default["default"].number
  };
  /**
   * Get the next index for a given keyboard event given a count of the total
   * items and the current index
   * @param {Event} event
   * @param {number} total
   * @param {number} index
   * @returns {number}
   */

  function getNextIndex(event, total, index) {
    if (match(event, ArrowRight)) {
      return (index + 1) % total;
    } else if (match(event, ArrowLeft)) {
      return (total + index - 1) % total;
    } else if (match(event, Home)) {
      return 0;
    } else if (match(event, End)) {
      return total - 1;
    }
  }

  function TabList(_ref2) {
    var _cx;

    var _ref2$activation = _ref2.activation,
        activation = _ref2$activation === void 0 ? 'automatic' : _ref2$activation,
        label = _ref2['aria-label'],
        children = _ref2.children,
        customClassName = _ref2.className,
        _ref2$contained = _ref2.contained,
        contained = _ref2$contained === void 0 ? false : _ref2$contained,
        iconSize = _ref2.iconSize,
        leftOverflowButtonProps = _ref2.leftOverflowButtonProps,
        light = _ref2.light,
        rightOverflowButtonProps = _ref2.rightOverflowButtonProps,
        _ref2$scrollDebounceW = _ref2.scrollDebounceWait,
        scrollDebounceWait = _ref2$scrollDebounceW === void 0 ? 200 : _ref2$scrollDebounceW,
        scrollIntoView = _ref2.scrollIntoView,
        rest = _objectWithoutProperties$2(_ref2, _excluded$10);

    var _React$useContext = React__default["default"].useContext(TabsContext),
        activeIndex = _React$useContext.activeIndex,
        selectedIndex = _React$useContext.selectedIndex,
        setSelectedIndex = _React$useContext.setSelectedIndex,
        setActiveIndex = _React$useContext.setActiveIndex;

    var prefix = usePrefix();
    var ref = React.useRef(null);
    var previousButton = React.useRef(null);
    var nextButton = React.useRef(null);

    var _useState3 = React.useState(false),
        _useState4 = _slicedToArray$1(_useState3, 2),
        isScrollable = _useState4[0],
        setIsScrollable = _useState4[1];

    var _useState5 = React.useState(false),
        _useState6 = _slicedToArray$1(_useState5, 2),
        scrollLeft = _useState6[0],
        setScrollLeft = _useState6[1];

    var className = cx("".concat(prefix, "--tabs"), customClassName, (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--tabs--contained"), contained), _defineProperty$2(_cx, "".concat(prefix, "--tabs--light"), light), _defineProperty$2(_cx, "".concat(prefix, "--tabs__icon--default"), iconSize === 'default'), _defineProperty$2(_cx, "".concat(prefix, "--tabs__icon--lg"), iconSize === 'lg'), _cx)); // Previous Button
    // VISIBLE IF:
    //   SCROLLABLE
    //   AND SCROLL_LEFT > 0

    var buttonWidth = 44;
    var isPreviousButtonVisible = ref.current ? isScrollable && scrollLeft > 0 : false; // Next Button
    // VISIBLE IF:
    //   SCROLLABLE
    //   AND SCROLL_LEFT + CLIENT_WIDTH < SCROLL_WIDTH

    var isNextButtonVisible = ref.current ? scrollLeft + buttonWidth + ref.current.clientWidth < ref.current.scrollWidth : false;
    var previousButtonClasses = cx("".concat(prefix, "--tab--overflow-nav-button"), "".concat(prefix, "--tab--overflow-nav-button--previous"), _defineProperty$2({}, "".concat(prefix, "--tab--overflow-nav-button--hidden"), !isPreviousButtonVisible));
    var nextButtonClasses = cx("".concat(prefix, "--tab--overflow-nav-button"), "".concat(prefix, "--tab--overflow-nav-button--next"), _defineProperty$2({}, "".concat(prefix, "--tab--overflow-nav-button--hidden"), !isNextButtonVisible));
    var tabs = [];
    var debouncedOnScroll = React.useCallback(function () {
      return debounce$4(function (event) {
        setScrollLeft(event.target.scrollLeft);
      }, scrollDebounceWait);
    }, [scrollDebounceWait]);

    function onKeyDown(event) {
      if (matches(event, [ArrowRight, ArrowLeft, Home, End])) {
        event.preventDefault();
        var activeTabs = tabs.filter(function (tab) {
          return !tab.current.disabled;
        });
        var currentIndex = activeTabs.indexOf(tabs[activation === 'automatic' ? selectedIndex : activeIndex]);
        var nextIndex = tabs.indexOf(activeTabs[getNextIndex(event, activeTabs.length, currentIndex)]);

        if (activation === 'automatic') {
          setSelectedIndex(nextIndex);
        } else if (activation === 'manual') {
          setActiveIndex(nextIndex);
        }

        tabs[nextIndex].current.focus();
      }
    }

    useEffectOnce(function () {
      var tab = tabs[selectedIndex];

      if (scrollIntoView && tab) {
        tab.current.scrollIntoView({
          block: 'nearest',
          inline: 'nearest'
        });
      }
    });
    useEffectOnce(function () {
      if (tabs[selectedIndex].current.disabled) {
        var activeTabs = tabs.filter(function (tab) {
          return !tab.current.disabled;
        });

        if (activeTabs.length > 0) {
          var tab = activeTabs[0];
          setSelectedIndex(tabs.indexOf(tab));
        }
      }
    });
    useIsomorphicEffect$1(function () {
      if (ref.current) {
        setIsScrollable(ref.current.scrollWidth > ref.current.clientWidth);
      }

      function handler() {
        if (ref.current) {
          setIsScrollable(ref.current.scrollWidth > ref.current.clientWidth);
        }
      }

      var debouncedHandler = debounce$4(handler, 200);
      window.addEventListener('resize', debouncedHandler);
      return function () {
        debouncedHandler.cancel();
        window.removeEventListener('resize', debouncedHandler);
      };
    }, []); // updates scroll location for all scroll behavior.

    useIsomorphicEffect$1(function () {
      ref.current.scrollLeft = scrollLeft;
    }, [scrollLeft]);
    useIsomorphicEffect$1(function () {
      var tab = activation === 'manual' ? tabs[activeIndex] : tabs[selectedIndex];

      if (tab) {
        // The width of the "scroll buttons"
        // The start and end position of the selected tab
        var _tab$current$getBound = tab.current.getBoundingClientRect(),
            tabWidth = _tab$current$getBound.width;

        var start = tab.current.offsetLeft;
        var end = tab.current.offsetLeft + tabWidth; // The start and end of the visible area for the tabs

        var visibleStart = ref.current.scrollLeft + buttonWidth;
        var visibleEnd = ref.current.scrollLeft + ref.current.clientWidth - buttonWidth; // The beginning of the tab is clipped and not visible

        if (start < visibleStart) {
          setScrollLeft(start - buttonWidth);
        } // The end of teh tab is clipped and not visible


        if (end > visibleEnd) {
          setScrollLeft(end + buttonWidth - ref.current.clientWidth);
        }
      }
    }, [activation, activeIndex, selectedIndex]);
    usePressable(previousButton, {
      onPress: function onPress(_ref3) {
        var longPress = _ref3.longPress;

        if (!longPress) {
          setScrollLeft(Math.max(scrollLeft - ref.current.scrollWidth / tabs.length * 1.5, 0));
        }
      },
      onLongPress: function onLongPress() {
        return createLongPressBehavior(ref, 'backward', setScrollLeft);
      }
    });
    usePressable(nextButton, {
      onPress: function onPress(_ref4) {
        var longPress = _ref4.longPress;

        if (!longPress) {
          setScrollLeft(Math.min(scrollLeft + ref.current.scrollWidth / tabs.length * 1.5, ref.current.scrollWidth - ref.current.clientWidth));
        }
      },
      onLongPress: function onLongPress() {
        return createLongPressBehavior(ref, 'forward', setScrollLeft);
      }
    });
    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: className
    }, /*#__PURE__*/React__default["default"].createElement("button", _extends$3({
      "aria-hidden": "true",
      "aria-label": "Scroll left",
      ref: previousButton,
      className: previousButtonClasses,
      type: "button"
    }, leftOverflowButtonProps), /*#__PURE__*/React__default["default"].createElement(ChevronLeft16, null)), /*#__PURE__*/React__default["default"].createElement("div", _extends$3({}, rest, {
      "aria-label": label,
      ref: ref,
      role: "tablist",
      className: "".concat(prefix, "--tab--list"),
      onScroll: debouncedOnScroll,
      onKeyDown: onKeyDown
    }), React__default["default"].Children.map(children, function (child, index) {
      var ref = /*#__PURE__*/React__default["default"].createRef();
      tabs.push(ref);
      return /*#__PURE__*/React__default["default"].createElement(TabContext.Provider, {
        value: index
      }, /*#__PURE__*/React__default["default"].cloneElement(child, {
        ref: ref
      }));
    })), /*#__PURE__*/React__default["default"].createElement("button", _extends$3({
      "aria-hidden": "true",
      "aria-label": "Scroll right",
      ref: nextButton,
      className: nextButtonClasses,
      type: "button"
    }, rightOverflowButtonProps), /*#__PURE__*/React__default["default"].createElement(ChevronRight16, null)));
  }

  TabList.propTypes = {
    /**
     * Specify whether the content tab should be activated automatically or
     * manually
     */
    activation: PropTypes__default["default"].oneOf(['automatic', 'manual']),

    /**
     * Provide an accessible label to be read when a user interacts with this
     * component
     */
    'aria-label': PropTypes__default["default"].string.isRequired,

    /**
     * Provide child elements to be rendered inside of `ContentTabs`.
     * These elements should render a `ContentTab`
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be added to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether component is contained type
     */
    contained: PropTypes__default["default"].bool,

    /**
     * If using `IconTab`, specify the size of the icon being used.
     */
    iconSize: PropTypes__default["default"].oneOf(['default', 'lg']),

    /**
     * Provide the props that describe the left overflow button
     */
    leftOverflowButtonProps: PropTypes__default["default"].object,

    /**
     * Specify whether or not to use the light component variant
     */
    light: PropTypes__default["default"].bool,

    /**
     * Provide the props that describe the right overflow button
     */
    rightOverflowButtonProps: PropTypes__default["default"].object,

    /**
     * Optionally provide a delay (in milliseconds) passed to the lodash
     * debounce of the onScroll handler. This will impact the responsiveness
     * of scroll arrow buttons rendering when scrolling to the first or last tab.
     */
    scrollDebounceWait: PropTypes__default["default"].number,

    /**
     * Choose whether or not to automatically scroll to newly selected tabs
     * on component rerender
     */
    scrollIntoView: PropTypes__default["default"].bool
  };
  /**
   * Helper function to setup the behavior when a button is "long pressed". This
   * function will take a ref to the tablist, a direction, and a setter for
   * scrollLeft and will update the scroll position within a
   * requestAnimationFrame.
   *
   * It returns a cleanup function to be run when the long press is
   * deactivated
   *
   * @param {RefObject} ref
   * @param {'forward' | 'backward'} direction
   * @param {Function} setScrollLeft
   * @returns {Function}
   */

  function createLongPressBehavior(ref, direction, setScrollLeft) {
    // We manually override the scroll behavior to be "auto". If it is set as
    // smooth, this animation does not update correctly
    var defaultScrollBehavior = ref.current.style['scroll-behavior'];
    ref.current.style['scroll-behavior'] = 'auto';
    var scrollDelta = direction === 'forward' ? 5 : -5;
    var frameId = null;

    function tick() {
      ref.current.scrollLeft = ref.current.scrollLeft + scrollDelta;
      frameId = requestAnimationFrame(tick);
    }

    frameId = requestAnimationFrame(tick);
    return function () {
      // Restore the previous scroll behavior
      ref.current.style['scroll-behavior'] = defaultScrollBehavior; // Make sure that our `scrollLeft` value is in sync with the existing
      // `ref` after our requestAnimationFrame loop above

      setScrollLeft(ref.current.scrollLeft);

      if (frameId) {
        cancelAnimationFrame(frameId);
      }
    };
  }

  var Tab$5 = /*#__PURE__*/React__default["default"].forwardRef(function Tab(_ref5, ref) {
    var _cx4;

    var _ref5$as = _ref5.as,
        BaseComponent = _ref5$as === void 0 ? 'button' : _ref5$as,
        children = _ref5.children,
        customClassName = _ref5.className,
        disabled = _ref5.disabled,
        _onClick = _ref5.onClick,
        onKeyDown = _ref5.onKeyDown,
        rest = _objectWithoutProperties$2(_ref5, _excluded2$2);

    var prefix = usePrefix();

    var _React$useContext2 = React__default["default"].useContext(TabsContext),
        selectedIndex = _React$useContext2.selectedIndex,
        setSelectedIndex = _React$useContext2.setSelectedIndex,
        baseId = _React$useContext2.baseId;

    var index = React__default["default"].useContext(TabContext);
    var id = "".concat(baseId, "-tab-").concat(index);
    var panelId = "".concat(baseId, "-tabpanel-").concat(index);
    var className = cx("".concat(prefix, "--tabs__nav-item"), "".concat(prefix, "--tabs__nav-link"), customClassName, (_cx4 = {}, _defineProperty$2(_cx4, "".concat(prefix, "--tabs__nav-item--selected"), selectedIndex === index), _defineProperty$2(_cx4, "".concat(prefix, "--tabs__nav-item--disabled"), disabled), _cx4));
    return /*#__PURE__*/React__default["default"].createElement(BaseComponent, _extends$3({}, rest, {
      "aria-controls": panelId,
      "aria-disabled": disabled,
      "aria-selected": selectedIndex === index,
      ref: ref,
      id: id,
      role: "tab",
      className: className,
      disabled: disabled,
      onClick: function onClick(evt) {
        if (disabled) {
          return;
        }

        setSelectedIndex(index);

        if (_onClick) {
          _onClick(evt);
        }
      },
      onKeyDown: onKeyDown,
      tabIndex: selectedIndex === index ? '0' : '-1',
      type: "button"
    }), children);
  });
  Tab$5.propTypes = {
    /**
     * Provide a custom element to render instead of the default button
     */
    as: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].elementType]),

    /**
     * Provide child elements to be rendered inside of `Tab`.
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be added to your Tab
     */
    className: PropTypes__default["default"].string,

    /**
     * Whether your Tab is disabled.
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Provide a handler that is invoked when a user clicks on the control
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Provide a handler that is invoked on the key down event for the control
     */
    onKeyDown: PropTypes__default["default"].func,

    /*
     * An optional parameter to allow overriding the anchor rendering.
     * Useful for using Tab along with react-router or other client
     * side router libraries.
     **/
    renderButton: PropTypes__default["default"].func
  };
  var IconTab = /*#__PURE__*/React__default["default"].forwardRef(function IconTab(_ref6, ref) {
    var children = _ref6.children,
        customClassName = _ref6.className,
        _ref6$defaultOpen = _ref6.defaultOpen,
        defaultOpen = _ref6$defaultOpen === void 0 ? false : _ref6$defaultOpen,
        enterDelayMs = _ref6.enterDelayMs,
        leaveDelayMs = _ref6.leaveDelayMs,
        label = _ref6.label,
        rest = _objectWithoutProperties$2(_ref6, _excluded3$2);

    var prefix = usePrefix();
    var classNames = cx("".concat(prefix, "--tabs__nav-item--icon"), customClassName);
    return /*#__PURE__*/React__default["default"].createElement(Tooltip$2, {
      align: "bottom",
      defaultOpen: defaultOpen,
      className: "".concat(prefix, "--icon-tooltip"),
      enterDelayMs: enterDelayMs,
      label: label,
      leaveDelayMs: leaveDelayMs
    }, /*#__PURE__*/React__default["default"].createElement(Tab$5, _extends$3({
      className: classNames,
      ref: ref
    }, rest), children));
  });
  IconTab.propTypes = {
    /**
     * Provide an icon to be rendered inside of `IconTab` as the visual label for Tab.
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be added to your Tab
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the tooltip for the icon should be open when it first renders
     */
    defaultOpen: PropTypes__default["default"].bool,

    /**
     * Specify the duration in milliseconds to delay before displaying the tooltip for the icon.
     */
    enterDelayMs: PropTypes__default["default"].number,

    /**
     * Provide the label to be rendered inside of the Tooltip. The label will use
     * `aria-labelledby` and will fully describe the child node that is provided.
     * This means that if you have text in the child node it will not be
     * announced to the screen reader.
     */
    label: PropTypes__default["default"].node.isRequired,

    /**
     * Specify the duration in milliseconds to delay before hiding the tooltip
     */
    leaveDelayMs: PropTypes__default["default"].number
  };
  var TabPanel = /*#__PURE__*/React__default["default"].forwardRef(function TabPanel(_ref7, forwardRef) {
    var children = _ref7.children,
        customClassName = _ref7.className,
        rest = _objectWithoutProperties$2(_ref7, _excluded4$2);

    var prefix = usePrefix();
    var panel = React.useRef(null);
    var ref = useMergedRefs([forwardRef, panel]);

    var _useState7 = React.useState('0'),
        _useState8 = _slicedToArray$1(_useState7, 2),
        tabIndex = _useState8[0],
        setTabIndex = _useState8[1];

    var _React$useContext3 = React__default["default"].useContext(TabsContext),
        selectedIndex = _React$useContext3.selectedIndex,
        baseId = _React$useContext3.baseId;

    var index = React__default["default"].useContext(TabPanelContext);
    var id = "".concat(baseId, "-tabpanel-").concat(index);
    var tabId = "".concat(baseId, "-tab-").concat(index);
    var className = cx("".concat(prefix, "--tab-content"), customClassName); // tabindex should only be 0 if no interactive content in children

    React.useEffect(function () {
      var interactiveContent = getInteractiveContent(panel.current);

      if (interactiveContent) {
        setTabIndex('-1');
      }
    }, []);
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({}, rest, {
      "aria-labelledby": tabId,
      id: id,
      className: className,
      ref: ref,
      role: "tabpanel",
      tabIndex: tabIndex,
      hidden: selectedIndex !== index
    }), children);
  });
  TabPanel.propTypes = {
    /**
     * Provide child elements to be rendered inside of `TabPanel`.
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be added to TabPanel.
     */
    className: PropTypes__default["default"].string
  };

  function TabPanels(_ref8) {
    var children = _ref8.children;
    return React__default["default"].Children.map(children, function (child, index) {
      return /*#__PURE__*/React__default["default"].createElement(TabPanelContext.Provider, {
        value: index
      }, child);
    });
  }

  TabPanels.propTypes = {
    /**
     * Provide child elements to be rendered inside of `TabPanels`.
     */
    children: PropTypes__default["default"].node
  };

  var _excluded$$ = ["id", "className", "handleTabClick", "handleTabKeyDown", "disabled", "href", "index", "label", "selected", "tabIndex", "onClick", "onKeyDown", "renderAnchor", "renderButton", "renderContent", "role"];

  var Tab$4 = /*#__PURE__*/function (_React$Component) {
    _inherits(Tab, _React$Component);

    var _super = _createSuper(Tab);

    function Tab() {
      _classCallCheck$1(this, Tab);

      return _super.apply(this, arguments);
    }

    _createClass$1(Tab, [{
      key: "render",
      value: function render() {
        var _classNames,
            _this = this,
            _buttonProps;

        var prefix = this.context;

        var _this$props = this.props,
            id = _this$props.id,
            className = _this$props.className,
            handleTabClick = _this$props.handleTabClick,
            handleTabKeyDown = _this$props.handleTabKeyDown,
            disabled = _this$props.disabled,
            _this$props$href = _this$props.href,
            href = _this$props$href === void 0 ? '#' : _this$props$href,
            index = _this$props.index,
            label = _this$props.label,
            selected = _this$props.selected,
            _this$props$tabIndex = _this$props.tabIndex,
            tabIndex = _this$props$tabIndex === void 0 ? 0 : _this$props$tabIndex,
            _onClick = _this$props.onClick,
            _onKeyDown = _this$props.onKeyDown,
            renderAnchor = _this$props.renderAnchor,
            renderButton = _this$props.renderButton;
            _this$props.renderContent;
            _this$props.role;
            var other = _objectWithoutProperties$2(_this$props, _excluded$$);

        var classes = cx(className, // TODO: remove scrollable in next major release
        // `${prefix}--tabs__nav-item`,
        "".concat(prefix, "--tabs--scrollable__nav-item"), (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--tabs__nav-item--disabled"), disabled), _defineProperty$2(_classNames, "".concat(prefix, "--tabs__nav-item--selected"), selected), _defineProperty$2(_classNames, "".concat(prefix, "--tabs--scrollable__nav-item--disabled"), disabled), _defineProperty$2(_classNames, "".concat(prefix, "--tabs--scrollable__nav-item--selected"), selected), _classNames));
        var buttonProps = (_buttonProps = {}, _defineProperty$2(_buttonProps, 'aria-selected', selected), _defineProperty$2(_buttonProps, 'aria-disabled', disabled), _defineProperty$2(_buttonProps, 'aria-controls', id && "".concat(id, "__panel")), _defineProperty$2(_buttonProps, "id", id), _defineProperty$2(_buttonProps, "className", "".concat(prefix, "--tabs--scrollable__nav-link")), _defineProperty$2(_buttonProps, "href", href), _defineProperty$2(_buttonProps, "tabIndex", !disabled ? tabIndex : -1), _defineProperty$2(_buttonProps, "ref", function ref(e) {
          _this.tabAnchor = e;
        }), _buttonProps);
        var renderElement = renderButton || renderAnchor;
        return /*#__PURE__*/React__default["default"].createElement("li", _extends$3({}, other, {
          className: classes,
          onClick: function onClick(evt) {
            if (disabled) {
              return;
            }

            if (handleTabClick) {
              handleTabClick(index, evt);
            }

            _onClick(evt);
          },
          onKeyDown: function onKeyDown(evt) {
            if (disabled) {
              return;
            }

            if (handleTabKeyDown) {
              handleTabKeyDown(index, evt);
            }

            _onKeyDown(evt);
          },
          role: "presentation"
        }), renderElement ? renderElement(buttonProps) : /*#__PURE__*/React__default["default"].createElement("button", _extends$3({
          type: "button",
          role: "tab"
        }, buttonProps), label));
      }
    }]);

    return Tab;
  }(React__default["default"].Component);

  _defineProperty$2(Tab$4, "contextType", PrefixContext);

  _defineProperty$2(Tab$4, "propTypes", {
    /**
     * Specify an optional className to be added to your Tab
     */
    className: PropTypes__default["default"].string,

    /**
     * Whether your Tab is disabled.
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * A handler that is invoked when a user clicks on the control.
     * Reserved for usage in Tabs
     */
    handleTabClick: PropTypes__default["default"].func,

    /**
     * A handler that is invoked on the key down event for the control.
     * Reserved for usage in Tabs
     */
    handleTabKeyDown: PropTypes__default["default"].func,

    /**
     * Provide a string that represents the `href` of the Tab
     */
    href: deprecate(PropTypes__default["default"].string),

    /**
     * The element ID for the top-level element.
     */
    id: PropTypes__default["default"].string,

    /**
     * The index of your Tab in your Tabs. Reserved for usage in Tabs
     */
    index: PropTypes__default["default"].number,

    /**
     * Provide the contents of your Tab
     */
    label: enabled('enable-v11-release') ? PropTypes__default["default"].node.isRequired : PropTypes__default["default"].node,

    /**
     * Provide a handler that is invoked when a user clicks on the control
     */
    onClick: PropTypes__default["default"].func.isRequired,

    /**
     * Provide a handler that is invoked on the key down event for the control
     */
    onKeyDown: PropTypes__default["default"].func.isRequired,

    /*
     * An optional parameter to allow overriding the anchor rendering.
     * Useful for using Tab along with react-router or other client
     * side router libraries.
     **/
    renderAnchor: deprecate(PropTypes__default["default"].func),
    renderButton: PropTypes__default["default"].func,

    /*
     * An optional parameter to allow overriding the content rendering.
     **/
    renderContent: PropTypes__default["default"].func,

    /**
     * Provide an accessibility role for your Tab
     */
    role: deprecate(PropTypes__default["default"].string),

    /**
     * Whether your Tab is selected.
     * Reserved for usage in Tabs
     */
    selected: PropTypes__default["default"].bool.isRequired,

    /**
     * Specify the tab index of the `<button>` node
     */
    tabIndex: PropTypes__default["default"].number
  });

  _defineProperty$2(Tab$4, "defaultProps", {
    label: enabled('enable-v11-release') ? undefined : 'provide a label',
    selected: false,
    onClick: function onClick() {},
    onKeyDown: function onKeyDown() {}
  });

  var Tab$2 = enabled('enable-v11-release') ? Tab$5 : Tab$4;
  var Tab$3 = Tab$2;

  var _excluded$_ = ["className", "selected", "children"];
  /**
   * Determine if the node within the provided ref contains content that is tabbable.
   */

  function useTabbableContent(ref) {
    var _useState = React.useState(false),
        _useState2 = _slicedToArray$1(_useState, 2),
        hasTabbableContent = _useState2[0],
        setHasTabbableContent = _useState2[1];

    useIsomorphicEffect$1(function () {
      if (ref.current) {
        setHasTabbableContent(ref.current.querySelector(selectorTabbable));
      }
    });
    return hasTabbableContent;
  }

  var TabContent = function TabContent(props) {
    var className = props.className,
        selected = props.selected,
        children = props.children,
        other = _objectWithoutProperties$2(props, _excluded$_);

    var prefix = usePrefix();
    var tabContentClasses = cx("".concat(prefix, "--tab-content"), _defineProperty$2({}, className, className));
    var ref = React.useRef(null);
    var hasTabbableContent = useTabbableContent(ref);
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      role: "tabpanel"
    }, other, {
      className: tabContentClasses,
      selected: selected,
      hidden: !selected,
      ref: ref,
      tabIndex: hasTabbableContent ? undefined : 0
    }), children);
  };

  TabContent.propTypes = {
    /**
     * Pass in content to render inside of the TabContent
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide a className for the tab content container
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the TabContent is selected
     */
    selected: PropTypes__default["default"].bool
  };
  TabContent.defaultProps = {
    selected: false
  };
  var TabContent$1 = TabContent;

  var _excluded$Z = ["className", "type", "light", "onSelectionChange", "scrollDebounceWait", "scrollIntoView", "selectionMode", "tabContentClassName", "leftOverflowButtonProps", "rightOverflowButtonProps"];

  var Tabs$2 = /*#__PURE__*/function (_React$Component) {
    _inherits(Tabs, _React$Component);

    var _super = _createSuper(Tabs);

    function Tabs() {
      var _this;

      _classCallCheck$1(this, Tabs);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty$2(_assertThisInitialized$1(_this), "state", {
        horizontalOverflow: false
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "tablist", /*#__PURE__*/React__default["default"].createRef());

      _defineProperty$2(_assertThisInitialized$1(_this), "leftOverflowNavButton", /*#__PURE__*/React__default["default"].createRef());

      _defineProperty$2(_assertThisInitialized$1(_this), "rightOverflowNavButton", /*#__PURE__*/React__default["default"].createRef());

      _defineProperty$2(_assertThisInitialized$1(_this), "OVERFLOW_BUTTON_OFFSET", 40);

      _defineProperty$2(_assertThisInitialized$1(_this), "handleScroll", function () {
        var _this$tablist;

        if (!((_this$tablist = _this.tablist) !== null && _this$tablist !== void 0 && _this$tablist.current)) {
          return;
        }

        var _this$tablist$current = _this.tablist.current,
            tablistClientWidth = _this$tablist$current.clientWidth,
            tablistScrollLeft = _this$tablist$current.scrollLeft,
            tablistScrollWidth = _this$tablist$current.scrollWidth;

        _this.setState({
          tablistClientWidth: tablistClientWidth,
          horizontalOverflow: tablistScrollWidth > tablistClientWidth,
          tablistScrollWidth: tablistScrollWidth,
          tablistScrollLeft: tablistScrollLeft
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "_debouncedHandleWindowResize", null);

      _defineProperty$2(_assertThisInitialized$1(_this), "_handleWindowResize", _this.handleScroll);

      _defineProperty$2(_assertThisInitialized$1(_this), "_debouncedHandleScroll", null);

      _defineProperty$2(_assertThisInitialized$1(_this), "_handleScroll", _this.handleScroll);

      _defineProperty$2(_assertThisInitialized$1(_this), "getEnabledTabs", function () {
        return React__default["default"].Children.toArray(_this.props.children).reduce(function (enabledTabs, tab, index) {
          return !tab.props.disabled ? enabledTabs.concat(index) : enabledTabs;
        }, []);
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "getNextIndex", function (index, direction) {
        var enabledTabs = _this.getEnabledTabs();

        var nextIndex = Math.max(enabledTabs.indexOf(index) + direction, // For `tab` not found in `enabledTabs`
        -1);
        var nextIndexLooped = nextIndex >= 0 && nextIndex < enabledTabs.length ? nextIndex : nextIndex - Math.sign(nextIndex) * enabledTabs.length;
        return enabledTabs[nextIndexLooped];
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "getDirection", function (evt) {
        if (match(evt, ArrowLeft)) {
          return -1;
        }

        if (match(evt, ArrowRight)) {
          return 1;
        }

        return 0;
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "getTabAt", function (index, useFresh) {
        return !useFresh && _this["tab".concat(index)] || React__default["default"].Children.toArray(_this.props.children)[index];
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "scrollTabIntoView", function (event, _ref) {
        var index = _ref.index;

        var tab = _this.getTabAt(index);

        if (matches(event, [ArrowLeft, ArrowRight]) || event.type === 'click') {
          var _tab$tabAnchor, _tab$tabAnchor2;

          var currentScrollLeft = _this.state.tablistScrollLeft;
          tab === null || tab === void 0 ? void 0 : (_tab$tabAnchor = tab.tabAnchor) === null || _tab$tabAnchor === void 0 ? void 0 : _tab$tabAnchor.scrollIntoView({
            block: 'nearest',
            inline: 'nearest'
          });
          tab === null || tab === void 0 ? void 0 : (_tab$tabAnchor2 = tab.tabAnchor) === null || _tab$tabAnchor2 === void 0 ? void 0 : _tab$tabAnchor2.focus();
          var newScrollLeft = _this.tablist.current.scrollLeft;

          if (newScrollLeft > currentScrollLeft) {
            _this.tablist.current.scrollLeft += _this.OVERFLOW_BUTTON_OFFSET;
          }
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "selectTabAt", function (event, _ref2) {
        var index = _ref2.index,
            onSelectionChange = _ref2.onSelectionChange;

        _this.scrollTabIntoView(event, {
          index: index
        });

        if (_this.state.selected !== index) {
          _this.setState({
            selected: index
          });

          if (typeof onSelectionChange === 'function') {
            onSelectionChange(index);
          }
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleTabKeyDown", function (onSelectionChange) {
        return function (index, evt) {
          if (matches(evt, [Enter, Space])) {
            _this.selectTabAt(evt, {
              index: index,
              onSelectionChange: onSelectionChange
            });
          }

          var nextIndex = function () {
            if (matches(evt, [ArrowLeft, ArrowRight])) {
              return _this.getNextIndex(index, _this.getDirection(evt));
            }

            if (match(evt, Home)) {
              return 0;
            }

            if (match(evt, End)) {
              return _this.getEnabledTabs().pop();
            }
          }();

          var tab = _this.getTabAt(nextIndex);

          if (matches(evt, [ArrowLeft, ArrowRight, Home, End])) {
            var _tab$tabAnchor3;

            evt.preventDefault();

            if (_this.props.selectionMode !== 'manual') {
              _this.selectTabAt(evt, {
                index: nextIndex,
                onSelectionChange: onSelectionChange
              });
            } else {
              _this.scrollTabIntoView(evt, {
                index: nextIndex
              });
            }

            tab === null || tab === void 0 ? void 0 : (_tab$tabAnchor3 = tab.tabAnchor) === null || _tab$tabAnchor3 === void 0 ? void 0 : _tab$tabAnchor3.focus();
          }
        };
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "getTabs", function () {
        return React__default["default"].Children.map(_this.props.children, function (tab) {
          return tab;
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleTabClick", function (onSelectionChange) {
        return function (index, evt) {
          evt.preventDefault();

          _this.selectTabAt(evt, {
            index: index,
            onSelectionChange: onSelectionChange
          });
        };
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "setTabAt", function (index, tabRef) {
        _this["tab".concat(index)] = tabRef;
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "overflowNavInterval", null);

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOverflowNavClick", function (_, _ref3) {
        var _this$tablist2;

        var direction = _ref3.direction,
            _ref3$multiplier = _ref3.multiplier,
            multiplier = _ref3$multiplier === void 0 ? 10 : _ref3$multiplier;

        // account for overflow button appearing and causing tablist width change
        var _this$tablist$current2 = (_this$tablist2 = _this.tablist) === null || _this$tablist2 === void 0 ? void 0 : _this$tablist2.current,
            clientWidth = _this$tablist$current2.clientWidth,
            scrollLeft = _this$tablist$current2.scrollLeft,
            scrollWidth = _this$tablist$current2.scrollWidth;

        if (direction === 1 && !scrollLeft) {
          _this.tablist.current.scrollLeft += _this.OVERFLOW_BUTTON_OFFSET;
        }

        _this.tablist.current.scrollLeft += direction * multiplier;
        var leftEdgeReached = direction === -1 && scrollLeft < _this.OVERFLOW_BUTTON_OFFSET;
        var rightEdgeReached = direction === 1 && scrollLeft + clientWidth >= scrollWidth - _this.OVERFLOW_BUTTON_OFFSET;

        if (leftEdgeReached || rightEdgeReached) {
          if (leftEdgeReached) {
            var _this$rightOverflowNa, _this$rightOverflowNa2;

            (_this$rightOverflowNa = _this.rightOverflowNavButton) === null || _this$rightOverflowNa === void 0 ? void 0 : (_this$rightOverflowNa2 = _this$rightOverflowNa.current) === null || _this$rightOverflowNa2 === void 0 ? void 0 : _this$rightOverflowNa2.focus();
          }

          if (rightEdgeReached) {
            var _this$leftOverflowNav, _this$leftOverflowNav2;

            (_this$leftOverflowNav = _this.leftOverflowNavButton) === null || _this$leftOverflowNav === void 0 ? void 0 : (_this$leftOverflowNav2 = _this$leftOverflowNav.current) === null || _this$leftOverflowNav2 === void 0 ? void 0 : _this$leftOverflowNav2.focus();
          }
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOverflowNavMouseDown", function (event, _ref4) {
        var direction = _ref4.direction;

        // disregard mouse buttons aside from left mouse button
        if (event.buttons !== 1) {
          return;
        }

        _this.overflowNavInterval = setInterval(function () {
          var _this$tablist3;

          var _this$tablist$current3 = (_this$tablist3 = _this.tablist) === null || _this$tablist3 === void 0 ? void 0 : _this$tablist3.current,
              clientWidth = _this$tablist$current3.clientWidth,
              scrollLeft = _this$tablist$current3.scrollLeft,
              scrollWidth = _this$tablist$current3.scrollWidth; // clear interval if scroll reaches left or right edge


          var leftEdgeReached = direction === -1 && scrollLeft < _this.OVERFLOW_BUTTON_OFFSET;
          var rightEdgeReached = direction === 1 && scrollLeft + clientWidth >= scrollWidth - _this.OVERFLOW_BUTTON_OFFSET;

          if (leftEdgeReached || rightEdgeReached) {
            clearInterval(_this.overflowNavInterval);
          } // account for overflow button appearing and causing tablist width change


          _this.handleOverflowNavClick(event, {
            direction: direction
          });
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOverflowNavMouseUp", function () {
        clearInterval(_this.overflowNavInterval);
      });

      return _this;
    }

    _createClass$1(Tabs, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this$tablist4;

        if (!this._debouncedHandleWindowResize) {
          this._debouncedHandleWindowResize = debounce$4(this._handleWindowResize, 200);
        }

        this._handleWindowResize();

        window.addEventListener('resize', this._debouncedHandleWindowResize);

        if (!this._debouncedHandleScroll) {
          this._debouncedHandleScroll = debounce$4(this._handleScroll, this.props.scrollDebounceWait);
        } // scroll selected tab into view on mount


        var _ref5 = ((_this$tablist4 = this.tablist) === null || _this$tablist4 === void 0 ? void 0 : _this$tablist4.current) || {},
            tablistClientWidth = _ref5.clientWidth,
            tablistScrollLeft = _ref5.scrollLeft,
            tablistScrollWidth = _ref5.scrollWidth;

        var tab = this.getTabAt(this.state.selected);
        var horizontalOverflow = tablistScrollWidth > tablistClientWidth;

        if (horizontalOverflow) {
          var _tab$tabAnchor4, _tab$tabAnchor5, _tab$tabAnchor6;

          var leftOverflowNavButtonHidden = (tab === null || tab === void 0 ? void 0 : (_tab$tabAnchor4 = tab.tabAnchor) === null || _tab$tabAnchor4 === void 0 ? void 0 : _tab$tabAnchor4.getBoundingClientRect().right) < (tab === null || tab === void 0 ? void 0 : (_tab$tabAnchor5 = tab.tabAnchor) === null || _tab$tabAnchor5 === void 0 ? void 0 : _tab$tabAnchor5.offsetParent.getBoundingClientRect().right);
          var rightOverflowNavButtonHidden = tablistScrollLeft + tablistClientWidth === tablistScrollWidth;
          this.props.scrollIntoView && (tab === null || tab === void 0 ? void 0 : (_tab$tabAnchor6 = tab.tabAnchor) === null || _tab$tabAnchor6 === void 0 ? void 0 : _tab$tabAnchor6.scrollIntoView({
            block: 'nearest',
            inline: 'nearest'
          })); // account for overflow buttons in scroll position on mount

          if (!leftOverflowNavButtonHidden && !rightOverflowNavButtonHidden) {
            this.tablist.current.scrollLeft += this.OVERFLOW_BUTTON_OFFSET * 2;
          }
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._debouncedHandleWindowResize) {
          this._debouncedHandleWindowResize.cancel();
        }

        window.removeEventListener('resize', this._debouncedHandleWindowResize);
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(_, prevState) {
        // compare current tablist properties to current state
        var _this$tablist$current4 = this.tablist.current,
            tablistClientWidth = _this$tablist$current4.clientWidth,
            tablistScrollLeft = _this$tablist$current4.scrollLeft,
            tablistScrollWidth = _this$tablist$current4.scrollWidth;
        var _this$state = this.state,
            currentStateClientWidth = _this$state.tablistClientWidth,
            currentStateScrollLeft = _this$state.tablistScrollLeft,
            currentStateScrollWidth = _this$state.tablistScrollWidth,
            selected = _this$state.selected;

        if (tablistClientWidth !== currentStateClientWidth || tablistScrollLeft !== currentStateScrollLeft || tablistScrollWidth !== currentStateScrollWidth) {
          this.setState({
            horizontalOverflow: tablistScrollWidth > tablistClientWidth,
            tablistClientWidth: tablistClientWidth,
            tablistScrollLeft: tablistScrollLeft,
            tablistScrollWidth: tablistScrollWidth
          });
        }

        if (this.props.scrollIntoView && prevState.selected !== selected) {
          var _this$getTabAt, _this$getTabAt$tabAnc;

          (_this$getTabAt = this.getTabAt(selected)) === null || _this$getTabAt === void 0 ? void 0 : (_this$getTabAt$tabAnc = _this$getTabAt.tabAnchor) === null || _this$getTabAt$tabAnc === void 0 ? void 0 : _this$getTabAt$tabAnc.scrollIntoView({
            block: 'nearest',
            inline: 'nearest'
          });
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this,
            _classNames,
            _classNames2,
            _classNames3;

        var _this$props = this.props,
            className = _this$props.className,
            type = _this$props.type,
            light = _this$props.light,
            onSelectionChange = _this$props.onSelectionChange;
            _this$props.scrollDebounceWait;
            _this$props.scrollIntoView;
            _this$props.selectionMode;
            var tabContentClassName = _this$props.tabContentClassName,
            leftOverflowButtonProps = _this$props.leftOverflowButtonProps,
            rightOverflowButtonProps = _this$props.rightOverflowButtonProps,
            other = _objectWithoutProperties$2(_this$props, _excluded$Z);

        var prefix = this.context;
        /**
         * The tab panel acts like a tab panel when the screen is wider, but acts
         * like a select list when the screen is narrow.  In the wide case we want
         * to allow the user to use the tab key to set the focus in the tab panel
         * and then use the left and right arrow keys to navigate the tabs.  In the
         * narrow case we want to use the tab key to select different options in
         * the list.
         *
         * We set the tab index based on the different states so the browser will treat
         * the whole tab panel as a single focus component when it looks like a tab
         * panel and separate components when it looks like a select list.
         */

        var tabsWithProps = this.getTabs().map(function (tab, index) {
          var tabIndex = index === _this2.state.selected ? 0 : -1;
          var newTab = /*#__PURE__*/React__default["default"].cloneElement(tab, {
            index: index,
            selected: index === _this2.state.selected,
            handleTabClick: _this2.handleTabClick(onSelectionChange),
            tabIndex: tabIndex,
            ref: function ref(e) {
              _this2.setTabAt(index, e);
            },
            handleTabKeyDown: _this2.handleTabKeyDown(onSelectionChange)
          });
          return newTab;
        });
        var tabContentWithProps = React__default["default"].Children.map(tabsWithProps, function (tab) {
          var _tab$props = tab.props,
              tabId = _tab$props.id,
              children = _tab$props.children,
              selected = _tab$props.selected,
              _tab$props$renderCont = _tab$props.renderContent,
              Content = _tab$props$renderCont === void 0 ? TabContent$1 : _tab$props$renderCont;
          return /*#__PURE__*/React__default["default"].createElement(Content, {
            id: tabId && "".concat(tabId, "__panel"),
            className: tabContentClassName,
            hidden: !selected,
            selected: selected,
            "aria-labelledby": tabId
          }, children);
        });
        var leftOverflowNavButtonHidden = !this.state.horizontalOverflow || !this.state.tablistScrollLeft;
        var rightOverflowNavButtonHidden = !this.state.horizontalOverflow || this.state.tablistScrollLeft + this.state.tablistClientWidth === this.state.tablistScrollWidth;
        var classes = {
          // TODO: remove scrollable from classnames in next major release and uncomment classnames that don't contain scrollable
          tabs: cx(className, // `${prefix}--tabs`,
          "".concat(prefix, "--tabs--scrollable"), (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--tabs--scrollable--container"), type === 'container'), _defineProperty$2(_classNames, "".concat(prefix, "--tabs--scrollable--light"), light), _classNames)),
          // TODO: remove scrollable from classnames in next major release and uncomment classnames that don't contain scrollable
          tablist: cx( // `${prefix}--tabs__nav`,
          "".concat(prefix, "--tabs--scrollable__nav")),
          leftOverflowButtonClasses: cx((_classNames2 = {}, _defineProperty$2(_classNames2, "".concat(prefix, "--tab--overflow-nav-button"), this.state.horizontalOverflow), _defineProperty$2(_classNames2, "".concat(prefix, "--tab--overflow-nav-button--hidden"), leftOverflowNavButtonHidden), _classNames2)),
          rightOverflowButtonClasses: cx((_classNames3 = {}, _defineProperty$2(_classNames3, "".concat(prefix, "--tab--overflow-nav-button"), this.state.horizontalOverflow), _defineProperty$2(_classNames3, "".concat(prefix, "--tab--overflow-nav-button--hidden"), rightOverflowNavButtonHidden), _classNames3))
        };
        return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("div", _extends$3({}, other, {
          className: classes.tabs
        }), /*#__PURE__*/React__default["default"].createElement("button", _extends$3({
          "aria-hidden": "true",
          "aria-label": "Scroll left",
          className: classes.leftOverflowButtonClasses,
          onClick: function onClick(_) {
            return _this2.handleOverflowNavClick(_, {
              direction: -1
            });
          },
          onMouseDown: function onMouseDown(event) {
            return _this2.handleOverflowNavMouseDown(event, {
              direction: -1
            });
          },
          onMouseUp: this.handleOverflowNavMouseUp,
          ref: this.leftOverflowNavButton,
          tabIndex: "-1",
          type: "button"
        }, leftOverflowButtonProps), /*#__PURE__*/React__default["default"].createElement(ChevronLeft16, null)), !leftOverflowNavButtonHidden && /*#__PURE__*/React__default["default"].createElement("div", {
          className: "".concat(prefix, "--tabs__overflow-indicator--left")
        }), /*#__PURE__*/React__default["default"].createElement("ul", {
          role: "tablist",
          tabIndex: -1,
          className: classes.tablist,
          ref: this.tablist,
          onScroll: this._debouncedHandleScroll
        }, tabsWithProps), !rightOverflowNavButtonHidden && /*#__PURE__*/React__default["default"].createElement("div", {
          className: "".concat(prefix, "--tabs__overflow-indicator--right")
        }), /*#__PURE__*/React__default["default"].createElement("button", _extends$3({
          "aria-hidden": "true",
          "aria-label": "Scroll right",
          className: classes.rightOverflowButtonClasses,
          onClick: function onClick(_) {
            return _this2.handleOverflowNavClick(_, {
              direction: 1
            });
          },
          onMouseDown: function onMouseDown(event) {
            return _this2.handleOverflowNavMouseDown(event, {
              direction: 1
            });
          },
          onMouseUp: this.handleOverflowNavMouseUp,
          ref: this.rightOverflowNavButton,
          tabIndex: "-1",
          type: "button"
        }, rightOverflowButtonProps), /*#__PURE__*/React__default["default"].createElement(ChevronRight16, null))), tabContentWithProps);
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref6, state) {
        var selected = _ref6.selected;
        var prevSelected = state.prevSelected;
        return prevSelected === selected ? null : {
          selected: selected,
          prevSelected: selected
        };
      }
      /**
       * `scroll` event handler to save tablist clientWidth, scrollWidth, and
       * scrollLeft
       */

    }]);

    return Tabs;
  }(React__default["default"].Component);

  _defineProperty$2(Tabs$2, "propTypes", {
    /**
     * Pass in a collection of <Tab> children to be rendered depending on the
     * currently selected tab
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide a className that is applied to the root <div> component for the
     * <Tabs>
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the Tab content is hidden
     */
    hidden: PropTypes__default["default"].bool,

    /**
     * Provide the props that describe the left overflow button
     */
    leftOverflowButtonProps: PropTypes__default["default"].object,

    /**
     * Specify whether or not to use the light component variant
     */
    light: PropTypes__default["default"].bool,

    /**
     * Optionally provide an `onClick` handler that is invoked when a <Tab> is
     * clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Optionally provide an `onKeyDown` handler that is invoked when keyed
     * navigation is triggered
     */
    onKeyDown: PropTypes__default["default"].func,

    /**
     * Provide an optional handler that is called whenever the selection
     * changes. This method is called with the index of the tab that was
     * selected
     */
    onSelectionChange: PropTypes__default["default"].func,

    /**
     * Provide the props that describe the right overflow button
     */
    rightOverflowButtonProps: PropTypes__default["default"].object,

    /**
     * Optionally provide a delay (in milliseconds) passed to the lodash
     * debounce of the onScroll handler. This will impact the responsiveness
     * of scroll arrow buttons rendering when scrolling to the first or last tab.
     */
    scrollDebounceWait: PropTypes__default["default"].number,

    /**
     * Choose whether or not to automatically scroll to newly selected tabs
     * on component rerender
     */
    scrollIntoView: PropTypes__default["default"].bool,

    /**
     * Optionally provide an index for the currently selected <Tab>
     */
    selected: PropTypes__default["default"].number,

    /**
     * Choose whether or not to automatically change selection on focus
     */
    selectionMode: PropTypes__default["default"].oneOf(['automatic', 'manual']),

    /**
     * Provide a className that is applied to the <TabContent> components
     */
    tabContentClassName: PropTypes__default["default"].string,

    /**
     * Provide the type of Tab
     */
    type: PropTypes__default["default"].oneOf(['default', 'container'])
  });

  _defineProperty$2(Tabs$2, "defaultProps", {
    type: 'default',
    scrollIntoView: true,
    selected: 0,
    selectionMode: 'automatic',
    scrollDebounceWait: 150
  });

  _defineProperty$2(Tabs$2, "contextType", PrefixContext);

  var _excluded$Y = ["className", "type"];

  function Tab$1() {
    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("li", {
      className: "".concat(prefix, "--tabs--scrollable__nav-item")
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--tabs__nav-link")
    }, /*#__PURE__*/React__default["default"].createElement("span", null)));
  }

  function TabsSkeleton$1(_ref) {
    var className = _ref.className,
        type = _ref.type,
        rest = _objectWithoutProperties$2(_ref, _excluded$Y);

    var prefix = usePrefix();
    var tabClasses = cx(className, "".concat(prefix, "--tabs"), "".concat(prefix, "--skeleton"), "".concat(prefix, "--tabs--scrollable"), _defineProperty$2({}, "".concat(prefix, "--tabs--scrollable--container"), type === 'container'));
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: tabClasses
    }, rest), /*#__PURE__*/React__default["default"].createElement("ul", {
      className: "".concat(prefix, "--tabs--scrollable__nav")
    }, Tab$1(), Tab$1(), Tab$1(), Tab$1(), Tab$1()));
  }

  TabsSkeleton$1.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes__default["default"].string,

    /**
     * Provide the type of Tab
     */
    type: PropTypes__default["default"].oneOf(['', 'default', 'container'])
  };

  var _excluded$X = ["className", "contained"];

  function Tab() {
    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("li", {
      className: "".concat(prefix, "--tabs__nav-item")
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--tabs__nav-link")
    }, /*#__PURE__*/React__default["default"].createElement("span", null)));
  }

  function TabsSkeleton(_ref) {
    var className = _ref.className,
        contained = _ref.contained,
        rest = _objectWithoutProperties$2(_ref, _excluded$X);

    var prefix = usePrefix();
    var tabClasses = cx(className, "".concat(prefix, "--tabs"), "".concat(prefix, "--skeleton"), _defineProperty$2({}, "".concat(prefix, "--tabs--contained"), contained));
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: tabClasses
    }, rest), /*#__PURE__*/React__default["default"].createElement("ul", {
      className: "".concat(prefix, "--tabs__nav")
    }, Tab(), Tab(), Tab(), Tab(), Tab()));
  }

  TabsSkeleton.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes__default["default"].string,

    /**
     * Provide the type of Tab
     */
    contained: PropTypes__default["default"].bool
  };

  var Tabs = enabled('enable-v11-release') ? Tabs$3 : Tabs$2;
  enabled('enable-v11-release') ? TabsSkeleton : TabsSkeleton$1;
  var Tabs$1 = Tabs;

  var _excluded$W = ["className", "size"];

  function TagSkeleton(_ref) {
    var className = _ref.className,
        size = _ref.size,
        rest = _objectWithoutProperties$2(_ref, _excluded$W);

    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("span", _extends$3({
      className: cx("".concat(prefix, "--tag"), "".concat(prefix, "--skeleton"), className, _defineProperty$2({}, "".concat(prefix, "--tag--").concat(size), size))
    }, rest));
  }

  TagSkeleton.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the size of the Tag. Currently supports either `sm` or
     * default sizes.
     */
    size: PropTypes__default["default"].oneOf(['sm'])
  };

  var _excluded$V = ["children", "className", "id", "type", "filter", "renderIcon", "title", "disabled", "onClose", "size"];
  var getInstanceId$5 = setupGetInstanceId$2();
  var TYPES = {
    red: 'Red',
    magenta: 'Magenta',
    purple: 'Purple',
    blue: 'Blue',
    cyan: 'Cyan',
    teal: 'Teal',
    green: 'Green',
    gray: 'Gray',
    'cool-gray': 'Cool-Gray',
    'warm-gray': 'Warm-Gray',
    'high-contrast': 'High-Contrast',
    outline: 'Outline'
  };

  var Tag = function Tag(_ref) {
    var _classNames;

    var children = _ref.children,
        className = _ref.className,
        id = _ref.id,
        type = _ref.type,
        filter = _ref.filter,
        CustomIconElement = _ref.renderIcon,
        title = _ref.title,
        disabled = _ref.disabled,
        onClose = _ref.onClose,
        size = _ref.size,
        other = _objectWithoutProperties$2(_ref, _excluded$V);

    var prefix = usePrefix();
    var tagId = id || "tag-".concat(getInstanceId$5());
    var tagClasses = cx("".concat(prefix, "--tag"), className, (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--tag--disabled"), disabled), _defineProperty$2(_classNames, "".concat(prefix, "--tag--filter"), filter), _defineProperty$2(_classNames, "".concat(prefix, "--tag--").concat(size), size), _defineProperty$2(_classNames, "".concat(prefix, "--tag--").concat(type), type), _defineProperty$2(_classNames, "".concat(prefix, "--tag--interactive"), other.onClick && !filter), _classNames));

    var handleClose = function handleClose(event) {
      if (onClose) {
        event.stopPropagation();
        onClose(event);
      }
    };

    if (filter) {
      return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
        className: tagClasses,
        id: tagId
      }, other), /*#__PURE__*/React__default["default"].createElement("span", {
        className: "".concat(prefix, "--tag__label"),
        title: typeof children === 'string' ? children : null
      }, children !== null && children !== undefined ? children : TYPES[type]), /*#__PURE__*/React__default["default"].createElement("button", {
        type: "button",
        className: "".concat(prefix, "--tag__close-icon"),
        onClick: handleClose,
        disabled: disabled,
        "aria-labelledby": tagId,
        title: title
      }, /*#__PURE__*/React__default["default"].createElement(Close16, null)));
    }

    var ComponentTag = other.onClick ? 'button' : 'div';
    return /*#__PURE__*/React__default["default"].createElement(ComponentTag, _extends$3({
      disabled: ComponentTag === 'button' ? disabled : null,
      className: tagClasses,
      id: tagId
    }, other), CustomIconElement ? /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--tag__custom-icon")
    }, /*#__PURE__*/React__default["default"].createElement(CustomIconElement, null)) : '', /*#__PURE__*/React__default["default"].createElement("span", {
      title: typeof children === 'string' ? children : null
    }, children !== null && children !== undefined ? children : TYPES[type]));
  };

  Tag.propTypes = {
    /**
     * Provide content to be rendered inside of a <Tag>
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide a custom className that is applied to the containing <span>
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify if the <Tag> is disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Determine if <Tag> is a filter/chip
     */
    filter: PropTypes__default["default"].bool,

    /**
     * Specify the id for the tag.
     */
    id: PropTypes__default["default"].string,

    /**
     * Click handler for filter tag close button.
     */
    onClose: PropTypes__default["default"].func,

    /**
     * Optional prop to render a custom icon.
     * Can be a React component class
     */
    renderIcon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),

    /**
     * Specify the size of the Tag. Currently supports either `sm` or
     * 'md' (default) sizes.
     */
    size: PropTypes__default["default"].oneOf(['sm', 'md']),

    /**
     * Text to show on clear filters
     */
    title: PropTypes__default["default"].string,

    /**
     * Specify the type of the <Tag>
     */
    type: PropTypes__default["default"].oneOf(Object.keys(TYPES))
  };
  var Tag$1 = Tag;

  var _excluded$U = ["hideLabel", "className"];

  var TextAreaSkeleton = function TextAreaSkeleton(_ref) {
    var hideLabel = _ref.hideLabel,
        className = _ref.className,
        rest = _objectWithoutProperties$2(_ref, _excluded$U);

    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: cx("".concat(prefix, "--form-item"), className)
    }, rest), !hideLabel && /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--label ").concat(prefix, "--skeleton")
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--skeleton ").concat(prefix, "--text-area")
    }));
  };

  TextAreaSkeleton.propTypes = {
    /**
     * Specify an optional className to add to the form item wrapper.
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the label should be hidden, or not
     */
    hideLabel: PropTypes__default["default"].bool
  };
  var TextAreaSkeleton$1 = TextAreaSkeleton;

  var _excluded$T = ["className", "id", "labelText", "hideLabel", "onChange", "onClick", "invalid", "invalidText", "helperText", "light", "placeholder", "enableCounter", "maxCount"];
  var getInstanceId$4 = setupGetInstanceId$2();
  var TextArea = /*#__PURE__*/React__default["default"].forwardRef(function TextArea(_ref, ref) {
    var _classNames, _classNames4;

    var className = _ref.className,
        id = _ref.id,
        labelText = _ref.labelText,
        hideLabel = _ref.hideLabel,
        _onChange = _ref.onChange,
        _onClick = _ref.onClick,
        invalid = _ref.invalid,
        invalidText = _ref.invalidText,
        helperText = _ref.helperText,
        light = _ref.light,
        placeholder = _ref.placeholder,
        enableCounter = _ref.enableCounter,
        maxCount = _ref.maxCount,
        other = _objectWithoutProperties$2(_ref, _excluded$T);

    var prefix = usePrefix();
    var enabled = useFeatureFlag('enable-v11-release');
    var defaultValue = other.defaultValue,
        value = other.value,
        disabled = other.disabled;

    var _useState = React.useState((defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.length) || (value === null || value === void 0 ? void 0 : value.length) || 0),
        _useState2 = _slicedToArray$1(_useState, 2),
        textCount = _useState2[0],
        setTextCount = _useState2[1];

    var _useRef = React.useRef(getInstanceId$4()),
        textAreaInstanceId = _useRef.current;

    var textareaProps = {
      id: id,
      onChange: function onChange(evt) {
        if (!other.disabled) {
          var _evt$target$value;

          setTextCount((_evt$target$value = evt.target.value) === null || _evt$target$value === void 0 ? void 0 : _evt$target$value.length);

          _onChange(evt);
        }
      },
      onClick: function onClick(evt) {
        if (!other.disabled) {
          _onClick(evt);
        }
      },
      ref: ref
    };

    if (enableCounter) {
      textareaProps.maxLength = maxCount;
    }

    var labelClasses = cx("".concat(prefix, "--label"), (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--visually-hidden"), hideLabel), _defineProperty$2(_classNames, "".concat(prefix, "--label--disabled"), disabled), _classNames));
    var label = labelText ? /*#__PURE__*/React__default["default"].createElement("label", {
      htmlFor: id,
      className: labelClasses
    }, labelText) : null;
    var counterClasses = cx("".concat(prefix, "--label"), _defineProperty$2({}, "".concat(prefix, "--label--disabled"), disabled));
    var counter = enableCounter && maxCount ? /*#__PURE__*/React__default["default"].createElement("div", {
      className: counterClasses
    }, "".concat(textCount, "/").concat(maxCount)) : null;
    var helperTextClasses = cx("".concat(prefix, "--form__helper-text"), _defineProperty$2({}, "".concat(prefix, "--form__helper-text--disabled"), other.disabled));
    var helperId = !helperText ? undefined : "text-area-helper-text-".concat(textAreaInstanceId);
    var helper = helperText ? /*#__PURE__*/React__default["default"].createElement("div", {
      id: helperId,
      className: helperTextClasses
    }, helperText) : null;
    var errorId = id + '-error-msg';
    var error = invalid ? /*#__PURE__*/React__default["default"].createElement("div", {
      role: "alert",
      className: "".concat(prefix, "--form-requirement"),
      id: errorId
    }, invalidText) : null;
    var textareaClasses = cx("".concat(prefix, "--text-area"), [enabled ? null : className], (_classNames4 = {}, _defineProperty$2(_classNames4, "".concat(prefix, "--text-area--light"), light), _defineProperty$2(_classNames4, "".concat(prefix, "--text-area--invalid"), invalid), _classNames4));
    var ariaDescribedBy;

    if (invalid) {
      ariaDescribedBy = errorId;
    } else if (!invalid && helperText) {
      ariaDescribedBy = helperId;
    }

    var input = /*#__PURE__*/React__default["default"].createElement("textarea", _extends$3({}, other, textareaProps, {
      placeholder: placeholder || null,
      className: textareaClasses,
      "aria-invalid": invalid || null,
      "aria-describedby": ariaDescribedBy,
      disabled: other.disabled
    }));
    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: enabled ? cx("".concat(prefix, "--form-item"), className) : "".concat(prefix, "--form-item")
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--text-area__label-wrapper")
    }, label, counter), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--text-area__wrapper"),
      "data-invalid": invalid || null
    }, invalid && /*#__PURE__*/React__default["default"].createElement(WarningFilled16, {
      className: "".concat(prefix, "--text-area__invalid-icon")
    }), input), invalid ? error : helper);
  });
  TextArea.displayName = 'TextArea';
  TextArea.propTypes = {
    /**
     * Provide a custom className that is applied directly to the underlying
     * `<textarea>` node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the `cols` attribute for the underlying `<textarea>` node
     */
    cols: PropTypes__default["default"].number,

    /**
     * Optionally provide the default value of the `<textarea>`
     */
    defaultValue: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),

    /**
     * Specify whether the control is disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Specify whether to display the character counter
     */
    enableCounter: PropTypes__default["default"].bool,

    /**
     * Provide text that is used alongside the control label for additional help
     */
    helperText: PropTypes__default["default"].node,

    /**
     * Specify whether you want the underlying label to be visually hidden
     */
    hideLabel: PropTypes__default["default"].bool,

    /**
     * Provide a unique identifier for the control
     */
    id: PropTypes__default["default"].string,

    /**
     * Specify whether the control is currently invalid
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * Provide the text that is displayed when the control is in an invalid state
     */
    invalidText: PropTypes__default["default"].node,

    /**
     * Provide the text that will be read by a screen reader when visiting this
     * control
     */
    labelText: PropTypes__default["default"].node.isRequired,

    /**
     * `true` to use the light version. For use on $ui-01 backgrounds only.
     * Don't use this to make tile background color same as container background color.
     */
    light: PropTypes__default["default"].bool,

    /**
     * Max character count allowed for the textarea. This is needed in order for enableCounter to display
     */
    maxCount: PropTypes__default["default"].number,

    /**
     * Optionally provide an `onChange` handler that is called whenever `<textarea>`
     * is updated
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Optionally provide an `onClick` handler that is called whenever the
     * `<textarea>` is clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Specify the placeholder attribute for the `<textarea>`
     */
    placeholder: PropTypes__default["default"].string,

    /**
     * Specify the rows attribute for the `<textarea>`
     */
    rows: PropTypes__default["default"].number,

    /**
     * Provide the current value of the `<textarea>`
     */
    value: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number])
  };
  TextArea.defaultProps = {
    disabled: false,
    onChange: function onChange() {},
    onClick: function onClick() {},
    placeholder: '',
    rows: 4,
    cols: 50,
    invalid: false,
    invalidText: '',
    helperText: '',
    light: false,
    enableCounter: false,
    maxCount: undefined
  };
  var TextArea$1 = TextArea;

  var _excluded$S = ["className", "disabled", "helperText", "hideLabel", "id", "inline", "invalid", "invalidText", "labelText", "light", "onChange", "onClick", "placeholder", "readOnly", "size", "type", "warn", "warnText"];
  var TextInput = /*#__PURE__*/React__default["default"].forwardRef(function TextInput(_ref, ref) {
    var _classNames, _classNames2, _classNames3, _classNames4, _classNames7;

    var className = _ref.className,
        _ref$disabled = _ref.disabled,
        disabled = _ref$disabled === void 0 ? false : _ref$disabled,
        helperText = _ref.helperText,
        hideLabel = _ref.hideLabel,
        id = _ref.id,
        _ref$inline = _ref.inline,
        inline = _ref$inline === void 0 ? false : _ref$inline,
        _ref$invalid = _ref.invalid,
        invalid = _ref$invalid === void 0 ? false : _ref$invalid,
        invalidText = _ref.invalidText,
        labelText = _ref.labelText,
        _ref$light = _ref.light,
        light = _ref$light === void 0 ? false : _ref$light,
        _ref$onChange = _ref.onChange,
        _onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
        _ref$onClick = _ref.onClick,
        _onClick = _ref$onClick === void 0 ? function () {} : _ref$onClick,
        placeholder = _ref.placeholder,
        readOnly = _ref.readOnly,
        _ref$size = _ref.size,
        size = _ref$size === void 0 ? 'md' : _ref$size,
        _ref$type = _ref.type,
        type = _ref$type === void 0 ? 'text' : _ref$type,
        _ref$warn = _ref.warn,
        warn = _ref$warn === void 0 ? false : _ref$warn,
        warnText = _ref.warnText,
        rest = _objectWithoutProperties$2(_ref, _excluded$S);

    var prefix = usePrefix();
    var enabled = useFeatureFlag('enable-v11-release');
    var normalizedProps = useNormalizedInputProps({
      id: id,
      readOnly: readOnly,
      disabled: disabled,
      invalid: invalid,
      invalidText: invalidText,
      warn: warn,
      warnText: warnText
    });
    var customClassName = className !== null && className !== void 0 ? className : "".concat(prefix, "--text__input");
    var textInputClasses = cx("".concat(prefix, "--text-input"), [enabled ? null : className], (_classNames = {}, _defineProperty$2(_classNames, customClassName, enabled), _defineProperty$2(_classNames, "".concat(prefix, "--text-input--light"), light), _defineProperty$2(_classNames, "".concat(prefix, "--text-input--invalid"), normalizedProps.invalid), _defineProperty$2(_classNames, "".concat(prefix, "--text-input--warning"), normalizedProps.warn), _defineProperty$2(_classNames, "".concat(prefix, "--text-input--").concat(size), size), _classNames));

    var sharedTextInputProps = _objectSpread2$2(_defineProperty$2({
      id: id,
      onChange: function onChange(evt) {
        if (!normalizedProps.disabled) {
          _onChange(evt);
        }
      },
      onClick: function onClick(evt) {
        if (!normalizedProps.disabled) {
          _onClick(evt);
        }
      },
      placeholder: placeholder,
      type: type,
      ref: ref,
      className: textInputClasses,
      title: placeholder,
      disabled: normalizedProps.disabled,
      readOnly: readOnly
    }, 'aria-describedby', helperText && normalizedProps.helperId), rest);

    var inputWrapperClasses = cx([enabled ? cx("".concat(prefix, "--form-item"), className) : "".concat(prefix, "--form-item")], "".concat(prefix, "--text-input-wrapper"), (_classNames2 = {}, _defineProperty$2(_classNames2, "".concat(prefix, "--text-input-wrapper--readonly"), readOnly), _defineProperty$2(_classNames2, "".concat(prefix, "--text-input-wrapper--light"), light), _defineProperty$2(_classNames2, "".concat(prefix, "--text-input-wrapper--inline"), inline), _classNames2));
    var labelClasses = cx("".concat(prefix, "--label"), (_classNames3 = {}, _defineProperty$2(_classNames3, "".concat(prefix, "--visually-hidden"), hideLabel), _defineProperty$2(_classNames3, "".concat(prefix, "--label--disabled"), normalizedProps.disabled), _defineProperty$2(_classNames3, "".concat(prefix, "--label--inline"), inline), _defineProperty$2(_classNames3, "".concat(prefix, "--label--inline--").concat(size), inline && !!size), _classNames3));
    var helperTextClasses = cx("".concat(prefix, "--form__helper-text"), (_classNames4 = {}, _defineProperty$2(_classNames4, "".concat(prefix, "--form__helper-text--disabled"), normalizedProps.disabled), _defineProperty$2(_classNames4, "".concat(prefix, "--form__helper-text--inline"), inline), _classNames4));
    var fieldOuterWrapperClasses = cx("".concat(prefix, "--text-input__field-outer-wrapper"), _defineProperty$2({}, "".concat(prefix, "--text-input__field-outer-wrapper--inline"), inline));
    var fieldWrapperClasses = cx("".concat(prefix, "--text-input__field-wrapper"), _defineProperty$2({}, "".concat(prefix, "--text-input__field-wrapper--warning"), normalizedProps.warn));
    var iconClasses = cx((_classNames7 = {}, _defineProperty$2(_classNames7, "".concat(prefix, "--text-input__invalid-icon"), normalizedProps.invalid || normalizedProps.warn), _defineProperty$2(_classNames7, "".concat(prefix, "--text-input__invalid-icon--warning"), normalizedProps.warn), _defineProperty$2(_classNames7, "".concat(prefix, "--text-input__readonly-icon"), readOnly), _classNames7));
    var label = labelText ? /*#__PURE__*/React__default["default"].createElement("label", {
      htmlFor: id,
      className: labelClasses
    }, labelText) : null;
    var helper = helperText ? /*#__PURE__*/React__default["default"].createElement("div", {
      id: normalizedProps.helperId,
      className: helperTextClasses
    }, helperText) : null;
    var input = /*#__PURE__*/React__default["default"].createElement("input", textInputProps({
      sharedTextInputProps: sharedTextInputProps,
      invalid: normalizedProps.invalid,
      invalidId: normalizedProps.invalidId,
      warn: normalizedProps.warn,
      warnId: normalizedProps.warnId
    }));

    var _useContext = React.useContext(FormContext),
        isFluid = _useContext.isFluid;

    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: inputWrapperClasses
    }, !inline ? label : /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--text-input__label-helper-wrapper")
    }, label, !isFluid && helper), /*#__PURE__*/React__default["default"].createElement("div", {
      className: fieldOuterWrapperClasses
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: fieldWrapperClasses,
      "data-invalid": normalizedProps.invalid || null
    }, normalizedProps.icon && /*#__PURE__*/React__default["default"].createElement(normalizedProps.icon, {
      className: iconClasses
    }), input, isFluid && /*#__PURE__*/React__default["default"].createElement("hr", {
      className: "".concat(prefix, "--text-input__divider")
    }), isFluid && !inline && normalizedProps.validation), !isFluid && !inline && (normalizedProps.validation || helper)));
  });
  TextInput.displayName = 'TextInput';
  TextInput.PasswordInput = PasswordInput$1;
  TextInput.ControlledPasswordInput = ControlledPasswordInput$1;
  TextInput.propTypes = {
    /**
     * Specify an optional className to be applied to the `<input>` node
     */
    className: PropTypes__default["default"].string,

    /**
     * Optionally provide the default value of the `<input>`
     */
    defaultValue: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),

    /**
     * Specify whether the `<input>` should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Provide text that is used alongside the control label for additional help
     */
    helperText: PropTypes__default["default"].node,

    /**
     * Specify whether you want the underlying label to be visually hidden
     */
    hideLabel: PropTypes__default["default"].bool,

    /**
     * Specify a custom `id` for the `<input>`
     */
    id: PropTypes__default["default"].string.isRequired,

    /**
     * `true` to use the inline version.
     */
    inline: PropTypes__default["default"].bool,

    /**
     * Specify whether the control is currently invalid
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * Provide the text that is displayed when the control is in an invalid state
     */
    invalidText: PropTypes__default["default"].node,

    /**
     * Provide the text that will be read by a screen reader when visiting this
     * control
     */
    labelText: PropTypes__default["default"].node.isRequired,

    /**
     * `true` to use the light version. For use on $ui-01 backgrounds only.
     * Don't use this to make tile background color same as container background color.
     */
    light: PropTypes__default["default"].bool,

    /**
     * Optionally provide an `onChange` handler that is called whenever `<input>`
     * is updated
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Optionally provide an `onClick` handler that is called whenever the
     * `<input>` is clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Specify the placeholder attribute for the `<input>`
     */
    placeholder: PropTypes__default["default"].string,

    /**
     * Whether the input should be read-only
     */
    readOnly: PropTypes__default["default"].bool,

    /**
     * Specify the size of the Text Input. Currently supports the following:
     */
    size: enabled('enable-v11-release') ? PropTypes__default["default"].oneOf(['sm', 'md', 'lg']) : PropTypes__default["default"].oneOf(['sm', 'md', 'lg', 'xl']),

    /**
     * Specify the type of the `<input>`
     */
    type: PropTypes__default["default"].string,

    /**
     * Specify the value of the `<input>`
     */
    value: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),

    /**
     * Specify whether the control is currently in warning state
     */
    warn: PropTypes__default["default"].bool,

    /**
     * Provide the text that is displayed when the control is in warning state
     */
    warnText: PropTypes__default["default"].node
  };
  var TextInput$1 = TextInput;

  var _excluded$R = ["hideLabel", "className"];

  var TextInputSkeleton = function TextInputSkeleton(_ref) {
    var hideLabel = _ref.hideLabel,
        className = _ref.className,
        rest = _objectWithoutProperties$2(_ref, _excluded$R);

    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: cx("".concat(prefix, "--form-item"), className)
    }, rest), !hideLabel && /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--label ").concat(prefix, "--skeleton")
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--skeleton ").concat(prefix, "--text-input")
    }));
  };

  TextInputSkeleton.propTypes = {
    /**
     * Specify an optional className to add to the form item wrapper.
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the label should be hidden, or not
     */
    hideLabel: PropTypes__default["default"].bool
  };
  var TextInputSkeleton$1 = TextInputSkeleton;

  TextInput$1.ControlledPasswordInput = ControlledPasswordInput$1;
  TextInput$1.PasswordInput = PasswordInput$1;

  {
    deprecateFieldOnObject(TextInput$1, 'ControlledPasswordInput', ControlledPasswordInput$1);
    deprecateFieldOnObject(TextInput$1, 'PasswordInput', PasswordInput$1);
  }

  var _excluded$Q = ["children", "className", "light"],
      _excluded2$1 = ["children", "className", "clicked", "handleClick", "handleKeyDown", "href", "light", "onClick", "onKeyDown"],
      _excluded3$1 = ["children", "className", "disabled", "handleClick", "handleKeyDown", "iconDescription", "id", "light", "name", "onClick", "onChange", "onKeyDown", "selected", "tabIndex", "title", "value"],
      _excluded4$1 = ["tabIndex", "className", "children", "expanded", "tileMaxHeight", "tilePadding", "onClick", "onKeyUp", "tileCollapsedIconText", "tileExpandedIconText", "tileCollapsedLabel", "tileExpandedLabel", "onBeforeClick", "light"];
  var Tile$2 = /*#__PURE__*/React__default["default"].forwardRef(function Tile(_ref, ref) {
    var children = _ref.children,
        className = _ref.className,
        _ref$light = _ref.light,
        light = _ref$light === void 0 ? false : _ref$light,
        rest = _objectWithoutProperties$2(_ref, _excluded$Q);

    var prefix = usePrefix();
    var tileClasses = cx("".concat(prefix, "--tile"), _defineProperty$2({}, "".concat(prefix, "--tile--light"), light), className);
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: tileClasses,
      ref: ref
    }, rest), children);
  });
  Tile$2.displayName = 'Tile';
  Tile$2.propTypes = {
    /**
     * The child nodes.
     */
    children: PropTypes__default["default"].node,

    /**
     * The CSS class names.
     */
    className: PropTypes__default["default"].string,

    /**
     * `true` to use the light version. For use on $ui-01 backgrounds only.
     * Don't use this to make tile background color same as container background color.
     */
    light: deprecate(PropTypes__default["default"].bool, 'The `light` prop for `Tile` is no longer needed and has been deprecated. It will be removed in the next major release. Use the Layer component instead.')
  };
  var ClickableTile$2 = /*#__PURE__*/React__default["default"].forwardRef(function ClickableTile(_ref2, ref) {
    var _cx2;

    var children = _ref2.children,
        className = _ref2.className,
        _ref2$clicked = _ref2.clicked,
        clicked = _ref2$clicked === void 0 ? false : _ref2$clicked,
        handleClick = _ref2.handleClick,
        handleKeyDown = _ref2.handleKeyDown,
        href = _ref2.href,
        _ref2$light = _ref2.light,
        light = _ref2$light === void 0 ? false : _ref2$light,
        _ref2$onClick = _ref2.onClick,
        onClick = _ref2$onClick === void 0 ? function () {} : _ref2$onClick,
        _ref2$onKeyDown = _ref2.onKeyDown,
        onKeyDown = _ref2$onKeyDown === void 0 ? function () {} : _ref2$onKeyDown,
        rest = _objectWithoutProperties$2(_ref2, _excluded2$1);

    var prefix = usePrefix();
    var classes = cx("".concat(prefix, "--tile"), "".concat(prefix, "--tile--clickable"), (_cx2 = {}, _defineProperty$2(_cx2, "".concat(prefix, "--tile--is-clicked"), clicked), _defineProperty$2(_cx2, "".concat(prefix, "--tile--light"), light), _cx2), className);

    var _useState = React.useState(clicked),
        _useState2 = _slicedToArray$1(_useState, 2),
        isSelected = _useState2[0],
        setIsSelected = _useState2[1]; // TODO: replace with onClick when handleClick prop is deprecated


    var clickHandler = handleClick || onClick; // TODO: replace with onClick when handleClick prop is deprecated

    var keyDownHandler = handleKeyDown || onKeyDown;

    function handleOnClick(evt) {
      evt.persist();
      setIsSelected(!isSelected);
      clickHandler(evt);
    }

    function handleOnKeyDown(evt) {
      evt.persist();

      if (matches(evt, [Enter, Space])) {
        evt.preventDefault();
        setIsSelected(!isSelected);
        keyDownHandler(evt);
      }

      keyDownHandler(evt);
    }

    return /*#__PURE__*/React__default["default"].createElement(Link$3, _extends$3({
      className: classes,
      href: href,
      onClick: handleOnClick,
      onKeyDown: handleOnKeyDown,
      ref: ref
    }, rest), children);
  });
  ClickableTile$2.displayName = 'ClickableTile';
  ClickableTile$2.propTypes = {
    /**
     * The child nodes.
     */
    children: PropTypes__default["default"].node,

    /**
     * The CSS class names.
     */
    className: PropTypes__default["default"].string,

    /**
     * Boolean for whether a tile has been clicked.
     */
    clicked: PropTypes__default["default"].bool,

    /**
     * Deprecated in v11. Use 'onClick' instead.
     */
    handleClick: deprecate(PropTypes__default["default"].func, 'The handleClick prop for ClickableTile has been deprecated in favor of onClick. It will be removed in the next major release.'),

    /**
     * Specify the function to run when the ClickableTile is interacted with via a keyboard
     */
    handleKeyDown: deprecate(PropTypes__default["default"].func, 'The handleKeyDown prop for ClickableTile has been deprecated in favor of onKeyDown. It will be removed in the next major release.'),

    /**
     * The href for the link.
     */
    href: PropTypes__default["default"].string,

    /**
     * `true` to use the light version. For use on $ui-01 backgrounds only.
     * Don't use this to make tile background color same as container background color.
     */
    light: deprecate(PropTypes__default["default"].bool, 'The `light` prop for `ClickableTile` is no longer needed and has been deprecated. It will be removed in the next major release. Use the Layer component instead.'),

    /**
     * Specify the function to run when the ClickableTile is clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Specify the function to run when the ClickableTile is interacted with via a keyboard
     */
    onKeyDown: PropTypes__default["default"].func,

    /**
     * The rel property for the link.
     */
    rel: PropTypes__default["default"].string
  };
  var SelectableTile$2 = /*#__PURE__*/React__default["default"].forwardRef(function SelectableTile(_ref3, ref) {
    var _cx3;

    var children = _ref3.children,
        className = _ref3.className,
        disabled = _ref3.disabled,
        handleClick = _ref3.handleClick,
        handleKeyDown = _ref3.handleKeyDown;
        _ref3.iconDescription;
        var id = _ref3.id,
        _ref3$light = _ref3.light,
        light = _ref3$light === void 0 ? false : _ref3$light,
        name = _ref3.name,
        _ref3$onClick = _ref3.onClick,
        onClick = _ref3$onClick === void 0 ? function () {} : _ref3$onClick,
        _ref3$onChange = _ref3.onChange,
        onChange = _ref3$onChange === void 0 ? function () {} : _ref3$onChange,
        _ref3$onKeyDown = _ref3.onKeyDown,
        onKeyDown = _ref3$onKeyDown === void 0 ? function () {} : _ref3$onKeyDown,
        _ref3$selected = _ref3.selected,
        selected = _ref3$selected === void 0 ? false : _ref3$selected,
        _ref3$tabIndex = _ref3.tabIndex,
        tabIndex = _ref3$tabIndex === void 0 ? 0 : _ref3$tabIndex,
        _ref3$title = _ref3.title,
        title = _ref3$title === void 0 ? 'title' : _ref3$title,
        _ref3$value = _ref3.value,
        value = _ref3$value === void 0 ? 'value' : _ref3$value,
        rest = _objectWithoutProperties$2(_ref3, _excluded3$1);

    var prefix = usePrefix(); // TODO: replace with onClick when handleClick prop is deprecated

    var clickHandler = handleClick || onClick; // TODO: replace with onKeyDown when handleKeyDown prop is deprecated

    var keyDownHandler = handleKeyDown || onKeyDown;

    var _useState3 = React.useState(selected),
        _useState4 = _slicedToArray$1(_useState3, 2),
        isSelected = _useState4[0],
        setIsSelected = _useState4[1];

    var _useState5 = React.useState(selected),
        _useState6 = _slicedToArray$1(_useState5, 2),
        prevSelected = _useState6[0],
        setPrevSelected = _useState6[1];

    var classes = cx("".concat(prefix, "--tile"), "".concat(prefix, "--tile--selectable"), (_cx3 = {}, _defineProperty$2(_cx3, "".concat(prefix, "--tile--is-selected"), isSelected), _defineProperty$2(_cx3, "".concat(prefix, "--tile--light"), light), _defineProperty$2(_cx3, "".concat(prefix, "--tile--disabled"), disabled), _cx3), className);
    var inputClasses = cx("".concat(prefix, "--tile-input"), _defineProperty$2({}, "".concat(prefix, "--tile-input--checked"), isSelected)); // TODO: rename to handleClick when handleClick prop is deprecated

    function handleOnClick(evt) {
      evt.preventDefault();
      evt.persist();
      setIsSelected(!isSelected);
      clickHandler(evt);
      onChange(evt);
    } // TODO: rename to handleKeyDown when handleKeyDown prop is deprecated


    function handleOnKeyDown(evt) {
      evt.persist();

      if (matches(evt, [Enter, Space])) {
        evt.preventDefault();
        setIsSelected(!isSelected);
        onChange(evt);
      }

      keyDownHandler(evt);
    }

    function handleChange(event) {
      setIsSelected(event.target.checked);
      onChange(event);
    }

    if (selected !== prevSelected) {
      setIsSelected(selected);
      setPrevSelected(selected);
    }

    return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("input", {
      checked: isSelected,
      className: inputClasses,
      disabled: disabled,
      id: id,
      name: name,
      onChange: !disabled ? handleChange : null,
      ref: ref,
      tabIndex: -1,
      title: title,
      type: "checkbox",
      value: value
    }), /*#__PURE__*/React__default["default"].createElement("label", _extends$3({
      className: classes,
      htmlFor: id,
      onClick: !disabled ? handleOnClick : null,
      onKeyDown: !disabled ? handleOnKeyDown : null // eslint-disable-next-line jsx-a11y/no-noninteractive-tabindex
      ,
      tabIndex: !disabled ? tabIndex : null
    }, rest), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--tile__checkmark ").concat(prefix, "--tile__checkmark--persistent")
    }, isSelected ? /*#__PURE__*/React__default["default"].createElement(CheckboxCheckedFilled16, null) : /*#__PURE__*/React__default["default"].createElement(Checkbox16, null)), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--tile-content")
    }, children)));
  });
  SelectableTile$2.displayName = 'SelectableTile';
  SelectableTile$2.propTypes = {
    /**
     * The child nodes.
     */
    children: PropTypes__default["default"].node,

    /**
     * The CSS class names.
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the SelectableTile should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Specify the function to run when the SelectableTile is clicked
     */
    handleClick: deprecate(PropTypes__default["default"].func, 'The `handleClick` prop for `SelectableTile` has been deprecated in favor of `onClick`. It will be removed in the next major release.'),

    /**
     * Specify the function to run when the SelectableTile is interacted with via a keyboard
     */
    handleKeyDown: deprecate(PropTypes__default["default"].func, 'The `handleKeyDown` prop for `SelectableTile` has been deprecated in favor of `onKeyDown`. It will be removed in the next major release.'),

    /**
     * The description of the checkmark icon.
     */
    iconDescription: deprecate(PropTypes__default["default"].string, 'The `iconDescription` prop for `SelectableTile` is no longer needed and has ' + 'been deprecated. It will be removed in the next major release.'),

    /**
     * The ID of the `<input>`.
     */
    id: PropTypes__default["default"].string,

    /**
     * `true` to use the light version. For use on $ui-01 backgrounds only.
     * Don't use this to make tile background color same as container background color.
     */
    light: deprecate(PropTypes__default["default"].bool, 'The `light` prop for `SelectableTile` is no longer needed and has been deprecated. It will be removed in the next major release. Use the Layer component instead.'),

    /**
     * The `name` of the `<input>`.
     */
    name: PropTypes__default["default"].string,

    /**
     * The empty handler of the `<input>`.
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Specify the function to run when the SelectableTile is clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Specify the function to run when the SelectableTile is interacted with via a keyboard
     */
    onKeyDown: PropTypes__default["default"].func,

    /**
     * `true` to select this tile.
     */
    selected: PropTypes__default["default"].bool,

    /**
     * Specify the tab index of the wrapper element
     */
    tabIndex: PropTypes__default["default"].number,

    /**
     * The `title` of the `<input>`.
     */
    title: PropTypes__default["default"].string,

    /**
     * The value of the `<input>`.
     */
    value: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]).isRequired
  };
  function ExpandableTile$2(_ref4) {
    var _cx5;

    var tabIndex = _ref4.tabIndex,
        className = _ref4.className,
        children = _ref4.children,
        expanded = _ref4.expanded,
        tileMaxHeight = _ref4.tileMaxHeight,
        tilePadding = _ref4.tilePadding,
        onClick = _ref4.onClick,
        onKeyUp = _ref4.onKeyUp,
        tileCollapsedIconText = _ref4.tileCollapsedIconText,
        tileExpandedIconText = _ref4.tileExpandedIconText,
        tileCollapsedLabel = _ref4.tileCollapsedLabel,
        tileExpandedLabel = _ref4.tileExpandedLabel,
        onBeforeClick = _ref4.onBeforeClick,
        light = _ref4.light,
        rest = _objectWithoutProperties$2(_ref4, _excluded4$1);

    var _useState7 = React.useState(tileMaxHeight),
        _useState8 = _slicedToArray$1(_useState7, 2),
        isTileMaxHeight = _useState8[0],
        setIsTileMaxHeight = _useState8[1];

    var _useState9 = React.useState(tilePadding),
        _useState10 = _slicedToArray$1(_useState9, 2),
        isTilePadding = _useState10[0],
        setIsTilePadding = _useState10[1];

    var _useState11 = React.useState(expanded),
        _useState12 = _slicedToArray$1(_useState11, 2),
        prevExpanded = _useState12[0],
        setPrevExpanded = _useState12[1];

    var _useState13 = React.useState(tileMaxHeight),
        _useState14 = _slicedToArray$1(_useState13, 2),
        prevTileMaxHeight = _useState14[0],
        setPrevTileMaxHeight = _useState14[1];

    var _useState15 = React.useState(tilePadding),
        _useState16 = _slicedToArray$1(_useState15, 2),
        prevTilePadding = _useState16[0],
        setPrevTilePadding = _useState16[1];

    var _useState17 = React.useState(expanded),
        _useState18 = _slicedToArray$1(_useState17, 2),
        isExpanded = _useState18[0],
        setIsExpanded = _useState18[1];

    var aboveTheFold = React.useRef(null);
    var tileContent = React.useRef(null);
    var tile = React.useRef(null);
    var prefix = usePrefix();

    if (expanded !== prevExpanded) {
      setIsExpanded(expanded);
      setPrevExpanded(expanded);
      setMaxHeight();
    }

    if (tileMaxHeight !== prevTileMaxHeight) {
      setIsTileMaxHeight(tileMaxHeight);
      setPrevTileMaxHeight(tileMaxHeight);
    }

    if (tilePadding !== prevTilePadding) {
      setIsTilePadding(tilePadding);
      setPrevTilePadding(tilePadding);
    }

    function setMaxHeight() {
      if (isExpanded) {
        setIsTileMaxHeight(tileContent.current.getBoundingClientRect().height);
      }

      setIsTileMaxHeight(aboveTheFold.current.getBoundingClientRect().height);
    }

    function handleClick(evt) {
      if (!onBeforeClick(evt) || evt.target.tagName === 'INPUT') {
        return;
      }

      evt.persist();
      setIsExpanded(!isExpanded);
      setMaxHeight();

      if (onClick) {
        onClick(evt);
      }
    }

    function handleKeyUp(evt) {
      if (evt.target !== tile.current) {
        if (matches(evt, [Enter, Space])) {
          evt.preventDefault();
        }
      }
    }

    function getChildren() {
      return React__default["default"].Children.toArray(children);
    }

    var classes = cx("".concat(prefix, "--tile"), "".concat(prefix, "--tile--expandable"), (_cx5 = {}, _defineProperty$2(_cx5, "".concat(prefix, "--tile--is-expanded"), isExpanded), _defineProperty$2(_cx5, "".concat(prefix, "--tile--light"), light), _cx5), className);
    var tileStyle = {
      maxHeight: isExpanded ? null : isTileMaxHeight + isTilePadding
    };
    var childrenAsArray = getChildren();
    useIsomorphicEffect$1(function () {
      var getStyle = window.getComputedStyle(tile.current, null);
      var node = aboveTheFold.current;

      var _node$getBoundingClie = node.getBoundingClientRect(),
          height = _node$getBoundingClie.height;

      var paddingTop = parseInt(getStyle.getPropertyValue('padding-top'), 10);
      var paddingBottom = parseInt(getStyle.getPropertyValue('padding-bottom'), 10);
      setIsTileMaxHeight(height);
      setIsTilePadding(paddingTop + paddingBottom);
    }, []);
    React.useEffect(function () {
      var resizeObserver = new ResizeObserver(function (entries) {
        var _entries = _slicedToArray$1(entries, 1),
            aboveTheFold = _entries[0];

        setIsTileMaxHeight(aboveTheFold.contentRect.height);
      });
      resizeObserver.observe(aboveTheFold.current);
      return function () {
        return resizeObserver.disconnect();
      };
    }, []);
    return /*#__PURE__*/React__default["default"].createElement("button", _extends$3({
      type: "button",
      ref: tile,
      style: tileStyle,
      className: classes,
      "aria-expanded": isExpanded,
      title: isExpanded ? tileExpandedIconText : tileCollapsedIconText
    }, rest, {
      onKeyUp: composeEventHandlers([onKeyUp, handleKeyUp]),
      onClick: composeEventHandlers([onClick, handleClick]),
      tabIndex: tabIndex
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      ref: tileContent
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      ref: aboveTheFold,
      className: "".concat(prefix, "--tile-content")
    }, childrenAsArray[0]), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--tile__chevron")
    }, /*#__PURE__*/React__default["default"].createElement("span", null, isExpanded ? tileExpandedLabel : tileCollapsedLabel), /*#__PURE__*/React__default["default"].createElement(ChevronDown16, null)), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--tile-content")
    }, childrenAsArray[1])));
  }
  ExpandableTile$2.propTypes = {
    /**
     * The child nodes.
     */
    children: PropTypes__default["default"].node,

    /**
     * The CSS class names.
     */
    className: PropTypes__default["default"].string,

    /**
     * `true` if the tile is expanded.
     */
    expanded: PropTypes__default["default"].bool,

    /**
     * An ID that can be provided to aria-labelledby
     */
    id: PropTypes__default["default"].string,

    /**
     * `true` to use the light version. For use on $ui-01 backgrounds only.
     * Don't use this to make tile background color same as container background color.
     */
    light: deprecate(PropTypes__default["default"].bool, 'The `light` prop for `ExpandableTile` is no longer needed and has been deprecated. It will be removed in the next major release. Use the Layer component instead.'),

    /**
     * optional handler to decide whether to ignore a click. returns false if click should be ignored
     */
    onBeforeClick: PropTypes__default["default"].func,

    /**
     * Specify the function to run when the ExpandableTile is clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * optional handler to trigger a function when a key is pressed
     */
    onKeyUp: PropTypes__default["default"].func,

    /**
     * The `tabindex` attribute.
     */
    tabIndex: PropTypes__default["default"].number,

    /**
     * The description of the "collapsed" icon that can be read by screen readers.
     */
    tileCollapsedIconText: PropTypes__default["default"].string,

    /**
     * When "collapsed", a label to appear next to the chevron (e.g., "View more").
     */
    tileCollapsedLabel: PropTypes__default["default"].string,

    /**
     * The description of the "expanded" icon that can be read by screen readers.
     */
    tileExpandedIconText: PropTypes__default["default"].string,

    /**
     * When "expanded", a label to appear next to the chevron (e.g., "View less").
     */
    tileExpandedLabel: PropTypes__default["default"].string
  };
  ExpandableTile$2.defaultProps = {
    tabIndex: 0,
    expanded: false,
    tileMaxHeight: 0,
    tilePadding: 0,
    onBeforeClick: function onBeforeClick() {
      return true;
    },
    onClick: function onClick() {},
    tileCollapsedIconText: 'Interact to expand Tile',
    tileExpandedIconText: 'Interact to collapse Tile'
  };
  ExpandableTile$2.displayName = 'ExpandableTile';
  var TileAboveTheFoldContent$2 = /*#__PURE__*/React__default["default"].forwardRef(function TilAboveTheFoldContent(_ref5, ref) {
    var children = _ref5.children;
    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("span", {
      ref: ref,
      className: "".concat(prefix, "--tile-content__above-the-fold")
    }, children);
  });
  TileAboveTheFoldContent$2.propTypes = {
    /**
     * The child nodes.
     */
    children: PropTypes__default["default"].node
  };
  TileAboveTheFoldContent$2.displayName = 'TileAboveTheFoldContent';
  var TileBelowTheFoldContent$2 = /*#__PURE__*/React__default["default"].forwardRef(function TileBelowTheFoldContent(_ref6, ref) {
    var children = _ref6.children;
    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("span", {
      ref: ref,
      className: "".concat(prefix, "--tile-content__below-the-fold")
    }, children);
  });
  TileBelowTheFoldContent$2.propTypes = {
    /**
     * The child nodes.
     */
    children: PropTypes__default["default"].node
  };
  TileBelowTheFoldContent$2.displayName = 'TileBelowTheFoldContent';

  var _excluded$P = ["children", "className", "light"],
      _excluded2 = ["children", "href", "className", "handleClick", "handleKeyDown", "onClick", "onKeyDown", "clicked", "light"],
      _excluded3 = ["children", "id", "tabIndex", "value", "name", "title", "iconDescription", "className", "handleClick", "handleKeyDown", "onClick", "onChange", "onKeyDown", "light", "disabled", "selected"],
      _excluded4 = ["tabIndex", "className", "expanded", "tileMaxHeight", "tilePadding", "handleClick", "onKeyUp", "tileCollapsedIconText", "tileExpandedIconText", "tileCollapsedLabel", "tileExpandedLabel", "onBeforeClick", "light"];
  var Tile$1 = /*#__PURE__*/function (_Component) {
    _inherits(Tile, _Component);

    var _super = _createSuper(Tile);

    function Tile() {
      _classCallCheck$1(this, Tile);

      return _super.apply(this, arguments);
    }

    _createClass$1(Tile, [{
      key: "render",
      value: function render() {
        var prefix = this.context;

        var _this$props = this.props,
            children = _this$props.children,
            className = _this$props.className,
            light = _this$props.light,
            rest = _objectWithoutProperties$2(_this$props, _excluded$P);

        var tileClasses = cx("".concat(prefix, "--tile"), _defineProperty$2({}, "".concat(prefix, "--tile--light"), light), className);
        return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
          className: tileClasses
        }, rest), children);
      }
    }]);

    return Tile;
  }(React.Component);

  _defineProperty$2(Tile$1, "propTypes", {
    /**
     * The child nodes.
     */
    children: PropTypes__default["default"].node,

    /**
     * The CSS class names.
     */
    className: PropTypes__default["default"].string,

    /**
     * `true` to use the light version. For use on $ui-01 backgrounds only.
     * Don't use this to make tile background color same as container background color.
     */
    light: PropTypes__default["default"].bool
  });

  _defineProperty$2(Tile$1, "contextType", PrefixContext);

  _defineProperty$2(Tile$1, "defaultProps", {
    light: false
  });

  var ClickableTile$1 = /*#__PURE__*/function (_Component2) {
    _inherits(ClickableTile, _Component2);

    var _super2 = _createSuper(ClickableTile);

    function ClickableTile() {
      var _this;

      _classCallCheck$1(this, ClickableTile);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super2.call.apply(_super2, [this].concat(args));

      _defineProperty$2(_assertThisInitialized$1(_this), "state", {});

      _defineProperty$2(_assertThisInitialized$1(_this), "handleClick", function (evt) {
        evt.persist();

        _this.setState({
          clicked: !_this.state.clicked
        }, function () {
          var _this$props$handleCli, _this$props2, _this$props$onClick, _this$props3;

          // TODO: Remove handleClick prop when handleClick is deprecated
          ((_this$props$handleCli = (_this$props2 = _this.props).handleClick) === null || _this$props$handleCli === void 0 ? void 0 : _this$props$handleCli.call(_this$props2, evt)) || ((_this$props$onClick = (_this$props3 = _this.props).onClick) === null || _this$props$onClick === void 0 ? void 0 : _this$props$onClick.call(_this$props3, evt));
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleKeyDown", function (evt) {
        evt.persist();

        if (matches(evt, [Enter, Space])) {
          _this.setState({
            clicked: !_this.state.clicked
          }, function () {
            var _this$props$handleKey, _this$props4;

            // TODO: Remove handleKeyDown prop when handleKeyDown is deprecated
            ((_this$props$handleKey = (_this$props4 = _this.props).handleKeyDown) === null || _this$props$handleKey === void 0 ? void 0 : _this$props$handleKey.call(_this$props4, evt)) || _this.props.onKeyDown(evt);
          });
        } else {
          var _this$props$handleKey2, _this$props5;

          // TODO: Remove handleKeyDown prop when handleKeyDown is deprecated
          ((_this$props$handleKey2 = (_this$props5 = _this.props).handleKeyDown) === null || _this$props$handleKey2 === void 0 ? void 0 : _this$props$handleKey2.call(_this$props5, evt)) || _this.props.onKeyDown(evt);
        }
      });

      return _this;
    }

    _createClass$1(ClickableTile, [{
      key: "render",
      value: function render() {
        var _cx2;

        var prefix = this.context;

        var _this$props6 = this.props,
            children = _this$props6.children,
            href = _this$props6.href,
            className = _this$props6.className;
            _this$props6.handleClick;
            _this$props6.handleKeyDown;
            _this$props6.onClick;
            _this$props6.onKeyDown;
            _this$props6.clicked;
            var light = _this$props6.light,
            rest = _objectWithoutProperties$2(_this$props6, _excluded2);

        var classes = cx("".concat(prefix, "--tile"), "".concat(prefix, "--tile--clickable"), (_cx2 = {}, _defineProperty$2(_cx2, "".concat(prefix, "--tile--is-clicked"), this.state.clicked), _defineProperty$2(_cx2, "".concat(prefix, "--tile--light"), light), _cx2), className);
        return /*#__PURE__*/React__default["default"].createElement(Link$3, _extends$3({
          href: href,
          className: classes
        }, rest, {
          onClick: this.handleClick,
          onKeyDown: this.handleKeyDown
        }), children);
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: // eslint-disable-next-line react/prop-types
      function getDerivedStateFromProps(_ref, state) {
        var clicked = _ref.clicked;
        var prevClicked = state.prevClicked;
        return prevClicked === clicked ? null : {
          clicked: clicked,
          prevClicked: clicked
        };
      }
    }]);

    return ClickableTile;
  }(React.Component);

  _defineProperty$2(ClickableTile$1, "propTypes", {
    /**
     * The child nodes.
     */
    children: PropTypes__default["default"].node,

    /**
     * The CSS class names.
     */
    className: PropTypes__default["default"].string,

    /**
     * Deprecated in v11. Use 'onClick' instead.
     */
    handleClick: deprecate(PropTypes__default["default"].func, 'The handleClick prop for ClickableTile has been deprecated in favor of onClick. It will be removed in the next major release.'),

    /**
     * Specify the function to run when the ClickableTile is interacted with via a keyboard
     */
    handleKeyDown: deprecate(PropTypes__default["default"].func, 'The handleKeyDown prop for ClickableTile has been deprecated in favor of onKeyDown. It will be removed in the next major release.'),

    /**
     * The href for the link.
     */
    href: PropTypes__default["default"].string,

    /**
     * `true` to use the light version. For use on $ui-01 backgrounds only.
     * Don't use this to make tile background color same as container background color.
     */
    light: PropTypes__default["default"].bool,

    /**
     * Specify the function to run when the ClickableTile is clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Specify the function to run when the ClickableTile is interacted with via a keyboard
     */
    onKeyDown: PropTypes__default["default"].func,

    /**
     * The rel property for the link.
     */
    rel: PropTypes__default["default"].string
  });

  _defineProperty$2(ClickableTile$1, "contextType", PrefixContext);

  _defineProperty$2(ClickableTile$1, "defaultProps", {
    clicked: false,
    onClick: function onClick() {},
    onKeyDown: function onKeyDown() {},
    light: false
  });

  function SelectableTile$1(props) {
    var _cx3;

    var children = props.children,
        id = props.id,
        tabIndex = props.tabIndex,
        value = props.value,
        name = props.name,
        title = props.title;
        props.iconDescription;
        var className = props.className,
        handleClick = props.handleClick,
        handleKeyDown = props.handleKeyDown,
        onClick = props.onClick,
        onChange = props.onChange,
        onKeyDown = props.onKeyDown,
        light = props.light,
        disabled = props.disabled,
        selected = props.selected,
        rest = _objectWithoutProperties$2(props, _excluded3);

    var prefix = usePrefix(); // TODO: replace with onClick when handleClick prop is deprecated

    var clickHandler = handleClick || onClick; // TODO: replace with onKeyDown when handleKeyDown prop is deprecated

    var keyDownHandler = handleKeyDown || onKeyDown;

    var _useState = React.useState(selected),
        _useState2 = _slicedToArray$1(_useState, 2),
        isSelected = _useState2[0],
        setIsSelected = _useState2[1];

    var input = React.useRef(null);
    var classes = cx("".concat(prefix, "--tile"), "".concat(prefix, "--tile--selectable"), (_cx3 = {}, _defineProperty$2(_cx3, "".concat(prefix, "--tile--is-selected"), isSelected), _defineProperty$2(_cx3, "".concat(prefix, "--tile--light"), light), _defineProperty$2(_cx3, "".concat(prefix, "--tile--disabled"), disabled), _cx3), className); // TODO: rename to handleClick when handleClick prop is deprecated

    function handleOnClick(evt) {
      evt.preventDefault();
      evt.persist();
      setIsSelected(!isSelected);
      clickHandler(evt);
      onChange(evt);
    } // TODO: rename to handleKeyDown when handleKeyDown prop is deprecated


    function handleOnKeyDown(evt) {
      evt.persist();

      if (matches(evt, [Enter, Space])) {
        evt.preventDefault();
        setIsSelected(!isSelected);
        onChange(evt);
      }

      keyDownHandler(evt);
    }

    function handleChange(event) {
      setIsSelected(event.target.checked);
      onChange(event);
    }

    React.useEffect(function () {
      setIsSelected(selected);
    }, [selected]);
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: classes,
      onClick: !disabled ? handleOnClick : null,
      role: "checkbox",
      "aria-checked": isSelected,
      disabled: disabled,
      onKeyDown: !disabled ? handleOnKeyDown : null // eslint-disable-next-line jsx-a11y/no-noninteractive-tabindex
      ,
      tabIndex: !disabled ? tabIndex : null,
      value: value,
      name: name,
      ref: input,
      id: id,
      onChange: !disabled ? handleChange : null,
      title: title
    }, rest), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--tile__checkmark ").concat(prefix, "--tile__checkmark--persistent")
    }, isSelected ? /*#__PURE__*/React__default["default"].createElement(CheckboxCheckedFilled16, null) : /*#__PURE__*/React__default["default"].createElement(Checkbox16, null)), /*#__PURE__*/React__default["default"].createElement("label", {
      htmlFor: id,
      className: "".concat(prefix, "--tile-content")
    }, children));
  }
  SelectableTile$1.defaultProps = {
    value: 'value',
    title: 'title',
    selected: false,
    tabIndex: 0,
    light: false,
    onClick: function onClick() {},
    onChange: function onChange() {},
    onKeyDown: function onKeyDown() {}
  };
  SelectableTile$1.propTypes = {
    /**
     * The child nodes.
     */
    children: PropTypes__default["default"].node,

    /**
     * The CSS class names.
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the SelectableTile should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Specify the function to run when the SelectableTile is clicked
     */
    handleClick: deprecate(PropTypes__default["default"].func, 'The `handleClick` prop for `SelectableTile` has been deprecated in favor of `onClick`. It will be removed in the next major release.'),

    /**
     * Specify the function to run when the SelectableTile is interacted with via a keyboard
     */
    handleKeyDown: deprecate(PropTypes__default["default"].func, 'The `handleKeyDown` prop for `SelectableTile` has been deprecated in favor of `onKeyDown`. It will be removed in the next major release.'),

    /**
     * The description of the checkmark icon.
     */
    iconDescription: deprecate(PropTypes__default["default"].string, 'The `iconDescription` prop for `SelectableTile` is no longer needed and has ' + 'been deprecated. It will be removed in the next major release.'),

    /**
     * The ID of the `<input>`.
     */
    id: PropTypes__default["default"].string,

    /**
     * `true` to use the light version. For use on $ui-01 backgrounds only.
     * Don't use this to make tile background color same as container background color.
     */
    light: PropTypes__default["default"].bool,

    /**
     * The `name` of the `<input>`.
     */
    name: PropTypes__default["default"].string,

    /**
     * The empty handler of the `<input>`.
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Specify the function to run when the SelectableTile is clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Specify the function to run when the SelectableTile is interacted with via a keyboard
     */
    onKeyDown: PropTypes__default["default"].func,

    /**
     * `true` to select this tile.
     */
    selected: PropTypes__default["default"].bool,

    /**
     * Specify the tab index of the wrapper element
     */
    tabIndex: PropTypes__default["default"].number,

    /**
     * The `title` of the `<input>`.
     */
    title: PropTypes__default["default"].string,

    /**
     * The value of the `<input>`.
     */
    value: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]).isRequired
  };
  var ExpandableTile$1 = /*#__PURE__*/function (_Component3) {
    _inherits(ExpandableTile, _Component3);

    var _super3 = _createSuper(ExpandableTile);

    function ExpandableTile() {
      var _this2;

      _classCallCheck$1(this, ExpandableTile);

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      _this2 = _super3.call.apply(_super3, [this].concat(args));

      _defineProperty$2(_assertThisInitialized$1(_this2), "state", {});

      _defineProperty$2(_assertThisInitialized$1(_this2), "resizeObserver", null);

      _defineProperty$2(_assertThisInitialized$1(_this2), "componentDidMount", function () {
        _this2.resizeObserver = new ResizeObserver(function (entries) {
          var _entries = _slicedToArray$1(entries, 1),
              aboveTheFold = _entries[0];

          _this2.setState({
            tileMaxHeight: aboveTheFold.contentRect.height
          });
        });

        if (_this2.tile) {
          var getStyle = window.getComputedStyle(_this2.tile, null);

          if (_this2.aboveTheFold) {
            _this2.resizeObserver.observe(_this2.aboveTheFold);

            _this2.setState({
              tileMaxHeight: _this2.aboveTheFold.getBoundingClientRect().height,
              tilePadding: parseInt(getStyle.getPropertyValue('padding-top'), 10) + parseInt(getStyle.getPropertyValue('padding-bottom'), 10)
            });
          }
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this2), "componentDidUpdate", function (prevProps) {
        if (prevProps.expanded !== _this2.props.expanded) {
          _this2.setMaxHeight();
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this2), "setMaxHeight", function () {
        if (_this2.state.expanded ? _this2.tileContent : _this2.aboveTheFold) {
          _this2.setState({
            tileMaxHeight: _this2.state.expanded ? _this2.tileContent.getBoundingClientRect().height : _this2.aboveTheFold.getBoundingClientRect().height
          });
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this2), "handleClick", function (evt) {
        if (!_this2.props.onBeforeClick(evt) || evt.target.tagName === 'INPUT') {
          return;
        }

        evt.persist();

        _this2.setState({
          expanded: !_this2.state.expanded
        }, function () {
          var _this2$props$handleCl, _this2$props, _this2$props$onClick, _this2$props2;

          _this2.setMaxHeight(); // TODO: Remove handleClick prop when handleClick is deprecated


          ((_this2$props$handleCl = (_this2$props = _this2.props).handleClick) === null || _this2$props$handleCl === void 0 ? void 0 : _this2$props$handleCl.call(_this2$props, evt)) || ((_this2$props$onClick = (_this2$props2 = _this2.props).onClick) === null || _this2$props$onClick === void 0 ? void 0 : _this2$props$onClick.call(_this2$props2, evt));
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this2), "handleKeyUp", function (evt) {
        if (evt.target !== _this2.tile) {
          if (matches(evt, [Enter, Space])) {
            evt.preventDefault();
          }
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this2), "getChildren", function () {
        return React__default["default"].Children.toArray(_this2.props.children);
      });

      return _this2;
    }

    _createClass$1(ExpandableTile, [{
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this.resizeObserver) {
          this.resizeObserver.disconnect();
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _cx4,
            _this3 = this;

        var _this$props7 = this.props,
            tabIndex = _this$props7.tabIndex,
            className = _this$props7.className;
            _this$props7.expanded;
            _this$props7.tileMaxHeight;
            _this$props7.tilePadding;
            _this$props7.handleClick;
            var onKeyUp = _this$props7.onKeyUp,
            tileCollapsedIconText = _this$props7.tileCollapsedIconText,
            tileExpandedIconText = _this$props7.tileExpandedIconText,
            tileCollapsedLabel = _this$props7.tileCollapsedLabel,
            tileExpandedLabel = _this$props7.tileExpandedLabel;
            _this$props7.onBeforeClick;
            var light = _this$props7.light,
            rest = _objectWithoutProperties$2(_this$props7, _excluded4);

        var prefix = this.context;
        var isExpanded = this.state.expanded;
        var classes = cx("".concat(prefix, "--tile"), "".concat(prefix, "--tile--expandable"), (_cx4 = {}, _defineProperty$2(_cx4, "".concat(prefix, "--tile--is-expanded"), isExpanded), _defineProperty$2(_cx4, "".concat(prefix, "--tile--light"), light), _cx4), className);
        var tileStyle = {
          maxHeight: isExpanded ? null : this.state.tileMaxHeight + this.state.tilePadding
        };
        var childrenAsArray = this.getChildren();
        return (
          /*#__PURE__*/
          // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
          React__default["default"].createElement("button", _extends$3({
            type: "button",
            ref: function ref(tile) {
              _this3.tile = tile;
            },
            style: tileStyle,
            className: classes,
            "aria-expanded": isExpanded,
            title: isExpanded ? tileExpandedIconText : tileCollapsedIconText
          }, rest, {
            onKeyUp: composeEventHandlers([onKeyUp, this.handleKeyUp]),
            onClick: this.handleClick,
            tabIndex: tabIndex
          }), /*#__PURE__*/React__default["default"].createElement("div", {
            ref: function ref(tileContent) {
              _this3.tileContent = tileContent;
            }
          }, /*#__PURE__*/React__default["default"].createElement("div", {
            ref: function ref(aboveTheFold) {
              _this3.aboveTheFold = aboveTheFold;
            },
            className: "".concat(prefix, "--tile-content")
          }, childrenAsArray[0]), /*#__PURE__*/React__default["default"].createElement("div", {
            className: "".concat(prefix, "--tile__chevron")
          }, /*#__PURE__*/React__default["default"].createElement("span", null, isExpanded ? tileExpandedLabel : tileCollapsedLabel), /*#__PURE__*/React__default["default"].createElement(ChevronDown16, null)), /*#__PURE__*/React__default["default"].createElement("div", {
            className: "".concat(prefix, "--tile-content")
          }, childrenAsArray[1])))
        );
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps( // eslint-disable-next-line react/prop-types
      _ref2, state) {
        var expanded = _ref2.expanded,
            tileMaxHeight = _ref2.tileMaxHeight,
            tilePadding = _ref2.tilePadding;
        var prevExpanded = state.prevExpanded,
            prevTileMaxHeight = state.prevTileMaxHeight,
            prevTilePadding = state.prevTilePadding,
            currentExpanded = state.expanded,
            currentTileMaxHeight = state.tileMaxHeight,
            currentTilePadding = state.tilePadding;
        var expandedChanged = prevExpanded !== expanded;
        var tileMaxHeightChanged = prevTileMaxHeight !== tileMaxHeight;
        var tilePaddingChanged = prevTilePadding !== tilePadding;
        return !expandedChanged && !tileMaxHeightChanged && !tilePaddingChanged ? null : {
          expanded: !expandedChanged ? currentExpanded : expanded,
          tileMaxHeight: !tileMaxHeightChanged ? currentTileMaxHeight : tileMaxHeight,
          tilePadding: !tilePaddingChanged ? currentTilePadding : tilePadding,
          prevExpanded: expanded,
          prevTileMaxHeight: tileMaxHeight,
          prevTilePadding: tilePadding
        };
      }
    }]);

    return ExpandableTile;
  }(React.Component);

  _defineProperty$2(ExpandableTile$1, "propTypes", {
    /**
     * The child nodes.
     */
    children: PropTypes__default["default"].node,

    /**
     * The CSS class names.
     */
    className: PropTypes__default["default"].string,

    /**
     * `true` if the tile is expanded.
     */
    expanded: PropTypes__default["default"].bool,

    /**
     * Deprecated in v11. Use 'onClick' instead.
     */
    handleClick: deprecate(PropTypes__default["default"].func, 'The handleClick prop for ExpandableTile has been deprecated in favor of onClick. It will be removed in the next major release.'),

    /**
     * An ID that can be provided to aria-labelledby
     */
    id: PropTypes__default["default"].string,

    /**
     * `true` to use the light version. For use on $ui-01 backgrounds only.
     * Don't use this to make tile background color same as container background color.
     */
    light: PropTypes__default["default"].bool,

    /**
     * optional handler to decide whether to ignore a click. returns false if click should be ignored
     */
    onBeforeClick: PropTypes__default["default"].func,

    /**
     * Specify the function to run when the ExpandableTile is clicked
      */
    onClick: PropTypes__default["default"].func,

    /**
     * optional handler to trigger a function when a key is pressed
     */
    onKeyUp: PropTypes__default["default"].func,

    /**
     * The `tabindex` attribute.
     */
    tabIndex: PropTypes__default["default"].number,

    /**
     * The description of the "collapsed" icon that can be read by screen readers.
     */
    tileCollapsedIconText: PropTypes__default["default"].string,

    /**
     * When "collapsed", a label to appear next to the chevron (e.g., "View more").
     */
    tileCollapsedLabel: PropTypes__default["default"].string,

    /**
     * The description of the "expanded" icon that can be read by screen readers.
     */
    tileExpandedIconText: PropTypes__default["default"].string,

    /**
     * When "expanded", a label to appear next to the chevron (e.g., "View less").
     */
    tileExpandedLabel: PropTypes__default["default"].string
  });

  _defineProperty$2(ExpandableTile$1, "contextType", PrefixContext);

  _defineProperty$2(ExpandableTile$1, "defaultProps", {
    tabIndex: 0,
    expanded: false,
    tileMaxHeight: 0,
    tilePadding: 0,
    onBeforeClick: function onBeforeClick() {
      return true;
    },
    onClick: function onClick() {},
    tileCollapsedIconText: 'Interact to expand Tile',
    tileExpandedIconText: 'Interact to collapse Tile',
    light: false
  });

  var TileAboveTheFoldContent$1 = /*#__PURE__*/function (_Component4) {
    _inherits(TileAboveTheFoldContent, _Component4);

    var _super4 = _createSuper(TileAboveTheFoldContent);

    function TileAboveTheFoldContent() {
      _classCallCheck$1(this, TileAboveTheFoldContent);

      return _super4.apply(this, arguments);
    }

    _createClass$1(TileAboveTheFoldContent, [{
      key: "render",
      value: function render() {
        var prefix = this.context;
        var children = this.props.children;
        return /*#__PURE__*/React__default["default"].createElement("span", {
          className: "".concat(prefix, "--tile-content__above-the-fold")
        }, children);
      }
    }]);

    return TileAboveTheFoldContent;
  }(React.Component);

  _defineProperty$2(TileAboveTheFoldContent$1, "propTypes", {
    /**
     * The child nodes.
     */
    children: PropTypes__default["default"].node
  });

  _defineProperty$2(TileAboveTheFoldContent$1, "contextType", PrefixContext);

  var TileBelowTheFoldContent$1 = /*#__PURE__*/function (_Component5) {
    _inherits(TileBelowTheFoldContent, _Component5);

    var _super5 = _createSuper(TileBelowTheFoldContent);

    function TileBelowTheFoldContent() {
      _classCallCheck$1(this, TileBelowTheFoldContent);

      return _super5.apply(this, arguments);
    }

    _createClass$1(TileBelowTheFoldContent, [{
      key: "render",
      value: function render() {
        var children = this.props.children;
        var prefix = this.context;
        return /*#__PURE__*/React__default["default"].createElement("span", {
          className: "".concat(prefix, "--tile-content__below-the-fold")
        }, children);
      }
    }]);

    return TileBelowTheFoldContent;
  }(React.Component);

  _defineProperty$2(TileBelowTheFoldContent$1, "propTypes", {
    /**
     * The child nodes.
     */
    children: PropTypes__default["default"].node
  });

  _defineProperty$2(TileBelowTheFoldContent$1, "contextType", PrefixContext);

  var Tile = enabled('enable-v11-release') ? Tile$2 : Tile$1;
  var ClickableTile = enabled('enable-v11-release') ? ClickableTile$2 : ClickableTile$1;
  var SelectableTile = enabled('enable-v11-release') ? SelectableTile$2 : SelectableTile$1;
  var ExpandableTile = enabled('enable-v11-release') ? ExpandableTile$2 : ExpandableTile$1;
  var TileAboveTheFoldContent = enabled('enable-v11-release') ? TileAboveTheFoldContent$2 : TileAboveTheFoldContent$1;
  var TileBelowTheFoldContent = enabled('enable-v11-release') ? TileBelowTheFoldContent$2 : TileBelowTheFoldContent$1;

  var _excluded$O = ["children", "className", "disabled", "iconDescription", "light", "checked", "name", "value", "id", "onChange", "tabIndex"];

  function RadioTile(_ref) {
    var _cx;

    var children = _ref.children,
        customClassName = _ref.className,
        disabled = _ref.disabled;
        _ref.iconDescription;
        var light = _ref.light,
        checked = _ref.checked,
        name = _ref.name,
        value = _ref.value,
        id = _ref.id,
        onChange = _ref.onChange,
        tabIndex = _ref.tabIndex,
        rest = _objectWithoutProperties$2(_ref, _excluded$O);

    var prefix = usePrefix();
    var inputId = useFallbackId(id);
    var enabled = useFeatureFlag('enable-v11-release');
    var className = cx(customClassName, "".concat(prefix, "--tile"), "".concat(prefix, "--tile--selectable"), (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--tile--is-selected"), checked), _defineProperty$2(_cx, "".concat(prefix, "--tile--light"), light), _defineProperty$2(_cx, "".concat(prefix, "--tile--disabled"), disabled), _cx));
    var inputProps = enabled ? {} : rest;
    var labelProps = enabled ? rest : {};

    function handleOnChange(evt) {
      onChange(value, name, evt);
    }

    function handleOnKeyDown(evt) {
      if (matches(evt, [Enter, Space])) {
        evt.preventDefault();
        onChange(value, name, evt);
      }
    }

    return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("input", _extends$3({}, inputProps, {
      checked: checked,
      className: "".concat(prefix, "--tile-input"),
      disabled: disabled,
      id: inputId,
      name: name,
      onChange: !disabled ? handleOnChange : null,
      onKeyDown: !disabled ? handleOnKeyDown : null,
      tabIndex: !disabled ? tabIndex : null,
      type: "radio",
      value: value
    })), /*#__PURE__*/React__default["default"].createElement("label", _extends$3({}, labelProps, {
      htmlFor: inputId,
      className: className
    }), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--tile__checkmark")
    }, /*#__PURE__*/React__default["default"].createElement(CheckmarkFilled16, null)), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--tile-content")
    }, children)));
  }

  RadioTile.propTypes = {
    /**
     * `true` if this tile should be selected.
     */
    checked: PropTypes__default["default"].bool,

    /**
     * The tile content.
     */
    children: PropTypes__default["default"].node,

    /**
     * The CSS class names.
     */
    className: PropTypes__default["default"].string,

    /**
     * `true` if the `<input>` should be checked at initialization.
     */
    defaultChecked: PropTypes__default["default"].bool,

    /**
     * Specify whether the RadioTile should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * The description of the tile checkmark icon.
     */
    iconDescription: deprecate(PropTypes__default["default"].string, 'The `iconDescription` prop for `RadioTile` is no longer needed and has ' + 'been deprecated. It will be moved in the next major release.'),

    /**
     * The ID of the `<input>`.
     */
    id: PropTypes__default["default"].string,

    /**
     * `true` to use the light version. For use on $ui-01 backgrounds only.
     * Don't use this to make tile background color same as container background color.
     */
    light: PropTypes__default["default"].bool,

    /**
     * The `name` of the `<input>`.
     */
    name: PropTypes__default["default"].string,

    /**
     * The handler of the massaged `change` event on the `<input>`.
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Specify the tab index of the wrapper element
     */
    tabIndex: PropTypes__default["default"].number,

    /**
     * The `value` of the `<input>`.
     */
    value: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]).isRequired
  };
  RadioTile.defaultProps = {
    onChange: function onChange() {},
    tabIndex: 0,
    light: false
  };

  var _excluded$N = ["value"];

  var TileGroup = /*#__PURE__*/function (_React$Component) {
    _inherits(TileGroup, _React$Component);

    var _super = _createSuper(TileGroup);

    function TileGroup() {
      var _this;

      _classCallCheck$1(this, TileGroup);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty$2(_assertThisInitialized$1(_this), "state", {
        selected: _this.props.valueSelected || _this.props.defaultSelected || null,
        prevValueSelected: _this.props.valueSelected
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "getRadioTiles", function () {
        var childrenArray = React__default["default"].Children.toArray(_this.props.children);
        var children = childrenArray.map(function (tileRadio) {
          var _tileRadio$props = tileRadio.props,
              value = _tileRadio$props.value,
              other = _objectWithoutProperties$2(_tileRadio$props, _excluded$N);
          /* istanbul ignore if */


          if (typeof tileRadio.props.checked !== 'undefined') {
            warning(false, "Instead of using the checked property on the RadioTile, set\n            the defaultSelected property or valueSelected property on the TileGroup.") ;
          }

          return /*#__PURE__*/React__default["default"].createElement(RadioTile, _extends$3({}, other, {
            name: _this.props.name,
            key: value,
            value: value,
            onChange: _this.handleChange,
            checked: value === _this.state.selected
          }));
        });
        return children;
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleChange", function (newSelection, value, evt) {
        if (newSelection !== _this.state.selected) {
          _this.setState({
            selected: newSelection
          });

          _this.props.onChange(newSelection, _this.props.name, evt);
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "renderLegend", function (legend) {
        if (legend) {
          return /*#__PURE__*/React__default["default"].createElement("legend", {
            className: "".concat(_this.prefix, "--label")
          }, legend);
        }
      });

      return _this;
    }

    _createClass$1(TileGroup, [{
      key: "render",
      value: function render() {
        var prefix = this.context;
        var _this$props = this.props,
            disabled = _this$props.disabled,
            _this$props$className = _this$props.className,
            className = _this$props$className === void 0 ? "".concat(prefix, "--tile-group") : _this$props$className,
            legend = _this$props.legend;
        return /*#__PURE__*/React__default["default"].createElement("fieldset", {
          className: className,
          disabled: disabled
        }, this.renderLegend(legend), /*#__PURE__*/React__default["default"].createElement("div", null, this.getRadioTiles()));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, state) {
        var valueSelected = _ref.valueSelected,
            defaultSelected = _ref.defaultSelected;
        var prevValueSelected = state.prevValueSelected;
        return prevValueSelected === valueSelected ? null : {
          selected: valueSelected || defaultSelected || null,
          prevValueSelected: valueSelected
        };
      }
    }]);

    return TileGroup;
  }(React__default["default"].Component);

  _defineProperty$2(TileGroup, "contextType", PrefixContext);

  _defineProperty$2(TileGroup, "propTypes", {
    /**
     * Provide a collection of <RadioTile> components to render in the group
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the the value of <RadioTile> to be selected by default
     */
    defaultSelected: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),

    /**
     * Specify whether the group is disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Provide an optional legend for this group
     */
    legend: PropTypes__default["default"].string,

    /**
     * Specify the name of the underlying `<input>` nodes
     */
    name: PropTypes__default["default"].string.isRequired,

    /**
     * Provide an optional `onChange` hook that is called whenever the value of
     * the group changes
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Specify the value that is currently selected in the group
     */
    valueSelected: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number])
  });

  _defineProperty$2(TileGroup, "defaultProps", {
    onChange:
    /* istanbul ignore next */
    function onChange() {}
  });

  var _excluded$M = ["children", "className", "disabled", "hideLabel", "id", "invalidText", "invalid", "labelText", "light", "maxLength", "onChange", "onClick", "onBlur", "pattern", "placeholder", "size", "type", "value"];
  var TimePicker$3 = /*#__PURE__*/React__default["default"].forwardRef(function TimePicker(_ref, ref) {
    var _cx2, _cx3;

    var children = _ref.children,
        className = _ref.className,
        _ref$disabled = _ref.disabled,
        disabled = _ref$disabled === void 0 ? false : _ref$disabled,
        hideLabel = _ref.hideLabel,
        id = _ref.id,
        _ref$invalidText = _ref.invalidText,
        invalidText = _ref$invalidText === void 0 ? 'Invalid time format.' : _ref$invalidText,
        _ref$invalid = _ref.invalid,
        invalid = _ref$invalid === void 0 ? false : _ref$invalid,
        labelText = _ref.labelText,
        _ref$light = _ref.light,
        light = _ref$light === void 0 ? false : _ref$light,
        _ref$maxLength = _ref.maxLength,
        maxLength = _ref$maxLength === void 0 ? 5 : _ref$maxLength,
        _ref$onChange = _ref.onChange,
        onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
        _ref$onClick = _ref.onClick,
        onClick = _ref$onClick === void 0 ? function () {} : _ref$onClick,
        _ref$onBlur = _ref.onBlur,
        onBlur = _ref$onBlur === void 0 ? function () {} : _ref$onBlur,
        _ref$pattern = _ref.pattern,
        pattern = _ref$pattern === void 0 ? '(1[012]|[1-9]):[0-5][0-9](\\s)?' : _ref$pattern,
        _ref$placeholder = _ref.placeholder,
        placeholder = _ref$placeholder === void 0 ? 'hh:mm' : _ref$placeholder,
        _ref$size = _ref.size,
        size = _ref$size === void 0 ? 'md' : _ref$size,
        _ref$type = _ref.type,
        type = _ref$type === void 0 ? 'text' : _ref$type,
        value = _ref.value,
        rest = _objectWithoutProperties$2(_ref, _excluded$M);

    var prefix = usePrefix();

    var _React$useState = React__default["default"].useState(value),
        _React$useState2 = _slicedToArray$1(_React$useState, 2),
        isValue = _React$useState2[0],
        setValue = _React$useState2[1];

    var _React$useState3 = React__default["default"].useState(value),
        _React$useState4 = _slicedToArray$1(_React$useState3, 2),
        prevValue = _React$useState4[0],
        setPrevValue = _React$useState4[1];

    if (value !== prevValue) {
      setValue(value);
      setPrevValue(value);
    }

    function handleOnClick(evt) {
      if (!disabled) {
        setValue(isValue);
        onClick(evt);
      }
    }

    function handleOnChange(evt) {
      if (!disabled) {
        setValue(isValue);
        onChange(evt);
      }
    }

    function handleOnBlur(evt) {
      if (!disabled) {
        setValue(isValue);
        onBlur(evt);
      }
    }

    var timePickerInputClasses = cx("".concat(prefix, "--time-picker__input-field"), "".concat(prefix, "--text-input"), [className], _defineProperty$2({}, "".concat(prefix, "--text-input--light"), light));
    var timePickerClasses = cx((_cx2 = {}, _defineProperty$2(_cx2, "".concat(prefix, "--time-picker"), true), _defineProperty$2(_cx2, "".concat(prefix, "--time-picker--light"), light), _defineProperty$2(_cx2, "".concat(prefix, "--time-picker--invalid"), invalid), _defineProperty$2(_cx2, "".concat(prefix, "--time-picker--").concat(size), size), _defineProperty$2(_cx2, className, className), _cx2));
    var labelClasses = cx("".concat(prefix, "--label"), (_cx3 = {}, _defineProperty$2(_cx3, "".concat(prefix, "--visually-hidden"), hideLabel), _defineProperty$2(_cx3, "".concat(prefix, "--label--disabled"), disabled), _cx3));
    var label = labelText ? /*#__PURE__*/React__default["default"].createElement("label", {
      htmlFor: id,
      className: labelClasses
    }, labelText) : null;
    var error = invalid ? /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--form-requirement")
    }, invalidText) : null;
    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: cx("".concat(prefix, "--form-item"), className)
    }, label, /*#__PURE__*/React__default["default"].createElement("div", {
      className: timePickerClasses
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--time-picker__input")
    }, /*#__PURE__*/React__default["default"].createElement("input", _extends$3({
      className: timePickerInputClasses,
      "data-invalid": invalid ? invalid : undefined,
      disabled: disabled,
      id: id,
      maxLength: maxLength,
      onClick: handleOnClick,
      onChange: handleOnChange,
      onBlur: handleOnBlur,
      placeholder: placeholder,
      pattern: pattern,
      ref: ref,
      type: type,
      value: value
    }, rest))), children), error);
  });
  TimePicker$3.propTypes = {
    /**
     * Pass in the children that will be rendered next to the form control
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the `<input>` should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Specify whether you want the underlying label to be visually hidden
     */
    hideLabel: PropTypes__default["default"].bool,

    /**
     * Specify a custom `id` for the `<input>`
     */
    id: PropTypes__default["default"].string.isRequired,

    /**
     * Specify whether the control is currently invalid
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * Provide the text that is displayed when the control is in an invalid state
     */
    invalidText: PropTypes__default["default"].node,

    /**
     * Provide the text that will be read by a screen reader when visiting this
     * control
     */
    labelText: PropTypes__default["default"].node,

    /**
     * The `light` prop for `TimePicker` has been deprecated. It will be removed in v12. Use the `Layer` component instead.
     */
    light: deprecate(PropTypes__default["default"].bool, 'The `light` prop for `TimePicker` is no longer needed and has been deprecated. It will be removed in the next major release. Use the `Layer` component instead.'),

    /**
     * Specify the maximum length of the time string in `<input>`
     */
    maxLength: PropTypes__default["default"].number,

    /**
     * Optionally provide an `onBlur` handler that is called whenever the
     * `<input>` loses focus
     */
    onBlur: PropTypes__default["default"].func,

    /**
     * Optionally provide an `onChange` handler that is called whenever `<input>`
     * is updated
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Optionally provide an `onClick` handler that is called whenever the
     * `<input>` is clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Specify the regular expression working as the pattern of the time string in `<input>`
     */
    pattern: PropTypes__default["default"].string,

    /**
     * Specify the placeholder attribute for the `<input>`
     */
    placeholder: PropTypes__default["default"].string,

    /**
     * Specify the size of the Time Picker.
     */
    size: PropTypes__default["default"].oneOf(['sm', 'md', 'lg']),

    /**
     * Specify the type of the `<input>`
     */
    type: PropTypes__default["default"].string,

    /**
     * Specify the value of the `<input>`
     */
    value: PropTypes__default["default"].string
  };
  var TimePickerNext = TimePicker$3;

  var _excluded$L = ["children", "className", "id", "labelText", "type", "pattern", "onChange", "onClick", "onBlur", "placeholder", "maxLength", "invalidText", "invalid", "hideLabel", "light", "size"];

  var TimePicker$2 = /*#__PURE__*/function (_Component) {
    _inherits(TimePicker, _Component);

    var _super = _createSuper(TimePicker);

    function TimePicker() {
      var _this;

      _classCallCheck$1(this, TimePicker);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _defineProperty$2(_assertThisInitialized$1(_this), "state", {});

      return _this;
    }

    _createClass$1(TimePicker, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props = this.props,
            children = _this$props.children,
            className = _this$props.className,
            id = _this$props.id,
            labelText = _this$props.labelText,
            type = _this$props.type,
            pattern = _this$props.pattern,
            _onChange = _this$props.onChange,
            _onClick = _this$props.onClick,
            _onBlur = _this$props.onBlur,
            placeholder = _this$props.placeholder,
            maxLength = _this$props.maxLength,
            invalidText = _this$props.invalidText,
            invalid = _this$props.invalid,
            hideLabel = _this$props.hideLabel,
            light = _this$props.light,
            size = _this$props.size,
            other = _objectWithoutProperties$2(_this$props, _excluded$L);

        var scope = this.context;
        var enabled;

        if (scope.enabled) {
          enabled = scope.enabled('enable-v11-release');
        }

        return /*#__PURE__*/React__default["default"].createElement(PrefixContext.Consumer, null, function (prefix) {
          var _classNames2, _classNames3;

          var timePickerInputProps = {
            className: cx("".concat(prefix, "--time-picker__input-field"), "".concat(prefix, "--text-input"), [enabled ? null : className], _defineProperty$2({}, "".concat(prefix, "--text-input--light"), light)),
            onChange: function onChange(evt) {
              if (!other.disabled) {
                _this2.setState({
                  value: evt.target.value
                });

                _onChange(evt);
              }
            },
            onClick: function onClick(evt) {
              if (!other.disabled) {
                _this2.setState({
                  value: evt.target.value
                });

                _onClick(evt);
              }
            },
            onBlur: function onBlur(evt) {
              if (!other.disabled) {
                _this2.setState({
                  value: evt.target.value
                });

                _onBlur(evt);
              }
            },
            pattern: pattern,
            placeholder: placeholder,
            maxLength: maxLength,
            id: id,
            type: type,
            value: _this2.state.value
          };
          var timePickerClasses = cx((_classNames2 = {}, _defineProperty$2(_classNames2, "".concat(prefix, "--time-picker"), true), _defineProperty$2(_classNames2, "".concat(prefix, "--time-picker--light"), light), _defineProperty$2(_classNames2, "".concat(prefix, "--time-picker--invalid"), invalid), _defineProperty$2(_classNames2, "".concat(prefix, "--time-picker--").concat(size), size), _defineProperty$2(_classNames2, className, className), _classNames2));
          var labelClasses = cx("".concat(prefix, "--label"), (_classNames3 = {}, _defineProperty$2(_classNames3, "".concat(prefix, "--visually-hidden"), hideLabel), _defineProperty$2(_classNames3, "".concat(prefix, "--label--disabled"), other.disabled), _classNames3));
          var label = labelText ? /*#__PURE__*/React__default["default"].createElement("label", {
            htmlFor: id,
            className: labelClasses
          }, labelText) : null;
          var error = invalid ? /*#__PURE__*/React__default["default"].createElement("div", {
            className: "".concat(prefix, "--form-requirement")
          }, invalidText) : null;
          return /*#__PURE__*/React__default["default"].createElement("div", {
            className: enabled ? cx("".concat(prefix, "--form-item"), className) : "".concat(prefix, "--form-item")
          }, label, /*#__PURE__*/React__default["default"].createElement("div", {
            className: timePickerClasses
          }, /*#__PURE__*/React__default["default"].createElement("div", {
            className: "".concat(prefix, "--time-picker__input")
          }, /*#__PURE__*/React__default["default"].createElement("input", _extends$3({}, other, timePickerInputProps, {
            "data-invalid": invalid ? invalid : undefined
          }))), children), error);
        });
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, state) {
        var value = _ref.value;
        var prevValue = state.prevValue;
        return prevValue === value ? null : {
          value: value,
          prevValue: value
        };
      }
    }]);

    return TimePicker;
  }(React.Component);

  _defineProperty$2(TimePicker$2, "propTypes", {
    /**
     * Pass in the children that will be rendered next to the form control
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the `<input>` should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Specify whether you want the underlying label to be visually hidden
     */
    hideLabel: PropTypes__default["default"].bool,

    /**
     * Specify a custom `id` for the `<input>`
     */
    id: PropTypes__default["default"].string.isRequired,

    /**
     * Specify whether the control is currently invalid
     */
    invalid: PropTypes__default["default"].bool,

    /**
     * Provide the text that is displayed when the control is in an invalid state
     */
    invalidText: PropTypes__default["default"].node,

    /**
     * Provide the text that will be read by a screen reader when visiting this
     * control
     */
    labelText: PropTypes__default["default"].node,

    /**
     * `true` to use the light version. For use on $ui-01 backgrounds only.
     * Don't use this to make tile background color same as container background color.
     */
    light: PropTypes__default["default"].bool,

    /**
     * Specify the maximum length of the time string in `<input>`
     */
    maxLength: PropTypes__default["default"].number,

    /**
     * Optionally provide an `onBlur` handler that is called whenever the
     * `<input>` loses focus
     */
    onBlur: PropTypes__default["default"].func,

    /**
     * Optionally provide an `onChange` handler that is called whenever `<input>`
     * is updated
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Optionally provide an `onClick` handler that is called whenever the
     * `<input>` is clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Specify the regular expression working as the pattern of the time string in `<input>`
     */
    pattern: PropTypes__default["default"].string,

    /**
     * Specify the placeholder attribute for the `<input>`
     */
    placeholder: PropTypes__default["default"].string,

    /**
     * Specify the size of the Time Picker.
     */
    size: PropTypes__default["default"].oneOf(['sm', 'md', 'lg', 'xl']),

    /**
     * Specify the type of the `<input>`
     */
    type: PropTypes__default["default"].string,

    /**
     * Specify the value of the `<input>`
     */
    value: PropTypes__default["default"].string
  });

  _defineProperty$2(TimePicker$2, "defaultProps", {
    type: 'text',
    pattern: '(1[012]|[1-9]):[0-5][0-9](\\s)?',
    placeholder: 'hh:mm',
    maxLength: 5,
    invalidText: 'Invalid time format.',
    invalid: false,
    disabled: false,
    onChange: function onChange() {},
    onClick: function onClick() {},
    onBlur: function onBlur() {},
    light: false
  });

  _defineProperty$2(TimePicker$2, "contextType", FeatureFlagContext);

  var TimePicker = enabled('enable-v11-release') ? TimePickerNext : TimePicker$2;
  var TimePicker$1 = TimePicker;

  var _excluded$K = ["aria-label", "children", "id", "disabled", "className"];
  var TimePickerSelect$3 = /*#__PURE__*/React__default["default"].forwardRef(function TimePickerSelect(_ref, ref) {
    var _cx;

    var _ref$ariaLabel = _ref['aria-label'],
        ariaLabel = _ref$ariaLabel === void 0 ? 'open list of options' : _ref$ariaLabel,
        children = _ref.children,
        id = _ref.id,
        _ref$disabled = _ref.disabled,
        disabled = _ref$disabled === void 0 ? false : _ref$disabled,
        className = _ref.className,
        rest = _objectWithoutProperties$2(_ref, _excluded$K);

    var prefix = usePrefix();
    var selectClasses = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--select"), true), _defineProperty$2(_cx, "".concat(prefix, "--time-picker__select"), true), _defineProperty$2(_cx, className, className), _cx));
    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: selectClasses
    }, /*#__PURE__*/React__default["default"].createElement("select", _extends$3({
      "aria-label": ariaLabel,
      className: "".concat(prefix, "--select-input"),
      disabled: disabled,
      id: id,
      ref: ref
    }, rest), children), /*#__PURE__*/React__default["default"].createElement(ChevronDown16, {
      className: "".concat(prefix, "--select__arrow"),
      "aria-hidden": "true"
    }));
  });
  TimePickerSelect$3.propTypes = {
    /**
     * Provide the contents of your TimePickerSelect
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the node containing the label and the select box
     */
    className: PropTypes__default["default"].string,

    /**
     * Optionally provide the default value of the `<select>`
     */
    defaultValue: PropTypes__default["default"].any,

    /**
     * Specify whether the control is disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Provide a description for the twistie icon that can be read by screen readers
     */
    iconDescription: deprecate(PropTypes__default["default"].string, 'The `iconDescription` prop for `TimePickerSelect` is no longer needed and has ' + 'been deprecated. It will be moved in the next major release. Use "aria-label" instead'),

    /**
     * Specify a custom `id` for the `<select>`
     */
    id: PropTypes__default["default"].string.isRequired
  };
  var TimePickerSelectNext = TimePickerSelect$3;

  var _defineProperty2$3;

  var _excluded$J = ["aria-label", "children", "className", "disabled", "hideLabel", "id", "iconDescription", "labelText"];

  var TimePickerSelect$2 = /*#__PURE__*/function (_Component) {
    _inherits(TimePickerSelect, _Component);

    var _super = _createSuper(TimePickerSelect);

    function TimePickerSelect() {
      _classCallCheck$1(this, TimePickerSelect);

      return _super.apply(this, arguments);
    }

    _createClass$1(TimePickerSelect, [{
      key: "render",
      value: function render() {
        var _classNames;

        var prefix = this.context;

        var _this$props = this.props,
            _this$props$ariaLabe = _this$props['aria-label'],
            ariaLabel = _this$props$ariaLabe === void 0 ? 'open list of options' : _this$props$ariaLabe,
            children = _this$props.children,
            className = _this$props.className,
            disabled = _this$props.disabled,
            _this$props$hideLabel = _this$props.hideLabel,
            hideLabel = _this$props$hideLabel === void 0 ? true : _this$props$hideLabel,
            id = _this$props.id,
            iconDescription = _this$props.iconDescription,
            labelText = _this$props.labelText,
            rest = _objectWithoutProperties$2(_this$props, _excluded$J);

        var selectClasses = cx((_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--select"), true), _defineProperty$2(_classNames, "".concat(prefix, "--time-picker__select"), true), _defineProperty$2(_classNames, className, className), _classNames));
        var labelClasses = cx("".concat(prefix, "--label"), _defineProperty$2({}, "".concat(prefix, "--visually-hidden"), hideLabel));
        var label = labelText ? /*#__PURE__*/React__default["default"].createElement("label", {
          htmlFor: id,
          className: labelClasses
        }, labelText) : null;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: selectClasses
        }, label, /*#__PURE__*/React__default["default"].createElement("select", _extends$3({
          className: "".concat(prefix, "--select-input"),
          disabled: disabled,
          id: id,
          "aria-label": ariaLabel
        }, rest), children), /*#__PURE__*/React__default["default"].createElement(ChevronDown16, {
          className: "".concat(prefix, "--select__arrow"),
          "aria-label": ariaLabel ? ariaLabel : iconDescription
        }));
      }
    }]);

    return TimePickerSelect;
  }(React.Component);

  _defineProperty$2(TimePickerSelect$2, "contextType", PrefixContext);

  _defineProperty$2(TimePickerSelect$2, "propTypes", (_defineProperty2$3 = {}, _defineProperty$2(_defineProperty2$3, 'aria-label', PropTypes__default["default"].string), _defineProperty$2(_defineProperty2$3, "children", PropTypes__default["default"].node), _defineProperty$2(_defineProperty2$3, "className", PropTypes__default["default"].string), _defineProperty$2(_defineProperty2$3, "defaultValue", PropTypes__default["default"].any), _defineProperty$2(_defineProperty2$3, "disabled", PropTypes__default["default"].bool), _defineProperty$2(_defineProperty2$3, "hideLabel", deprecate(PropTypes__default["default"].bool, 'The `hideLabel` prop for `TimePickerSelect` is no longer needed and has ' + 'been deprecated. It will be removed in the next major release.')), _defineProperty$2(_defineProperty2$3, "iconDescription", deprecate(PropTypes__default["default"].string, 'The `iconDescription` prop for `TimePickerSelect` is no longer needed and has ' + 'been deprecated. It will be removed in the next major release. Use `aria-label` instead.')), _defineProperty$2(_defineProperty2$3, "id", PropTypes__default["default"].string.isRequired), _defineProperty$2(_defineProperty2$3, "labelText", PropTypes__default["default"].node.isRequired), _defineProperty2$3));

  _defineProperty$2(TimePickerSelect$2, "defaultProps", {
    disabled: false
  });

  var TimePickerSelect = enabled('enable-v11-release') ? TimePickerSelectNext : TimePickerSelect$2;
  var TimePickerSelect$1 = TimePickerSelect;

  var _excluded$I = ["className", "defaultToggled", "disabled", "hideLabel", "id", "labelA", "labelB", "labelText", "onClick", "onToggle", "size", "toggled"];
  function Toggle$3(_ref) {
    var className = _ref.className,
        _ref$defaultToggled = _ref.defaultToggled,
        defaultToggled = _ref$defaultToggled === void 0 ? false : _ref$defaultToggled,
        _ref$disabled = _ref.disabled,
        disabled = _ref$disabled === void 0 ? false : _ref$disabled,
        _ref$hideLabel = _ref.hideLabel,
        hideLabel = _ref$hideLabel === void 0 ? false : _ref$hideLabel,
        id = _ref.id,
        _ref$labelA = _ref.labelA,
        labelA = _ref$labelA === void 0 ? 'Off' : _ref$labelA,
        _ref$labelB = _ref.labelB,
        labelB = _ref$labelB === void 0 ? 'On' : _ref$labelB,
        labelText = _ref.labelText,
        onClick = _ref.onClick,
        onToggle = _ref.onToggle,
        _ref$size = _ref.size,
        size = _ref$size === void 0 ? 'md' : _ref$size,
        toggled = _ref.toggled,
        other = _objectWithoutProperties$2(_ref, _excluded$I);

    var prefix = usePrefix();

    var _useControllableState = useControllableState({
      value: toggled,
      onChange: onToggle,
      defaultValue: defaultToggled
    }),
        _useControllableState2 = _slicedToArray$1(_useControllableState, 2),
        checked = _useControllableState2[0],
        setChecked = _useControllableState2[1];

    function handleClick(e) {
      setChecked(!checked);

      if (onClick) {
        onClick(e);
      }
    }

    var isSm = size === 'sm';
    var sideLabel = hideLabel ? labelText : checked ? labelB : labelA;
    var wrapperClasses = cx("".concat(prefix, "--toggle"), _defineProperty$2({}, "".concat(prefix, "--toggle--disabled"), disabled), className);
    var labelTextClasses = cx("".concat(prefix, "--toggle__label-text"), _defineProperty$2({}, "".concat(prefix, "--visually-hidden"), hideLabel));
    var appearanceClasses = cx("".concat(prefix, "--toggle__appearance"), _defineProperty$2({}, "".concat(prefix, "--toggle__appearance--sm"), isSm));
    var switchClasses = cx("".concat(prefix, "--toggle__switch"), _defineProperty$2({}, "".concat(prefix, "--toggle__switch--checked"), checked));
    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: wrapperClasses
    }, /*#__PURE__*/React__default["default"].createElement("button", _extends$3({}, other, {
      id: id,
      className: "".concat(prefix, "--toggle__button"),
      role: "switch",
      type: "button",
      "aria-checked": checked,
      disabled: disabled,
      onClick: handleClick
    })), /*#__PURE__*/React__default["default"].createElement("label", {
      htmlFor: id,
      className: "".concat(prefix, "--toggle__label")
    }, /*#__PURE__*/React__default["default"].createElement("span", {
      className: labelTextClasses
    }, labelText), /*#__PURE__*/React__default["default"].createElement("div", {
      className: appearanceClasses
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: switchClasses
    }, isSm && /*#__PURE__*/React__default["default"].createElement("svg", {
      className: "".concat(prefix, "--toggle__check"),
      width: "6px",
      height: "5px",
      viewBox: "0 0 6 5"
    }, /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M2.2 2.7L5 0 6 1 2.2 5 0 2.7 1 1.5z"
    }))), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--toggle__text"),
      "aria-hidden": "true"
    }, sideLabel))));
  }
  Toggle$3.propTypes = {
    /**
     * Specify a custom className to apply to the form-item node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the toggle should be on by default
     */
    defaultToggled: PropTypes__default["default"].bool,

    /**
     * Whether this control should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Specify whether the label should be hidden, or not
     */
    hideLabel: PropTypes__default["default"].bool,

    /**
     * Provide an id that unique represents the underlying `<button>`
     */
    id: PropTypes__default["default"].string.isRequired,

    /**
     * Specify the label for the "off" position
     */
    labelA: PropTypes__default["default"].node,

    /**
     * Specify the label for the "on" position
     */
    labelB: PropTypes__default["default"].node,

    /**
     * Provide the text that will be read by a screen reader when visiting this
     * control
     */
    labelText: PropTypes__default["default"].node.isRequired,

    /**
     * Provide an event listener that is called when the control is clicked
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Provide an event listener that is called when the control is toggled
     */
    onToggle: PropTypes__default["default"].func,

    /**
     * Specify the size of the Toggle. Currently only supports 'sm' or 'md' (default)
     */
    size: PropTypes__default["default"].oneOf(['sm', 'md']),

    /**
     * Specify whether the control is toggled
     */
    toggled: PropTypes__default["default"].bool
  };

  var _defineProperty2$2, _defineProperty3$1;

  var _excluded$H = ["className", "defaultToggled", "toggled", "onChange", "onToggle", "id", "labelText", "labelA", "labelB", "size"];
  var getInstanceId$3 = setupGetInstanceId$2();

  var Toggle$2 = /*#__PURE__*/function (_React$Component) {
    _inherits(Toggle, _React$Component);

    var _super = _createSuper(Toggle);

    function Toggle() {
      _classCallCheck$1(this, Toggle);

      return _super.apply(this, arguments);
    }

    _createClass$1(Toggle, [{
      key: "render",
      value: function render() {
        var prefix = this.context;

        var _this$props = this.props,
            className = _this$props.className,
            defaultToggled = _this$props.defaultToggled,
            toggled = _this$props.toggled,
            _onChange = _this$props.onChange,
            onToggle = _this$props.onToggle,
            _this$props$id = _this$props.id,
            id = _this$props$id === void 0 ? this.inputId = this.inputId || "__carbon-toggle_".concat(getInstanceId$3()) : _this$props$id,
            labelText = _this$props.labelText,
            labelA = _this$props.labelA,
            labelB = _this$props.labelB,
            size = _this$props.size,
            other = _objectWithoutProperties$2(_this$props, _excluded$H);

        var input;
        var wrapperClasses = cx("".concat(prefix, "--form-item"), _defineProperty$2({}, className, className));
        var toggleClasses = cx("".concat(prefix, "--toggle-input"), _defineProperty$2({}, "".concat(prefix, "--toggle-input--small"), size === 'sm'));
        var checkedProps = {};

        if (typeof toggled !== 'undefined') {
          checkedProps.checked = toggled;
        } else {
          checkedProps.defaultChecked = defaultToggled;
        }

        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: wrapperClasses
        }, /*#__PURE__*/React__default["default"].createElement("input", _extends$3({}, other, checkedProps, {
          "aria-label": null,
          type: "checkbox",
          id: id,
          className: toggleClasses,
          onChange: function onChange(evt) {
            _onChange && _onChange(evt);
            onToggle(input.checked, id, evt);
          },
          ref: function ref(el) {
            input = el;
          },
          onKeyUp: function onKeyUp(evt) {
            if (match(evt, Enter)) {
              input.checked = !input.checked;
              _onChange && _onChange(evt);
              onToggle(input.checked, id, evt);
            }
          }
        })), /*#__PURE__*/React__default["default"].createElement("label", {
          className: "".concat(prefix, "--toggle-input__label"),
          htmlFor: id,
          "aria-label": typeof labelText === 'string' ? null : this.props['aria-label']
        }, labelText, /*#__PURE__*/React__default["default"].createElement("span", {
          className: "".concat(prefix, "--toggle__switch")
        }, size && /*#__PURE__*/React__default["default"].createElement("svg", {
          className: "".concat(prefix, "--toggle__check"),
          width: "6px",
          height: "5px",
          viewBox: "0 0 6 5"
        }, /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M2.2 2.7L5 0 6 1 2.2 5 0 2.7 1 1.5z"
        })), /*#__PURE__*/React__default["default"].createElement("span", {
          className: "".concat(prefix, "--toggle__text--off"),
          "aria-hidden": "true"
        }, labelA), /*#__PURE__*/React__default["default"].createElement("span", {
          className: "".concat(prefix, "--toggle__text--on"),
          "aria-hidden": "true"
        }, labelB))));
      }
    }]);

    return Toggle;
  }(React__default["default"].Component);

  _defineProperty$2(Toggle$2, "propTypes", (_defineProperty2$2 = {}, _defineProperty$2(_defineProperty2$2, 'aria-label', PropTypes__default["default"].string.isRequired), _defineProperty$2(_defineProperty2$2, "className", PropTypes__default["default"].string), _defineProperty$2(_defineProperty2$2, "defaultToggled", PropTypes__default["default"].bool), _defineProperty$2(_defineProperty2$2, "id", PropTypes__default["default"].string.isRequired), _defineProperty$2(_defineProperty2$2, "labelA", PropTypes__default["default"].node.isRequired), _defineProperty$2(_defineProperty2$2, "labelB", PropTypes__default["default"].node.isRequired), _defineProperty$2(_defineProperty2$2, "labelText", PropTypes__default["default"].node), _defineProperty$2(_defineProperty2$2, "onChange", PropTypes__default["default"].func), _defineProperty$2(_defineProperty2$2, "onToggle", PropTypes__default["default"].func), _defineProperty$2(_defineProperty2$2, "size", PropTypes__default["default"].oneOf(['sm', 'md'])), _defineProperty$2(_defineProperty2$2, "toggled", PropTypes__default["default"].bool), _defineProperty2$2));

  _defineProperty$2(Toggle$2, "contextType", PrefixContext);

  _defineProperty$2(Toggle$2, "defaultProps", (_defineProperty3$1 = {
    defaultToggled: false
  }, _defineProperty$2(_defineProperty3$1, 'aria-label', 'Toggle'), _defineProperty$2(_defineProperty3$1, "labelA", 'Off'), _defineProperty$2(_defineProperty3$1, "labelB", 'On'), _defineProperty$2(_defineProperty3$1, "onToggle", function onToggle() {}), _defineProperty3$1));

  var ToggleClassic = Toggle$2;

  var _defineProperty2$1, _defineProperty3;

  var _excluded$G = ["id", "labelText", "className", "size"];

  var ToggleSkeleton = /*#__PURE__*/function (_React$Component) {
    _inherits(ToggleSkeleton, _React$Component);

    var _super = _createSuper(ToggleSkeleton);

    function ToggleSkeleton() {
      _classCallCheck$1(this, ToggleSkeleton);

      return _super.apply(this, arguments);
    }

    _createClass$1(ToggleSkeleton, [{
      key: "render",
      value: function render() {
        var _this = this;

        var _this$props = this.props,
            id = _this$props.id,
            labelText = _this$props.labelText,
            className = _this$props.className,
            size = _this$props.size,
            rest = _objectWithoutProperties$2(_this$props, _excluded$G);

        return /*#__PURE__*/React__default["default"].createElement(PrefixContext.Consumer, null, function (prefix) {
          var toggleInputClassNames = cx("".concat(prefix, "--toggle ").concat(prefix, "--skeleton"), _defineProperty$2({}, "".concat(prefix, "--toggle-input--small"), size === 'sm'));
          return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
            className: cx("".concat(prefix, "--form-item"), className)
          }, rest), /*#__PURE__*/React__default["default"].createElement("input", {
            type: "checkbox",
            id: id,
            className: toggleInputClassNames
          }), /*#__PURE__*/React__default["default"].createElement("label", {
            className: "".concat(prefix, "--toggle-input__label"),
            htmlFor: id,
            "aria-label": labelText ? null : _this.props['aria-label']
          }, labelText ? /*#__PURE__*/React__default["default"].createElement("div", null, labelText) : null, /*#__PURE__*/React__default["default"].createElement("span", {
            className: "".concat(prefix, "--toggle__switch")
          }, /*#__PURE__*/React__default["default"].createElement("span", {
            className: "".concat(prefix, "--toggle__text--left")
          }), /*#__PURE__*/React__default["default"].createElement("span", {
            className: "".concat(prefix, "--toggle__appearance")
          }), /*#__PURE__*/React__default["default"].createElement("span", {
            className: "".concat(prefix, "--toggle__text--right")
          }))));
        });
      }
    }]);

    return ToggleSkeleton;
  }(React__default["default"].Component);

  _defineProperty$2(ToggleSkeleton, "propTypes", (_defineProperty2$1 = {}, _defineProperty$2(_defineProperty2$1, 'aria-label', PropTypes__default["default"].string.isRequired), _defineProperty$2(_defineProperty2$1, "className", PropTypes__default["default"].string), _defineProperty$2(_defineProperty2$1, "id", PropTypes__default["default"].string), _defineProperty$2(_defineProperty2$1, "labelText", PropTypes__default["default"].string), _defineProperty$2(_defineProperty2$1, "size", PropTypes__default["default"].oneOf(['sm', 'md'])), _defineProperty2$1));

  _defineProperty$2(ToggleSkeleton, "defaultProps", (_defineProperty3 = {}, _defineProperty$2(_defineProperty3, 'aria-label', 'Toggle is loading'), _defineProperty$2(_defineProperty3, "size", 'md'), _defineProperty3));

  var Toggle = createComponentToggle({
    name: 'Toggle',
    next: Toggle$3,
    classic: ToggleClassic
  });
  var Toggle$1 = Toggle;

  var _defineProperty2;

  var _excluded$F = ["id", "labelText", "className"];

  var ToggleSmallSkeleton = /*#__PURE__*/function (_React$Component) {
    _inherits(ToggleSmallSkeleton, _React$Component);

    var _super = _createSuper(ToggleSmallSkeleton);

    function ToggleSmallSkeleton() {
      _classCallCheck$1(this, ToggleSmallSkeleton);

      return _super.apply(this, arguments);
    }

    _createClass$1(ToggleSmallSkeleton, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            id = _this$props.id,
            labelText = _this$props.labelText,
            className = _this$props.className,
            rest = _objectWithoutProperties$2(_this$props, _excluded$F);

        return /*#__PURE__*/React__default["default"].createElement(PrefixContext.Consumer, null, function (prefix) {
          return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
            className: cx("".concat(prefix, "--form-item"), className)
          }, rest), /*#__PURE__*/React__default["default"].createElement("input", {
            type: "checkbox",
            id: id,
            className: "".concat(prefix, "--toggle ").concat(prefix, "--toggle--small ").concat(prefix, "--skeleton")
          }), /*#__PURE__*/React__default["default"].createElement("label", {
            className: "".concat(prefix, "--toggle__label ").concat(prefix, "--skeleton"),
            htmlFor: id
          }, labelText && /*#__PURE__*/React__default["default"].createElement("span", {
            className: "".concat(prefix, "--toggle__label-text")
          }, labelText), /*#__PURE__*/React__default["default"].createElement("span", {
            className: "".concat(prefix, "--toggle__appearance")
          }, /*#__PURE__*/React__default["default"].createElement("svg", {
            className: "".concat(prefix, "--toggle__check"),
            width: "6px",
            height: "5px",
            viewBox: "0 0 6 5"
          }, /*#__PURE__*/React__default["default"].createElement("path", {
            d: "M2.2403 2.7299L4.9245 0 6 1.1117 2.2384 5 0 2.6863 1.0612 1.511z"
          })))));
        });
      }
    }]);

    return ToggleSmallSkeleton;
  }(React__default["default"].Component);

  _defineProperty$2(ToggleSmallSkeleton, "propTypes", (_defineProperty2 = {}, _defineProperty$2(_defineProperty2, 'aria-label', PropTypes__default["default"].string.isRequired), _defineProperty$2(_defineProperty2, "className", PropTypes__default["default"].string), _defineProperty$2(_defineProperty2, "id", PropTypes__default["default"].string), _defineProperty$2(_defineProperty2, "labelText", PropTypes__default["default"].string), _defineProperty2));

  _defineProperty$2(ToggleSmallSkeleton, "defaultProps", _defineProperty$2({}, 'aria-label', 'Toggle is loading'));

  var _ToggleSmall$propType;

  var _excluded$E = ["className", "defaultToggled", "toggled", "onChange", "onToggle", "id", "labelText", "labelA", "labelB"];
  var didWarnAboutDeprecation$2 = false;

  var ToggleSmall = function ToggleSmall(_ref) {
    var className = _ref.className,
        defaultToggled = _ref.defaultToggled,
        toggled = _ref.toggled,
        _onChange = _ref.onChange,
        onToggle = _ref.onToggle,
        id = _ref.id,
        labelText = _ref.labelText,
        labelA = _ref.labelA,
        labelB = _ref.labelB,
        other = _objectWithoutProperties$2(_ref, _excluded$E);

    var prefix = usePrefix();

    {
      warning(didWarnAboutDeprecation$2, '`<ToggleSmall>` has been deprecated in favor of `<Toggle size="sm" />` and will be removed in the next major release of `carbon-components-react`') ;
      didWarnAboutDeprecation$2 = true;
    }

    var input;
    var wrapperClasses = cx("".concat(prefix, "--form-item"), _defineProperty$2({}, className, className));
    var checkedProps = {};

    if (typeof toggled !== 'undefined') {
      checkedProps.checked = toggled;
    } else {
      checkedProps.defaultChecked = defaultToggled;
    }

    var ariaLabel = typeof labelText === 'string' && labelText || other['aria-label'] || other.ariaLabel || null;
    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: wrapperClasses
    }, /*#__PURE__*/React__default["default"].createElement("input", _extends$3({}, other, checkedProps, {
      "aria-label": null,
      type: "checkbox",
      id: id,
      className: "".concat(prefix, "--toggle-input ").concat(prefix, "--toggle-input--small"),
      onChange: function onChange(evt) {
        _onChange && _onChange(evt);
        onToggle(input.checked, id, evt);
      },
      ref: function ref(el) {
        input = el;
      },
      onKeyUp: function onKeyUp(evt) {
        if (match(evt, Enter)) {
          input.checked = !input.checked;
          _onChange && _onChange(evt);
          onToggle(input.checked, id, evt);
        }
      }
    })), /*#__PURE__*/React__default["default"].createElement("label", {
      className: "".concat(prefix, "--toggle-input__label"),
      htmlFor: id,
      "aria-label": ariaLabel
    }, labelText, /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--toggle__switch")
    }, /*#__PURE__*/React__default["default"].createElement("svg", {
      className: "".concat(prefix, "--toggle__check"),
      width: "6px",
      height: "5px",
      viewBox: "0 0 6 5"
    }, /*#__PURE__*/React__default["default"].createElement("path", {
      d: "M2.2 2.7L5 0 6 1 2.2 5 0 2.7 1 1.5z"
    })), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--toggle__text--off"),
      "aria-hidden": "true"
    }, labelA), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--toggle__text--on"),
      "aria-hidden": "true"
    }, labelB))));
  };

  ToggleSmall.propTypes = (_ToggleSmall$propType = {}, _defineProperty$2(_ToggleSmall$propType, 'aria-label', PropTypes__default["default"].string.isRequired), _defineProperty$2(_ToggleSmall$propType, "className", PropTypes__default["default"].string), _defineProperty$2(_ToggleSmall$propType, "defaultToggled", PropTypes__default["default"].bool), _defineProperty$2(_ToggleSmall$propType, "id", PropTypes__default["default"].string.isRequired), _defineProperty$2(_ToggleSmall$propType, "labelA", PropTypes__default["default"].node.isRequired), _defineProperty$2(_ToggleSmall$propType, "labelB", PropTypes__default["default"].node.isRequired), _defineProperty$2(_ToggleSmall$propType, "labelText", PropTypes__default["default"].node), _defineProperty$2(_ToggleSmall$propType, "onChange", PropTypes__default["default"].func), _defineProperty$2(_ToggleSmall$propType, "onToggle", PropTypes__default["default"].func), _defineProperty$2(_ToggleSmall$propType, "toggled", PropTypes__default["default"].bool), _ToggleSmall$propType);
  ToggleSmall.defaultProps = {
    defaultToggled: false,
    onToggle: function onToggle() {},
    labelA: 'Off',
    labelB: 'On'
  };
  var ToggleSmall$1 = ToggleSmall;

  var _excluded$D = ["className", "type", "id", "placeHolderText", "labelText", "role", "labelId"];
  var didWarnAboutDeprecation$1 = false;

  var ToolbarSearch = /*#__PURE__*/function (_Component) {
    _inherits(ToolbarSearch, _Component);

    var _super = _createSuper(ToolbarSearch);

    function ToolbarSearch(props) {
      var _this;

      _classCallCheck$1(this, ToolbarSearch);

      _this = _super.call(this, props);

      _defineProperty$2(_assertThisInitialized$1(_this), "state", {
        expanded: false
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "expandSearch", function () {
        _this.setState({
          expanded: !_this.state.expanded
        });

        _this.input.focus();
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleClickOutside", function () {
        _this.setState({
          expanded: false
        });
      });

      {
        warning(didWarnAboutDeprecation$1, 'The ToolbarSearch component has been deprecated and will be removed in the next major release of `carbon-components-react`') ;
        didWarnAboutDeprecation$1 = true;
      }

      return _this;
    }

    _createClass$1(ToolbarSearch, [{
      key: "render",
      value: function render() {
        var _classNames,
            _this2 = this;

        var prefix = this.context;

        var _this$props = this.props,
            className = _this$props.className,
            type = _this$props.type,
            id = _this$props.id,
            placeHolderText = _this$props.placeHolderText,
            labelText = _this$props.labelText,
            role = _this$props.role,
            labelId = _this$props.labelId,
            other = _objectWithoutProperties$2(_this$props, _excluded$D);

        var searchClasses = cx((_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--search ").concat(prefix, "--search--sm ").concat(prefix, "--toolbar-search"), true), _defineProperty$2(_classNames, "".concat(prefix, "--toolbar-search--active"), this.state.expanded), _defineProperty$2(_classNames, className, className), _classNames));
        return /*#__PURE__*/React__default["default"].createElement(ClickListener, {
          onClickOutside: this.handleClickOutside
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: searchClasses,
          role: role
        }, /*#__PURE__*/React__default["default"].createElement("label", {
          htmlFor: id,
          className: "".concat(prefix, "--label"),
          id: labelId
        }, labelText), /*#__PURE__*/React__default["default"].createElement("input", _extends$3({}, other, {
          type: type,
          className: "".concat(prefix, "--search-input"),
          id: id,
          "aria-labelledby": labelId,
          placeholder: placeHolderText,
          ref: function ref(input) {
            _this2.input = input;
          }
        })), /*#__PURE__*/React__default["default"].createElement("button", {
          type: "button",
          className: "".concat(prefix, "--toolbar-search__btn"),
          title: labelText,
          onClick: this.expandSearch
        }, /*#__PURE__*/React__default["default"].createElement(Search16, {
          className: "".concat(prefix, "--search-magnifier"),
          "aria-label": labelText
        }))));
      }
    }]);

    return ToolbarSearch;
  }(React.Component);

  _defineProperty$2(ToolbarSearch, "contextType", PrefixContext);

  _defineProperty$2(ToolbarSearch, "propTypes", {
    /**
     * The child nodes.
     */
    children: PropTypes__default["default"].node,

    /**
     * The CSS class names.
     */
    className: PropTypes__default["default"].string,

    /**
     * The ID of the `<input>`.
     */
    id: PropTypes__default["default"].string,

    /**
     * The ID of the `<label>`.
     */
    labelId: PropTypes__default["default"].string,

    /**
     * The text in the `<label>`.
     */
    labelText: PropTypes__default["default"].node,

    /**
     * The placeholder text of the `<input>`.
     */
    placeHolderText: PropTypes__default["default"].string,

    /**
     * Optional prop to specify the role of the ToolbarSearch
     */
    role: PropTypes__default["default"].string,

    /**
     * `true` to use the small version of the UI.
     */
    small: PropTypes__default["default"].bool,

    /**
     * The `type` of the `<input>`.
     */
    type: PropTypes__default["default"].string
  });

  _defineProperty$2(ToolbarSearch, "defaultProps", {
    type: 'search',
    id: 'search__input',
    labelText: '',
    placeHolderText: '',
    role: 'search',
    labelId: 'search__label'
  });

  var _excluded$C = ["children", "className"];
  var didWarnAboutDeprecation = false;

  var Toolbar = function Toolbar(_ref) {
    var children = _ref.children,
        className = _ref.className,
        other = _objectWithoutProperties$2(_ref, _excluded$C);

    var prefix = usePrefix();
    var wrapperClasses = cx("".concat(prefix, "--toolbar"), className);

    {
      warning(didWarnAboutDeprecation, 'The Toolbar component has been deprecated and will be removed in the next major release of `carbon-components-react`') ;
      didWarnAboutDeprecation = true;
    }

    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: wrapperClasses
    }, other), children);
  };

  Toolbar.propTypes = {
    /**
     * Specify a collection of ToolbarItem's that should render in the Toolbar
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the containing Toolbar node
     */
    className: PropTypes__default["default"].string
  };
  var ToolbarItem = function ToolbarItem(_ref2) {
    var children = _ref2.children,
        type = _ref2.type,
        placeHolderText = _ref2.placeHolderText;
    var toolbarItem = type === 'search' ? /*#__PURE__*/React__default["default"].createElement(ToolbarSearch, {
      placeHolderText: placeHolderText
    }) : children;
    return toolbarItem;
  };
  ToolbarItem.propTypes = {
    /**
     * Specify the contents of the ToolbarItem
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify the placeholder text for the ToolbarSearch component. Useful if
     * `type` is set to 'search'
     */
    placeHolderText: PropTypes__default["default"].string,

    /**
     * Specify the type of the ToolbarItem. The `search` type will render a
     * `ToolbarSearch` component
     */
    type: PropTypes__default["default"].string
  };
  ToolbarItem.defaultProps = {
    placeHolderText: 'Provide placeHolderText'
  }; // eslint-disable-next-line react/display-name

  var ToolbarTitle = /*#__PURE__*/React__default["default"].forwardRef(function (_ref3, ref) {
    var title = _ref3.title;
    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("li", {
      ref: ref,
      className: "".concat(prefix, "--toolbar-menu__title")
    }, title);
  });
  ToolbarTitle.displayName = 'ToolbarTitle';
  ToolbarTitle.propTypes = {
    /**
     * Specify the title of the Toolbar
     */
    title: PropTypes__default["default"].string
  }; // eslint-disable-next-line react/display-name

  var ToolbarOption = /*#__PURE__*/React__default["default"].forwardRef(function (_ref4, ref) {
    var children = _ref4.children;
    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("li", {
      ref: ref,
      className: "".concat(prefix, "--toolbar-menu__option")
    }, children);
  });
  ToolbarOption.displayName = 'ToolbarOption';
  ToolbarOption.propTypes = {
    /**
     * Specify the contents of the ToolbarOption
     */
    children: PropTypes__default["default"].node
  }; // eslint-disable-next-line react/display-name

  var ToolbarDivider = /*#__PURE__*/React__default["default"].forwardRef(function (props, ref) {
    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("hr", {
      ref: ref,
      className: "".concat(prefix, "--toolbar-menu__divider")
    });
  });
  ToolbarDivider.displayName = 'ToolbarDivider';
  var Toolbar$1 = Toolbar;

  var _excluded$B = ["triggerId", "tooltipBodyId", "children", "className", "triggerClassName", "focusTrap", "triggerText", "showIcon", "iconName", "iconDescription", "renderIcon", "menuOffset", "tabIndex", "innerRef", "selectorPrimaryFocus", "tooltipId", "autoOrientation", "align"];
  /**
   * @param {Element} menuBody The menu body with the menu arrow.
   * @param {string} menuDirection Where the floating menu menu should be placed relative to the trigger button.
   * @returns {FloatingMenu~offset} The adjustment of the floating menu position, upon the position of the menu arrow.
   * @private
   */

  var getMenuOffset = function getMenuOffset(menuBody, menuDirection) {
    var _DIRECTION_LEFT$DIREC, _DIRECTION_LEFT$DIREC2;

    var arrowStyle = menuBody.ownerDocument.defaultView.getComputedStyle(menuBody, ':before');
    var arrowPositionProp = (_DIRECTION_LEFT$DIREC = {}, _defineProperty$2(_DIRECTION_LEFT$DIREC, DIRECTION_LEFT, 'right'), _defineProperty$2(_DIRECTION_LEFT$DIREC, DIRECTION_TOP, 'bottom'), _defineProperty$2(_DIRECTION_LEFT$DIREC, DIRECTION_RIGHT, 'left'), _defineProperty$2(_DIRECTION_LEFT$DIREC, DIRECTION_BOTTOM, 'top'), _DIRECTION_LEFT$DIREC)[menuDirection];
    var menuPositionAdjustmentProp = (_DIRECTION_LEFT$DIREC2 = {}, _defineProperty$2(_DIRECTION_LEFT$DIREC2, DIRECTION_LEFT, 'left'), _defineProperty$2(_DIRECTION_LEFT$DIREC2, DIRECTION_TOP, 'top'), _defineProperty$2(_DIRECTION_LEFT$DIREC2, DIRECTION_RIGHT, 'left'), _defineProperty$2(_DIRECTION_LEFT$DIREC2, DIRECTION_BOTTOM, 'top'), _DIRECTION_LEFT$DIREC2)[menuDirection];
    var values = [arrowPositionProp, 'border-bottom-width'].reduce(function (o, name) {
      return _objectSpread2$2(_objectSpread2$2({}, o), {}, _defineProperty$2({}, name, Number((/^([\d-]+)px$/.exec(arrowStyle.getPropertyValue(name)) || [])[1])));
    }, {});
    values[arrowPositionProp] = values[arrowPositionProp] || -6; // IE, etc.

    if (Object.keys(values).every(function (name) {
      return !isNaN(values[name]);
    })) {
      var arrowPosition = values[arrowPositionProp],
          borderBottomWidth = values['border-bottom-width'];
      return _defineProperty$2({
        left: 0,
        top: 0
      }, menuPositionAdjustmentProp, Math.sqrt(Math.pow(borderBottomWidth, 2) * 2) - arrowPosition);
    }
  };

  var Tooltip = /*#__PURE__*/function (_Component) {
    _inherits(Tooltip, _Component);

    var _super = _createSuper(Tooltip);

    function Tooltip(props) {
      var _this;

      _classCallCheck$1(this, Tooltip);

      _this = _super.call(this, props);

      _defineProperty$2(_assertThisInitialized$1(_this), "_tooltipEl", null);

      _defineProperty$2(_assertThisInitialized$1(_this), "_triggerRef", /*#__PURE__*/React__default["default"].createRef());

      _defineProperty$2(_assertThisInitialized$1(_this), "_tooltipId", _this.props.id || _this.props.tooltipId || "__carbon-tooltip_".concat(Math.random().toString(36).substr(2)));

      _defineProperty$2(_assertThisInitialized$1(_this), "_tooltipDismissed", false);

      _defineProperty$2(_assertThisInitialized$1(_this), "updateOrientation", function (params) {
        if (_this.props.autoOrientation) {
          var newOrientation = _this.getBestDirection(params);

          var direction = newOrientation.direction,
              align = newOrientation.align;

          if (direction !== _this.state.storedDirection) {
            _this.setState({
              open: false
            }, function () {
              _this.setState({
                open: true,
                storedDirection: direction
              });
            });
          }

          if (align === 'original') {
            _this.setState({
              storedAlign: _this.props.align
            });
          } else {
            _this.setState({
              storedAlign: align
            });
          }
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "getBestDirection", function (_ref2) {
        var menuSize = _ref2.menuSize,
            _ref2$refPosition = _ref2.refPosition,
            refPosition = _ref2$refPosition === void 0 ? {} : _ref2$refPosition,
            _ref2$offset = _ref2.offset,
            offset = _ref2$offset === void 0 ? {} : _ref2$offset,
            _ref2$direction = _ref2.direction,
            direction = _ref2$direction === void 0 ? DIRECTION_BOTTOM : _ref2$direction,
            _ref2$scrollX = _ref2.scrollX,
            pageXOffset = _ref2$scrollX === void 0 ? 0 : _ref2$scrollX,
            _ref2$scrollY = _ref2.scrollY,
            pageYOffset = _ref2$scrollY === void 0 ? 0 : _ref2$scrollY,
            container = _ref2.container;
        var _refPosition$left = refPosition.left,
            refLeft = _refPosition$left === void 0 ? 0 : _refPosition$left,
            _refPosition$top = refPosition.top,
            refTop = _refPosition$top === void 0 ? 0 : _refPosition$top,
            _refPosition$right = refPosition.right,
            refRight = _refPosition$right === void 0 ? 0 : _refPosition$right,
            _refPosition$bottom = refPosition.bottom,
            refBottom = _refPosition$bottom === void 0 ? 0 : _refPosition$bottom;
        var scrollX = container.position !== 'static' ? 0 : pageXOffset;
        var scrollY = container.position !== 'static' ? 0 : pageYOffset;
        var relativeDiff = {
          top: container.position !== 'static' ? container.rect.top : 0,
          left: container.position !== 'static' ? container.rect.left : 0
        };
        var width = menuSize.width,
            height = menuSize.height;
        var _offset$top = offset.top,
            top = _offset$top === void 0 ? 0 : _offset$top,
            _offset$left = offset.left,
            left = _offset$left === void 0 ? 0 : _offset$left;
        var refCenterHorizontal = (refLeft + refRight) / 2;
        var refCenterVertical = (refTop + refBottom) / 2; // Calculate whether a new direction is needed to stay in parent.
        // It will switch the current direction to the opposite i.e.
        // If the direction="top" and the top boundary is overflowed
        // then it switches the direction to "bottom".

        var newDirection = function newDirection() {
          switch (direction) {
            case DIRECTION_LEFT:
              return refLeft - width + scrollX - left - relativeDiff.left < 0 ? DIRECTION_RIGHT : direction;

            case DIRECTION_TOP:
              return refTop - height + scrollY - top - relativeDiff.top < 0 ? DIRECTION_BOTTOM : direction;

            case DIRECTION_RIGHT:
              return refRight + scrollX + left - relativeDiff.left + width > container.rect.width ? DIRECTION_LEFT : direction;

            case DIRECTION_BOTTOM:
              return refBottom + scrollY + top - relativeDiff.top + height > container.rect.height ? DIRECTION_TOP : direction;

            default:
              // If there is a new direction then ignore the logic above
              return direction;
          }
        }; // Calculate whether a new alignment is needed to stay in parent
        // If the direction is left or right this involves checking the
        // overflow in the vertical direction. If the direction is top or
        // bottom, this involves checking overflow in the horizontal direction.
        // "original" is used to signify no change.


        var newAlignment = function newAlignment() {
          switch (direction) {
            case DIRECTION_LEFT:
            case DIRECTION_RIGHT:
              if (refCenterVertical - height / 2 + scrollY + top - 9 - relativeDiff.top < 0) {
                // If goes above the top boundary
                return 'start';
              } else if (refCenterVertical - height / 2 + scrollY + top - 9 - relativeDiff.top + height > container.rect.height) {
                // If goes below the bottom boundary
                return 'end';
              } else {
                // No need to change alignment
                return 'original';
              }

            case DIRECTION_TOP:
            case DIRECTION_BOTTOM:
              if (refCenterHorizontal - width / 2 + scrollX + left - relativeDiff.left < 0) {
                // If goes below the left boundary
                return 'start';
              } else if (refCenterHorizontal - width / 2 + scrollX + left - relativeDiff.left + width > container.rect.width) {
                // If it goes over the right boundary
                return 'end';
              } else {
                // No need to change alignment
                return 'original';
              }

            default:
              // No need to change alignment
              return 'original';
          }
        };

        return {
          direction: newDirection(),
          align: newAlignment()
        };
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "_handleUserInputOpenClose", function (event, _ref3) {
        var open = _ref3.open;

        if (_this.isControlled && _this.props.onChange) {
          // Callback to the parent to let them decide what to do
          _this.props.onChange(event, {
            open: open
          });

          return;
        } // capture tooltip body element before it is removed from the DOM


        var tooltipBody = _this._tooltipEl;

        _this.setState({
          open: open
        }, function () {
          if (_this.props.onChange) {
            _this.props.onChange(event, {
              open: open
            });
          }

          if (!open && tooltipBody && tooltipBody.id === _this._tooltipId) {
            _this._tooltipDismissed = true;
            var currentActiveNode = event === null || event === void 0 ? void 0 : event.relatedTarget;

            if (!currentActiveNode && document.activeElement === document.body && (event === null || event === void 0 ? void 0 : event.type) !== 'click') {
              var _this$_triggerRef;

              (_this$_triggerRef = _this._triggerRef) === null || _this$_triggerRef === void 0 ? void 0 : _this$_triggerRef.current.focus();
            }
          }
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "_handleFocus", function (state, evt) {
        var currentTarget = evt.currentTarget,
            relatedTarget = evt.relatedTarget;

        if (currentTarget !== relatedTarget) {
          _this._tooltipDismissed = false;
        }

        if (state === 'over' && !_this.isControlled) {
          if (!_this._tooltipDismissed) {
            _this._handleUserInputOpenClose(evt, {
              open: true
            });
          }

          _this._tooltipDismissed = false;
        } else if (state !== 'out') {
          // Note: SVGElement in IE11 does not have `.contains()`
          var triggerEl = _this._triggerRef.current;

          var shouldPreventClose = relatedTarget && (triggerEl && (triggerEl === null || triggerEl === void 0 ? void 0 : triggerEl.contains(relatedTarget)) || _this._tooltipEl && _this._tooltipEl.contains(relatedTarget));

          if (!shouldPreventClose) {
            _this._handleUserInputOpenClose(evt, {
              open: false
            });
          }
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "_debouncedHandleFocus", null);

      _defineProperty$2(_assertThisInitialized$1(_this), "_getTarget", function () {
        var triggerEl = _this._triggerRef.current;
        return triggerEl && triggerEl.closest('[data-floating-menu-container]') || document.body;
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleMouse", function (evt) {
        evt.persist();
        var state = {
          focus: 'over',
          blur: 'out',
          click: 'click'
        }[evt.type];
        var hadContextMenu = _this._hasContextMenu;

        if (evt.type === 'click' || evt.type === 'contextmenu') {
          _this._hasContextMenu = evt.type === 'contextmenu';
        }

        if (_this._hasContextMenu) {
          _this._handleUserInputOpenClose(evt, {
            open: false
          });

          return;
        }

        if (state === 'click') {
          evt.preventDefault();
          var shouldOpen = _this.isControlled ? !_this.props.open : !_this.state.open;

          _this._handleUserInputOpenClose(evt, {
            open: shouldOpen
          });
        } else if (state && (state !== 'out' || !hadContextMenu)) {
          var _assertThisInitialize;

          (_assertThisInitialize = _assertThisInitialized$1(_this)) === null || _assertThisInitialize === void 0 ? void 0 : _assertThisInitialize._debouncedHandleFocus(state, evt);
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleClickOutside", function (evt) {
        var shouldPreventClose = evt && evt.target && _this._tooltipEl && _this._tooltipEl.contains(evt.target);

        if (!shouldPreventClose && _this.state.open) {
          _this._handleUserInputOpenClose(evt, {
            open: false
          });
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleKeyPress", function (event) {
        if (matches(event, [Escape, Tab$6])) {
          event.stopPropagation();

          _this._handleUserInputOpenClose(event, {
            open: false
          });
        }

        if (matches(event, [Enter, Space])) {
          event.stopPropagation();
          event.preventDefault();
          var shouldOpen = _this.isControlled ? !_this.props.open : !_this.state.open;

          _this._handleUserInputOpenClose(event, {
            open: shouldOpen
          });
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleEscKeyPress", function (event) {
        var _ref4 = _this.isControlled ? _this.props : _this.state,
            open = _ref4.open;

        if (open && matches(event, [Escape])) {
          event.stopPropagation();
          return _this._handleUserInputOpenClose(event, {
            open: false
          });
        }
      });

      _this.isControlled = props.open !== undefined;

      if (useControlledStateWithValue && _this.isControlled) {
        // Skips the logic of setting initial state if this component is controlled
        return _possibleConstructorReturn(_this);
      }

      var _open = useControlledStateWithValue ? props.defaultOpen : props.open;

      _this.state = {
        open: _open,
        storedDirection: props.direction,
        storedAlign: props.align
      };
      return _this;
    }

    _createClass$1(Tooltip, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        if (!this._debouncedHandleFocus) {
          this._debouncedHandleFocus = debounce$4(this._handleFocus, 200);
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps, prevState) {
        if (prevProps.direction != this.props.direction) {
          this.setState({
            storedDirection: this.props.direction
          });
        }

        if (prevProps.align != this.props.align) {
          this.setState({
            storedAlign: this.props.align
          });
        }

        if (prevState.open && !this.state.open) {
          // Reset orientation when closing
          this.setState({
            storedDirection: this.props.direction,
            storedAlign: this.props.align
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._debouncedHandleFocus) {
          this._debouncedHandleFocus.cancel();

          this._debouncedHandleFocus = null;
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props = this.props,
            _this$props$triggerId = _this$props.triggerId,
            triggerId = _this$props$triggerId === void 0 ? this.triggerId = this.triggerId || "__carbon-tooltip-trigger_".concat(Math.random().toString(36).substr(2)) : _this$props$triggerId,
            tooltipBodyId = _this$props.tooltipBodyId,
            children = _this$props.children,
            className = _this$props.className,
            triggerClassName = _this$props.triggerClassName,
            focusTrap = _this$props.focusTrap,
            triggerText = _this$props.triggerText,
            showIcon = _this$props.showIcon,
            iconName = _this$props.iconName,
            iconDescription = _this$props.iconDescription,
            IconCustomElement = _this$props.renderIcon,
            menuOffset = _this$props.menuOffset,
            _this$props$tabIndex = _this$props.tabIndex,
            tabIndex = _this$props$tabIndex === void 0 ? 0 : _this$props$tabIndex,
            ref = _this$props.innerRef;
            _this$props.selectorPrimaryFocus;
            _this$props.tooltipId;
            _this$props.autoOrientation;
            _this$props.align;
            var other = _objectWithoutProperties$2(_this$props, _excluded$B);

        var _ref5 = this.isControlled ? this.props : this.state,
            open = _ref5.open;

        var _this$state = this.state,
            storedDirection = _this$state.storedDirection,
            storedAlign = _this$state.storedAlign;
        return /*#__PURE__*/React__default["default"].createElement(PrefixContext.Consumer, null, function (prefix) {
          var _classNames;

          var tooltipClasses = cx("".concat(prefix, "--tooltip"), (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--tooltip--shown"), open), _defineProperty$2(_classNames, "".concat(prefix, "--tooltip--").concat(storedDirection), storedDirection), _defineProperty$2(_classNames, "".concat(prefix, "--tooltip--align-").concat(storedAlign), storedAlign), _classNames), className);
          var triggerClasses = cx("".concat(prefix, "--tooltip__label"), triggerClassName);
          var refProp = mergeRefs$1(_this2._triggerRef, ref);
          var iconProperties = {
            name: iconName,
            role: null,
            description: null
          };

          var properties = _objectSpread2$2({
            role: 'button',
            tabIndex: tabIndex,
            onClick: _this2.handleMouse,
            onContextMenu: _this2.handleMouse,
            onKeyDown: _this2.handleKeyPress,
            onMouseOver: _this2.handleMouse,
            onMouseOut: _this2.handleMouse,
            onFocus: _this2.handleMouse,
            onBlur: _this2.handleMouse,
            'aria-controls': !open ? undefined : _this2._tooltipId,
            'aria-expanded': open,
            'aria-describedby': open ? _this2._tooltipId : null
          }, triggerText ? {
            'aria-labelledby': triggerId
          } : {
            'aria-label': iconDescription
          });

          return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement(ClickListener, {
            onClickOutside: _this2.handleClickOutside
          }, showIcon ? /*#__PURE__*/React__default["default"].createElement("div", {
            id: triggerId,
            className: triggerClasses
          }, triggerText, /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
            className: "".concat(prefix, "--tooltip__trigger")
          }, properties, {
            ref: refProp,
            "aria-describedby": tooltipBodyId || properties['aria-describedby']
          }), /*#__PURE__*/React__default["default"].createElement(IconCustomElement, iconProperties))) : /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
            id: triggerId,
            className: triggerClasses,
            ref: refProp
          }, properties, {
            "aria-describedby": tooltipBodyId || properties['aria-describedby']
          }), triggerText)), open && /*#__PURE__*/React__default["default"].createElement(FloatingMenu, {
            focusTrap: focusTrap,
            selectorPrimaryFocus: _this2.props.selectorPrimaryFocus,
            target: _this2._getTarget,
            triggerRef: _this2._triggerRef,
            menuDirection: storedDirection,
            menuOffset: menuOffset,
            menuRef: function menuRef(node) {
              _this2._tooltipEl = node;
            },
            updateOrientation: _this2.updateOrientation
          }, /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
            className: tooltipClasses,
            onKeyDown: _this2.handleEscKeyPress
          }, other, {
            id: _this2._tooltipId,
            "data-floating-menu-direction": storedDirection,
            onMouseOver: _this2.handleMouse,
            onMouseOut: _this2.handleMouse,
            onFocus: _this2.handleMouse,
            onBlur: _this2.handleMouse,
            onContextMenu: _this2.handleMouse
          }), /*#__PURE__*/React__default["default"].createElement("span", {
            className: "".concat(prefix, "--tooltip__caret")
          }), /*#__PURE__*/React__default["default"].createElement("div", {
            className: "".concat(prefix, "--tooltip__content"),
            "aria-labelledby": _this2._tooltipId,
            role: "dialog"
          }, children))));
        });
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref6, state) {
        var open = _ref6.open;

        /**
         * so that tooltip can be controlled programmatically through this `open` prop
         */
        var prevOpen = state.prevOpen;
        return prevOpen === open ? null : {
          open: open,
          prevOpen: open
        };
      }
    }]);

    return Tooltip;
  }(React.Component);

  _defineProperty$2(Tooltip, "propTypes", _objectSpread2$2({
    /**
     * Specify the alignment (to the trigger button) of the tooltip.
     * Can be one of: start, center, or end.
     */
    align: PropTypes__default["default"].oneOf(['start', 'center', 'end']),

    /**
     * Whether or not to re-orientate the tooltip if it goes outside,
     * of the bounds of the parent.
     */
    autoOrientation: PropTypes__default["default"].bool,

    /**
     * Contents to put into the tooltip.
     */
    children: PropTypes__default["default"].node,

    /**
     * The CSS class names of the tooltip.
     */
    className: PropTypes__default["default"].string,

    /**
     * Optional starting value for uncontrolled state
     */
    defaultOpen: PropTypes__default["default"].bool,

    /**
     * Where to put the tooltip, relative to the trigger UI.
     */
    direction: PropTypes__default["default"].oneOf(['bottom', 'top', 'left', 'right']),

    /**
     * Enable or disable focus trap behavior
     */
    focusTrap: PropTypes__default["default"].bool,

    /**
     * The name of the default tooltip icon.
     */
    iconName: PropTypes__default["default"].string,

    /**
     * The adjustment of the tooltip position.
     */
    menuOffset: PropTypes__default["default"].oneOfType([PropTypes__default["default"].shape({
      top: PropTypes__default["default"].number,
      left: PropTypes__default["default"].number
    }), PropTypes__default["default"].func]),

    /**
     * * the signature of the event handler will be:
     * * `onChange(event, { open })` where:
     *   * `event` is the (React) raw event
     *   * `open` is the new value
     */
    onChange: !useControlledStateWithValue ? PropTypes__default["default"].func : requiredIfValueExists(PropTypes__default["default"].func),

    /**
     * Open/closed state.
     */
    open: PropTypes__default["default"].bool,

    /**
     * The callback function to optionally render the icon element.
     * It should be a component with React.forwardRef().
     */
    renderIcon: function renderIcon(props, propName, componentName) {
      if (props[propName] == undefined) {
        return;
      }

      var RefForwardingComponent = props[propName];

      if (!reactIs.exports.isForwardRef( /*#__PURE__*/React__default["default"].createElement(RefForwardingComponent, null))) {
        return new Error("Invalid value of prop '".concat(propName, "' supplied to '").concat(componentName, "',\n                          it should be created/wrapped with React.forwardRef() to have a ref and access the proper\n                          DOM node of the element to calculate its position in the viewport."));
      }
    },

    /**
     * Specify a CSS selector that matches the DOM element that should
     * be focused when the Tooltip opens
     */
    selectorPrimaryFocus: PropTypes__default["default"].string,

    /**
     * `true` to show the default tooltip icon.
     */
    showIcon: PropTypes__default["default"].bool,

    /**
     * Optional prop to specify the tabIndex of the Tooltip
     */
    tabIndex: PropTypes__default["default"].number,

    /**
     * The ID of the tooltip body content.
     */
    tooltipBodyId: PropTypes__default["default"].string,

    /**
     * The ID of the tooltip content.
     */
    tooltipId: PropTypes__default["default"].string,

    /**
     * The CSS class names of the trigger UI.
     */
    triggerClassName: PropTypes__default["default"].string,

    /**
     * The ID of the trigger button.
     */
    triggerId: PropTypes__default["default"].string
  }, isRequiredOneOf({
    /**
     * The content to put into the trigger UI, except the (default) tooltip icon.
     */
    triggerText: PropTypes__default["default"].node,

    /**
     * The description of the default tooltip icon, to be put in its SVG 'aria-label' and 'alt' .
     */
    iconDescription: PropTypes__default["default"].string
  })));

  _defineProperty$2(Tooltip, "defaultProps", {
    align: 'center',
    direction: DIRECTION_BOTTOM,
    focusTrap: true,
    renderIcon: Information16,
    showIcon: true,
    triggerText: null,
    menuOffset: getMenuOffset,
    selectorPrimaryFocus: '[data-tooltip-primary-focus]'
  });
  var Tooltip$1 = (function () {
    var forwardRef = function forwardRef(props, ref) {
      return /*#__PURE__*/React__default["default"].createElement(Tooltip, _extends$3({}, props, {
        innerRef: ref
      }));
    };

    forwardRef.displayName = 'Tooltip';
    return /*#__PURE__*/React__default["default"].forwardRef(forwardRef);
  })();

  var _excluded$A = ["id", "className", "triggerClassName", "children", "direction", "align", "onBlur", "onFocus", "onMouseEnter", "onMouseLeave", "tooltipText"];
  var getInstanceId$2 = setupGetInstanceId$2();

  var TooltipDefinition = function TooltipDefinition(_ref) {
    var _cx;

    var id = _ref.id,
        className = _ref.className,
        triggerClassName = _ref.triggerClassName,
        children = _ref.children,
        direction = _ref.direction,
        align = _ref.align,
        onBlur = _ref.onBlur,
        onFocus = _ref.onFocus,
        onMouseEnter = _ref.onMouseEnter,
        onMouseLeave = _ref.onMouseLeave,
        tooltipText = _ref.tooltipText,
        rest = _objectWithoutProperties$2(_ref, _excluded$A);

    var prefix = usePrefix();

    var _useState = React.useState(true),
        _useState2 = _slicedToArray$1(_useState, 2),
        allowTooltipVisibility = _useState2[0],
        setAllowTooltipVisibility = _useState2[1];

    var _useState3 = React.useState(false),
        _useState4 = _slicedToArray$1(_useState3, 2),
        tooltipVisible = _useState4[0],
        setTooltipVisible = _useState4[1];

    var tooltipId = id || "definition-tooltip-".concat(getInstanceId$2());
    var tooltipClassName = cx("".concat(prefix, "--tooltip--definition"), "".concat(prefix, "--tooltip--a11y"), className);
    var tooltipTriggerClasses = cx("".concat(prefix, "--tooltip__trigger"), "".concat(prefix, "--tooltip--a11y"), "".concat(prefix, "--tooltip__trigger--definition"), triggerClassName, (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--tooltip--").concat(direction), direction), _defineProperty$2(_cx, "".concat(prefix, "--tooltip--align-").concat(align), align), _defineProperty$2(_cx, "".concat(prefix, "--tooltip--hidden"), !allowTooltipVisibility), _defineProperty$2(_cx, "".concat(prefix, "--tooltip--visible"), tooltipVisible), _cx));
    var debounceTooltipVisible = debounce$4(function () {
      return setTooltipVisible(false);
    }, 100);

    var handleFocus = function handleFocus() {
      debounceTooltipVisible.cancel();
      setAllowTooltipVisibility(true);
      setTooltipVisible(true);
    };

    var handleBlur = debounceTooltipVisible;

    var handleMouseEnter = function handleMouseEnter() {
      debounceTooltipVisible.cancel();
      setAllowTooltipVisibility(true);
      setTooltipVisible(true);
    };

    var handleMouseLeave = debounceTooltipVisible;
    React.useEffect(function () {
      var handleEscKeyDown = function handleEscKeyDown(event) {
        if (matches(event, [Escape])) {
          setAllowTooltipVisibility(false);
        }
      };

      document.addEventListener('keydown', handleEscKeyDown);
      return function () {
        return document.removeEventListener('keydown', handleEscKeyDown);
      };
    }, []);
    return /*#__PURE__*/React__default["default"].createElement("span", _extends$3({}, rest, {
      className: tooltipClassName,
      onMouseEnter: composeEventHandlers([onMouseEnter, handleMouseEnter]),
      onMouseLeave: composeEventHandlers([onMouseLeave, handleMouseLeave])
    }), /*#__PURE__*/React__default["default"].createElement("button", {
      type: "button",
      className: tooltipTriggerClasses,
      "aria-describedby": tooltipId,
      onFocus: composeEventHandlers([onFocus, handleFocus]),
      onBlur: composeEventHandlers([onBlur, handleBlur])
    }, children), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--assistive-text"),
      id: tooltipId,
      role: "tooltip"
    }, tooltipText));
  };

  TooltipDefinition.propTypes = {
    /**
     * Specify the alignment (to the trigger button) of the tooltip.
     * Can be one of: start, center, or end.
     */
    align: PropTypes__default["default"].oneOf(['start', 'center', 'end']),

    /**
     * Specify the tooltip trigger text that is rendered to the UI for the user to
     * interact with in order to display the tooltip.
     */
    children: PropTypes__default["default"].node.isRequired,

    /**
     * Specify an optional className to be applied to the container node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the direction of the tooltip. Can be either top or bottom.
     */
    direction: PropTypes__default["default"].oneOf(['top', 'bottom']),

    /**
     * Optionally specify a custom id for the tooltip. If one is not provided, we
     * generate a unique id for you.
     */
    id: PropTypes__default["default"].string,

    /**
     * The event handler for the `blur` event.
     */
    onBlur: PropTypes__default["default"].func,

    /**
     * The event handler for the `focus` event.
     */
    onFocus: PropTypes__default["default"].func,

    /**
     * The event handler for the `mouseenter` event.
     */
    onMouseEnter: PropTypes__default["default"].func,

    /**
     * The event handler for the `mouseleave` event.
     */
    onMouseLeave: PropTypes__default["default"].func,

    /**
     * Provide the text that will be displayed in the tooltip when it is rendered.
     * TODO: rename this prop (will be a breaking change)
     */
    tooltipText: PropTypes__default["default"].node.isRequired,

    /**
     * The CSS class name of the trigger element
     */
    triggerClassName: PropTypes__default["default"].string
  };
  TooltipDefinition.defaultProps = {
    direction: 'bottom',
    align: 'start'
  };
  var TooltipDefinition$1 = TooltipDefinition;

  var _excluded$z = ["id", "className", "children", "direction", "disabled", "align", "onClick", "onBlur", "onFocus", "onMouseEnter", "onMouseLeave", "renderIcon", "tooltipText"];
  var getInstanceId$1 = setupGetInstanceId$2();

  var TooltipIcon = function TooltipIcon(_ref) {
    var _cx;

    var id = _ref.id,
        className = _ref.className,
        children = _ref.children,
        direction = _ref.direction,
        disabled = _ref.disabled,
        align = _ref.align,
        onClick = _ref.onClick,
        onBlur = _ref.onBlur,
        onFocus = _ref.onFocus,
        onMouseEnter = _ref.onMouseEnter,
        onMouseLeave = _ref.onMouseLeave,
        IconElement = _ref.renderIcon,
        tooltipText = _ref.tooltipText,
        rest = _objectWithoutProperties$2(_ref, _excluded$z);

    var prefix = usePrefix();

    var _useState = React.useState(true),
        _useState2 = _slicedToArray$1(_useState, 2),
        allowTooltipVisibility = _useState2[0],
        setAllowTooltipVisibility = _useState2[1];

    var _useState3 = React.useState(false),
        _useState4 = _slicedToArray$1(_useState3, 2),
        isHovered = _useState4[0],
        setIsHovered = _useState4[1];

    var _useState5 = React.useState(false),
        _useState6 = _slicedToArray$1(_useState5, 2),
        isFocused = _useState6[0],
        setIsFocused = _useState6[1];

    var tooltipRef = React.useRef(null);
    var tooltipTimeout = React.useRef(null);
    var tooltipId = id || "icon-tooltip-".concat(getInstanceId$1());
    var tooltipTriggerClasses = cx("".concat(prefix, "--tooltip__trigger"), "".concat(prefix, "--tooltip--a11y"), className, (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--tooltip--").concat(direction), direction), _defineProperty$2(_cx, "".concat(prefix, "--tooltip--align-").concat(align), align), _defineProperty$2(_cx, "".concat(prefix, "--tooltip--hidden"), !allowTooltipVisibility || disabled), _defineProperty$2(_cx, "".concat(prefix, "--tooltip--visible"), isHovered), _cx));

    var closeTooltips = function closeTooltips(evt) {
      var _document;

      var tooltipNode = (_document = document) === null || _document === void 0 ? void 0 : _document.querySelectorAll(".".concat(prefix, "--tooltip--a11y"));

      _toConsumableArray(tooltipNode).map(function (node) {
        toggleClass$1(node, "".concat(prefix, "--tooltip--hidden"), node !== evt.currentTarget);
      });
    };

    var handleFocus = function handleFocus(evt) {
      closeTooltips(evt);
      setIsFocused(true);
      setAllowTooltipVisibility(true);
    };

    var handleBlur = function handleBlur() {
      setIsHovered(false);
      setIsFocused(false);
      setAllowTooltipVisibility(false);
    };

    var handleMouseEnter = function handleMouseEnter(evt) {
      if (!disabled) {
        tooltipTimeout.current && clearTimeout(tooltipTimeout.current);

        if (evt.target === tooltipRef.current) {
          setAllowTooltipVisibility(true);
          return;
        }

        closeTooltips(evt);
        setAllowTooltipVisibility(true);
      }
    };

    var handleMouseLeave = function handleMouseLeave() {
      if (!isFocused) {
        tooltipTimeout.current = setTimeout(function () {
          setAllowTooltipVisibility(false);
          setIsHovered(false);
        }, 100);
      }
    };

    var handleClick = function handleClick(evt) {
      setAllowTooltipVisibility(false); // Prevent clicks on the tooltip from triggering the button click event

      if (evt.target === tooltipRef.current) {
        evt.preventDefault();
        return;
      }
    };

    React.useEffect(function () {
      var handleEscKeyDown = function handleEscKeyDown(event) {
        if (matches(event, [Escape])) {
          setAllowTooltipVisibility(false);
          setIsHovered(false);
        }
      };

      document.addEventListener('keydown', handleEscKeyDown);
      return function () {
        return document.removeEventListener('keydown', handleEscKeyDown);
      };
    }, []);
    var cursorStyle;

    if (disabled) {
      cursorStyle = 'not-allowed';
    } else {
      cursorStyle = onClick ? 'pointer' : 'default';
    }

    return /*#__PURE__*/React__default["default"].createElement("button", _extends$3({
      disabled: disabled,
      style: {
        cursor: cursorStyle
      }
    }, rest, {
      type: "button",
      className: tooltipTriggerClasses,
      "aria-describedby": tooltipId,
      onMouseEnter: composeEventHandlers([onMouseEnter, handleMouseEnter]),
      onMouseLeave: composeEventHandlers([onMouseLeave, handleMouseLeave]),
      onFocus: composeEventHandlers([onFocus, handleFocus]),
      onBlur: composeEventHandlers([onBlur, handleBlur]),
      onClick: composeEventHandlers([handleClick, onClick])
    }), /*#__PURE__*/React__default["default"].createElement("span", {
      ref: tooltipRef,
      onMouseEnter: handleMouseEnter,
      className: "".concat(prefix, "--assistive-text"),
      id: tooltipId
    }, tooltipText), IconElement && /*#__PURE__*/React__default["default"].createElement(IconElement, null), !IconElement && children);
  };

  TooltipIcon.propTypes = {
    /**
     * Specify the alignment (to the trigger button) of the tooltip.
     * Can be one of: start, center, or end.
     */
    align: PropTypes__default["default"].oneOf(['start', 'center', 'end']),

    /**
     * Specify an icon as children that will be used as the tooltip trigger. This
     * can be an icon from our Icon component, or a custom SVG element.
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the trigger node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the direction of the tooltip. Can be either top or bottom.
     */
    direction: PropTypes__default["default"].oneOf(['top', 'right', 'left', 'bottom']),

    /**
     * Specify whether the `<TooltipIcon>` should be disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Optionally specify a custom id for the tooltip. If one is not provided, we
     * generate a unique id for you.
     */
    id: PropTypes__default["default"].string,

    /**
     * The event handler for the `blur` event.
     */
    onBlur: PropTypes__default["default"].func,

    /**
     * The event handler for the `click` event.
     */
    onClick: PropTypes__default["default"].func,

    /**
     * The event handler for the `focus` event.
     */
    onFocus: PropTypes__default["default"].func,

    /**
     * The event handler for the `mouseenter` event.
     */
    onMouseEnter: PropTypes__default["default"].func,

    /**
     * The event handler for the `mouseleave` event.
     */
    onMouseLeave: PropTypes__default["default"].func,

    /**
     * Function called to override icon rendering.
     */
    renderIcon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),

    /**
     * Provide the ARIA label for the tooltip.
     * TODO: rename this prop (will be a breaking change)
     */
    tooltipText: PropTypes__default["default"].node.isRequired
  };
  TooltipIcon.defaultProps = {
    direction: 'bottom',
    align: 'center'
  };
  var TooltipIcon$1 = TooltipIcon;

  var _excluded$y = ["children", "className", "nested", "isExpressive"];

  var UnorderedList = function UnorderedList(_ref) {
    var _classnames;

    var children = _ref.children,
        className = _ref.className,
        nested = _ref.nested,
        isExpressive = _ref.isExpressive,
        other = _objectWithoutProperties$2(_ref, _excluded$y);

    var prefix = usePrefix();
    var classNames = cx("".concat(prefix, "--list--unordered"), className, (_classnames = {}, _defineProperty$2(_classnames, "".concat(prefix, "--list--nested"), nested), _defineProperty$2(_classnames, "".concat(prefix, "--list--expressive"), isExpressive), _classnames));
    return /*#__PURE__*/React__default["default"].createElement("ul", _extends$3({
      className: classNames
    }, other), children);
  };

  UnorderedList.propTypes = {
    /**
     * Specify a collection of ListItem's to be rendered in the UnorderedList
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the underlying `<ul>` node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether this ordered list expressive or not
     */
    isExpressive: PropTypes__default["default"].bool,

    /**
     * Specify whether the list is nested, or not
     */
    nested: PropTypes__default["default"].bool
  };
  UnorderedList.defaultProps = {
    nested: false,
    isExpressive: false
  };
  var UnorderedList$1 = UnorderedList;

  var _excluded$x = ["className"];

  var SkeletonPlaceholder = function SkeletonPlaceholder(_ref) {
    var _classNames;

    var className = _ref.className,
        other = _objectWithoutProperties$2(_ref, _excluded$x);

    var prefix = usePrefix();
    var skeletonPlaceholderClasses = cx((_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--skeleton__placeholder"), true), _defineProperty$2(_classNames, className, className), _classNames));
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: skeletonPlaceholderClasses
    }, other));
  };

  SkeletonPlaceholder.propTypes = {
    /**
     * the class to be applied to the component
     */
    className: PropTypes__default["default"].string
  };
  var SkeletonPlaceholder$1 = SkeletonPlaceholder;

  var _excluded$w = ["className"];

  var SkeletonIcon = function SkeletonIcon(_ref) {
    var _classNames;

    var className = _ref.className,
        other = _objectWithoutProperties$2(_ref, _excluded$w);

    var prefix = usePrefix();
    var skeletonIconClasses = cx((_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--icon--skeleton"), true), _defineProperty$2(_classNames, className, className), _classNames));
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({
      className: skeletonIconClasses
    }, other));
  };

  SkeletonIcon.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes__default["default"].string,

    /**
     * The CSS styles.
     */
    style: PropTypes__default["default"].object
  };
  var SkeletonIcon$1 = SkeletonIcon;

  var _excluded$v = ["headers", "rowCount", "columnCount", "zebra", "compact", "className", "showHeader", "showToolbar"];

  var DataTableSkeleton = function DataTableSkeleton(_ref) {
    var _cx;

    var headers = _ref.headers,
        rowCount = _ref.rowCount,
        columnCount = _ref.columnCount,
        zebra = _ref.zebra,
        compact = _ref.compact,
        className = _ref.className,
        showHeader = _ref.showHeader,
        showToolbar = _ref.showToolbar,
        rest = _objectWithoutProperties$2(_ref, _excluded$v);

    var prefix = usePrefix();
    var dataTableSkeletonClasses = cx(className, (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--skeleton"), true), _defineProperty$2(_cx, "".concat(prefix, "--data-table"), true), _defineProperty$2(_cx, "".concat(prefix, "--data-table--zebra"), zebra), _defineProperty$2(_cx, "".concat(prefix, "--data-table--compact"), compact), _cx));
    var rowRepeat = rowCount;
    var rows = Array(rowRepeat);
    var columnsArray = Array.from({
      length: columnCount
    }, function (_, index) {
      return index;
    });

    for (var i = 0; i < rowRepeat; i++) {
      rows[i] = /*#__PURE__*/React__default["default"].createElement("tr", {
        key: i
      }, columnsArray.map(function (j) {
        return /*#__PURE__*/React__default["default"].createElement("td", {
          key: j
        }, /*#__PURE__*/React__default["default"].createElement("span", null));
      }));
    }

    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--skeleton ").concat(prefix, "--data-table-container")
    }, showHeader ? /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--data-table-header")
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--data-table-header__title")
    }), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--data-table-header__description")
    })) : null, showToolbar ? /*#__PURE__*/React__default["default"].createElement("section", {
      "aria-label": "data table toolbar",
      className: "".concat(prefix, "--table-toolbar")
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--toolbar-content")
    }, /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--skeleton ").concat(prefix, "--btn ").concat(prefix, "--btn--sm")
    }))) : null, /*#__PURE__*/React__default["default"].createElement("table", _extends$3({
      className: dataTableSkeletonClasses
    }, rest), /*#__PURE__*/React__default["default"].createElement("thead", null, /*#__PURE__*/React__default["default"].createElement("tr", null, columnsArray.map(function (i) {
      var _headers$i;

      return /*#__PURE__*/React__default["default"].createElement("th", {
        key: i
      }, headers ? /*#__PURE__*/React__default["default"].createElement("div", {
        className: "bx--table-header-label"
      }, (_headers$i = headers[i]) === null || _headers$i === void 0 ? void 0 : _headers$i.header) : /*#__PURE__*/React__default["default"].createElement("span", null));
    }))), /*#__PURE__*/React__default["default"].createElement("tbody", null, rows)));
  };

  DataTableSkeleton.propTypes = {
    /**
     * Specify an optional className to add.
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the number of columns that you want to render in the skeleton state
     */
    columnCount: PropTypes__default["default"].number,

    /**
     * Optionally specify whether you want the Skeleton to be rendered as a
     * compact DataTable
     */
    compact: PropTypes__default["default"].bool,

    /**
     * Optionally specify the displayed headers
     */
    headers: PropTypes__default["default"].oneOfType([PropTypes__default["default"].array, PropTypes__default["default"].shape({
      key: PropTypes__default["default"].string
    })]),

    /**
     * Specify the number of rows that you want to render in the skeleton state
     */
    rowCount: PropTypes__default["default"].number,

    /**
     * Specify if the table header should be rendered as part of the skeleton.
     */
    showHeader: PropTypes__default["default"].bool,

    /**
     * Specify if the table toolbar should be rendered as part of the skeleton.
     */
    showToolbar: PropTypes__default["default"].bool,

    /**
     * Optionally specify whether you want the DataTable to be zebra striped
     */
    zebra: PropTypes__default["default"].bool
  };
  DataTableSkeleton.defaultProps = {
    rowCount: 5,
    columnCount: 5,
    zebra: false,
    compact: false,
    showHeader: true,
    showToolbar: true
  };
  var DataTableSkeleton$1 = DataTableSkeleton;

  var _excluded$u = ["aria-label", "aria-labelledby", "children", "className"];

  var HeaderNavigation$2 = /*#__PURE__*/function (_React$Component) {
    _inherits(HeaderNavigation, _React$Component);

    var _super = _createSuper(HeaderNavigation);

    function HeaderNavigation(props) {
      var _this;

      _classCallCheck$1(this, HeaderNavigation);

      _this = _super.call(this, props);

      _defineProperty$2(_assertThisInitialized$1(_this), "handleItemRef", function (index) {
        return function (node) {
          _this.items[index] = node;
        };
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "_renderNavItem", function (child, index) {
        if ( /*#__PURE__*/React__default["default"].isValidElement(child)) {
          return /*#__PURE__*/React__default["default"].cloneElement(child, {
            ref: _this.handleItemRef(index)
          });
        }
      });

      _this.items = [];
      _this.state = {
        selectedIndex: 0
      };
      return _this;
    }

    _createClass$1(HeaderNavigation, [{
      key: "render",
      value: function render() {
        var prefix = this.context;

        var _this$props = this.props,
            ariaLabel = _this$props['aria-label'],
            ariaLabelledBy = _this$props['aria-labelledby'],
            children = _this$props.children,
            customClassName = _this$props.className,
            rest = _objectWithoutProperties$2(_this$props, _excluded$u);

        var className = cx("".concat(prefix, "--header__nav"), customClassName); // Assign both label strategies in this option, only one should be defined
        // so when we spread that should be the one that is applied to the node

        var accessibilityLabel = {
          'aria-label': ariaLabel,
          'aria-labelledby': ariaLabelledBy
        };
        return /*#__PURE__*/React__default["default"].createElement("nav", _extends$3({}, rest, accessibilityLabel, {
          className: className
        }), /*#__PURE__*/React__default["default"].createElement("ul", _extends$3({}, accessibilityLabel, {
          className: "".concat(prefix, "--header__menu-bar")
        }), React__default["default"].Children.map(children, this._renderNavItem)));
      }
      /**
       * Render an individual menuitem, adding a `ref` for each child inside of
       * `this.items` to properly manage focus.
       */

    }]);

    return HeaderNavigation;
  }(React__default["default"].Component);

  _defineProperty$2(HeaderNavigation$2, "propTypes", _objectSpread2$2(_objectSpread2$2({}, AriaLabelPropType), {}, {
    /**
     * Provide valid children of HeaderNavigation, for example `HeaderMenuItem`
     * or `HeaderMenu`
     */
    children: PropTypes__default["default"].node,

    /**
     * Optionally provide a custom class to apply to the underlying <nav> node
     */
    className: PropTypes__default["default"].string
  }));

  _defineProperty$2(HeaderNavigation$2, "contextType", PrefixContext);

  var _excluded$t = ["aria-label", "aria-labelledby", "children", "className"];

  function HeaderNavigation$1(props) {
    var ariaLabel = props['aria-label'],
        ariaLabelledBy = props['aria-labelledby'],
        children = props.children,
        customClassName = props.className,
        rest = _objectWithoutProperties$2(props, _excluded$t);

    var prefix = usePrefix();
    var className = cx("".concat(prefix, "--header__nav"), customClassName); // Assign both label strategies in this option, only one should be defined
    // so when we spread that should be the one that is applied to the node

    var accessibilityLabel = {
      'aria-label': ariaLabel,
      'aria-labelledby': ariaLabelledBy
    };
    return /*#__PURE__*/React__default["default"].createElement("nav", _extends$3({}, rest, accessibilityLabel, {
      className: className
    }), /*#__PURE__*/React__default["default"].createElement("ul", {
      className: "".concat(prefix, "--header__menu-bar")
    }, children));
  }

  HeaderNavigation$1.propTypes = _objectSpread2$2(_objectSpread2$2({}, AriaLabelPropType), {}, {
    /**
     * Provide valid children of HeaderNavigation, for example `HeaderMenuItem`
     * or `HeaderMenu`
     */
    children: PropTypes__default["default"].node,

    /**
     * Optionally provide a custom class to apply to the underlying <nav> node
     */
    className: PropTypes__default["default"].string
  });

  var SideNavIcon = function SideNavIcon(_ref) {
    var _cx;

    var children = _ref.children,
        customClassName = _ref.className,
        small = _ref.small;
    var prefix = usePrefix();
    var className = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--side-nav__icon"), true), _defineProperty$2(_cx, "".concat(prefix, "--side-nav__icon--small"), small), _defineProperty$2(_cx, customClassName, !!customClassName), _cx));
    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: className
    }, children);
  };

  SideNavIcon.propTypes = {
    /**
     * Provide a single icon as the child to `SideNavIcon` to render in the
     * container
     */
    children: PropTypes__default["default"].node.isRequired,

    /**
     * Provide an optional class to be applied to the containing node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the icon should be placed in a smaller bounding box
     */
    small: PropTypes__default["default"].bool.isRequired
  };
  SideNavIcon.defaultProps = {
    small: false
  };
  var SideNavIcon$1 = SideNavIcon;

  var SideNavMenu$2 = /*#__PURE__*/React__default["default"].forwardRef(function SideNavMenu(props, ref) {
    var _cx;

    var customClassName = props.className,
        children = props.children,
        _props$defaultExpande = props.defaultExpanded,
        defaultExpanded = _props$defaultExpande === void 0 ? false : _props$defaultExpande,
        _props$isActive = props.isActive,
        isActive = _props$isActive === void 0 ? false : _props$isActive,
        _props$large = props.large,
        large = _props$large === void 0 ? false : _props$large,
        IconElement = props.renderIcon,
        isSideNavExpanded = props.isSideNavExpanded,
        title = props.title;
    var prefix = usePrefix();

    var _useState = React.useState(defaultExpanded),
        _useState2 = _slicedToArray$1(_useState, 2),
        isExpanded = _useState2[0],
        setIsExpanded = _useState2[1];

    var _useState3 = React.useState(defaultExpanded),
        _useState4 = _slicedToArray$1(_useState3, 2),
        prevExpanded = _useState4[0],
        setPrevExpanded = _useState4[1];

    var className = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--side-nav__item"), true), _defineProperty$2(_cx, "".concat(prefix, "--side-nav__item--active"), isActive || hasActiveChild(children) && !isExpanded), _defineProperty$2(_cx, "".concat(prefix, "--side-nav__item--icon"), IconElement), _defineProperty$2(_cx, "".concat(prefix, "--side-nav__item--large"), large), _defineProperty$2(_cx, customClassName, !!customClassName), _cx));

    if (isSideNavExpanded === false && isExpanded === true) {
      setIsExpanded(false);
      setPrevExpanded(true);
    } else if (isSideNavExpanded === true && prevExpanded === true) {
      setIsExpanded(true);
      setPrevExpanded(false);
    }

    return (
      /*#__PURE__*/
      // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
      React__default["default"].createElement("li", {
        className: className,
        onKeyDown: function onKeyDown(event) {
          if (match(event, Escape)) {
            setIsExpanded(false);
          }
        }
      }, /*#__PURE__*/React__default["default"].createElement("button", {
        "aria-expanded": isExpanded,
        className: "".concat(prefix, "--side-nav__submenu"),
        onClick: function onClick() {
          setIsExpanded(!isExpanded);
        },
        ref: ref,
        type: "button"
      }, IconElement && /*#__PURE__*/React__default["default"].createElement(SideNavIcon$1, null, /*#__PURE__*/React__default["default"].createElement(IconElement, null)), /*#__PURE__*/React__default["default"].createElement("span", {
        className: "".concat(prefix, "--side-nav__submenu-title")
      }, title), /*#__PURE__*/React__default["default"].createElement(SideNavIcon$1, {
        className: "".concat(prefix, "--side-nav__submenu-chevron"),
        small: true
      }, /*#__PURE__*/React__default["default"].createElement(ChevronDown20, null))), /*#__PURE__*/React__default["default"].createElement("ul", {
        className: "".concat(prefix, "--side-nav__menu")
      }, children))
    );
  });
  SideNavMenu$2.propTypes = {
    /**
     * Provide <SideNavMenuItem>'s inside of the `SideNavMenu`
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide an optional class to be applied to the containing node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the menu should default to expanded. By default, it will
     * be closed.
     */
    defaultExpanded: PropTypes__default["default"].bool,

    /**
     * Specify whether the `SideNavMenu` is "active". `SideNavMenu` should be
     * considered active if one of its menu items are a link for the current
     * page.
     */
    isActive: PropTypes__default["default"].bool,

    /**
     * Property to indicate if the side nav container is open (or not). Use to
     * keep local state and styling in step with the SideNav expansion state.
     */
    isSideNavExpanded: PropTypes__default["default"].bool,

    /**
     * Specify if this is a large variation of the SideNavMenu
     */
    large: PropTypes__default["default"].bool,

    /**
     * Pass in a custom icon to render next to the `SideNavMenu` title
     */
    renderIcon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),

    /**
     * Provide the text for the overall menu name
     */
    title: PropTypes__default["default"].string.isRequired
  };

  function hasActiveChild(children) {
    // if we have children, either a single or multiple, find if it is active
    if (Array.isArray(children)) {
      return children.some(function (child) {
        if (!child.props) {
          return false;
        }

        if (child.props.isActive === true) {
          return true;
        }

        if (child.props['aria-current']) {
          return true;
        }

        return false;
      });
    }

    if (children.props) {
      if (children.props.isActive === true || children.props['aria-current']) {
        return true;
      }
    }

    return false;
  }

  var SideNavMenu$1 = /*#__PURE__*/function (_React$Component) {
    _inherits(SideNavMenu, _React$Component);

    var _super = _createSuper(SideNavMenu);

    function SideNavMenu(props) {
      var _this;

      _classCallCheck$1(this, SideNavMenu);

      _this = _super.call(this, props);

      _defineProperty$2(_assertThisInitialized$1(_this), "handleToggleExpand", function () {
        _this.setState(function (state) {
          return {
            isExpanded: !state.isExpanded
          };
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleKeyDown", function (event) {
        if (match(event, Escape)) {
          _this.setState(function () {
            return {
              isExpanded: false
            };
          });
        }
      });

      _this.state = {
        isExpanded: props.defaultExpanded || false,
        wasPreviouslyExpanded: props.defaultExpanded || false
      };
      return _this;
    }

    _createClass$1(SideNavMenu, [{
      key: "render",
      value: function render() {
        var _cx;

        var prefix = this.context;
        var _this$props = this.props,
            buttonRef = _this$props.buttonRef,
            customClassName = _this$props.className,
            children = _this$props.children,
            IconElement = _this$props.renderIcon,
            isActive = _this$props.isActive,
            title = _this$props.title,
            large = _this$props.large;
        var isExpanded = this.state.isExpanded;
        var hasActiveChild;

        if (children) {
          // if we have children, either a single or multiple, find if it is active
          hasActiveChild = Array.isArray(children) ? children.some(function (child) {
            if (child.props && (child.props.isActive === true || child.props['aria-current'])) {
              return true;
            }

            return false;
          }) : children.props && (children.props.isActive === true || children.props['aria-current']);
        }

        var className = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--side-nav__item"), true), _defineProperty$2(_cx, "".concat(prefix, "--side-nav__item--active"), isActive || hasActiveChild && !isExpanded), _defineProperty$2(_cx, "".concat(prefix, "--side-nav__item--icon"), IconElement), _defineProperty$2(_cx, "".concat(prefix, "--side-nav__item--large"), large), _defineProperty$2(_cx, customClassName, !!customClassName), _cx));
        return (
          /*#__PURE__*/
          // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
          React__default["default"].createElement("li", {
            className: className,
            onKeyDown: this.handleKeyDown
          }, /*#__PURE__*/React__default["default"].createElement("button", {
            "aria-expanded": isExpanded,
            className: "".concat(prefix, "--side-nav__submenu"),
            onClick: this.handleToggleExpand,
            ref: buttonRef,
            type: "button"
          }, IconElement && /*#__PURE__*/React__default["default"].createElement(SideNavIcon$1, null, /*#__PURE__*/React__default["default"].createElement(IconElement, null)), /*#__PURE__*/React__default["default"].createElement("span", {
            className: "".concat(prefix, "--side-nav__submenu-title")
          }, title), /*#__PURE__*/React__default["default"].createElement(SideNavIcon$1, {
            className: "".concat(prefix, "--side-nav__submenu-chevron"),
            small: true
          }, /*#__PURE__*/React__default["default"].createElement(ChevronDown20, null))), /*#__PURE__*/React__default["default"].createElement("ul", {
            className: "".concat(prefix, "--side-nav__menu")
          }, children))
        );
      }
    }]);

    return SideNavMenu;
  }(React__default["default"].Component);

  _defineProperty$2(SideNavMenu$1, "contextType", PrefixContext);

  _defineProperty$2(SideNavMenu$1, "propTypes", {
    buttonRef: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].shape({
      current: PropTypes__default["default"].any
    })]),

    /**
     * Provide <SideNavMenuItem>'s inside of the `SideNavMenu`
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide an optional class to be applied to the containing node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the menu should default to expanded. By default, it will
     * be closed.
     */
    defaultExpanded: PropTypes__default["default"].bool,

    /**
     * Specify whether the `SideNavMenu` is "active". `SideNavMenu` should be
     * considered active if one of its menu items are a link for the current
     * page.
     */
    isActive: PropTypes__default["default"].bool,

    /**
     * Property to indicate if the side nav container is open (or not). Use to
     * keep local state and styling in step with the SideNav expansion state.
     */
    isSideNavExpanded: PropTypes__default["default"].bool,

    /**
     * Specify if this is a large variation of the SideNavMenu
     */
    large: PropTypes__default["default"].bool,

    /**
     * Pass in a custom icon to render next to the `SideNavMenu` title
     */
    renderIcon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),

    /**
     * Provide the text for the overall menu name
     */
    title: PropTypes__default["default"].string.isRequired
  });

  _defineProperty$2(SideNavMenu$1, "defaultProps", {
    defaultExpanded: false,
    isActive: false,
    large: false
  });

  _defineProperty$2(SideNavMenu$1, "getDerivedStateFromProps", function (props, state) {
    var derivedState = null;

    if (props.isSideNavExpanded === false && state.isExpanded === true) {
      derivedState = {
        isExpanded: props.isSideNavExpanded,
        wasPreviouslyExpanded: true
      };
    } else if (props.isSideNavExpanded === true && state.wasPreviouslyExpanded === true) {
      derivedState = {
        isExpanded: props.isSideNavExpanded,
        wasPreviouslyExpanded: false
      };
    }

    return derivedState;
  });

  var SideNavMenuForwardRef = /*#__PURE__*/React__default["default"].forwardRef(function (props, ref) {
    return /*#__PURE__*/React__default["default"].createElement(SideNavMenu$1, _extends$3({}, props, {
      buttonRef: ref
    }));
  });
  SideNavMenuForwardRef.displayName = 'SideNavMenu';
  var SideNavMenuClassic = SideNavMenuForwardRef;

  var _excluded$s = ["className", "children", "tagName"];

  var Content = function Content(_ref) {
    var customClassName = _ref.className,
        children = _ref.children,
        tagName = _ref.tagName,
        rest = _objectWithoutProperties$2(_ref, _excluded$s);

    var prefix = usePrefix();
    var className = cx("".concat(prefix, "--content"), customClassName);
    return /*#__PURE__*/React__default["default"].createElement(tagName, _objectSpread2$2(_objectSpread2$2({}, rest), {}, {
      className: className
    }), children);
  };

  Content.propTypes = {
    /**
     * Provide children nodes to be rendered in the content container
     */
    children: PropTypes__default["default"].node,

    /**
     * Optionally provide a custom class name that is applied to the container
     */
    className: PropTypes__default["default"].string,

    /**
     * Optionally specify the tag of the content node. Defaults to `main`
     */
    tagName: PropTypes__default["default"].string
  };
  Content.defaultProps = {
    tagName: 'main'
  };
  var Content$1 = Content;

  var _excluded$r = ["className", "children"];

  var Header = function Header(_ref) {
    var customClassName = _ref.className,
        children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, _excluded$r);

    var prefix = usePrefix();
    var className = cx("".concat(prefix, "--header"), customClassName);
    return /*#__PURE__*/React__default["default"].createElement("header", _extends$3({}, rest, {
      className: className
    }), children);
  };

  Header.propTypes = _objectSpread2$2(_objectSpread2$2({}, AriaLabelPropType), {}, {
    /**
     * Optionally provide a custom class name that is applied to the underlying <header>
     */
    className: PropTypes__default["default"].string
  });
  var Header$1 = Header;

  var HeaderContainer = function HeaderContainer(_ref) {
    var isSideNavExpanded = _ref.isSideNavExpanded,
        Children = _ref.render;

    //state for expandable sidenav
    var _useState = React.useState(isSideNavExpanded),
        _useState2 = _slicedToArray$1(_useState, 2),
        isSideNavExpandedState = _useState2[0],
        setIsSideNavExpandedState = _useState2[1];

    var handleHeaderMenuButtonClick = React.useCallback(function () {
      setIsSideNavExpandedState(function (prevIsSideNavExpanded) {
        return !prevIsSideNavExpanded;
      });
    }, [setIsSideNavExpandedState]);
    return /*#__PURE__*/React__default["default"].createElement(Children, {
      isSideNavExpanded: isSideNavExpandedState,
      onClickSideNavExpand: handleHeaderMenuButtonClick
    });
  };

  HeaderContainer.propTypes = {
    /**
     * Optionally provide a custom class name that is applied to the underlying <header>
     */
    isSideNavExpanded: PropTypes__default["default"].bool
  };
  HeaderContainer.defaultProps = {
    isSideNavExpanded: false
  };
  var HeaderContainer$1 = HeaderContainer;

  var _excluded$q = ["aria-label", "aria-labelledby", "children", "className", "onClick", "isActive", "tooltipAlignment"];
  /**
   * HeaderGlobalAction is used as a part of the `HeaderGlobalBar`. It is
   * essentially an Icon Button with an additional state to indicate whether it is
   * "active". The active state comes from when a user clicks on the global action
   * which should trigger a panel to appear.
   *
   * Note: children passed to this component should be an Icon.
   */

  var HeaderGlobalAction = /*#__PURE__*/React__default["default"].forwardRef(function HeaderGlobalAction(_ref, ref) {
    var _cx;

    var ariaLabel = _ref['aria-label'],
        ariaLabelledBy = _ref['aria-labelledby'],
        children = _ref.children,
        customClassName = _ref.className,
        onClick = _ref.onClick,
        isActive = _ref.isActive,
        tooltipAlignment = _ref.tooltipAlignment,
        rest = _objectWithoutProperties$2(_ref, _excluded$q);

    var prefix = usePrefix();
    var className = cx((_cx = {}, _defineProperty$2(_cx, customClassName, !!customClassName), _defineProperty$2(_cx, "".concat(prefix, "--header__action"), true), _defineProperty$2(_cx, "".concat(prefix, "--header__action--active"), isActive), _cx));
    var accessibilityLabel = {
      'aria-label': ariaLabel,
      'aria-labelledby': ariaLabelledBy
    };
    return /*#__PURE__*/React__default["default"].createElement(Button$1, _extends$3({}, rest, accessibilityLabel, {
      className: className,
      onClick: onClick,
      type: "button",
      hasIconOnly: true,
      iconDescription: ariaLabel,
      tooltipPosition: "bottom",
      tooltipAlignment: tooltipAlignment,
      ref: ref
    }), children);
  });
  HeaderGlobalAction.propTypes = _objectSpread2$2(_objectSpread2$2({}, AriaLabelPropType), {}, {
    /**
     * Provide a custom icon for this global action
     */
    children: PropTypes__default["default"].node.isRequired,

    /**
     * Optionally provide a custom class name that is applied to the underlying
     * button
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the action is currently active
     */
    isActive: PropTypes__default["default"].bool,

    /**
     * Optionally provide an onClick handler that is called when the underlying
     * button fires it's onclick event
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Specify the alignment of the tooltip to the icon-only button.
     * Can be one of: start, center, or end.
     */
    tooltipAlignment: PropTypes__default["default"].oneOf(['start', 'center', 'end'])
  });
  HeaderGlobalAction.displayName = 'HeaderGlobalAction';
  var HeaderGlobalAction$1 = HeaderGlobalAction;

  var prefix$1 = settings_1.prefix;
  /**
   * Generic container for `HeaderGlobalAction` components
   */

  var HeaderGlobalBar = wrapComponent$1({
    name: 'HeaderGlobalBar',
    className: "".concat(prefix$1, "--header__global"),
    type: 'div'
  });

  var _excluded$p = ["isCurrentPage", "aria-label", "aria-labelledby", "className", "children", "renderMenuContent", "menuLinkName", "focusRef"];
  /**
   * `HeaderMenu` is used to render submenu's in the `Header`. Most often children
   * will be a `HeaderMenuItem`. It handles certain keyboard events to help
   * with managing focus. It also passes along refs to each child so that it can
   * help manage focus state of its children.
   */

  var HeaderMenu = /*#__PURE__*/function (_React$Component) {
    _inherits(HeaderMenu, _React$Component);

    var _super = _createSuper(HeaderMenu);

    function HeaderMenu(props) {
      var _this;

      _classCallCheck$1(this, HeaderMenu);

      _this = _super.call(this, props);

      _defineProperty$2(_assertThisInitialized$1(_this), "_subMenus", /*#__PURE__*/React__default["default"].createRef());

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOnClick", function (e) {
        var subMenusNode = _this._subMenus.current;

        if (!subMenusNode || !subMenusNode.contains(e.target)) {
          e.preventDefault();
        }

        _this.setState(function (prevState) {
          return {
            expanded: !prevState.expanded
          };
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOnKeyDown", function (event) {
        // Handle enter or space key for toggling the expanded state of the menu.
        if (matches(event, [Enter, Space])) {
          event.stopPropagation();
          event.preventDefault();

          _this.setState(function (prevState) {
            return {
              expanded: !prevState.expanded
            };
          });

          return;
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleOnBlur", function (event) {
        // Rough guess for a blur event that is triggered outside of our menu or
        // menubar context
        var itemTriggeredBlur = _this.items.find(function (element) {
          return element === event.relatedTarget;
        });

        if (event.relatedTarget && (event.relatedTarget.getAttribute('href') && event.relatedTarget.getAttribute('href') !== '#' || itemTriggeredBlur)) {
          return;
        }

        _this.setState({
          expanded: false,
          selectedIndex: null
        });
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleMenuButtonRef", function (node) {
        if (_this.props.focusRef) {
          _this.props.focusRef(node);
        }

        _this.menuButtonRef = node;
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleItemRef", function (index) {
        return function (node) {
          _this.items[index] = node;
        };
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "handleMenuClose", function (event) {
        // Handle ESC keydown for closing the expanded menu.
        if (matches(event, [Escape]) && _this.state.expanded) {
          event.stopPropagation();
          event.preventDefault();

          _this.setState(function () {
            return {
              expanded: false,
              selectedIndex: null
            };
          }); // Return focus to menu button when the user hits ESC.


          _this.menuButtonRef.focus();

          return;
        }
      });

      _defineProperty$2(_assertThisInitialized$1(_this), "_renderMenuItem", function (item, index) {
        if ( /*#__PURE__*/React__default["default"].isValidElement(item)) {
          return /*#__PURE__*/React__default["default"].cloneElement(item, {
            ref: _this.handleItemRef(index)
          });
        }
      });

      _this.state = {
        // Used to manage the expansion state of the menu
        expanded: false,
        // Refers to the menuitem that is currently focused
        // Note: children should have `role="menuitem"` on node consuming ref
        selectedIndex: null
      };
      _this.items = [];
      return _this;
    }
    /**
     * Toggle the expanded state of the menu on click.
     */


    _createClass$1(HeaderMenu, [{
      key: "render",
      value: function render() {
        var _cx;

        var prefix = this.context;

        var _this$props = this.props,
            isCurrentPage = _this$props.isCurrentPage,
            ariaLabel = _this$props['aria-label'],
            ariaLabelledBy = _this$props['aria-labelledby'],
            customClassName = _this$props.className,
            children = _this$props.children,
            MenuContent = _this$props.renderMenuContent,
            menuLinkName = _this$props.menuLinkName;
            _this$props.focusRef;
            var rest = _objectWithoutProperties$2(_this$props, _excluded$p);

        var accessibilityLabel = {
          'aria-label': ariaLabel,
          'aria-labelledby': ariaLabelledBy
        };
        var className = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--header__submenu"), true), _defineProperty$2(_cx, customClassName, true), _defineProperty$2(_cx, "".concat(prefix, "--header__submenu--current"), isCurrentPage), _cx)); // Notes on eslint comments and based on the examples in:
        // https://www.w3.org/TR/wai-aria-practices/examples/menubar/menubar-1/menubar-1.html#
        // - The focus is handled by the <a> menuitem, onMouseOver is for mouse
        // users
        // - aria-haspopup can definitely have the value "menu"
        // - aria-expanded is on their example node with role="menuitem"
        // - href can be set to javascript:void(0), ideally this will be a button

        return /*#__PURE__*/React__default["default"].createElement("li", _extends$3({}, rest, {
          className: className,
          onKeyDown: this.handleMenuClose,
          onClick: this.handleOnClick,
          onBlur: this.handleOnBlur
        }), /*#__PURE__*/React__default["default"].createElement("a", _extends$3({
          // eslint-disable-line jsx-a11y/role-supports-aria-props,jsx-a11y/anchor-is-valid
          "aria-haspopup": "menu" // eslint-disable-line jsx-a11y/aria-proptypes
          ,
          "aria-expanded": this.state.expanded,
          className: "".concat(prefix, "--header__menu-item ").concat(prefix, "--header__menu-title"),
          href: "#",
          onKeyDown: this.handleOnKeyDown,
          ref: this.handleMenuButtonRef,
          tabIndex: 0
        }, accessibilityLabel), menuLinkName, MenuContent ? /*#__PURE__*/React__default["default"].createElement(MenuContent, null) : /*#__PURE__*/React__default["default"].createElement(ChevronDown16, {
          className: "".concat(this.context, "--header__menu-arrow")
        })), /*#__PURE__*/React__default["default"].createElement("ul", _extends$3({}, accessibilityLabel, {
          ref: this._subMenus,
          className: "".concat(prefix, "--header__menu")
        }), React__default["default"].Children.map(children, this._renderMenuItem)));
      }
      /**
       * We capture the `ref` for each child inside of `this.items` to properly
       * manage focus. In addition to this focus management, all items receive a
       * `tabIndex: -1` so the user won't hit a large number of items in their tab
       * sequence when they might not want to go through all the items.
       */

    }]);

    return HeaderMenu;
  }(React__default["default"].Component);

  _defineProperty$2(HeaderMenu, "propTypes", _objectSpread2$2(_objectSpread2$2({}, AriaLabelPropType), {}, {
    /**
     * Provide a custom ref handler for the menu button
     */
    focusRef: PropTypes__default["default"].func,

    /**
     * Provide a label for the link text
     */
    menuLinkName: PropTypes__default["default"].string.isRequired,

    /**
     * Optional component to render instead of string
     */
    renderMenuContent: PropTypes__default["default"].func,

    /**
     * Optionally provide a tabIndex for the underlying menu button
     */
    tabIndex: PropTypes__default["default"].number
  }));

  _defineProperty$2(HeaderMenu, "contextType", PrefixContext);

  var HeaderMenuForwardRef = /*#__PURE__*/React__default["default"].forwardRef(function (props, ref) {
    return /*#__PURE__*/React__default["default"].createElement(HeaderMenu, _extends$3({}, props, {
      focusRef: ref
    }));
  });
  HeaderMenuForwardRef.displayName = 'HeaderMenu';
  var HeaderMenuForwardRef$1 = HeaderMenuForwardRef;

  var _excluded$o = ["aria-label", "aria-labelledby", "className", "renderMenuIcon", "renderCloseIcon", "onClick", "isActive", "isCollapsible"];

  var HeaderMenuButton = function HeaderMenuButton(_ref) {
    var _cx;

    var ariaLabel = _ref['aria-label'],
        ariaLabelledBy = _ref['aria-labelledby'],
        customClassName = _ref.className,
        renderMenuIcon = _ref.renderMenuIcon,
        renderCloseIcon = _ref.renderCloseIcon,
        onClick = _ref.onClick,
        isActive = _ref.isActive,
        isCollapsible = _ref.isCollapsible,
        rest = _objectWithoutProperties$2(_ref, _excluded$o);

    var prefix = usePrefix();
    var className = cx((_cx = {}, _defineProperty$2(_cx, customClassName, !!customClassName), _defineProperty$2(_cx, "".concat(prefix, "--header__action"), true), _defineProperty$2(_cx, "".concat(prefix, "--header__menu-trigger"), true), _defineProperty$2(_cx, "".concat(prefix, "--header__action--active"), isActive), _defineProperty$2(_cx, "".concat(prefix, "--header__menu-toggle"), true), _defineProperty$2(_cx, "".concat(prefix, "--header__menu-toggle__hidden"), !isCollapsible), _cx));
    var accessibilityLabel = {
      'aria-label': ariaLabel,
      'aria-labelledby': ariaLabelledBy
    };
    var menuIcon = renderMenuIcon ? renderMenuIcon : /*#__PURE__*/React__default["default"].createElement(Menu20, null);
    var closeIcon = renderCloseIcon ? renderCloseIcon : /*#__PURE__*/React__default["default"].createElement(Close20, null);
    return /*#__PURE__*/React__default["default"].createElement("button", _extends$3({}, rest, accessibilityLabel, {
      className: className,
      title: ariaLabel,
      type: "button",
      onClick: onClick
    }), isActive ? closeIcon : menuIcon);
  };

  HeaderMenuButton.propTypes = _objectSpread2$2(_objectSpread2$2({}, AriaLabelPropType), {}, {
    /**
     * Optionally provide a custom class name that is applied to the underlying
     * button
     */
    className: PropTypes__default["default"].string,
    isActive: PropTypes__default["default"].bool,

    /**
     * Optionally provide an onClick handler that is called when the underlying
     * button fires it's onclick event
     */
    onClick: PropTypes__default["default"].func
  });
  var HeaderMenuButton$1 = HeaderMenuButton;

  var _excluded$n = ["element", "isSideNavExpanded"];
  /**
   * Link is a custom component that allows us to supporting rendering elements
   * other than `a` in our markup. The goal is to allow users to support passing
   * in their own components to support use-cases like `react-router` or
   * `@reach/router`
   */

  var Link = /*#__PURE__*/React__default["default"].forwardRef(function Link(props, ref) {
    var element = props.element;
        props.isSideNavExpanded;
        var rest = _objectWithoutProperties$2(props, _excluded$n);

    return /*#__PURE__*/React__default["default"].createElement(element, _objectSpread2$2(_objectSpread2$2({}, rest), {}, {
      ref: ref
    }));
  });
  var LinkPropTypes = {
    /**
     * The base element to use to build the link. Defaults to `a`, can also accept
     * alternative tag names or custom components like `Link` from `react-router`.
     */
    element: PropTypes__default["default"].elementType,

    /**
     * Property to indicate if the side nav container is open (or not). Use to
     * keep local state and styling in step with the SideNav expansion state.
     */
    isSideNavExpanded: PropTypes__default["default"].bool
  };
  Link.displayName = 'Link';
  Link.propTypes = LinkPropTypes;
  Link.defaultProps = {
    element: 'a'
  };
  var Link$1 = Link;

  var _excluded$m = ["className", "isCurrentPage", "aria-current", "children", "role", "tabIndex"];
  var HeaderMenuItem = /*#__PURE__*/React__default["default"].forwardRef(function HeaderMenuItem(_ref, ref) {
    var _cx;

    var className = _ref.className,
        isCurrentPage = _ref.isCurrentPage,
        ariaCurrent = _ref['aria-current'],
        children = _ref.children,
        role = _ref.role,
        _ref$tabIndex = _ref.tabIndex,
        tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex,
        rest = _objectWithoutProperties$2(_ref, _excluded$m);

    var prefix = usePrefix();
    var linkClassName = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--header__menu-item"), true), _defineProperty$2(_cx, "".concat(prefix, "--header__menu-item--current"), isCurrentPage && ariaCurrent !== 'page'), _cx));
    return /*#__PURE__*/React__default["default"].createElement("li", {
      className: className,
      role: role
    }, /*#__PURE__*/React__default["default"].createElement(Link$1, _extends$3({}, rest, {
      "aria-current": ariaCurrent,
      className: linkClassName,
      ref: ref,
      tabIndex: tabIndex
    }), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--text-truncate--end")
    }, children)));
  });
  HeaderMenuItem.displayName = 'HeaderMenuItem';
  HeaderMenuItem.propTypes = _objectSpread2$2(_objectSpread2$2({}, LinkPropTypes), {}, {
    /**
     * Pass in children that are either a string or can be read as a string by
     * screen readers
     */
    children: PropTypes__default["default"].node.isRequired,

    /**
     * Optionally provide a custom class to apply to the underlying `<li>` node
     */
    className: PropTypes__default["default"].string,

    /**
     * Applies selected styles to the item if a user sets this to true and aria-current !== 'page'.
     */
    isCurrentPage: PropTypes__default["default"].bool,

    /**
     * Optionally supply a role for the underlying `<li>` node. Useful for resetting
     * `<ul>` semantics for menus.
     */
    role: PropTypes__default["default"].string,

    /**
     * Specify the tab index of the Link
     */
    tabIndex: PropTypes__default["default"].number
  });
  var HeaderMenuItem$1 = HeaderMenuItem;

  var _excluded$l = ["children", "className", "prefix", "href"];

  var HeaderName = function HeaderName(_ref) {
    var children = _ref.children,
        customClassName = _ref.className,
        prefix = _ref.prefix,
        href = _ref.href,
        rest = _objectWithoutProperties$2(_ref, _excluded$l);

    var selectorPrefix = usePrefix();
    var className = cx("".concat(selectorPrefix, "--header__name"), customClassName);
    return /*#__PURE__*/React__default["default"].createElement(Link$1, _extends$3({}, rest, {
      className: className,
      href: href
    }), prefix && /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(selectorPrefix, "--header__name--prefix")
    }, prefix), "\xA0"), children);
  };

  HeaderName.propTypes = _objectSpread2$2(_objectSpread2$2({}, LinkPropTypes), {}, {
    /**
     * Pass in children that are either a string or can be read as a string by
     * screen readers
     */
    children: PropTypes__default["default"].node.isRequired,

    /**
     * Optionally provide a custom class to apply to the underlying `<li>` node
     */
    className: PropTypes__default["default"].string,

    /**
     * Provide an href for the name to link to
     */
    href: PropTypes__default["default"].string,

    /**
     * Optionally specify a prefix to your header name. Useful for companies, for
     * example: IBM [Product Name] versus solely [Product Name]
     */
    prefix: PropTypes__default["default"].string
  });
  HeaderName.defaultProps = {
    prefix: 'IBM'
  };
  var HeaderName$1 = HeaderName;

  var _excluded$k = ["children", "className", "expanded"];
  var HeaderPanel = /*#__PURE__*/React__default["default"].forwardRef(function HeaderPanel(_ref, ref) {
    var _cx;

    var children = _ref.children,
        customClassName = _ref.className,
        expanded = _ref.expanded,
        other = _objectWithoutProperties$2(_ref, _excluded$k);

    var prefix = usePrefix();
    var className = cx("".concat(prefix, "--header-panel"), (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--header-panel--expanded"), expanded), _defineProperty$2(_cx, customClassName, !!customClassName), _cx));
    return /*#__PURE__*/React__default["default"].createElement("div", _extends$3({}, other, {
      className: className,
      ref: ref
    }), children);
  });
  HeaderPanel.propTypes = {
    /**
     * The content that will render inside of the `HeaderPanel`
     */
    children: PropTypes__default["default"].node,

    /**
     * Optionally provide a custom class to apply to the underlying `<li>` node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the panel is expanded
     */
    expanded: PropTypes__default["default"].bool
  };
  HeaderPanel.displayName = 'HeaderPanel';
  var HeaderPanel$1 = HeaderPanel;

  var HeaderSideNavItems = function HeaderSideNavItems(_ref) {
    var _cx;

    var customClassName = _ref.className,
        children = _ref.children,
        hasDivider = _ref.hasDivider;
    var prefix = usePrefix();
    var className = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--side-nav__header-navigation"), true), _defineProperty$2(_cx, "".concat(prefix, "--side-nav__header-divider"), hasDivider), _cx), customClassName);
    return /*#__PURE__*/React__default["default"].createElement("ul", {
      className: className
    }, children);
  };

  HeaderSideNavItems.propTypes = {
    /**
     * The child nodes to be rendered
     */
    children: PropTypes__default["default"].node,

    /**
     * Optionally provide a custom class name that is applied to the underlying
     * button
     */
    className: PropTypes__default["default"].string,

    /**
     * Optionally specify if container will have a bottom divider to differentiate
     * between original sidenav items and header menu items. False by default.
     */
    hasDivider: PropTypes__default["default"].bool
  };
  HeaderSideNavItems.defaultProps = {
    hasDivider: false
  };
  var HeaderSideNavItems$1 = HeaderSideNavItems;

  var Switcher = /*#__PURE__*/React__default["default"].forwardRef(function Switcher(props, ref) {
    var prefix = usePrefix();
    var ariaLabel = props['aria-label'],
        ariaLabelledBy = props['aria-labelledby'],
        customClassName = props.className,
        children = props.children;
    var accessibilityLabel = {
      'aria-label': ariaLabel,
      'aria-labelledby': ariaLabelledBy
    };
    var className = cx("".concat(prefix, "--switcher"), _defineProperty$2({}, customClassName, !!customClassName));
    return /*#__PURE__*/React__default["default"].createElement("ul", _extends$3({
      ref: ref,
      className: className
    }, accessibilityLabel), children);
  });
  Switcher.displayName = 'Switcher';
  Switcher.propTypes = _objectSpread2$2(_objectSpread2$2({}, AriaLabelPropType), {}, {
    /**
     * expects to receive <SwitcherItem />
     */
    children: PropTypes__default["default"].node.isRequired,

    /**
     * Optionally provide a custom class to apply to the underlying `<ul>` node
     */
    className: PropTypes__default["default"].string
  });
  var Switcher$1 = Switcher;

  var _excluded$j = ["aria-label", "aria-labelledby", "className", "children", "isSelected", "tabIndex"];
  var SwitcherItem = /*#__PURE__*/React__default["default"].forwardRef(function SwitcherItem(props, ref) {
    var prefix = usePrefix();

    var ariaLabel = props['aria-label'],
        ariaLabelledBy = props['aria-labelledby'],
        customClassName = props.className,
        children = props.children,
        isSelected = props.isSelected,
        _props$tabIndex = props.tabIndex,
        tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex,
        rest = _objectWithoutProperties$2(props, _excluded$j);

    var className = cx("".concat(prefix, "--switcher__item"), _defineProperty$2({}, customClassName, !!customClassName));
    var accessibilityLabel = {
      'aria-label': ariaLabel,
      'aria-labelledby': ariaLabelledBy
    };
    var linkClassName = cx("".concat(prefix, "--switcher__item-link"), _defineProperty$2({}, "".concat(prefix, "--switcher__item-link--selected"), isSelected));
    return /*#__PURE__*/React__default["default"].createElement("li", {
      className: className
    }, /*#__PURE__*/React__default["default"].createElement(Link$1, _extends$3({}, rest, {
      ref: ref,
      className: linkClassName,
      tabIndex: tabIndex
    }, accessibilityLabel), children));
  });
  SwitcherItem.displayName = 'SwitcherItem';
  SwitcherItem.propTypes = _objectSpread2$2(_objectSpread2$2({}, AriaLabelPropType), {}, {
    /**
     * Specify the text content for the link
     */
    children: PropTypes__default["default"].node.isRequired,

    /**
     * Optionally provide a custom class to apply to the underlying `<li>` node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the tab index of the Link
     */
    tabIndex: PropTypes__default["default"].number
  });
  var SwitcherItem$1 = SwitcherItem;

  var _excluded$i = ["className"];

  var SwitcherDivider = function SwitcherDivider(_ref) {
    var customClassName = _ref.className,
        other = _objectWithoutProperties$2(_ref, _excluded$i);

    var prefix = usePrefix();
    var className = cx("".concat(prefix, "--switcher__item--divider"), _defineProperty$2({}, customClassName, !!customClassName));
    return /*#__PURE__*/React__default["default"].createElement("hr", _extends$3({}, other, {
      className: className
    }));
  };

  SwitcherDivider.propTypes = {
    /**
     * Optionally provide a custom class to apply to the underlying `<li>` node
     */
    className: PropTypes__default["default"].string
  };
  var SwitcherDivider$1 = SwitcherDivider;

  var _excluded$h = ["children", "className", "href", "tabIndex"];

  var SkipToContent = function SkipToContent(_ref) {
    var children = _ref.children,
        customClassName = _ref.className,
        href = _ref.href,
        tabIndex = _ref.tabIndex,
        rest = _objectWithoutProperties$2(_ref, _excluded$h);

    var prefix = usePrefix();
    var className = cx("".concat(prefix, "--skip-to-content"), customClassName);
    return /*#__PURE__*/React__default["default"].createElement("a", _extends$3({}, rest, {
      className: className,
      href: href,
      tabIndex: tabIndex
    }), children);
  };

  SkipToContent.propTypes = {
    /**
     * Provide text to display in the SkipToContent `a` tag
     */
    children: PropTypes__default["default"].string.isRequired,
    className: PropTypes__default["default"].string,

    /**
     * Provide the `href` to the id of the element on your package that is the
     * main content.
     */
    href: PropTypes__default["default"].string.isRequired,

    /**
     * Optionally override the default tabindex of 0
     */
    tabIndex: PropTypes__default["default"].string
  };
  SkipToContent.defaultProps = {
    children: 'Skip to main content',
    href: '#main-content',
    tabIndex: '0'
  };
  var SkipToContent$1 = SkipToContent;

  var CARBON_SIDENAV_ITEMS = ['SideNavFooter', 'SideNavHeader', 'SideNavItems', 'SideNavMenu'];

  var _excluded$g = ["expanded", "defaultExpanded", "isChildOfHeader", "aria-label", "aria-labelledby", "children", "onToggle", "className", "isFixedNav", "isRail", "isPersistent", "addFocusListeners", "addMouseListeners", "onOverlayClick"];
  // import SideNavFooter from './SideNavFooter';

  var SideNav = /*#__PURE__*/React__default["default"].forwardRef(function SideNav(props, ref) {
    var _cx, _cx2;

    var expandedProp = props.expanded,
        defaultExpanded = props.defaultExpanded,
        isChildOfHeader = props.isChildOfHeader,
        ariaLabel = props['aria-label'],
        ariaLabelledBy = props['aria-labelledby'],
        children = props.children,
        onToggle = props.onToggle,
        customClassName = props.className,
        isFixedNav = props.isFixedNav,
        isRail = props.isRail,
        isPersistent = props.isPersistent,
        addFocusListeners = props.addFocusListeners,
        addMouseListeners = props.addMouseListeners,
        onOverlayClick = props.onOverlayClick,
        other = _objectWithoutProperties$2(props, _excluded$g);

    var prefix = usePrefix();

    var _useRef = React.useRef(expandedProp !== undefined),
        controlled = _useRef.current;

    var _useState = React.useState(defaultExpanded),
        _useState2 = _slicedToArray$1(_useState, 2),
        expandedState = _useState2[0],
        setExpandedState = _useState2[1];

    var _useState3 = React.useState(defaultExpanded),
        _useState4 = _slicedToArray$1(_useState3, 2),
        expandedViaHoverState = _useState4[0],
        setExpandedViaHoverState = _useState4[1];

    var expanded = controlled ? expandedProp : expandedState;

    var handleToggle = function handleToggle(event) {
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !expanded;

      if (!controlled) {
        setExpandedState(value);
      }

      if (onToggle) {
        onToggle(event, value);
      }

      if (controlled || isRail) {
        setExpandedViaHoverState(value);
      }
    };

    var accessibilityLabel = {
      'aria-label': ariaLabel,
      'aria-labelledby': ariaLabelledBy
    }; // TO-DO: comment back in when footer is added for rails
    // const assistiveText = expanded
    //   ? t('carbon.sidenav.state.open')
    //   : t('carbon.sidenav.state.closed');

    var className = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--side-nav"), true), _defineProperty$2(_cx, "".concat(prefix, "--side-nav--expanded"), expanded || expandedViaHoverState), _defineProperty$2(_cx, "".concat(prefix, "--side-nav--collapsed"), !expanded && isFixedNav), _defineProperty$2(_cx, "".concat(prefix, "--side-nav--rail"), isRail), _defineProperty$2(_cx, customClassName, !!customClassName), _defineProperty$2(_cx, "".concat(prefix, "--side-nav--ux"), isChildOfHeader), _defineProperty$2(_cx, "".concat(prefix, "--side-nav--hidden"), !isPersistent), _cx));
    var overlayClassName = cx((_cx2 = {}, _defineProperty$2(_cx2, "".concat(prefix, "--side-nav__overlay"), true), _defineProperty$2(_cx2, "".concat(prefix, "--side-nav__overlay-active"), expanded || expandedViaHoverState), _cx2));
    var childrenToRender = children; // if a rail, pass the expansion state as a prop, so children can update themselves to match

    if (isRail) {
      childrenToRender = React__default["default"].Children.map(children, function (child) {
        var _child$type$displayNa, _child$type, _child$type2;

        // if we are controlled, check for if we have hovered over or the expanded state, else just use the expanded state (uncontrolled)
        var currentExpansionState = controlled ? expandedViaHoverState || expanded : expanded; // avoid spreading `isSideNavExpanded` to non-Carbon UI Shell children

        return /*#__PURE__*/React__default["default"].cloneElement(child, _objectSpread2$2({}, CARBON_SIDENAV_ITEMS.includes((_child$type$displayNa = (_child$type = child.type) === null || _child$type === void 0 ? void 0 : _child$type.displayName) !== null && _child$type$displayNa !== void 0 ? _child$type$displayNa : (_child$type2 = child.type) === null || _child$type2 === void 0 ? void 0 : _child$type2.name) ? {
          isSideNavExpanded: currentExpansionState
        } : {}));
      });
    }

    var eventHandlers = {};

    if (addFocusListeners) {
      eventHandlers.onFocus = function (event) {
        if (!event.currentTarget.contains(event.relatedTarget)) {
          handleToggle(event, true);
        }
      };

      eventHandlers.onBlur = function (event) {
        if (!event.currentTarget.contains(event.relatedTarget)) {
          handleToggle(event, false);
        }
      };
    }

    if (addMouseListeners && isRail) {
      eventHandlers.onMouseEnter = function () {
        return handleToggle(true, true);
      };

      eventHandlers.onMouseLeave = function () {
        return handleToggle(false, false);
      };
    }

    return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, isFixedNav ? null :
    /*#__PURE__*/
    // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
    React__default["default"].createElement("div", {
      className: overlayClassName,
      onClick: onOverlayClick
    }), /*#__PURE__*/React__default["default"].createElement("nav", _extends$3({
      ref: ref,
      className: "".concat(prefix, "--side-nav__navigation ").concat(className)
    }, accessibilityLabel, eventHandlers, other), childrenToRender));
  });
  SideNav.displayName = 'SideNav';
  SideNav.defaultProps = {
    // TO-DO: comment back in when footer is added for rails
    // translateById: (id) => {
    //   const translations = {
    //     'carbon.sidenav.state.open': 'Close',
    //     'carbon.sidenav.state.closed': 'Open',
    //   };
    //   return translations[id];
    // },
    defaultExpanded: false,
    isChildOfHeader: true,
    isFixedNav: false,
    isPersistent: true,
    addFocusListeners: true,
    addMouseListeners: true
  };
  SideNav.propTypes = _objectSpread2$2(_objectSpread2$2({}, AriaLabelPropType), {}, {
    /**
     * Specify whether focus and blur listeners are added. They are by default.
     */
    addFocusListeners: PropTypes__default["default"].bool,

    /**
     * Specify whether mouse entry/exit listeners are added. They are by default.
     */
    addMouseListeners: PropTypes__default["default"].bool,

    /**
     * Optionally provide a custom class to apply to the underlying `<li>` node
     */
    className: PropTypes__default["default"].string,

    /**
     * If `true`, the SideNav will be open on initial render.
     */
    defaultExpanded: PropTypes__default["default"].bool,

    /**
     * If `true`, the SideNav will be expanded, otherwise it will be collapsed.
     * Using this prop causes SideNav to become a controled component.
     */
    expanded: PropTypes__default["default"].bool,

    /**
     * Optionally provide a custom class to apply to the underlying `<li>` node
     */
    isChildOfHeader: PropTypes__default["default"].bool,

    /**
     * Specify if sideNav is standalone
     */
    isFixedNav: PropTypes__default["default"].bool,

    /**
     * Specify if the sideNav will be persistent above the lg breakpoint
     */
    isPersistent: PropTypes__default["default"].bool,

    /**
     * Optional prop to display the side nav rail.
     */
    isRail: PropTypes__default["default"].bool,

    /**
     * An optional listener that is called when the SideNav overlay is clicked
     *
     * @param {object} event
     */
    onOverlayClick: PropTypes__default["default"].func,

    /**
     * An optional listener that is called when an event that would cause
     * toggling the SideNav occurs.
     *
     * @param {object} event
     * @param {boolean} value
     */
    onToggle: PropTypes__default["default"].func,

    /**
     * Provide a custom function for translating all message ids within this
     * component. This function will take in two arguments: the mesasge Id and the
     * state of the component. From this, you should return a string representing
     * the label you want displayed or read by screen readers.
     */
    translateById: PropTypes__default["default"].func
  });
  var SideNav$1 = SideNav;

  var SideNavDetails = function SideNavDetails(_ref) {
    var children = _ref.children,
        customClassName = _ref.className,
        title = _ref.title;
    var prefix = usePrefix();
    var className = cx("".concat(prefix, "--side-nav__details"), customClassName);
    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: className
    }, /*#__PURE__*/React__default["default"].createElement("h2", {
      className: "".concat(prefix, "--side-nav__title"),
      title: title
    }, title), children);
  };

  SideNavDetails.propTypes = {
    /**
     * Provide optional children to render in `SideNavDetails`. Useful for
     * rendering the `SideNavSwitcher` component.
     */
    children: PropTypes__default["default"].node,

    /**
     * Optionally provide a custom class to apply to the underlying `<li>` node
     */
    className: PropTypes__default["default"].string,

    /**
     * Provide the text that will be rendered as the title in the component
     */
    title: PropTypes__default["default"].string.isRequired
  };
  var SideNavDetails$1 = SideNavDetails;

  function SideNavDivider(_ref) {
    var className = _ref.className;
    var prefix = usePrefix();
    var classNames = cx("".concat(prefix, "--side-nav__divider"), className);
    return /*#__PURE__*/React__default["default"].createElement("li", {
      role: "separator",
      className: classNames
    });
  }

  SideNavDivider.propTypes = {
    /**
     * Provide an optional class to be applied to the containing node
     */
    className: PropTypes__default["default"].string
  };

  /**
   * SideNavFooter is used for rendering the button at the bottom of the side
   * navigation that is a part of the UI Shell. It is responsible for handling the
   * user interaction to expand or collapse the side navigation.
   */

  var SideNavFooter = function SideNavFooter(_ref) {
    var assistiveText = _ref.assistiveText,
        customClassName = _ref.className,
        expanded = _ref.expanded,
        onToggle = _ref.onToggle;
    var prefix = usePrefix();
    var className = cx("".concat(prefix, "--side-nav__footer"), customClassName);
    return /*#__PURE__*/React__default["default"].createElement("footer", {
      className: className
    }, /*#__PURE__*/React__default["default"].createElement("button", {
      className: "".concat(prefix, "--side-nav__toggle"),
      type: "button",
      onClick: function onClick(evt) {
        return onToggle(evt);
      },
      title: assistiveText
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--side-nav__icon")
    }, expanded ? /*#__PURE__*/React__default["default"].createElement(Close20, null) : /*#__PURE__*/React__default["default"].createElement(ChevronRight20, null)), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--assistive-text")
    }, assistiveText)));
  };

  SideNavFooter.propTypes = {
    /**
     * Provide text to be read to screen readers and shown as a tooltip when
     * interacting with the toggle button in the footer
     */
    assistiveText: PropTypes__default["default"].string.isRequired,
    className: PropTypes__default["default"].string,

    /**
     * Specify whether the side navigation is expanded or collapsed
     */
    expanded: PropTypes__default["default"].bool.isRequired,

    /**
     * Property to indicate if the side nav container is open (or not). Use to
     * keep local state and styling in step with the SideNav expansion state.
     */
    isSideNavExpanded: PropTypes__default["default"].bool,

    /**
     * Provide a function that is called when the toggle button is interacted
     * with. Useful for controlling the expansion state of the side navigation.
     */
    onToggle: PropTypes__default["default"].func.isRequired
  };
  SideNavFooter.defaultProps = {
    assistiveText: 'Toggle opening or closing the side navigation'
  };
  var SideNavFooter$1 = SideNavFooter;

  var SideNavHeader = function SideNavHeader(_ref) {
    var customClassName = _ref.className,
        children = _ref.children,
        IconElement = _ref.renderIcon;
    var prefix = usePrefix();
    var className = cx("".concat(prefix, "--side-nav__header"), customClassName);
    return /*#__PURE__*/React__default["default"].createElement("header", {
      className: className
    }, /*#__PURE__*/React__default["default"].createElement(SideNavIcon$1, null, /*#__PURE__*/React__default["default"].createElement(IconElement, null)), children);
  };

  SideNavHeader.propTypes = {
    /**
     * The child nodes to be rendered
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide an optional class to be applied to the containing node
     */
    className: PropTypes__default["default"].string,

    /**
     * Property to indicate if the side nav container is open (or not). Use to
     * keep local state and styling in step with the SideNav expansion state.
     */
    isSideNavExpanded: PropTypes__default["default"].bool,

    /**
     * Provide an icon to render in the header of the side navigation. Should be
     * a React class.
     */
    renderIcon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]).isRequired
  };
  var SideNavHeader$1 = SideNavHeader;

  var SideNavItem = function SideNavItem(_ref) {
    var _cx;

    var customClassName = _ref.className,
        children = _ref.children,
        _ref$large = _ref.large,
        large = _ref$large === void 0 ? false : _ref$large;
    var prefix = usePrefix();
    var className = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--side-nav__item"), true), _defineProperty$2(_cx, "".concat(prefix, "--side-nav__item--large"), large), _defineProperty$2(_cx, customClassName, !!customClassName), _cx));
    return /*#__PURE__*/React__default["default"].createElement("li", {
      className: className
    }, children);
  };

  SideNavItem.propTypes = {
    /**
     * Provide a single icon as the child to `SideNavIcon` to render in the
     * container
     */
    children: PropTypes__default["default"].node.isRequired,

    /**
     * Provide an optional class to be applied to the containing node
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify if this is a large variation of the SideNavItem
     */
    large: PropTypes__default["default"].bool
  };
  var SideNavItem$1 = SideNavItem;

  var SideNavItems = function SideNavItems(_ref) {
    var customClassName = _ref.className,
        children = _ref.children,
        isSideNavExpanded = _ref.isSideNavExpanded;
    var prefix = usePrefix();
    var className = cx(["".concat(prefix, "--side-nav__items")], customClassName);
    var childrenWithExpandedState = React__default["default"].Children.map(children, function (child) {
      if ( /*#__PURE__*/React__default["default"].isValidElement(child)) {
        var _child$type;

        // avoid spreading `isSideNavExpanded` to non-Carbon UI Shell children
        return /*#__PURE__*/React__default["default"].cloneElement(child, _objectSpread2$2({}, CARBON_SIDENAV_ITEMS.includes((_child$type = child.type) === null || _child$type === void 0 ? void 0 : _child$type.displayName) ? {
          isSideNavExpanded: isSideNavExpanded
        } : {}));
      }
    });
    return /*#__PURE__*/React__default["default"].createElement("ul", {
      className: className
    }, childrenWithExpandedState);
  };

  SideNavItems.propTypes = {
    /**
     * Provide a single icon as the child to `SideNavIcon` to render in the
     * container
     */
    children: PropTypes__default["default"].node.isRequired,

    /**
     * Provide an optional class to be applied to the containing node
     */
    className: PropTypes__default["default"].string,

    /**
     * Property to indicate if the side nav container is open (or not). Use to
     * keep local state and styling in step with the SideNav expansion state.
     */
    isSideNavExpanded: PropTypes__default["default"].bool
  };
  var SideNavItems$1 = SideNavItems;

  var _excluded$f = ["className", "children"];

  var SideNavLinkText = function SideNavLinkText(_ref) {
    var customClassName = _ref.className,
        children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, _excluded$f);

    var prefix = usePrefix();
    var className = cx("".concat(prefix, "--side-nav__link-text"), customClassName);
    return /*#__PURE__*/React__default["default"].createElement("span", _extends$3({}, rest, {
      className: className
    }), children);
  };

  SideNavLinkText.propTypes = {
    /**
     * Provide the content for the link text
     */
    children: PropTypes__default["default"].node.isRequired,

    /**
     * Provide an optional class to be applied to the containing node
     */
    className: PropTypes__default["default"].string
  };
  var SideNavLinkText$1 = SideNavLinkText;

  var _excluded$e = ["className", "children", "renderIcon", "isActive", "large"];
  var SideNavLink = /*#__PURE__*/React__default["default"].forwardRef(function SideNavLink(_ref, ref) {
    var _cx;

    var customClassName = _ref.className,
        children = _ref.children,
        IconElement = _ref.renderIcon,
        isActive = _ref.isActive,
        large = _ref.large,
        rest = _objectWithoutProperties$2(_ref, _excluded$e);

    var prefix = usePrefix();
    var className = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--side-nav__link"), true), _defineProperty$2(_cx, "".concat(prefix, "--side-nav__link--current"), isActive), _defineProperty$2(_cx, customClassName, !!customClassName), _cx));
    return /*#__PURE__*/React__default["default"].createElement(SideNavItem$1, {
      large: large
    }, /*#__PURE__*/React__default["default"].createElement(Link$1, _extends$3({}, rest, {
      className: className,
      ref: ref
    }), IconElement && /*#__PURE__*/React__default["default"].createElement(SideNavIcon$1, {
      small: true
    }, /*#__PURE__*/React__default["default"].createElement(IconElement, null)), /*#__PURE__*/React__default["default"].createElement(SideNavLinkText$1, null, children)));
  });
  SideNavLink.displayName = 'SideNavLink';
  SideNavLink.propTypes = _objectSpread2$2(_objectSpread2$2({}, LinkPropTypes), {}, {
    /**
     * Specify the text content for the link
     */
    children: PropTypes__default["default"].node.isRequired,

    /**
     * Provide an optional class to be applied to the containing node
     */
    className: PropTypes__default["default"].string,

    /**
     * Property to indicate if the side nav container is open (or not). Use to
     * keep local state and styling in step with the SideNav expansion state.
     */
    isSideNavExpanded: PropTypes__default["default"].bool,

    /**
     * Specify if this is a large variation of the SideNavLink
     */
    large: PropTypes__default["default"].bool,

    /**
     * Provide an icon to render in the side navigation link. Should be a React class.
     */
    renderIcon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object])
  });
  SideNavLink.defaultProps = {
    element: 'a',
    large: false
  }; // eslint-disable-next-line react/display-name
  var SideNavLink$1 = SideNavLink;

  var _excluded$d = ["children", "className", "isActive"];
  var SideNavMenuItem = /*#__PURE__*/React__default["default"].forwardRef(function SideNavMenuItem(props, ref) {
    var _cx;

    var prefix = usePrefix();

    var children = props.children,
        customClassName = props.className,
        isActive = props.isActive,
        rest = _objectWithoutProperties$2(props, _excluded$d);

    var className = cx("".concat(prefix, "--side-nav__menu-item"), customClassName);
    var linkClassName = cx((_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--side-nav__link"), true), _defineProperty$2(_cx, "".concat(prefix, "--side-nav__link--current"), isActive), _cx));
    return /*#__PURE__*/React__default["default"].createElement("li", {
      className: className
    }, /*#__PURE__*/React__default["default"].createElement(Link$1, _extends$3({}, rest, {
      className: linkClassName,
      ref: ref
    }), /*#__PURE__*/React__default["default"].createElement(SideNavLinkText$1, null, children)));
  });
  SideNavMenuItem.displayName = 'SideNavMenuItem';
  SideNavMenuItem.propTypes = {
    /**
     * Specify the children to be rendered inside of the `SideNavMenuItem`
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide an optional class to be applied to the containing node
     */
    className: PropTypes__default["default"].string,

    /**
     * Optionally specify whether the link is "active". An active link is one that
     * has an href that is the same as the current page. Can also pass in
     * `aria-current="page"`, as well.
     */
    isActive: PropTypes__default["default"].bool
  };
  var SideNavMenuItem$1 = SideNavMenuItem;

  var SideNavSwitcher = /*#__PURE__*/React__default["default"].forwardRef(function SideNavSwitcher(props, ref) {
    var prefix = usePrefix();
    var customClassName = props.className,
        labelText = props.labelText,
        onChange = props.onChange,
        options = props.options;
    var className = cx("".concat(prefix, "--side-nav__switcher"), customClassName); // Note for usage around `onBlur`: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-onchange.md

    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: className
    }, /*#__PURE__*/React__default["default"].createElement("label", {
      htmlFor: "side-nav-switcher",
      className: "".concat(prefix, "--assistive-text")
    }, labelText), /*#__PURE__*/React__default["default"].createElement("select", {
      id: "carbon-side-nav-switcher",
      className: "".concat(prefix, "--side-nav__select"),
      defaultValue: "",
      onBlur: onChange,
      onChange: onChange,
      ref: ref
    }, /*#__PURE__*/React__default["default"].createElement("option", {
      className: "".concat(prefix, "--side-nav__option"),
      disabled: true,
      hidden: true,
      value: ""
    }, labelText), options.map(function (option) {
      return /*#__PURE__*/React__default["default"].createElement("option", {
        key: option,
        className: "".concat(prefix, "--side-nav__option"),
        value: option
      }, option);
    })), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--side-nav__switcher-chevron")
    }, /*#__PURE__*/React__default["default"].createElement(ChevronDown20, null)));
  });
  SideNavSwitcher.displayName = 'SideNavSwitcher';
  SideNavSwitcher.propTypes = {
    /**
     * Provide an optional class to be applied to the containing node
     */
    className: PropTypes__default["default"].string,

    /**
     * Provide the label for the switcher. This will be the first visible option
     * when someone views this control
     */
    labelText: PropTypes__default["default"].string.isRequired,

    /**
     * Provide a callback function that is called whenever the switcher value is
     * updated
     */
    onChange: PropTypes__default["default"].func,

    /**
     * Provide an array of options to be rendered in the switcher as an
     * `<option>`. The text value will be what is displayed to the user and is set
     * as the `value` prop for each `<option>`.
     */
    options: PropTypes__default["default"].arrayOf(PropTypes__default["default"].string).isRequired
  };
  var SideNavSwitcher$1 = SideNavSwitcher;

  var HeaderNavigation = enabled('enable-v11-release') ? HeaderNavigation$1 : HeaderNavigation$2;
  var SideNavMenu = enabled('enable-v11-release') ? SideNavMenu$2 : SideNavMenuClassic;

  /**
   * @param {Element|Document|Window} [trigger=document] The element which should trigger the Menu on right-click
   * @returns {object} Props object to pass onto Menu component
   */

  function useContextMenu() {
    var trigger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;

    var _useState = React.useState(false),
        _useState2 = _slicedToArray$1(_useState, 2),
        open = _useState2[0],
        setOpen = _useState2[1];

    var _useState3 = React.useState([0, 0]),
        _useState4 = _slicedToArray$1(_useState3, 2),
        position = _useState4[0],
        setPosition = _useState4[1];

    function openContextMenu(e) {
      e.preventDefault();
      var x = e.x,
          y = e.y;
      setPosition([x, y]);
      setOpen(true);
    }

    function onClose() {
      setOpen(false);
    }

    React.useEffect(function () {
      if (trigger && trigger instanceof Element || trigger instanceof Document || trigger instanceof Window) {
        trigger.addEventListener('contextmenu', openContextMenu);
        return function () {
          trigger.removeEventListener('contextmenu', openContextMenu);
        };
      }
    }, [trigger]);
    return {
      open: open,
      x: position[0],
      y: position[1],
      onClose: onClose
    };
  }

  var _excluded$c = ["as", "children"];
  var HeadingContext = /*#__PURE__*/React__default["default"].createContext(1);

  function Section(_ref) {
    var _ref$as = _ref.as,
        BaseComponent = _ref$as === void 0 ? 'section' : _ref$as,
        children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, _excluded$c);

    var level = React__default["default"].useContext(HeadingContext);
    return /*#__PURE__*/React__default["default"].createElement(HeadingContext.Provider, {
      value: Math.min(level + 1, 6)
    }, /*#__PURE__*/React__default["default"].createElement(BaseComponent, rest, children));
  }

  Section.propTypes = {
    /**
     * Provide an alternative tag or component to use instead of the default
     * <section> element
     */
    as: PropTypes__default["default"].elementType,

    /**
     * Specify the content that will be placed in the component
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify a class name for the outermost node of the component
     */
    className: PropTypes__default["default"].string
  };

  function Heading(props) {
    var level = React__default["default"].useContext(HeadingContext);
    return /*#__PURE__*/React__default["default"].createElement("h".concat(level), props);
  }

  Heading.propTypes = {
    /**
     * Specify the content that will be placed in the component
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify a class name for the outermost node of the component
     */
    className: PropTypes__default["default"].string
  };

  var _excluded$b = ["align", "children", "defaultOpen", "enterDelayMs", "kind", "label", "leaveDelayMs", "size"];
  var IconButton = /*#__PURE__*/React__default["default"].forwardRef(function IconButton(props, ref) {
    var align = props.align,
        children = props.children,
        _props$defaultOpen = props.defaultOpen,
        defaultOpen = _props$defaultOpen === void 0 ? false : _props$defaultOpen,
        enterDelayMs = props.enterDelayMs,
        kind = props.kind,
        label = props.label,
        leaveDelayMs = props.leaveDelayMs,
        _props$size = props.size,
        size = _props$size === void 0 ? 'md' : _props$size,
        rest = _objectWithoutProperties$2(props, _excluded$b);

    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement(Tooltip$2, {
      align: align,
      className: "".concat(prefix, "--icon-tooltip"),
      defaultOpen: defaultOpen,
      enterDelayMs: enterDelayMs,
      label: label,
      leaveDelayMs: leaveDelayMs
    }, /*#__PURE__*/React__default["default"].createElement(Button$1, _extends$3({}, rest, {
      hasIconOnly: true,
      kind: kind,
      ref: ref,
      size: size
    }), children));
  });
  IconButton.propTypes = {
    /**
     * Specify how the trigger should align with the tooltip
     */
    align: PropTypes__default["default"].oneOf(['top', 'top-left', 'top-right', 'bottom', 'bottom-left', 'bottom-right', 'left', 'right']),

    /**
     * Provide an icon or asset to be rendered inside of the IconButton
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify whether the tooltip should be open when it first renders
     */
    defaultOpen: PropTypes__default["default"].bool,

    /**
     * Specify the duration in milliseconds to delay before displaying the tooltip
     */
    enterDelayMs: PropTypes__default["default"].number,

    /**
     * Specify the type of button to be used as the base for the IconButton
     */
    kind: PropTypes__default["default"].oneOf(['primary', 'secondary', 'ghost', 'tertiary']),

    /**
     * Provide the label to be rendered inside of the Tooltip. The label will use
     * `aria-labelledby` and will fully describe the child node that is provided.
     * This means that if you have text in the child node it will not be
     * announced to the screen reader.
     */
    label: PropTypes__default["default"].node.isRequired,

    /**
     * Specify the duration in milliseconds to delay before hiding the tooltip
     */
    leaveDelayMs: PropTypes__default["default"].number,

    /**
     * Specify the size of the Button. Defaults to `md`.
     */
    size: PropTypes__default["default"].oneOf(['sm', 'md', 'lg'])
  };

  var LayerContext = /*#__PURE__*/React__default["default"].createContext(1);

  var _excluded$a = ["as", "className", "children"];
  var levels = ['one', 'two', 'three'];
  var MAX_LEVEL = levels.length - 1;
  function Layer(_ref) {
    var _ref$as = _ref.as,
        BaseComponent = _ref$as === void 0 ? 'div' : _ref$as,
        customClassName = _ref.className,
        children = _ref.children,
        rest = _objectWithoutProperties$2(_ref, _excluded$a);

    var level = React__default["default"].useContext(LayerContext);
    var prefix = usePrefix();
    var className = cx("".concat(prefix, "--layer-").concat(levels[level]), customClassName);
    return (
      /*#__PURE__*/
      // The level should be between 0 and MAX_LEVEL
      React__default["default"].createElement(LayerContext.Provider, {
        value: Math.max(0, Math.min(level + 1, MAX_LEVEL))
      }, /*#__PURE__*/React__default["default"].createElement(BaseComponent, _extends$3({}, rest, {
        className: className
      }), children))
    );
  }
  Layer.propTypes = {
    /**
     * Specify a custom component or element to be rendered as the top-level
     * element in the component
     */
    as: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].string, PropTypes__default["default"].elementType]),

    /**
     * Provide child elements to be rendered inside of `Theme`
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide a custom class name to be used on the outermost element rendered by
     * the component
     */
    className: PropTypes__default["default"].string
  };

  var prefix = settings_1.prefix;
  function resetFocus(el) {
    if (el) {
      var _el$querySelectorAll;

      Array.from((_el$querySelectorAll = el.querySelectorAll('[tabindex="0"]')) !== null && _el$querySelectorAll !== void 0 ? _el$querySelectorAll : []).forEach(function (node) {
        node.tabIndex = -1;
      });
    }
  }
  function focusNode(node) {
    if (node) {
      node.tabIndex = 0;
      node.focus();
    }
  }
  function getValidNodes(list) {
    var level = list.dataset.level;
    var nodes = [];

    if (level) {
      var submenus = Array.from(list.querySelectorAll('[data-level]'));
      nodes = Array.from(list.querySelectorAll("li.".concat(prefix, "--menu-option"))).filter(function (child) {
        return !submenus.some(function (submenu) {
          return submenu.contains(child);
        });
      });
    }

    return nodes.filter(function (node) {
      return node.matches(":not(.".concat(prefix, "--menu-option--disabled)"));
    });
  }
  function getNextNode(current, direction) {
    var menu = getParentMenu(current);
    var nodes = getValidNodes(menu);
    var currentIndex = nodes.indexOf(current);
    var nextNode = nodes[currentIndex + direction];
    return nextNode || null;
  }
  function getFirstSubNode(node) {
    var submenu = node.querySelector("ul.".concat(prefix, "--menu"));

    if (submenu) {
      var subnodes = getValidNodes(submenu);
      return subnodes[0] || null;
    }

    return null;
  }
  function getParentNode(node) {
    if (node) {
      var parentNode = node.parentNode.closest("li.".concat(prefix, "--menu-option"));
      return parentNode || null;
    }

    return null;
  }
  function getSubMenuOffset(node) {
    if (node) {
      var nodeStyles = getComputedStyle(node);
      var spacings = parseInt(nodeStyles.paddingTop) + parseInt(nodeStyles.paddingBottom); // styles always in px, convert to number

      var elementHeight = node.firstElementChild.offsetHeight;
      return elementHeight + spacings || 0;
    }

    return 0;
  }
  function getParentMenu(el) {
    if (el) {
      var parentMenu = el.parentNode.closest("ul.".concat(prefix, "--menu"));
      return parentMenu || null;
    }

    return null;
  }
  function clickedElementHasSubnodes(e) {
    if (e) {
      var closestFocusableElement = e.target.closest('[tabindex]');

      if ((closestFocusableElement === null || closestFocusableElement === void 0 ? void 0 : closestFocusableElement.tagName) === 'LI') {
        return getFirstSubNode(closestFocusableElement) !== null;
      }
    }

    return false;
  }
  /**
   * @param {number} [value] The value to cap
   * @param {number} [min] The minimum of the range
   * @param {number} [max] The maximum of the range
   * @returns {number} Whether or not the element fits inside the boundaries on the given axis
   */

  function capWithinRange(value, min, max) {
    if (value > max) {
      return max;
    }

    if (value < min) {
      return min;
    }

    return value;
  }
  /**
   * @param {number[]} [elementDimensions] The dimensions of the element: [width, height]
   * @param {number[]} [position] The desired position of the element: [x, y]
   * @param {number[]} [boundaries] The boundaries of the container the element should be contained in: [minX, minY, maxX, maxY]
   * @param {string} [axis="x"] Which axis to check. Either "x" or "y"
   * @returns {boolean} Whether or not the element fits inside the boundaries on the given axis
   */

  function elementFits(elementDimensions, position, boundaries) {
    var axis = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'x';
    var index = axis === 'y' ? 1 : 0;
    var min = boundaries[index];
    var max = boundaries[index + 2];
    var start = position[index];
    var end = position[index] + elementDimensions[index];
    return start >= min && end <= max;
  }
  /**
   * @param {number[]} [elementDimensions] The dimensions of the element: [width, height]
   * @param {number[]} [targetBoundaries] The boundaries of the target the element should attach to: [minX, minY, maxX, maxY]
   * @param {number[]} [containerBoundaries] The boundaries of the container the element should be contained in: [minX, minY, maxX, maxY]
   * @param {number} [preferredDirection=1] Which direction is preferred. Either 1 (right right) or -1 (to left)
   * @param {boolean} [isRootLevel] Flag that indicates if the element is on level 1 (the root level)
   * @param {object} [element] The list element - used to calculate the offset of submenus
   * @returns {object} The determined position and direction of the element: { position: [x, y], direction: 1 | -1 }
   */


  function getPosition(elementDimensions, targetBoundaries, containerBoundaries) {
    var preferredDirection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var isRootLevel = arguments.length > 4 ? arguments[4] : undefined;
    var element = arguments.length > 5 ? arguments[5] : undefined;
    var position = [0, 0];
    var direction = preferredDirection; // x

    position[0] = direction === 1 ? targetBoundaries[0] : targetBoundaries[2] - elementDimensions[0];
    var xFits = elementFits(elementDimensions, position, containerBoundaries, 'x');

    if (!xFits) {
      direction = direction * -1;
      position[0] = direction === 1 ? targetBoundaries[0] : targetBoundaries[2] - elementDimensions[0];
    } // y


    position[1] = targetBoundaries[3];
    var yFits = elementFits(elementDimensions, position, containerBoundaries, 'y');

    if (!yFits) {
      position[1] = targetBoundaries[1] - elementDimensions[1];

      if (!isRootLevel && element) {
        // if sub-menu and not root level, consider offset
        var diff = getSubMenuOffset(element);
        position[1] += diff;
      }
    }

    return {
      position: position,
      direction: direction
    };
  }

  function MenuGroup(_ref) {
    var label = _ref.label,
        children = _ref.children;
    return /*#__PURE__*/React__default["default"].createElement("li", {
      role: "none"
    }, /*#__PURE__*/React__default["default"].createElement("ul", {
      role: "group",
      "aria-label": label
    }, children));
  }

  MenuGroup.propTypes = {
    /**
     * Specify the children of the MenuGroup
     */
    children: PropTypes__default["default"].node,

    /**
     * Rendered label for the MenuGroup
     */
    label: PropTypes__default["default"].node.isRequired
  };

  var _excluded$9 = ["children", "disabled", "indented", "kind", "label", "level", "onClick", "renderIcon", "shortcut"];
  var hoverIntentDelay = 150; // in ms

  function MenuOptionContent(_ref) {
    var label = _ref.label,
        info = _ref.info,
        disabled = _ref.disabled,
        Icon = _ref.icon,
        indented = _ref.indented;
    var prefix = usePrefix();
    var classes = cx("".concat(prefix, "--menu-option__content"), _defineProperty$2({}, "".concat(prefix, "--menu-option__content--disabled"), disabled));
    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: classes
    }, indented && /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--menu-option__icon")
    }, Icon && /*#__PURE__*/React__default["default"].createElement(Icon, null)), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--menu-option__label"),
      title: label
    }, label), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--menu-option__info")
    }, info));
  }

  function MenuOption(_ref2) {
    var _classnames2;

    var children = _ref2.children,
        disabled = _ref2.disabled,
        indented = _ref2.indented,
        _ref2$kind = _ref2.kind,
        kind = _ref2$kind === void 0 ? 'default' : _ref2$kind,
        label = _ref2.label,
        level = _ref2.level,
        _ref2$onClick = _ref2.onClick,
        onClick = _ref2$onClick === void 0 ? function () {} : _ref2$onClick,
        renderIcon = _ref2.renderIcon,
        shortcut = _ref2.shortcut,
        rest = _objectWithoutProperties$2(_ref2, _excluded$9);

    var _useState = React.useState(false),
        _useState2 = _slicedToArray$1(_useState, 2),
        submenuOpen = _useState2[0],
        setSubmenuOpen = _useState2[1];

    var _useState3 = React.useState(false),
        _useState4 = _slicedToArray$1(_useState3, 2),
        submenuOpenedByKeyboard = _useState4[0],
        setSubmenuOpenedByKeyboard = _useState4[1];

    var rootRef = React.useRef(null);
    var hoverIntentTimeout = React.useRef(null);
    var prefix = usePrefix();
    var subOptions = React__default["default"].Children.map(children, function (node) {
      if ( /*#__PURE__*/React__default["default"].isValidElement(node)) {
        return /*#__PURE__*/React__default["default"].cloneElement(node);
      }
    });

    function openSubmenu() {
      var openedByKeyboard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      setSubmenuOpenedByKeyboard(openedByKeyboard);
      setSubmenuOpen(true);
    }

    function handleKeyDown(event) {
      if (clickedElementHasSubnodes(event) && (match(event, ArrowRight) || match(event, Enter) || match(event, Space))) {
        openSubmenu(true);
      } else if ((match(event, Enter) || match(event, Space)) && onClick) {
        onClick(event);
      }
    }

    function handleMouseEnter() {
      hoverIntentTimeout.current = setTimeout(openSubmenu, hoverIntentDelay);
    }

    function handleMouseLeave() {
      clearTimeout(hoverIntentTimeout === null || hoverIntentTimeout === void 0 ? void 0 : hoverIntentTimeout.current);
      setSubmenuOpen(false);
    }

    function getSubmenuPosition() {
      var pos = [0, 0];

      if (subOptions) {
        var parentMenu = getParentMenu(rootRef === null || rootRef === void 0 ? void 0 : rootRef.current);

        if (parentMenu) {
          var _parentMenu$getBoundi = parentMenu.getBoundingClientRect(),
              x = _parentMenu$getBoundi.x,
              width = _parentMenu$getBoundi.width;

          var _rootRef$current$getB = rootRef.current.getBoundingClientRect(),
              y = _rootRef$current$getB.y;

          pos[0] = x + width;
          pos[1] = y;
        }
      }

      return pos;
    }

    React.useEffect(function () {
      if (subOptions && submenuOpenedByKeyboard) {
        var firstSubnode = getFirstSubNode(rootRef === null || rootRef === void 0 ? void 0 : rootRef.current);
        focusNode(firstSubnode);
      } // eslint-disable-next-line react-hooks/exhaustive-deps

    }, [submenuOpen]);
    var classes = cx("".concat(prefix, "--menu-option"), (_classnames2 = {}, _defineProperty$2(_classnames2, "".concat(prefix, "--menu-option--disabled"), disabled), _defineProperty$2(_classnames2, "".concat(prefix, "--menu-option--active"), subOptions && submenuOpen), _defineProperty$2(_classnames2, "".concat(prefix, "--menu-option--danger"), !subOptions && kind === 'danger'), _classnames2));
    var allowedRoles = ['menuitemradio', 'menuitemcheckbox'];
    var role = rest.role && allowedRoles.includes(rest.role) ? rest.role : 'menuitem';
    var submenuPosition = getSubmenuPosition();
    return (
      /*#__PURE__*/
      // role is either menuitemradio, menuitemcheckbox, or menuitem which are all interactive
      // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
      React__default["default"].createElement("li", _extends$3({}, rest, {
        ref: rootRef,
        className: classes,
        role: role,
        tabIndex: -1,
        "aria-disabled": !subOptions && disabled,
        "aria-haspopup": subOptions ? true : null,
        "aria-expanded": subOptions ? submenuOpen : null,
        onKeyDown: handleKeyDown,
        onMouseEnter: subOptions ? handleMouseEnter : null,
        onMouseLeave: subOptions ? handleMouseLeave : null,
        onClick: onClick
      }), subOptions ? /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement(MenuOptionContent, {
        label: label,
        icon: renderIcon,
        info: /*#__PURE__*/React__default["default"].createElement(CaretRight16, null),
        indented: indented
      }), /*#__PURE__*/React__default["default"].createElement(Menu$1, {
        level: level + 1,
        open: submenuOpen,
        onClose: function onClose() {
          setSubmenuOpen(false);
        },
        x: submenuPosition[0],
        y: submenuPosition[1]
      }, subOptions)) : /*#__PURE__*/React__default["default"].createElement(MenuOptionContent, {
        label: label,
        disabled: disabled,
        icon: renderIcon,
        info: shortcut,
        indented: indented
      }))
    );
  }

  MenuOptionContent.propTypes = {
    /**
     * Whether this option is disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Icon that is displayed in front of the option
     */
    icon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),

    /**
     * Whether the content should be indented
     */
    indented: PropTypes__default["default"].bool,

    /**
     * Additional information such as shortcut or caret
     */
    info: PropTypes__default["default"].node,

    /**
     * Rendered label for the MenuOptionContent
     */
    label: PropTypes__default["default"].node.isRequired
  };
  MenuOption.propTypes = {
    /**
     * Specify the children of the MenuOption
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify whether this MenuOption is disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Whether the content should be indented (for example because it's in a group with options that have icons).
     * Is automatically set by Menu
     */
    indented: PropTypes__default["default"].bool,

    /**
     * Optional prop to specify the kind of the MenuOption
     */
    kind: PropTypes__default["default"].oneOf(['default', 'danger']),

    /**
     * Rendered label for the MenuOption
     */
    label: PropTypes__default["default"].node.isRequired,

    /**
     * Which nested level this option is located in.
     * Is automatically set by Menu
     */
    level: PropTypes__default["default"].number,

    /**
     * The onClick handler
     */
    onClick: PropTypes__default["default"].func,

    /**
     * Rendered icon for the MenuOption.
     * Can be a React component class
     */
    renderIcon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),

    /**
     * Rendered shortcut for the MenuOption
     */
    shortcut: PropTypes__default["default"].node
  };

  function MenuRadioGroupOptions(_ref) {
    var items = _ref.items,
        initialSelectedItem = _ref.initialSelectedItem,
        _ref$onChange = _ref.onChange,
        onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange;

    var _useState = React.useState(initialSelectedItem),
        _useState2 = _slicedToArray$1(_useState, 2),
        selected = _useState2[0],
        setSelected = _useState2[1];

    function handleClick(option) {
      setSelected(option);
      onChange(option);
    }

    var options = items.map(function (option, i) {
      var isSelected = selected === option;
      return /*#__PURE__*/React__default["default"].createElement(MenuOption, {
        key: i,
        role: "menuitemradio",
        "aria-checked": isSelected,
        renderIcon: isSelected ? Checkmark16 : null,
        label: option,
        indented: true,
        onClick: function onClick() {
          handleClick(option);
        }
      });
    });
    return options;
  }

  MenuRadioGroupOptions.propTypes = {
    /**
     * Whether the option should be checked by default
     */
    initialSelectedItem: PropTypes__default["default"].string,

    /**
     * Array of the radio options
     */
    items: PropTypes__default["default"].arrayOf(PropTypes__default["default"].string).isRequired,

    /**
     * Callback function when selection the has been changed
     */
    onChange: PropTypes__default["default"].func
  };

  function MenuRadioGroup(_ref) {
    var items = _ref.items,
        initialSelectedItem = _ref.initialSelectedItem,
        label = _ref.label,
        _ref$onChange = _ref.onChange,
        onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange;
    return /*#__PURE__*/React__default["default"].createElement(MenuGroup, {
      label: label
    }, /*#__PURE__*/React__default["default"].createElement(MenuRadioGroupOptions, {
      items: items,
      initialSelectedItem: initialSelectedItem,
      onChange: onChange
    }));
  }

  MenuRadioGroup.propTypes = {
    /**
     * Whether the option should be checked by default
     */
    initialSelectedItem: PropTypes__default["default"].string,

    /**
     * Array of the radio options
     */
    items: PropTypes__default["default"].arrayOf(PropTypes__default["default"].string).isRequired,

    /**
     * The radio group label
     */
    label: PropTypes__default["default"].string.isRequired,

    /**
     * Callback function when selection the has been changed
     */
    onChange: PropTypes__default["default"].func
  };

  function MenuSelectableItem(_ref) {
    var label = _ref.label,
        initialChecked = _ref.initialChecked,
        _ref$onChange = _ref.onChange,
        onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange;

    var _useState = React.useState(initialChecked),
        _useState2 = _slicedToArray$1(_useState, 2),
        checked = _useState2[0],
        setChecked = _useState2[1];

    function handleClick() {
      setChecked(!checked);
      onChange(!checked);
    }

    return /*#__PURE__*/React__default["default"].createElement(MenuOption, {
      role: "menuitemcheckbox",
      "aria-checked": checked,
      renderIcon: checked ? Checkmark16 : null,
      label: label,
      indented: true,
      onClick: handleClick
    });
  }

  MenuSelectableItem.propTypes = {
    /**
     * Whether the option should be checked by default
     */
    initialChecked: PropTypes__default["default"].bool,

    /**
     * Rendered label for the MenuOptionContent
     */
    label: PropTypes__default["default"].node.isRequired,

    /**
     * Callback function when selection the has been changed
     */
    onChange: PropTypes__default["default"].func
  };

  var _excluded$8 = ["children", "className", "id", "level", "open", "size", "target", "x", "y", "onClose"];
  var margin = 16; // distance to keep to body edges, in px

  var defaultSize$1 = 'sm';

  var Menu = function Menu(_ref) {
    var _classnames;

    var children = _ref.children,
        className = _ref.className,
        id = _ref.id,
        _ref$level = _ref.level,
        level = _ref$level === void 0 ? 1 : _ref$level,
        open = _ref.open,
        _ref$size = _ref.size,
        size = _ref$size === void 0 ? defaultSize$1 : _ref$size,
        _ref$target = _ref.target,
        target = _ref$target === void 0 ? document.body : _ref$target,
        _ref$x = _ref.x,
        x = _ref$x === void 0 ? 0 : _ref$x,
        _ref$y = _ref.y,
        y = _ref$y === void 0 ? 0 : _ref$y,
        _ref$onClose = _ref.onClose,
        onClose = _ref$onClose === void 0 ? function () {} : _ref$onClose,
        rest = _objectWithoutProperties$2(_ref, _excluded$8);

    var rootRef = React.useRef(null);

    var _useState = React.useState(1),
        _useState2 = _slicedToArray$1(_useState, 2),
        direction = _useState2[0],
        setDirection = _useState2[1]; // 1 = to right, -1 = to left


    var _useState3 = React.useState([x, y]),
        _useState4 = _slicedToArray$1(_useState3, 2),
        position = _useState4[0],
        setPosition = _useState4[1];

    var isRootMenu = level === 1;
    var focusReturn = React.useRef(null);
    var prefix = usePrefix();

    function returnFocus() {
      if (focusReturn.current) {
        focusReturn.current.focus();
      }
    }

    function close(eventType) {
      var isKeyboardEvent = /^key/.test(eventType);

      if (isKeyboardEvent) {
        window.addEventListener('keyup', returnFocus, {
          once: true
        });
      } else {
        window.addEventListener('mouseup', returnFocus, {
          once: true
        });
      }

      onClose();
    }

    function getContainerBoundaries() {
      var _document$body = document.body,
          bodyWidth = _document$body.clientWidth,
          bodyHeight = _document$body.clientHeight;
      return [margin, margin, bodyWidth - margin, bodyHeight - margin];
    }

    function getTargetBoundaries() {
      var xIsRange = _typeof(x) === 'object' && x.length === 2;
      var yIsRange = _typeof(y) === 'object' && y.length === 2;
      var targetBoundaries = [xIsRange ? x[0] : x, yIsRange ? y[0] : y, xIsRange ? x[1] : x, yIsRange ? y[1] : y];

      if (!isRootMenu) {
        var _getParentMenu;

        var _getParentMenu$getBou = (_getParentMenu = getParentMenu(rootRef.current)) === null || _getParentMenu === void 0 ? void 0 : _getParentMenu.getBoundingClientRect(),
            parentWidth = _getParentMenu$getBou.width;

        targetBoundaries[2] -= parentWidth;
      }

      var containerBoundaries = getContainerBoundaries();
      return [capWithinRange(targetBoundaries[0], containerBoundaries[0], containerBoundaries[2]), capWithinRange(targetBoundaries[1], containerBoundaries[1], containerBoundaries[3]), capWithinRange(targetBoundaries[2], containerBoundaries[0], containerBoundaries[2]), capWithinRange(targetBoundaries[3], containerBoundaries[1], containerBoundaries[3])];
    }

    function focusNode$1(node) {
      if (node) {
        resetFocus(rootRef.current);
        focusNode(node);
      }
    }

    function handleKeyDown(event) {
      if (match(event, Tab$6)) {
        event.preventDefault();
        close(event.type);
      }

      if (event.target.tagName === 'LI' && (match(event, Enter) || match(event, Space))) {
        handleClick(event);
      } else {
        event.stopPropagation();
      }

      if (match(event, Escape) || !isRootMenu && match(event, ArrowLeft)) {
        close(event.type);
      }

      var nodeToFocus;

      if (event.target.tagName === 'LI') {
        var currentNode = event.target;

        if (match(event, ArrowUp)) {
          nodeToFocus = getNextNode(currentNode, -1);
        } else if (match(event, ArrowDown)) {
          nodeToFocus = getNextNode(currentNode, 1);
        } else if (match(event, ArrowLeft)) {
          nodeToFocus = getParentNode(currentNode);
        }
      } else if (event.target.tagName === 'UL') {
        var validNodes = getValidNodes(event.target);

        if (validNodes.length > 0 && match(event, ArrowUp)) {
          nodeToFocus = validNodes[validNodes.length - 1];
        } else if (validNodes.length > 0 && match(event, ArrowDown)) {
          nodeToFocus = validNodes[0];
        }
      }

      focusNode$1(nodeToFocus);

      if (rest.onKeyDown) {
        rest.onKeyDown(event);
      }
    }

    function handleClick(event) {
      if (!clickedElementHasSubnodes(event) && event.target.tagName !== 'UL') {
        close(event.type);
      } else {
        event.stopPropagation();
      }
    }

    function getCorrectedPosition(preferredDirection) {
      var _rootRef$current;

      var elementRect = (_rootRef$current = rootRef.current) === null || _rootRef$current === void 0 ? void 0 : _rootRef$current.getBoundingClientRect();
      var elementDimensions = [elementRect.width, elementRect.height];
      var targetBoundaries = getTargetBoundaries();
      var containerBoundaries = getContainerBoundaries();

      var _getPosition = getPosition(elementDimensions, targetBoundaries, containerBoundaries, preferredDirection, isRootMenu, rootRef.current),
          correctedPosition = _getPosition.position,
          correctedDirection = _getPosition.direction;

      setDirection(correctedDirection);
      return correctedPosition;
    }

    function handleBlur(event) {
      var _rootRef$current2;

      if (isRootMenu && !((_rootRef$current2 = rootRef.current) !== null && _rootRef$current2 !== void 0 && _rootRef$current2.contains(event.relatedTarget))) {
        close(event.type);
      }
    }

    React.useEffect(function () {
      if (open) {
        focusReturn.current = document.activeElement;
        var localDirection = 1;

        if (isRootMenu) {
          var _rootRef$current3;

          (_rootRef$current3 = rootRef.current) === null || _rootRef$current3 === void 0 ? void 0 : _rootRef$current3.focus();
        } else {
          var parentMenu = getParentMenu(rootRef.current);

          if (parentMenu) {
            localDirection = Number(parentMenu.dataset.direction);
          }
        }

        var correctedPosition = getCorrectedPosition(localDirection);
        setPosition(correctedPosition);
      } else {
        setPosition([0, 0]);
      } // eslint-disable-next-line react-hooks/exhaustive-deps

    }, [open, x, y]);
    var someNodesHaveIcons = React__default["default"].Children.toArray(children).some(function (node) {
      return node.type === MenuSelectableItem || node.type === MenuRadioGroup;
    });
    var options = React__default["default"].Children.map(children, function (node) {
      if ( /*#__PURE__*/React__default["default"].isValidElement(node)) {
        return /*#__PURE__*/React__default["default"].cloneElement(node, {
          indented: someNodesHaveIcons,
          level: level
        });
      }
    });
    var classes = cx("".concat(prefix, "--menu"), (_classnames = {}, _defineProperty$2(_classnames, "".concat(prefix, "--menu--open"), open), _defineProperty$2(_classnames, "".concat(prefix, "--menu--invisible"), open && position[0] === 0 && position[1] === 0), _defineProperty$2(_classnames, "".concat(prefix, "--menu--root"), isRootMenu), _classnames), size !== defaultSize$1 && "".concat(prefix, "--menu--").concat(size), className);

    var ulAttributes = _objectSpread2$2(_objectSpread2$2({}, rest), {}, {
      id: id,
      ref: rootRef,
      className: classes,
      onKeyDown: handleKeyDown,
      onClick: handleClick,
      onBlur: handleBlur,
      role: 'menu',
      tabIndex: -1,
      'data-direction': direction,
      'data-level': level,
      style: {
        left: "".concat(position[0], "px"),
        top: "".concat(position[1], "px")
      }
    });

    var childrenToRender = options; // if the only child is a radiogroup, don't render it as radiogroup component, but
    // only the items to prevent duplicate markup

    if (options && options.length === 1 && options[0].type === MenuRadioGroup) {
      var radioGroupProps = options[0].props;
      ulAttributes['aria-label'] = radioGroupProps.label;
      childrenToRender = /*#__PURE__*/React__default["default"].createElement(MenuRadioGroupOptions, {
        items: radioGroupProps.items,
        initialSelectedItem: radioGroupProps.initialSelectedItem,
        onChange: radioGroupProps.onChange
      });
    } // if the only child is a generic group, don't render it as group component, but
    // only the children to prevent duplicate markup


    if (options && options.length === 1 && options[0].type === MenuGroup) {
      var groupProps = options[0].props;
      ulAttributes['aria-label'] = groupProps.label;
      childrenToRender = React__default["default"].Children.toArray(options[0].props.children);
    }

    var menu = /*#__PURE__*/React__default["default"].createElement("ul", ulAttributes, childrenToRender);
    return isRootMenu ? open && /*#__PURE__*/ReactDOM__default["default"].createPortal(menu, target) || null : menu;
  };

  Menu.propTypes = {
    /**
     * Specify the children of the Menu
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify a custom className to apply to the ul node
     */
    className: PropTypes__default["default"].string,

    /**
     * Define an ID for this menu
     */
    id: PropTypes__default["default"].string,

    /**
     * Internal: keeps track of the nesting level of the menu
     */
    level: PropTypes__default["default"].number,

    /**
     * Function called when the menu is closed
     */
    onClose: PropTypes__default["default"].func,

    /**
     * Specify whether the Menu is currently open
     */
    open: PropTypes__default["default"].bool,

    /**
     * Specify the size of the menu, from a list of available sizes.
     */
    size: PropTypes__default["default"].oneOf(['sm', 'md', 'lg']),

    /**
     * Optionally pass an element the Menu should be appended to as a child. Defaults to document.body.
     */
    target: PropTypes__default["default"].element,

    /**
     * Specify the x position where this menu is rendered
     */
    x: PropTypes__default["default"].oneOfType([PropTypes__default["default"].number, PropTypes__default["default"].arrayOf(PropTypes__default["default"].number)]),

    /**
     * Specify the y position where this menu is rendered
     */
    y: PropTypes__default["default"].oneOfType([PropTypes__default["default"].number, PropTypes__default["default"].arrayOf(PropTypes__default["default"].number)])
  };
  var Menu$1 = Menu;

  function MenuDivider() {
    var prefix = usePrefix();
    return /*#__PURE__*/React__default["default"].createElement("li", {
      role: "separator",
      className: "".concat(prefix, "--menu-divider")
    });
  }

  var _excluded$7 = ["label", "children", "disabled", "kind", "shortcut"];

  function MenuItem(_ref) {
    var label = _ref.label,
        children = _ref.children,
        disabled = _ref.disabled,
        kind = _ref.kind,
        shortcut = _ref.shortcut,
        rest = _objectWithoutProperties$2(_ref, _excluded$7);

    return /*#__PURE__*/React__default["default"].createElement(MenuOption, _extends$3({}, rest, {
      label: label,
      disabled: disabled,
      kind: kind,
      shortcut: shortcut
    }), children);
  }

  MenuItem.propTypes = {
    /**
     * Specify the children of the MenuItem
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify whether this MenuItem is disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Optional prop to specify the kind of the MenuItem
     */
    kind: PropTypes__default["default"].oneOf(['default', 'danger']),

    /**
     * Rendered label for the MenuItem
     */
    label: PropTypes__default["default"].node.isRequired,

    /**
     * Rendered shortcut for the MenuItem
     */
    shortcut: PropTypes__default["default"].node
  };

  Menu$1.MenuDivider = MenuDivider;
  Menu$1.MenuGroup = MenuGroup;
  Menu$1.MenuItem = MenuItem;
  Menu$1.MenuRadioGroup = MenuRadioGroup;
  Menu$1.MenuSelectableItem = MenuSelectableItem;

  var _excluded$6 = ["children", "className", "renderIcon", "size"];
  var defaultSize = 'md';

  function OverflowMenuV2(_ref) {
    var _classNames;

    var children = _ref.children,
        className = _ref.className,
        _ref$renderIcon = _ref.renderIcon,
        IconElement = _ref$renderIcon === void 0 ? OverflowMenuVertical16 : _ref$renderIcon,
        _ref$size = _ref.size,
        size = _ref$size === void 0 ? defaultSize : _ref$size,
        rest = _objectWithoutProperties$2(_ref, _excluded$6);

    var id = useId('overflowmenu');

    var _useState = React.useState(false),
        _useState2 = _slicedToArray$1(_useState, 2),
        open = _useState2[0],
        setOpen = _useState2[1];

    var _useState3 = React.useState([[0, 0], [0, 0]]),
        _useState4 = _slicedToArray$1(_useState3, 2),
        position = _useState4[0],
        setPosition = _useState4[1];

    var triggerRef = React.useRef(null);
    var prefix = usePrefix();

    function openMenu() {
      if (triggerRef.current) {
        var _triggerRef$current$g = triggerRef.current.getBoundingClientRect(),
            left = _triggerRef$current$g.left,
            top = _triggerRef$current$g.top,
            right = _triggerRef$current$g.right,
            bottom = _triggerRef$current$g.bottom;

        setPosition([[left, right], [top, bottom]]);
      }

      setOpen(true);
    }

    function closeMenu() {
      setOpen(false);
    }

    function handleClick() {
      if (open) {
        closeMenu();
      } else {
        openMenu();
      }
    }

    function handleMousedown(e) {
      // prevent default for mousedown on trigger element to avoid
      // the "blur" event from firing on the menu as this would close
      // it and immediately re-open since "click" event is fired after
      // "blur" event.
      e.preventDefault();
    }

    function handleKeyPress(e) {
      if (open && matches(e, [ArrowUp, ArrowRight, ArrowDown, ArrowLeft])) {
        e.preventDefault();
      }
    }

    var containerClasses = cx("".concat(prefix, "--overflow-menu__container"));
    var triggerClasses = cx("".concat(prefix, "--overflow-menu"), (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--overflow-menu--open"), open), _defineProperty$2(_classNames, className, className), _classNames), size !== defaultSize && "".concat(prefix, "--overflow-menu--").concat(size));
    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: containerClasses,
      "aria-owns": id
    }, /*#__PURE__*/React__default["default"].createElement("button", _extends$3({}, rest, {
      type: "button",
      "aria-haspopup": true,
      "aria-expanded": open,
      className: triggerClasses,
      onClick: handleClick,
      onMouseDown: handleMousedown,
      onKeyDown: handleKeyPress,
      ref: triggerRef
    }), /*#__PURE__*/React__default["default"].createElement(IconElement, {
      className: "".concat(prefix, "--overflow-menu__icon")
    })), /*#__PURE__*/React__default["default"].createElement(Menu$1, {
      id: id,
      size: size,
      open: open,
      onClose: closeMenu,
      x: position[0],
      y: position[1]
    }, children));
  }

  OverflowMenuV2.propTypes = {
    /**
     * Specify the children of the OverflowMenu
     */
    children: PropTypes__default["default"].node,

    /**
     * Optional className for the trigger button
     */
    className: PropTypes__default["default"].string,

    /**
     * Function called to override icon rendering.
     */
    renderIcon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),

    /**
     * Specify the size of the menu, from a list of available sizes.
     */
    size: PropTypes__default["default"].oneOf(['sm', 'md', 'lg'])
  };

  var _excluded$5 = ["backwardText", "children", "className", "disabled", "forwardText", "id", "initialPage", "itemsPerPageText", "itemRangeText", "itemText", "onChange", "pageRangeText", "pageSize", "pageSizes", "pageText", "pagesUnknown", "totalItems"];

  function Pagination(_ref) {
    var backwardText = _ref.backwardText,
        children = _ref.children,
        className = _ref.className,
        disabled = _ref.disabled,
        forwardText = _ref.forwardText,
        id = _ref.id,
        initialPage = _ref.initialPage,
        itemsPerPageText = _ref.itemsPerPageText,
        itemRangeText = _ref.itemRangeText,
        itemText = _ref.itemText,
        onChange = _ref.onChange,
        pageRangeText = _ref.pageRangeText,
        pageSize = _ref.pageSize,
        pageSizes = _ref.pageSizes,
        pageText = _ref.pageText,
        pagesUnknown = _ref.pagesUnknown,
        totalItems = _ref.totalItems,
        other = _objectWithoutProperties$2(_ref, _excluded$5);

    var _useState = React.useState(initialPage),
        _useState2 = _slicedToArray$1(_useState, 2),
        currentPage = _useState2[0],
        setCurrentPage = _useState2[1];

    var _useState3 = React.useState(pageSize),
        _useState4 = _slicedToArray$1(_useState3, 2),
        currentPageSize = _useState4[0],
        setCurrentPageSize = _useState4[1];

    var prefix = usePrefix();
    var totalPages = totalItems ? Math.max(Math.ceil(totalItems / currentPageSize), 1) : undefined;
    var backButtonDisabled = disabled || currentPage === 1;
    var forwardButtonDisabled = disabled || currentPage === totalPages;

    function onSetPage(newPage) {
      setCurrentPage(Number(newPage));
    }

    function incrementPage() {
      var page = currentPage + 1;
      setCurrentPage(page);
      onChange({
        page: page,
        pageSize: currentPageSize
      });
    }

    function decrementPage() {
      var page = currentPage - 1;
      setCurrentPage(page);
      onChange({
        page: page,
        pageSize: currentPageSize
      });
    }

    var namespace = "".concat(prefix, "--unstable-pagination");
    return /*#__PURE__*/React__default["default"].createElement("section", _extends$3({
      className: cx(namespace, className)
    }, other), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(namespace, "__left")
    }, pageSizes && /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("label", {
      id: "".concat(namespace, "__page-sizer__counter-").concat(id),
      className: "".concat(namespace, "__text"),
      htmlFor: "".concat(namespace, "__page-sizer__input-").concat(id)
    }, itemsPerPageText), /*#__PURE__*/React__default["default"].createElement(Select$1, {
      id: "".concat(namespace, "__page-sizer__input-").concat(id),
      className: "".concat(namespace, "__page-sizer"),
      labelText: "",
      hideLabel: true,
      noLabel: true,
      inline: true,
      onChange: function onChange(event) {
        return setCurrentPageSize(Number(event.target.value));
      },
      value: currentPageSize
    }, pageSizes.map(function (size) {
      return /*#__PURE__*/React__default["default"].createElement(SelectItem$1, {
        key: size,
        value: size,
        text: String(size)
      });
    }))), /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(namespace, "__text")
    }, totalItems && !pagesUnknown && itemRangeText(Math.min(currentPageSize * (currentPage - 1) + 1, totalItems), Math.min(currentPage * currentPageSize, totalItems), totalItems), totalItems && pagesUnknown && itemText(currentPageSize * (currentPage - 1) + 1, currentPage * currentPageSize), !totalItems && itemText(currentPageSize * (currentPage - 1) + 1, currentPage * currentPageSize))), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(namespace, "__right")
    }, children && totalItems && children({
      currentPage: currentPage,
      currentPageSize: currentPageSize,
      onSetPage: onSetPage,
      totalPages: totalPages
    }), children && totalItems && !pagesUnknown && /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(namespace, "__text")
    }, pageRangeText('', totalPages)), children && !totalItems && /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(namespace, "__text")
    }, pageText(currentPage)), !children && /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(namespace, "__text")
    }, !totalItems ? pageText(currentPage) : pageRangeText(currentPage, totalPages)), /*#__PURE__*/React__default["default"].createElement(Button$1, {
      className: cx("".concat(namespace, "__button"), "".concat(namespace, "__button--backward"), _defineProperty$2({}, "".concat(namespace, "__button--no-index"), backButtonDisabled)),
      onClick: function onClick() {
        return decrementPage();
      },
      disabled: backButtonDisabled,
      hasIconOnly: true,
      renderIcon: CaretLeft16,
      tooltipAlignment: "center",
      tooltipPosition: "top",
      iconDescription: backwardText
    }), /*#__PURE__*/React__default["default"].createElement(Button$1, {
      className: cx("".concat(namespace, "__button"), "".concat(namespace, "__button--forward"), _defineProperty$2({}, "".concat(namespace, "__button--no-index"), forwardButtonDisabled)),
      onClick: function onClick() {
        return incrementPage();
      },
      disabled: forwardButtonDisabled,
      hasIconOnly: true,
      renderIcon: CaretRight16,
      tooltipAlignment: "center",
      tooltipPosition: "top",
      iconDescription: forwardText
    })));
  }

  Pagination.propTypes = {
    /**
     * The description for the backward icon.
     */
    backwardText: PropTypes__default["default"].string,

    /**
     * The children of the pagination component.
     */
    children: PropTypes__default["default"].oneOfType([PropTypes__default["default"].node, PropTypes__default["default"].func]),

    /**
     * Extra classes to add.
     */
    className: PropTypes__default["default"].string,

    /**
     * `true` if the backward/forward buttons should be disabled.
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * The description for the forward icon.
     */
    forwardText: PropTypes__default["default"].string,

    /** The unique ID of this component instance. */
    id: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),

    /**
     * The initial active page when the component is first mounted.
     */
    initialPage: PropTypes__default["default"].number,

    /**
     * The function returning a translatable text showing where the current page is,
     * in a manner of the range of items.
     */
    itemRangeText: PropTypes__default["default"].func,

    /**
     * A variant of `itemRangeText`, used if the total number of items is unknown.
     */
    itemText: PropTypes__default["default"].func,

    /**
     * The translatable text indicating the number of items per page.
     */
    itemsPerPageText: PropTypes__default["default"].string,

    /**
     * The callback function called when the current page changes.
     */
    onChange: PropTypes__default["default"].func,

    /**
     * The function returning a translatable text showing where the current page is,
     * in a manner of the total number of pages.
     */
    pageRangeText: PropTypes__default["default"].func,

    /**
     * The number dictating how many items a page contains.
     */
    pageSize: PropTypes__default["default"].number,

    /**
     * The choices for `pageSize`.
     */
    pageSizes: PropTypes__default["default"].arrayOf(PropTypes__default["default"].number),

    /**
     * The translatable text showing the current page.
     */
    pageText: PropTypes__default["default"].func,

    /**
     * `true` if total number of pages is unknown.
     */
    pagesUnknown: PropTypes__default["default"].bool,

    /**
     * The total number of items.
     * You need to provide total items to calculate total page,
     * which is required by a child like the `PageSelector`
     * to know how many pages to display.
     */
    totalItems: PropTypes__default["default"].number
  };
  Pagination.defaultProps = {
    backwardText: 'Previous page',
    className: null,
    children: undefined,
    disabled: false,
    forwardText: 'Next page',
    id: 1,
    itemsPerPageText: 'Items per page:',
    itemRangeText: function itemRangeText(min, max, total) {
      return "".concat(min, "\u2013").concat(max, " of ").concat(total, " items");
    },
    itemText: function itemText(min, max) {
      return "".concat(min, "\u2013").concat(max, " items");
    },
    initialPage: 1,
    pageRangeText: function pageRangeText(current, total) {
      return "".concat(current, " of ").concat(total, " pages");
    },
    pageSize: 10,
    pageSizes: undefined,
    pageText: function pageText(page) {
      return "page ".concat(page);
    },
    pagesUnknown: false,
    totalItems: undefined
  };

  var _excluded$4 = ["className", "currentPage", "id", "labelText", "totalPages"];
  var getInstanceId = setupGetInstanceId$2();

  function PageSelector(_ref) {
    var className = _ref.className,
        currentPage = _ref.currentPage,
        id = _ref.id,
        labelText = _ref.labelText,
        totalPages = _ref.totalPages,
        other = _objectWithoutProperties$2(_ref, _excluded$4);

    var prefix = usePrefix();
    var namespace = "".concat(prefix, "--unstable-pagination__page-selector");
    var instanceId = "".concat(namespace, "__select-").concat(getInstanceId());

    var renderPages = function renderPages(total) {
      var pages = [];

      for (var counter = 1; counter <= total; counter += 1) {
        pages.push( /*#__PURE__*/React__default["default"].createElement(SelectItem$1, {
          key: counter,
          value: counter,
          text: String(counter)
        }));
      }

      return pages;
    };

    return /*#__PURE__*/React__default["default"].createElement(Select$1, _extends$3({
      className: cx(namespace, className),
      hideLabel: true,
      id: instanceId || id,
      inline: true,
      labelText: labelText,
      value: currentPage
    }, other), renderPages(totalPages));
  }

  PageSelector.propTypes = {
    /** Extra class names to add. */
    className: PropTypes__default["default"].string,

    /** The current page. */
    currentPage: PropTypes__default["default"].number.isRequired,

    /** The unique ID of this component instance. */
    id: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),

    /** Translatable string to label the page selector element. */
    labelText: PropTypes__default["default"].string,

    /**
     * Total number of pages.
     * This value is calculated using a valid `totalItems` prop passed to the parent `Unstable_Pagination`.
     */
    totalPages: PropTypes__default["default"].number.isRequired
  };
  PageSelector.defaultProps = {
    className: null,
    id: 1,
    labelText: 'Current page number'
  };

  function ProgressBar(_ref) {
    var _classNames;

    var className = _ref.className,
        helperText = _ref.helperText,
        hideLabel = _ref.hideLabel,
        label = _ref.label,
        _ref$max = _ref.max,
        max = _ref$max === void 0 ? 100 : _ref$max,
        _ref$size = _ref.size,
        size = _ref$size === void 0 ? 'big' : _ref$size,
        _ref$status = _ref.status,
        status = _ref$status === void 0 ? 'active' : _ref$status,
        _ref$type = _ref.type,
        type = _ref$type === void 0 ? 'default' : _ref$type,
        value = _ref.value;
    var labelId = useId('progress-bar');
    var helperId = useId('progress-bar-helper');
    var prefix = usePrefix();
    var isFinished = status === 'finished';
    var isError = status === 'error';
    var indeterminate = !isFinished && !isError && (value === null || value === undefined);
    var cappedValue = value;

    if (cappedValue > max) {
      cappedValue = max;
    }

    if (cappedValue < 0) {
      cappedValue = 0;
    }

    if (isError) {
      cappedValue = 0;
    } else if (isFinished) {
      cappedValue = max;
    }

    var percentage = cappedValue / max;
    var wrapperClasses = cx("".concat(prefix, "--progress-bar"), "".concat(prefix, "--progress-bar--").concat(size), "".concat(prefix, "--progress-bar--").concat(type), (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--progress-bar--indeterminate"), indeterminate), _defineProperty$2(_classNames, "".concat(prefix, "--progress-bar--finished"), isFinished), _defineProperty$2(_classNames, "".concat(prefix, "--progress-bar--error"), isError), _classNames), className);
    var labelClasses = cx("".concat(prefix, "--progress-bar__label"), _defineProperty$2({}, "".concat(prefix, "--visually-hidden"), hideLabel));
    var StatusIcon = null;

    if (isError) {
      StatusIcon = ErrorFilled16;
    } else if (isFinished) {
      StatusIcon = CheckmarkFilled16;
    }

    return /*#__PURE__*/React__default["default"].createElement("div", {
      className: wrapperClasses
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: labelClasses,
      id: labelId
    }, /*#__PURE__*/React__default["default"].createElement("span", {
      className: "".concat(prefix, "--progress-bar__label-text")
    }, label), StatusIcon && /*#__PURE__*/React__default["default"].createElement(StatusIcon, {
      className: "".concat(prefix, "--progress-bar__status-icon")
    })), /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--progress-bar__track"),
      role: "progressbar",
      "aria-invalid": isError,
      "aria-labelledby": labelId,
      "aria-describedby": helperText ? helperId : null,
      "aria-valuemin": !indeterminate ? 0 : null,
      "aria-valuemax": !indeterminate ? max : null,
      "aria-valuenow": !indeterminate ? cappedValue : null
    }, /*#__PURE__*/React__default["default"].createElement("div", {
      className: "".concat(prefix, "--progress-bar__bar"),
      style: !isFinished && !isError ? {
        transform: "scaleX(".concat(percentage, ")")
      } : null
    })), helperText && /*#__PURE__*/React__default["default"].createElement("div", {
      id: helperId,
      className: "".concat(prefix, "--progress-bar__helper-text")
    }, helperText));
  }

  ProgressBar.propTypes = {
    /**
     * Additional CSS class names.
     */
    className: PropTypes__default["default"].string,

    /**
     * The current progress as a textual representation.
     */
    helperText: PropTypes__default["default"].string,

    /**
     * Whether the label should be visually hidden.
     */
    hideLabel: PropTypes__default["default"].bool,

    /**
     * A label describing the progress bar.
     */
    label: PropTypes__default["default"].string.isRequired,

    /**
     * The maximum value.
     */
    max: PropTypes__default["default"].number,

    /**
     * Specify the size of the ProgressBar.
     */
    size: PropTypes__default["default"].oneOf(['small', 'big']),

    /**
     * Specify the status.
     */
    status: PropTypes__default["default"].oneOf(['active', 'finished', 'error']),

    /**
     * Defines the alignment variant of the progress bar.
     */
    type: PropTypes__default["default"].oneOf(['default', 'inline', 'indented']),

    /**
     * The current value.
     */
    value: PropTypes__default["default"].number
  };

  /**
   * Copyright IBM Corp. 2018, 2018
   *
   * This source code is licensed under the Apache-2.0 license found in the
   * LICENSE file in the root directory of this source tree.
   */
  // Default, Use with em() and rem() functions

  var baseFontSize = 16;
  /**
   * Convert a given px unit to a rem unit
   * @param {number} px
   * @returns {string}
   */

  function rem(px) {
    return "".concat(px / baseFontSize, "rem");
  }


  var miniUnit = 8;

  function miniUnits(count) {
    return rem(miniUnit * count);
  } // Spacing


  var spacing01 = miniUnits(0.25);
  var spacing02 = miniUnits(0.5);
  var spacing03 = miniUnits(1);
  var spacing04 = miniUnits(1.5);
  var spacing05 = miniUnits(2);
  var spacing06 = miniUnits(3);
  var spacing07 = miniUnits(4);
  var spacing08 = miniUnits(5);
  var spacing09 = miniUnits(6);
  var spacing10 = miniUnits(8);
  var spacing11 = miniUnits(10);
  var spacing12 = miniUnits(12);
  var spacing13 = miniUnits(20);
  var spacing = [spacing01, spacing02, spacing03, spacing04, spacing05, spacing06, spacing07, spacing08, spacing09, spacing10, spacing11, spacing12, spacing13]; // Fluid spacing

  var _excluded$3 = ["as", "children", "className", "gap", "orientation"];
  /**
   * The steps in the spacing scale
   * @type {Array<number>}
   */

  var SPACING_STEPS = Array.from({
    length: spacing.length - 1
  }).map(function (_, step) {
    return step + 1;
  });
  /**
   * The Stack component is a useful layout utility in a component-based model.
   * This allows components to not use margin and instead delegate the
   * responsibility of positioning and layout to parent components.
   *
   * In the case of the Stack component, it uses the spacing scale from the
   * Design Language in order to determine how much space there should be between
   * items rendered by the Stack component. It also supports a custom `gap` prop
   * which will allow a user to provide a custom value for the gap of the layout.
   *
   * This component supports both horizontal and vertical orientations.
   *
   * Inspiration for this component:
   *
   * - https://paste.twilio.design/layout/stack/
   * - https://github.com/Workday/canvas-kit/blob/f2f599654876700f483a1d8c5de82a41315c76f1/modules/labs-react/layout/lib/Stack.tsx
   */

  var Stack = /*#__PURE__*/React__default["default"].forwardRef(function Stack(props, ref) {
    var _cx;

    var _props$as = props.as,
        BaseComponent = _props$as === void 0 ? 'div' : _props$as,
        children = props.children,
        customClassName = props.className,
        gap = props.gap,
        _props$orientation = props.orientation,
        orientation = _props$orientation === void 0 ? 'vertical' : _props$orientation,
        rest = _objectWithoutProperties$2(props, _excluded$3);

    var prefix = usePrefix();
    var className = cx(customClassName, (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--stack-").concat(orientation), true), _defineProperty$2(_cx, "".concat(prefix, "--stack-scale-").concat(gap), typeof gap === 'number'), _cx));
    var style = {};

    if (typeof gap === 'string') {
      style["--".concat(prefix, "-stack-gap")] = gap;
    }

    return /*#__PURE__*/React__default["default"].createElement(BaseComponent, _extends$3({}, rest, {
      ref: ref,
      className: className,
      style: style
    }), children);
  });
  Stack.propTypes = {
    /**
     * Provide a custom element type to render as the outermost element in
     * the Stack component. By default, this component will render a `div`.
     */
    as: PropTypes__default["default"].elementType,

    /**
     * Provide the elements that will be rendered as children inside of the Stack
     * component. These elements will have having spacing between them according
     * to the `step` and `orientation` prop
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide a custom class name to be used by the outermost element rendered by
     * Stack
     */
    className: PropTypes__default["default"].string,

    /**
     * Provide either a custom value or a step from the spacing scale to be used
     * as the gap in the layout
     */
    gap: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].oneOf(SPACING_STEPS)]),

    /**
     * Specify the orientation of them items in the Stack
     */
    orientation: PropTypes__default["default"].oneOf(['horizontal', 'vertical'])
  };

  var HStack = /*#__PURE__*/React__default["default"].forwardRef(function HStack(props, ref) {
    return /*#__PURE__*/React__default["default"].createElement(Stack, _extends$3({}, props, {
      ref: ref,
      orientation: "horizontal"
    }));
  });
  var VStack = /*#__PURE__*/React__default["default"].forwardRef(function VStack(props, ref) {
    return /*#__PURE__*/React__default["default"].createElement(Stack, _extends$3({}, props, {
      ref: ref,
      orientation: "vertical"
    }));
  });

  var _excluded$2 = ["active", "children", "className", "hideLabel", "label", "multiselect", "onSelect", "selected", "size"];
  function TreeView(_ref) {
    var prespecifiedActive = _ref.active,
        children = _ref.children,
        className = _ref.className,
        _ref$hideLabel = _ref.hideLabel,
        hideLabel = _ref$hideLabel === void 0 ? false : _ref$hideLabel,
        label = _ref.label,
        multiselect = _ref.multiselect,
        onSelect = _ref.onSelect,
        _ref$selected = _ref.selected,
        preselected = _ref$selected === void 0 ? [] : _ref$selected,
        _ref$size = _ref.size,
        size = _ref$size === void 0 ? enabled('enable-v11-release') ? 'sm' : 'default' : _ref$size,
        rest = _objectWithoutProperties$2(_ref, _excluded$2);

    var _useRef = React.useRef(rest.id || uniqueId()),
        treeId = _useRef.current;

    var prefix = usePrefix();
    var treeClasses = cx(className, "".concat(prefix, "--tree"), _defineProperty$2({}, "".concat(prefix, "--tree--").concat(size), size !== 'default'));
    var treeRootRef = React.useRef(null);
    var treeWalker = React.useRef(treeRootRef === null || treeRootRef === void 0 ? void 0 : treeRootRef.current);

    var _useState = React.useState(preselected),
        _useState2 = _slicedToArray$1(_useState, 2),
        selected = _useState2[0],
        setSelected = _useState2[1];

    var _useState3 = React.useState(prespecifiedActive),
        _useState4 = _slicedToArray$1(_useState3, 2),
        active = _useState4[0],
        setActive = _useState4[1];

    function resetNodeTabIndices() {
      var _treeRootRef$current$, _treeRootRef$current;

      Array.prototype.forEach.call((_treeRootRef$current$ = treeRootRef === null || treeRootRef === void 0 ? void 0 : (_treeRootRef$current = treeRootRef.current) === null || _treeRootRef$current === void 0 ? void 0 : _treeRootRef$current.querySelectorAll('[tabIndex="0"]')) !== null && _treeRootRef$current$ !== void 0 ? _treeRootRef$current$ : [], function (item) {
        item.tabIndex = -1;
      });
    }

    function handleTreeSelect(event) {
      var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var nodeId = node.id;

      if (multiselect && (event.metaKey || event.ctrlKey)) {
        if (!selected.includes(nodeId)) {
          setSelected(selected.concat(nodeId));
        } else {
          setSelected(selected.filter(function (selectedId) {
            return selectedId !== nodeId;
          }));
        }
      } else {
        setSelected([nodeId]);
        setActive(nodeId);
      }

      if (onSelect) {
        onSelect(event, node);
      }
    }

    function handleFocusEvent(event) {
      if (event.type === 'blur') {
        var _treeRootRef$current2;

        var currentFocusedNode = event.relatedTarget,
            prevFocusedNode = event.target;

        if (treeRootRef !== null && treeRootRef !== void 0 && (_treeRootRef$current2 = treeRootRef.current) !== null && _treeRootRef$current2 !== void 0 && _treeRootRef$current2.contains(currentFocusedNode)) {
          prevFocusedNode.tabIndex = -1;
        }
      }

      if (event.type === 'focus') {
        var _treeRootRef$current3;

        resetNodeTabIndices();
        var _prevFocusedNode = event.relatedTarget,
            _currentFocusedNode = event.target;

        if (treeRootRef !== null && treeRootRef !== void 0 && (_treeRootRef$current3 = treeRootRef.current) !== null && _treeRootRef$current3 !== void 0 && _treeRootRef$current3.contains(_prevFocusedNode)) {
          _prevFocusedNode.tabIndex = -1;
        }

        _currentFocusedNode.tabIndex = 0;
      }
    }

    var focusTarget = false;
    var nodesWithProps = React__default["default"].Children.map(children, function (node) {
      var sharedNodeProps = {
        active: active,
        depth: 0,
        onNodeFocusEvent: handleFocusEvent,
        onTreeSelect: handleTreeSelect,
        selected: selected,
        tabIndex: !node.props.disabled && -1 || null
      };

      if (!focusTarget && !node.props.disabled) {
        sharedNodeProps.tabIndex = 0;
        focusTarget = true;
      }

      if ( /*#__PURE__*/React__default["default"].isValidElement(node)) {
        return /*#__PURE__*/React__default["default"].cloneElement(node, sharedNodeProps);
      }
    });

    function handleKeyDown(event) {
      event.stopPropagation();

      if (matches(event, [ArrowUp, ArrowDown])) {
        event.preventDefault();
      }

      treeWalker.current.currentNode = event.target;
      var nextFocusNode;

      if (match(event, ArrowUp)) {
        nextFocusNode = treeWalker.current.previousNode();
      }

      if (match(event, ArrowDown)) {
        nextFocusNode = treeWalker.current.nextNode();
      }

      if (nextFocusNode && nextFocusNode !== event.target) {
        resetNodeTabIndices();
        nextFocusNode.tabIndex = 0;
        nextFocusNode.focus();
      }

      if (rest.onKeyDown) {
        rest.onKeyDown(event);
      }
    }

    React.useEffect(function () {
      var _treeWalker$current;

      treeWalker.current = (_treeWalker$current = treeWalker.current) !== null && _treeWalker$current !== void 0 ? _treeWalker$current : document.createTreeWalker(treeRootRef === null || treeRootRef === void 0 ? void 0 : treeRootRef.current, NodeFilter.SHOW_ELEMENT, {
        acceptNode: function acceptNode(node) {
          if (node.classList.contains("".concat(prefix, "--tree-node--disabled"))) {
            return NodeFilter.FILTER_REJECT;
          }

          if (node.matches("li.".concat(prefix, "--tree-node"))) {
            return NodeFilter.FILTER_ACCEPT;
          }

          return NodeFilter.FILTER_SKIP;
        }
      });
    }, [prefix]);
    React.useEffect(function () {
      if (preselected.length) {
        setSelected(preselected);
      }

      if (prespecifiedActive) {
        setActive(prespecifiedActive);
      }
    }, [preselected, prespecifiedActive]);
    var labelId = "".concat(treeId, "__label");

    var TreeLabel = function TreeLabel() {
      return !hideLabel && /*#__PURE__*/React__default["default"].createElement("label", {
        id: labelId,
        className: "".concat(prefix, "--label")
      }, label);
    };

    return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement(TreeLabel, null), /*#__PURE__*/React__default["default"].createElement("ul", _extends$3({}, rest, {
      "aria-label": hideLabel ? label : null,
      "aria-labelledby": !hideLabel ? labelId : null,
      "aria-multiselectable": multiselect || null,
      className: treeClasses,
      onKeyDown: handleKeyDown,
      ref: treeRootRef,
      role: "tree"
    }), nodesWithProps));
  }
  TreeView.propTypes = {
    /**
     * Mark the active node in the tree, represented by its value
     */
    active: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),

    /**
     * Specify the children of the TreeView
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the TreeView
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify whether or not the label should be hidden
     */
    hideLabel: PropTypes__default["default"].bool,

    /**
     * Provide the label text that will be read by a screen reader
     */
    label: PropTypes__default["default"].string.isRequired,

    /**
     * Specify the selection mode of the tree.
     * If `multiselect` is `false` then only one node can be selected at a time
     */
    multiselect: PropTypes__default["default"].bool,

    /**
     * Callback function that is called when any node is selected
     */
    onSelect: PropTypes__default["default"].func,

    /**
     * Array representing all selected node IDs in the tree
     */
    selected: PropTypes__default["default"].arrayOf(PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number])),

    /**
     * Specify the size of the tree from a list of available sizes.
     */
    size: enabled('enable-v11-release') ? PropTypes__default["default"].oneOf(['xs', 'sm']) : PropTypes__default["default"].oneOf(['default', 'compact'])
  };

  var _excluded$1 = ["active", "children", "className", "depth", "disabled", "isExpanded", "label", "onNodeFocusEvent", "onSelect", "onToggle", "onTreeSelect", "renderIcon", "selected", "value"];
  function TreeNode(_ref) {
    var _classNames, _objectSpread2;

    var active = _ref.active,
        children = _ref.children,
        className = _ref.className,
        depth = _ref.depth,
        disabled = _ref.disabled,
        isExpanded = _ref.isExpanded,
        label = _ref.label,
        onNodeFocusEvent = _ref.onNodeFocusEvent,
        onNodeSelect = _ref.onSelect,
        onToggle = _ref.onToggle,
        onTreeSelect = _ref.onTreeSelect,
        Icon = _ref.renderIcon,
        selected = _ref.selected,
        value = _ref.value,
        rest = _objectWithoutProperties$2(_ref, _excluded$1);

    var _useRef = React.useRef(rest.id || uniqueId()),
        id = _useRef.current;

    var _useState = React.useState(isExpanded),
        _useState2 = _slicedToArray$1(_useState, 2),
        expanded = _useState2[0],
        setExpanded = _useState2[1];

    var currentNode = React.useRef(null);
    var currentNodeLabel = React.useRef(null);
    var prefix = usePrefix();
    var nodesWithProps = React__default["default"].Children.map(children, function (node) {
      if ( /*#__PURE__*/React__default["default"].isValidElement(node)) {
        return /*#__PURE__*/React__default["default"].cloneElement(node, {
          active: active,
          depth: depth + 1,
          disabled: disabled,
          onTreeSelect: onTreeSelect,
          selected: selected,
          tabIndex: !node.props.disabled && -1 || null
        });
      }
    });
    var isActive = active === id;
    var isSelected = selected.includes(id);
    var treeNodeClasses = cx(className, "".concat(prefix, "--tree-node"), (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefix, "--tree-node--active"), isActive), _defineProperty$2(_classNames, "".concat(prefix, "--tree-node--disabled"), disabled), _defineProperty$2(_classNames, "".concat(prefix, "--tree-node--selected"), isSelected), _defineProperty$2(_classNames, "".concat(prefix, "--tree-node--with-icon"), Icon), _defineProperty$2(_classNames, "".concat(prefix, "--tree-leaf-node"), !children), _defineProperty$2(_classNames, "".concat(prefix, "--tree-parent-node"), children), _classNames));
    var toggleClasses = cx("".concat(prefix, "--tree-parent-node__toggle-icon"), _defineProperty$2({}, "".concat(prefix, "--tree-parent-node__toggle-icon--expanded"), expanded));

    function handleToggleClick(event) {
      if (onToggle) {
        onToggle(event, {
          id: id,
          isExpanded: !expanded,
          label: label,
          value: value
        });
      }

      setExpanded(!expanded);
    }

    function handleClick(event) {
      event.stopPropagation();

      if (!disabled) {
        if (onTreeSelect) {
          onTreeSelect(event, {
            id: id,
            label: label,
            value: value
          });
        }

        if (onNodeSelect) {
          onNodeSelect(event, {
            id: id,
            label: label,
            value: value
          });
        }

        if (rest.onClick) {
          rest.onClick(event);
        }
      }
    }

    function handleKeyDown(event) {
      if (matches(event, [ArrowLeft, ArrowRight, Enter])) {
        event.stopPropagation();
      }

      if (match(event, ArrowLeft)) {
        var findParentTreeNode = function findParentTreeNode(node) {
          if (node.classList.contains("".concat(prefix, "--tree-parent-node"))) {
            return node;
          }

          if (node.classList.contains("".concat(prefix, "--tree"))) {
            return null;
          }

          return findParentTreeNode(node.parentNode);
        };

        if (children && expanded) {
          onToggle(event, {
            id: id,
            isExpanded: false,
            label: label,
            value: value
          });
          setExpanded(false);
        } else {
          var _findParentTreeNode;

          /**
           * When focus is on a leaf node or a closed parent node, move focus to
           * its parent node (unless its depth is level 1)
           */
          (_findParentTreeNode = findParentTreeNode(currentNode.current.parentNode)) === null || _findParentTreeNode === void 0 ? void 0 : _findParentTreeNode.focus();
        }
      }

      if (children && match(event, ArrowRight)) {
        if (expanded) {
          /**
           * When focus is on an expanded parent node, move focus to the first
           * child node
           */
          currentNode.current.lastChild.firstChild.focus();
        } else {
          onToggle(event, {
            id: id,
            isExpanded: true,
            label: label,
            value: value
          });
          setExpanded(true);
        }
      }

      if (matches(event, [Enter, Space])) {
        event.preventDefault();
        handleClick(event);
      }

      if (rest.onKeyDown) {
        rest.onKeyDown(event);
      }
    }

    function handleFocusEvent(event) {
      if (event.type === 'blur' && rest.onBlur) {
        rest.onBlur(event);
      }

      if (event.type === 'focus' && rest.onFocus) {
        rest.onFocus(event);
      }

      onNodeFocusEvent && onNodeFocusEvent(event);
    }

    React.useEffect(function () {
      /**
       * Negative margin shifts node to align with the left side boundary of the
       * tree
       * Dynamically calculate padding to recreate tree node indentation
       * - parent nodes have (depth + 1rem) left padding
       * - leaf nodes have (depth + 2.5rem) left padding without icons (because
       *   of expand icon + spacing)
       * - leaf nodes have (depth + 2rem) left padding with icons (because of
       *   reduced spacing between the expand icon and the node icon + label)
       */
      var calcOffset = function calcOffset() {
        // parent node
        if (children) {
          return depth + 1;
        } // leaf node with icon


        if (Icon) {
          return depth + 2;
        } // leaf node without icon


        return depth + 2.5;
      };

      if (currentNodeLabel.current) {
        currentNodeLabel.current.style.marginLeft = "-".concat(calcOffset(), "rem");
        currentNodeLabel.current.style.paddingLeft = "".concat(calcOffset(), "rem");
      } // sync props and state


      setExpanded(isExpanded);
    }, [children, depth, Icon, isExpanded]);

    var treeNodeProps = _objectSpread2$2(_objectSpread2$2({}, rest), {}, (_objectSpread2 = {}, _defineProperty$2(_objectSpread2, 'aria-current', isActive || null), _defineProperty$2(_objectSpread2, 'aria-selected', disabled ? null : isSelected), _defineProperty$2(_objectSpread2, 'aria-disabled', disabled), _defineProperty$2(_objectSpread2, "className", treeNodeClasses), _defineProperty$2(_objectSpread2, "id", id), _defineProperty$2(_objectSpread2, "onBlur", handleFocusEvent), _defineProperty$2(_objectSpread2, "onClick", handleClick), _defineProperty$2(_objectSpread2, "onFocus", handleFocusEvent), _defineProperty$2(_objectSpread2, "onKeyDown", handleKeyDown), _defineProperty$2(_objectSpread2, "ref", currentNode), _defineProperty$2(_objectSpread2, "role", 'treeitem'), _objectSpread2));

    if (!children) {
      return /*#__PURE__*/React__default["default"].createElement("li", treeNodeProps, /*#__PURE__*/React__default["default"].createElement("div", {
        className: "".concat(prefix, "--tree-node__label"),
        ref: currentNodeLabel
      }, Icon && /*#__PURE__*/React__default["default"].createElement(Icon, {
        className: "".concat(prefix, "--tree-node__icon")
      }), label));
    }

    return (
      /*#__PURE__*/
      // eslint-disable-next-line jsx-a11y/role-supports-aria-props
      React__default["default"].createElement("li", _extends$3({}, treeNodeProps, {
        "aria-expanded": !!expanded
      }), /*#__PURE__*/React__default["default"].createElement("div", {
        className: "".concat(prefix, "--tree-node__label"),
        ref: currentNodeLabel
      }, /*#__PURE__*/React__default["default"].createElement("span", {
        className: "".concat(prefix, "--tree-parent-node__toggle"),
        disabled: disabled,
        onClick: handleToggleClick
      }, /*#__PURE__*/React__default["default"].createElement(CaretDown16, {
        className: toggleClasses
      })), /*#__PURE__*/React__default["default"].createElement("span", {
        className: "".concat(prefix, "--tree-node__label__details")
      }, Icon && /*#__PURE__*/React__default["default"].createElement(Icon, {
        className: "".concat(prefix, "--tree-node__icon")
      }), label)), expanded && /*#__PURE__*/React__default["default"].createElement("ul", {
        role: "group",
        className: "".concat(prefix, "--tree-node__children")
      }, nodesWithProps))
    );
  }
  TreeNode.propTypes = {
    /**
     * The value of the active node in the tree
     */
    active: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),

    /**
     * Specify the children of the TreeNode
     */
    children: PropTypes__default["default"].node,

    /**
     * Specify an optional className to be applied to the TreeNode
     */
    className: PropTypes__default["default"].string,

    /**
     * TreeNode depth to determine spacing, automatically calculated by default
     */
    depth: PropTypes__default["default"].number,

    /**
     * Specify if the TreeNode is disabled
     */
    disabled: PropTypes__default["default"].bool,

    /**
     * Specify if the TreeNode is expanded (only applicable to parent nodes)
     */
    isExpanded: PropTypes__default["default"].bool,

    /**
     * Rendered label for the TreeNode
     */
    label: PropTypes__default["default"].node,

    /**
     * Callback function for when the node receives or loses focus
     */
    onNodeFocusEvent: PropTypes__default["default"].func,

    /**
     * Callback function for when the node is selected
     */
    onSelect: PropTypes__default["default"].func,

    /**
     * Callback function for when a parent node is expanded or collapsed
     */
    onToggle: PropTypes__default["default"].func,

    /**
     * Callback function for when any node in the tree is selected
     */
    onTreeSelect: PropTypes__default["default"].func,

    /**
     * Optional prop to allow each node to have an associated icon.
     * Can be a React component class
     */
    renderIcon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),

    /**
     * Array containing all selected node IDs in the tree
     */
    selected: PropTypes__default["default"].arrayOf(PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number])),

    /**
     * Specify the value of the TreeNode
     */
    value: PropTypes__default["default"].string
  };

  TreeView.TreeNode = TreeNode;

  var _excluded = ["as", "children", "className", "theme"];
  var ThemeContext = /*#__PURE__*/React__default["default"].createContext({
    theme: 'white'
  });
  /**
   * Specify the theme to be applied to a page, or a region in a page
   */

  function Theme(_ref) {
    var _cx;

    var _ref$as = _ref.as,
        BaseComponent = _ref$as === void 0 ? 'div' : _ref$as,
        children = _ref.children,
        customClassName = _ref.className,
        theme = _ref.theme,
        rest = _objectWithoutProperties$2(_ref, _excluded);

    var prefix = usePrefix();
    var className = cx(customClassName, (_cx = {}, _defineProperty$2(_cx, "".concat(prefix, "--white"), theme === 'white'), _defineProperty$2(_cx, "".concat(prefix, "--g10"), theme === 'g10'), _defineProperty$2(_cx, "".concat(prefix, "--g90"), theme === 'g90'), _defineProperty$2(_cx, "".concat(prefix, "--g100"), theme === 'g100'), _defineProperty$2(_cx, "".concat(prefix, "--layer-one"), true), _cx));
    var value = React__default["default"].useMemo(function () {
      return {
        theme: theme
      };
    }, [theme]);
    return /*#__PURE__*/React__default["default"].createElement(ThemeContext.Provider, {
      value: value
    }, /*#__PURE__*/React__default["default"].createElement(LayerContext.Provider, {
      value: 1
    }, /*#__PURE__*/React__default["default"].createElement(BaseComponent, _extends$3({}, rest, {
      className: className
    }), children)));
  }
  Theme.propTypes = {
    /**
     * Specify a custom component or element to be rendered as the top-level
     * element in the component
     */
    as: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].string, PropTypes__default["default"].elementType]),

    /**
     * Provide child elements to be rendered inside of `Theme`
     */
    children: PropTypes__default["default"].node,

    /**
     * Provide a custom class name to be used on the outermost element rendered by
     * the component
     */
    className: PropTypes__default["default"].string,

    /**
     * Specify the theme
     */
    theme: PropTypes__default["default"].oneOf(['white', 'g10', 'g90', 'g100'])
  };
  /**
   * Get access to the current theme
   */

  function useTheme() {
    return React__default["default"].useContext(ThemeContext);
  }

  exports.Accordion = Accordion;
  exports.AccordionItem = AccordionItem;
  exports.AccordionSkeleton = AccordionSkeleton;
  exports.ActionableNotification = ActionableNotification;
  exports.AspectRatio = AspectRatio;
  exports.Breadcrumb = Breadcrumb$1;
  exports.BreadcrumbItem = BreadcrumbItem$1;
  exports.BreadcrumbSkeleton = BreadcrumbSkeleton;
  exports.Button = Button$1;
  exports.ButtonSet = ButtonSet$1;
  exports.ButtonSkeleton = ButtonSkeleton$1;
  exports.Checkbox = Checkbox$1;
  exports.CheckboxSkeleton = CheckboxSkeleton$1;
  exports.ClickableTile = ClickableTile;
  exports.CodeSnippet = CodeSnippet;
  exports.CodeSnippetSkeleton = CodeSnippetSkeleton;
  exports.Column = Column;
  exports.ComboBox = ComboBox$1;
  exports.ComposedModal = ComposedModal$1;
  exports.Content = Content$1;
  exports.ContentSwitcher = ContentSwitcher;
  exports.ControlledPasswordInput = ControlledPasswordInput$1;
  exports.Copy = Copy;
  exports.CopyButton = CopyButton;
  exports.DangerButton = DangerButton$1;
  exports.DataTable = DataTable;
  exports.DataTableSkeleton = DataTableSkeleton$1;
  exports.DatePicker = DatePicker$1;
  exports.DatePickerInput = DatePickerInput$1;
  exports.DatePickerSkeleton = DatePickerSkeleton$1;
  exports.Dropdown = Dropdown$1;
  exports.DropdownSkeleton = DropdownSkeleton$1;
  exports.ErrorBoundary = ErrorBoundary;
  exports.ErrorBoundaryContext = ErrorBoundaryContext;
  exports.ExpandableSearch = ExpandableSearch;
  exports.ExpandableTile = ExpandableTile;
  exports.FileUploader = index$2;
  exports.FileUploaderButton = FileUploaderButton;
  exports.FileUploaderDropContainer = FileUploaderDropContainer;
  exports.FileUploaderItem = FileUploaderItem;
  exports.FileUploaderSkeleton = FileUploaderSkeleton;
  exports.Filename = Filename;
  exports.FilterableMultiSelect = FilterableMultiSelect;
  exports.FluidForm = FluidForm;
  exports.Form = Form$1;
  exports.FormGroup = FormGroup$1;
  exports.FormItem = FormItem$1;
  exports.FormLabel = FormLabel;
  exports.Grid = Grid;
  exports.Header = Header$1;
  exports.HeaderContainer = HeaderContainer$1;
  exports.HeaderGlobalAction = HeaderGlobalAction$1;
  exports.HeaderGlobalBar = HeaderGlobalBar;
  exports.HeaderMenu = HeaderMenuForwardRef$1;
  exports.HeaderMenuButton = HeaderMenuButton$1;
  exports.HeaderMenuItem = HeaderMenuItem$1;
  exports.HeaderName = HeaderName$1;
  exports.HeaderNavigation = HeaderNavigation;
  exports.HeaderPanel = HeaderPanel$1;
  exports.HeaderSideNavItems = HeaderSideNavItems$1;
  exports.Icon = Icon$1;
  exports.IconSkeleton = IconSkeleton$1;
  exports.InlineLoading = InlineLoading;
  exports.InlineNotification = InlineNotification;
  exports.Link = Link$3;
  exports.ListItem = ListItem$1;
  exports.Loading = Loading;
  exports.Modal = Modal$1;
  exports.ModalBody = ModalBody$1;
  exports.ModalFooter = ModalFooter;
  exports.ModalHeader = ModalHeader;
  exports.ModalWrapper = ModalWrapper;
  exports.MultiSelect = MultiSelect$1;
  exports.NotificationActionButton = NotificationActionButton;
  exports.NotificationButton = NotificationButton;
  exports.NotificationTextDetails = NotificationTextDetails;
  exports.NumberInput = NumberInput$1;
  exports.NumberInputSkeleton = NumberInputSkeleton$1;
  exports.NumberInputV2 = NumberInputV2$1;
  exports.OrderedList = OrderedList$1;
  exports.OverflowMenu = OverflowMenu;
  exports.OverflowMenuItem = OverflowMenuItem;
  exports.Pagination = index$1;
  exports.PaginationNav = PaginationNav$1;
  exports.PaginationSkeleton = PaginationSkeleton;
  exports.PasswordInput = PasswordInput$1;
  exports.PrimaryButton = PrimaryButton$1;
  exports.ProgressIndicator = ProgressIndicator;
  exports.ProgressIndicatorSkeleton = ProgressIndicatorSkeleton;
  exports.ProgressStep = ProgressStep;
  exports.RadioButton = RadioButton$1;
  exports.RadioButtonGroup = RadioButtonGroup$1;
  exports.RadioButtonSkeleton = RadioButtonSkeleton;
  exports.RadioTile = RadioTile;
  exports.Row = Row;
  exports.Search = Search$1;
  exports.SearchFilterButton = SearchFilterButton$1;
  exports.SearchLayoutButton = SearchLayoutButton$1;
  exports.SearchSkeleton = SearchSkeleton$1;
  exports.SecondaryButton = SecondaryButton$1;
  exports.Select = Select$1;
  exports.SelectItem = SelectItem$1;
  exports.SelectItemGroup = SelectItemGroup$1;
  exports.SelectSkeleton = SelectSkeleton$1;
  exports.SelectableTile = SelectableTile;
  exports.SideNav = SideNav$1;
  exports.SideNavDetails = SideNavDetails$1;
  exports.SideNavDivider = SideNavDivider;
  exports.SideNavFooter = SideNavFooter$1;
  exports.SideNavHeader = SideNavHeader$1;
  exports.SideNavIcon = SideNavIcon$1;
  exports.SideNavItem = SideNavItem$1;
  exports.SideNavItems = SideNavItems$1;
  exports.SideNavLink = SideNavLink$1;
  exports.SideNavLinkText = SideNavLinkText$1;
  exports.SideNavMenu = SideNavMenu;
  exports.SideNavMenuItem = SideNavMenuItem$1;
  exports.SideNavSwitcher = SideNavSwitcher$1;
  exports.SkeletonIcon = SkeletonIcon$1;
  exports.SkeletonPlaceholder = SkeletonPlaceholder$1;
  exports.SkeletonText = SkeletonText$1;
  exports.SkipToContent = SkipToContent$1;
  exports.Slider = index;
  exports.SliderSkeleton = SliderSkeleton$1;
  exports.StructuredListBody = StructuredListBody;
  exports.StructuredListCell = StructuredListCell;
  exports.StructuredListHead = StructuredListHead;
  exports.StructuredListInput = StructuredListInput;
  exports.StructuredListRow = StructuredListRow;
  exports.StructuredListSkeleton = StructuredListSkeleton$1;
  exports.StructuredListWrapper = StructuredListWrapper;
  exports.Switch = Switch$1;
  exports.Switcher = Switcher$1;
  exports.SwitcherDivider = SwitcherDivider$1;
  exports.SwitcherItem = SwitcherItem$1;
  exports.Tab = Tab$3;
  exports.TabContent = TabContent$1;
  exports.Table = Table$1;
  exports.TableActionList = TableActionList$1;
  exports.TableBatchAction = TableBatchAction$1;
  exports.TableBatchActions = TableBatchActions$1;
  exports.TableBody = TableBody$1;
  exports.TableCell = TableCell$1;
  exports.TableContainer = TableContainer$1;
  exports.TableExpandHeader = TableExpandHeader$1;
  exports.TableExpandRow = TableExpandRow$1;
  exports.TableExpandedRow = TableExpandedRow$1;
  exports.TableHead = TableHead$1;
  exports.TableHeader = TableHeader$1;
  exports.TableRow = TableRow$1;
  exports.TableSelectAll = TableSelectAll$1;
  exports.TableSelectRow = TableSelectRow$1;
  exports.TableToolbar = TableToolbar$1;
  exports.TableToolbarAction = TableToolbarAction$1;
  exports.TableToolbarContent = TableToolbarContent$1;
  exports.TableToolbarMenu = TableToolbarMenu$1;
  exports.TableToolbarSearch = TableToolbarSearch$1;
  exports.Tabs = Tabs$1;
  exports.TabsSkeleton = TabsSkeleton$1;
  exports.Tag = Tag$1;
  exports.TagSkeleton = TagSkeleton;
  exports.TextArea = TextArea$1;
  exports.TextAreaSkeleton = TextAreaSkeleton$1;
  exports.TextInput = TextInput$1;
  exports.TextInputSkeleton = TextInputSkeleton$1;
  exports.Tile = Tile;
  exports.TileAboveTheFoldContent = TileAboveTheFoldContent;
  exports.TileBelowTheFoldContent = TileBelowTheFoldContent;
  exports.TileGroup = TileGroup;
  exports.TimePicker = TimePicker$1;
  exports.TimePickerSelect = TimePickerSelect$1;
  exports.ToastNotification = ToastNotification;
  exports.Toggle = Toggle$1;
  exports.ToggleSkeleton = ToggleSkeleton;
  exports.ToggleSmall = ToggleSmall$1;
  exports.ToggleSmallSkeleton = ToggleSmallSkeleton;
  exports.Toolbar = Toolbar$1;
  exports.ToolbarDivider = ToolbarDivider;
  exports.ToolbarItem = ToolbarItem;
  exports.ToolbarOption = ToolbarOption;
  exports.ToolbarSearch = ToolbarSearch;
  exports.ToolbarTitle = ToolbarTitle;
  exports.Tooltip = Tooltip$1;
  exports.TooltipDefinition = TooltipDefinition$1;
  exports.TooltipIcon = TooltipIcon$1;
  exports.UnorderedList = UnorderedList$1;
  exports.unstable_ColumnHang = ColumnHang;
  exports.unstable_DefinitionTooltip = DefinitionTooltip;
  exports.unstable_FeatureFlags = FeatureFlags;
  exports.unstable_FlexGrid = FlexGrid;
  exports.unstable_HStack = HStack;
  exports.unstable_Heading = Heading;
  exports.unstable_IconButton = IconButton;
  exports.unstable_IconTab = IconTab;
  exports.unstable_Layer = Layer;
  exports.unstable_Menu = Menu$1;
  exports.unstable_MenuDivider = MenuDivider;
  exports.unstable_MenuGroup = MenuGroup;
  exports.unstable_MenuItem = MenuItem;
  exports.unstable_MenuRadioGroup = MenuRadioGroup;
  exports.unstable_MenuSelectableItem = MenuSelectableItem;
  exports.unstable_OverflowMenuV2 = OverflowMenuV2;
  exports.unstable_PageSelector = PageSelector;
  exports.unstable_Pagination = Pagination;
  exports.unstable_Popover = Popover;
  exports.unstable_PopoverContent = PopoverContent;
  exports.unstable_ProgressBar = ProgressBar;
  exports.unstable_Section = Section;
  exports.unstable_Stack = Stack;
  exports.unstable_TabList = TabList;
  exports.unstable_TabPanel = TabPanel;
  exports.unstable_TabPanels = TabPanels;
  exports.unstable_Theme = Theme;
  exports.unstable_ThemeContext = ThemeContext;
  exports.unstable_Tooltip = Tooltip$2;
  exports.unstable_TreeNode = TreeNode;
  exports.unstable_TreeView = TreeView;
  exports.unstable_VStack = VStack;
  exports.unstable_useContextMenu = useContextMenu;
  exports.unstable_useFeatureFlag = useFeatureFlag;
  exports.unstable_useFeatureFlags = useFeatureFlags;
  exports.unstable_usePrefix = usePrefix;
  exports.unstable_useTheme = useTheme;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
